import * as _geenee_bodytracking from '@geenee/bodytracking';
import { Coord3D, Size as Size$1, Box } from '@geenee/bodytracking';
import { ShaderProgram, Size, Plugin, Renderer, ShaderPlugin, ImageTexture } from '@geenee/armature';
import * as _geenee_bodyprocessors from '@geenee/bodyprocessors';
import { PoseResult, FaceResult, MaskResult, Pose, Face } from '@geenee/bodyprocessors';

/**
 * Parameters of pose fine-tuning
 *
 * These parameters control optional adjustments added to basic
 * pose-model alignment method. {@link PoseAlignPlugin} supports
 * rigs compatible with Mixamo armature (Ready Player Me avatars).
 * This is the most common armature standard for human-like models,
 * supported by many game engines. But for example models rigged
 * and skinned manually or using Mixamo tool can variate depending
 * on anthropomorphous model topology, e.g. animated characters
 * can have disproportional body parts like a much bigger head.
 * In such cases fine-tuning may be required. Also depending on
 * use case you can try several options and see what works better.
 * As an example turning off adjustment of spine curvature gives
 * better results in virtual garment try-on experiences, while for
 * full-body avatar overlaying it can provide more natural look.
 */
interface PoseTuneParams {
    /**
     * Pose plugin can adjust estimated spine skeleton resembling
     * curvature of model's spine in rest (default) pose. In other
     * words it slightly modifies bone positions and rotations to
     * mimic spine curve. Parameter is a number, usually in range
     * [0..1]. 0 or undefined means spine of the rig will remain
     * flat (default estimation), while 1 - rig's curvature is
     * projected completely. Values in between control strength
     * of curvature and values bigger than 1.0 will amplify it.
     */
    spineCurve?: number;
    /**
     * Whether limb bones should be rescaled to preserve lengthes.
     * When armature of a limb is aligned to fit detected joints
     * lengthes of bones may not perfectly correspond to distnaces
     * between pose keypoints. There are two options, uniformly
     * rescale bones to perfectly align armature and pose joints,
     * or allow slight displacement of armature joints relative to
     * detected positions, in other words gap between bones. The
     * first option is enabled by this flag, the downside is that
     * this may introduce scale difference between connected bones
     * that leads to unnatural behaviour like bigger arms or legs.
     * The second approach is preferable (flag is not set) but it
     * may lead to self-intersection or stretching near joints.
     */
    scaleLimbs?: boolean;
    /**
     * In some cases it can be useful to adjust positions of
     * the hips making them slightly wider, higher or deeper.
     * This adjustment helps to adapt model to proportions of
     * human body or to make sure body is completely covered.
     * `hipsD` define hips [width, height, depth] adjustment in
     * meters, we recommend values of 0.01 order of magnitude.
     * Default value is 0 meaning the hips are not adjusted.
     */
    hipsD?: Coord3D;
    /**
     * In some cases it can be useful to adjust positions of
     * shoulders making them slightly wider, higher or deeper.
     * This adjustment helps to adapt model to proportions of
     * human body or to make sure body is completely covered.
     * `shouldersD` adjusts shoulders [width, height, depth] in
     * meters, we recommend values of 0.01 order of magnitude.
     * Default value is 0 meaning shoulders are not adjusted.
     */
    shouldersD?: Coord3D;
    /**
     * In many models head of shoulder's bone doesn't coincide
     * with tail of the parent. This parameter defines distance
     * from head of the neck bone to head of the shoulder bone
     * ratio to distance to tail of shoulder. Value should be
     * in range [0..1], default value for most models is 0.2
     */
    shoulderOffset?: number;
    /**
     * Distance between center of the head defined by midpoint
     * of ears and position of the head bone (its start) ratio
     * to overall length of head bone. Relative lengths of neck
     * and head bones vary a lot between human-like models. It
     * is not possible to automatically find where ears or the
     * model's mesh are so this value provides a way to define it.
     * Recommended range is [0.3 .. 0.5], default value is 0.35
     * that close to topology of all Ready Player Me avatars.
     */
    headRatio?: number;
    /**
     * Advanced adjustment of the neck bone. Naturally base of
     * a neck is not exactly center between shoulders, it shifts
     * depending on direction of shoulder bones. This parameter
     * defines magnitude of this shift in meters. Recommended
     * values are 0.01 order of magnitude. Default is undefined.
     */
    neckAdjust?: number;
    /**
     * Adjustment of pelvis bone. In some cases it may be needed
     * to fine-tune pelvis bone making it directed slightly
     */
    pelvisDZ?: number;
}
/**
 * Outfit options
 *
 * Defines occluder and hidden meshes of the node.
 * Names of meshes are provided as strings or regex.
 * If name of a child mesh equals string or matches
 * regex it's assigned the corresponding type. All
 * other meshes are assumed to be visible as usual.
 */
interface OutfitParams {
    /** Occluder meshes */
    occluders?: (string | RegExp)[];
    /** Hidden meshes */
    hidden?: (string | RegExp)[];
}

/**
 * Image dilation shader
 *
 * Specialization of {@link ShaderProgram} performing
 * dilation operation on a grayscale image. Dilation
 * is a morphological operations adding pixels to the
 * boundaries of objects in an image. The value of the
 * output pixel is maximum value of all pixels in the
 * neighbourhood which radius is a modifiable parameter.
 */
declare class DilationShader extends ShaderProgram {
    /**
     * Constructor
     *
     * @param gl - WebGL context where program is instantiated
     * @param size - Size of processed (input & output) image
     * @param radius - Dilation operation radius
     */
    constructor(gl: WebGL2RenderingContext, size: Size, radius?: number);
}
/**
 * Image erosion shader
 *
 * Specialization of {@link ShaderProgram} performing
 * erosion operation on a grayscale image. Erosion
 * is a morphological operations removing pixels on the
 * boundaries of objects in an image. The value of the
 * output pixel is minimum value of all pixels in the
 * neighbourhood which radius is a modifiable parameter.
 */
declare class ErosionShader extends ShaderProgram {
    /**
     * Constructor
     *
     * @param gl - WebGL context where program is instantiated
     * @param size - Size of processed (input & output) image
     * @param radius - Erosion operation radius
     */
    constructor(gl: WebGL2RenderingContext, size: Size, radius?: number);
}

/**
 * Segmentation mask texture
 *
 * Segmentation mask is a monochrome image where
 * every pixel has value from 0 to 1 denoting the
 * probability of it being a foreground pixel.
 */
interface BodyMaskTexture {
    /** Mask data */
    texture: WebGLTexture;
    /** Size of the mask */
    size: Size$1;
    /** Region of the mask */
    box: Box;
}
/** Tracking results having segmentation mask */
type SegmentationResult = PoseResult | FaceResult | MaskResult;
declare module "@geenee/bodyprocessors" {
    interface Pose {
        /** Segmentation mask texture */
        maskTex?: BodyMaskTexture;
    }
    interface Face {
        /** Segmentation mask texture */
        maskTex?: BodyMaskTexture;
    }
    interface Mask {
        /** Segmentation mask texture */
        maskTex?: BodyMaskTexture;
    }
}
/**
 * Segmentation mask upload plugin
 *
 * Uploads segmentation mask to an image texture that can
 * be reused by plugins next in the rendering pipeline.
 * Uploading texture ones and reusing it speeds up rendering.
 * Most plugins that post-process or utilize mask depend on
 * MaskUploadPlugin and require it to be attached to renderer.
 * Mask texture will be loaded and added to the corresponding
 * {@link @geenee/bodyprocessors!Pose | Pose},
 * {@link @geenee/bodyprocessors!Face | Face}, or
 * {@link @geenee/bodyprocessors!Mask | Mask} of the tracking
 * results as `maskTex` field of {@link BodyMaskTexture} type.
 * Evaluation of body segmentation mask must be enabled in
 * {@link @geenee/bodyprocessors!PoseProcessor#init} setting
 * {@link @geenee/bodyprocessors!PoseParams#mask} to true or
 * {@link @geenee/bodyprocessors!FaceProcessor#init} setting
 * {@link @geenee/bodyprocessors!FaceParams#mask} to true.
 */
declare class MaskUploadPlugin extends Plugin<SegmentationResult> {
    protected size: Size$1;
    /** Segmentation mask texture */
    private maskTexture?;
    /** Constructor
     *
     * @param size - Size of segmentation mask
     */
    constructor(size?: Size$1);
    /**
     * Initialize plugin
     *
     * Initializes texture to upload segmentation mask.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Upload segmentation masks
     *
     * Uploads segmentation mask to texture and adds corresponding field
     * to results of tracking to be used by plugins next in the pipeline.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}
/**
 * Convert segmentation mask box to rect shader uniform
 *
 * @param b - Mask box
 * @returns Mask rect shader uniform
 */
declare function maskRectUniform(b: Box): [number, number, number, number];
/**
 * Extract detected object with segmentation mask
 *
 * @param result - Processing/tracking results
 * @returns Detcted object with segmentation mask
 */
declare function getMaskObj(result: SegmentationResult): _geenee_bodyprocessors.Mask | undefined;
/**
 * Extract mask buffer from processing results
 *
 * @param result - Processing/tracking results
 * @returns Segmentation mask buffer
 */
declare function getMaskBuf(result: SegmentationResult): _geenee_bodytracking.BodyMask | undefined;
/**
 * Extract mask texture from processing results
 *
 * @param result - Processing/tracking results
 * @returns Segmentation mask texture
 */
declare function getMaskTex(result: SegmentationResult): BodyMaskTexture | undefined;

/**
 * Segmentation mask upscale plugin
 *
 * Performs smart upscaling of a segmentation mask on a pixel
 * level using input image as a context provider. Increases the
 * resolution of a segmentation mask preserving the consistency
 * of foreground and background regions. BodyMaskHDPlugin is a
 * processing (pre-render) stage plugin that can be attached to
 * a {@link @geenee/armature!ShaderRenderer}. It depends on
 * {@link MaskUploadPlugin} that must be attached to a renderer.
 * High resolution mask will replace current `maskTex` within
 * tracking results as described in {@link MaskUploadPlugin}.
 * It can be utilized by plugins next in the rendering pipeline.
 * Higher resolution segmentation increases quality and accuracy
 * of partial patching and occluder components of the rendering.
 */
declare class MaskUpscalePlugin extends Plugin<SegmentationResult> {
    protected thresh: number;
    protected steps: number;
    protected size: Size;
    /** Segmentation mask upscaler */
    private upscaler;
    /**
     * Constructor
     *
     * @param thresh - Foreground threshold
     * @param steps - Number of x2 upscale steps
     * @param size - Size of input segmentation mask
     */
    constructor(thresh?: number, steps?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes resources required for shader effect.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Upscale segmentation masks
     *
     * Performs smart pixel-level upscaling of
     * a segmentation mask to a higher resolution.
     * Replaces `maskTex` of tracks with HD mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Smoothing plugin for segmentation mask
 *
 * Performs a smoothing convolution on a segmentation mask.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * One may utilize {@link MaskUpscalePlugin} providing higher
 * resolution segmentation mask that significantly increases
 * mask's accuracy. Plugin may be combined with other mask
 * post-processing plugins. Order in which operation on mask
 * are applied is defined by order of plugins' attachment.
 */
declare class MaskSmoothPlugin extends Plugin<SegmentationResult> {
    protected smooth: number;
    protected size: Size;
    protected radius: number;
    /** Gaussian filter x pass */
    private xpass?;
    /** Gaussian filter y pass */
    private ypass?;
    /** Gaussian kernel */
    private gaussian;
    /**
     * Constructor
     *
     * @param smooth - Smoothing strength
     * @param size - Size of segmentation mask
     * @param radius - Convolution radius
     */
    constructor(smooth?: number, size?: Size, radius?: number);
    /**
     * Initialize plugin
     *
     * Initializes smoothing shader programs.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates the mask applying smoothing convolution.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Temporal filter plugin for segmentation mask
 *
 * Performs temporal filtering of a segmentation mask that
 * is based on minimization of entropy in probability space.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * It may be combined with other mask post-processing plugins.
 * Order in which operation on mask are applied corresponds
 * to the order in which plugins are attached to the renderer.
 */
declare class MaskFilterPlugin extends Plugin<SegmentationResult> {
    protected alpha: number;
    protected size: Size;
    /** Temporal filters pass */
    private filters?;
    /** Switcher for filters */
    private filterTurn;
    /**
     * Constructor
     *
     * @param alpha - Filtering strength
     * @param size - Size of segmentation mask
     */
    constructor(alpha?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes filter shader programs.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Filters the segmentation applying temporal smoothing.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Sharpening plugin for segmentation mask
 *
 * Applies a smart sharpening filter on a segmentation mask.
 * This plugin may significantly increase accuracy of a mask.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * It may be combined with other mask post-processing plugins.
 * Order in which operation on mask are applied corresponds
 * to the order in which plugins are attached to the renderer.
 */
declare class MaskSharpPlugin extends Plugin<SegmentationResult> {
    protected radius: number;
    protected size: Size;
    /** Sharpening y pass */
    private ypass?;
    /** Sharpening x pass */
    private xpass?;
    /**
     * Constructor
     *
     * @param radius - Filter radius
     * @param size - Size of segmentation mask
     */
    constructor(radius?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes sharpening shader program.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates segmentation mask applying sharpening filter.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Dilation operation plugin for segmentation mask
 *
 * Performs the dilation operation on a segmentation mask.
 * Dilation is a morphological operations adding pixels to
 * the boundaries of masked objects in an image. The value
 * of the output pixel is maximum value of all pixels in
 * the neighbourhood which radius is a plugin's parameter.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * One may utilize {@link MaskUpscalePlugin} providing higher
 * resolution segmentation mask that significantly increases
 * mask's accuracy. Plugin may be combined with other mask
 * post-processing plugins. Order in which operation on mask
 * are applied is defined by order of plugins' attachment.
 */
declare class MaskDilationPlugin extends Plugin<SegmentationResult> {
    protected radius: number;
    protected size: Size;
    /** Dilation shader */
    protected shader?: DilationShader;
    /** Constructor
     *
     * @param radius - Dilation operation radius
     * @param size - Size of segmentation mask
     */
    constructor(radius?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes dilation shader program.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates segmentation mask applying dilation operation.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Erosion operation plugin for segmentation mask
 *
 * Performs the erosion operation on a segmentation mask.
 * Erosion is a morphological operations removing pixels on
 * the boundaries of masked objects in an image. The value
 * of the output pixel is minimum value of all pixels in
 * the neighbourhood which radius is a plugin's parameter.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * One may utilize {@link MaskUpscalePlugin} providing higher
 * resolution segmentation mask that significantly increases
 * mask's accuracy. Plugin may be combined with other mask
 * post-processing plugins. Order in which operation on mask
 * are applied is defined by order of plugins' attachment.
 */
declare class MaskErosionPlugin extends Plugin<SegmentationResult> {
    protected radius: number;
    protected size: Size;
    /** Dilation shader */
    protected shader?: ErosionShader;
    /** Constructor
     *
     * @param radius - Erosion operation radius
     * @param size - Size of segmentation mask
     */
    constructor(radius?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes dilation shader program.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates segmentation mask applying dilation operation.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Morphological operation plugin for segmentation mask
 *
 * Performs a morphological operation on a segmentation mask.
 * The most basic morphological ops are dilation and erosion.
 * Dilation adds pixels to the boundaries of objects in an
 * image, while erosion removes pixels on object boundaries.
 * Value of the output pixel is maximum value of all pixels
 * in the neighbourhood for dilation, and minimum for erosion.
 * Radius of a square neighbourhood is a plugin's parameter.
 * Positive radius provides dilation while negative - erosion.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * One may utilize {@link MaskUpscalePlugin} providing higher
 * resolution segmentation mask that significantly increases
 * mask's accuracy. Plugin may be combined with other mask
 * post-processing plugins. Order in which operation on mask
 * are applied is defined by order of plugins' attachment.
 */
declare class MaskMorphPlugin extends Plugin<SegmentationResult> {
    protected radius: number;
    protected size: Size;
    /** Dilation or erosion shader */
    protected shader?: DilationShader | ErosionShader;
    /** Constructor
     *
     * @param radius - Morphological operation radius
     * @param size - Size of segmentation mask
     */
    constructor(radius?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes dilation or erosion shader program.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates segmentation mask applying morphological op.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Binarization plugin for segmentation mask
 *
 * Applies a mask binarization agains provided threshold.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * It may be combined with other mask post-processing plugins.
 * Order in which operation on mask are applied corresponds
 * to the order in which plugins are attached to the renderer.
 */
declare class MaskBinaryPlugin extends Plugin<SegmentationResult> {
    protected thresh: number;
    protected size: Size;
    /** Binarization shader */
    protected shader?: ShaderProgram;
    /**
     * Constructor
     *
     * @param thresh - Foreground threshold
     * @param size - Size of segmentation mask
     */
    constructor(thresh?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes binarization shader program.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates segmentation mask applying binarization op.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Smooth binarization plugin for segmentation mask
 *
 * Performs mask binarization with smooth transition beetween
 * 0 and 1 applying sigmoid function within threshold range.
 * Plugin depends on {@link MaskUploadPlugin} that must be
 * attached to the renderer to upload mask buffer in texture.
 * It may be combined with other mask post-processing plugins.
 * Order in which operation on mask are applied corresponds
 * to the order in which plugins are attached to the renderer.
 */
declare class MaskStepPlugin extends Plugin<SegmentationResult> {
    protected edge0: number;
    protected edge1: number;
    protected size: Size;
    /** Smooth step shader */
    protected shader?: ShaderProgram;
    /**
     * Constructor
     *
     * @param edge0 - Background threshold
     * @param edge1 - Foreground threshold
     * @param size - Size of segmentation mask
     */
    constructor(edge0?: number, edge1?: number, size?: Size);
    /**
     * Initialize plugin
     *
     * Initializes binarization shader program.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources initialized in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update segmentation masks
     *
     * Updates segmentation mask applying binarization op.
     * Replaces `maskTex` of tracks with the updated mask.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @override
     */
    update(result: SegmentationResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Background blur plugin
 *
 * {@link @geenee/armature!ShaderPlugin} blurring background region of an
 * image. Segmentation mask defines image foreground that stays untouched.
 * Plugin depends on {@link @geenee/bodyrenderers-common!MaskUploadPlugin}
 * that must be attached to the renderer to upload mask buffer in texture.
 * One may utilize a {@link @geenee/bodyrenderers-common!MaskUpscalePlugin}
 * providing higher resolution segmentation mask that significantly increases
 * accuracy of patching and reduces the size of the patch region. Other mask
 * post-processing plugins may be used to fine-tune for particular use case.
 */
declare class BgBlurPlugin extends ShaderPlugin<SegmentationResult> {
    protected smooth: number;
    protected radius: number;
    /** Gaussian filter x pass */
    private xpass?;
    /** Gaussian kernel */
    private gaussian;
    /**
     * Constructor
     *
     * @param smooth - Smoothing strength
     * @param thresh - Background threshold
     * @param radius - Convolution radius
     */
    constructor(smooth?: number, thresh?: number, radius?: number);
    /**
     * Initialize plugin
     *
     * Initializes resources required for shader effect.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Process the image
     *
     * Applies background blur filter.
     *
     * @param result - Results of video processing
     * @param input - Current image texture
     * @returns True on success, false otherwise
     * @override
     */
    process(result: SegmentationResult, input: WebGLTexture): Promise<boolean>;
    /**
     * Set video size
     *
     * Adjusts shader and texture to a new size.
     *
     * @param size - Resolution of input video
     * @override
     */
    setupVideo(size: Size): void;
}

/**
 * Background replace plugin
 *
 * {@link @geenee/armature!ShaderPlugin} replaces background region of an
 * image. Segmentation mask defines image foreground that stays untouched.
 * Foreground-background classification is based on two thresholds defining
 * uncertainty interval. Probability above foreground threshold classifies
 * pixel as foreground, below background threshold as background. FG pixels
 * are kept untouched, BG pixels are replaced with corresponding pixels from
 * the background texture. For pixels within uncertainty region weighted
 * interpolation between image and background textures takes place. Weight
 * is evaluated by scaling uncertainty interval and probability to [0..1].
 * Plugin depends on {@link @geenee/bodyrenderers-common!MaskUploadPlugin}
 * that must be attached to the renderer to upload mask buffer in texture.
 * One may utilize a {@link @geenee/bodyrenderers-common!MaskUpscalePlugin}
 * providing higher resolution segmentation mask that significantly increases
 * accuracy of patching and reduces the size of the patch region. Other mask
 * post-processing plugins may be used to fine-tune for particular use case.
 */
declare class BgReplacePlugin extends ShaderPlugin<SegmentationResult> {
    protected mirror: boolean;
    /** Background texture */
    protected bgTexture?: ImageTexture;
    /**
     * Constructor
     *
     * @param threshBg - Background threshold
     * @param threshFg - Foreground threshold
     * @param mirror - Mirror background
     */
    constructor(threshBg?: number, threshFg?: number, mirror?: boolean);
    /**
     * Initialize plugin
     *
     * Initializes resources required for shader effect.
     * Allocates texture that will replace background.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Process the image
     *
     * Applies background replacement with texture.
     *
     * @param result - Results of video processing
     * @param input - Current image texture
     * @returns True on success, false otherwise
     * @override
     */
    process(result: SegmentationResult, input: WebGLTexture): Promise<boolean>;
    /**
     * Texture replacing a background
     *
     * @returns Background texture
     */
    background(): ImageTexture | undefined;
    /**
     * Set background mirror mode
     *
     * @param mirror - Mirror flag
     */
    setMirror(mirror: boolean): void;
    /**
     * Set video size
     *
     * Adjusts shader and texture to a new size.
     *
     * @param size - Resolution of input video
     * @override
     */
    setupVideo(size: Size): void;
}

/**
 * Video merge plugin
 *
 * {@link @geenee/armature!ShaderPlugin} merges input video stream with
 * the background texture. Merge is done by linear interpolation between
 * images and interpolation weight (alpha) is a tunable input parameter
 * that can be changed on runtime for smooth transition between streams.
 * Background texture is allocated by the plugin and has the same size as
 * the input stream, it can be accessed and updated on runtime, this, for
 * example, allows to replace input video stream with a background video.
 */
declare class VideoMergePlugin extends ShaderPlugin<any> {
    protected alpha: number;
    protected mirror: boolean;
    /** Background texture */
    protected bgTexture?: ImageTexture;
    /**
     * Constructor
     *
     * @param alpha - Interpolation factor
     * @param mirror - Mirror background
     */
    constructor(alpha?: number, mirror?: boolean);
    /**
     * Initialize plugin
     *
     * Initializes resources required for the shader effect.
     * Allocates texture that will be merged with the video.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<any>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Process the image
     *
     * Merges the video with a background texture.
     *
     * @param result - Results of video processing
     * @param input - Current image texture
     * @returns True on success, false otherwise
     * @override
     */
    process(result: any, input: WebGLTexture): Promise<boolean>;
    /**
     * Background texture merged with the video
     *
     * @returns Background texture
     */
    background(): ImageTexture | undefined;
    /**
     * Set interpolation factor
     *
     * @param alpha - Interpolation factor
     */
    setAlpha(alpha: number): void;
    /**
     * Set background mirror mode
     *
     * @param mirror - Mirror flag
     */
    setMirror(mirror: boolean): void;
    /**
     * Set video size
     *
     * Adjusts shader and texture to a new size.
     *
     * @param size - Resolution of input video
     * @override
     */
    setupVideo(size: Size): void;
}

/**
 * Bilateral smoothing plugin
 *
 * {@link ShaderPlugin} applying bilateral filter: non-linear,
 * edge-preserving, and noise-reducing smoothing image filter.
 */
declare class BilateralPlugin extends ShaderPlugin<any> {
    protected smooth: number;
    protected sense: number;
    protected radius: number;
    /** Bilateral filter pass */
    private xpass?;
    /** Gaussian kernel */
    private gaussian;
    /**
     * Constructor
     *
     * @param smooth - Smoothing strength
     * @param sense - Edge sensitivity
     * @param radius - Convolution radius
     */
    constructor(smooth?: number, sense?: number, radius?: number);
    /**
     * Initialize plugin
     *
     * Initializes resources required for shader effect.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<any>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Process the image
     *
     * Applies bilateral smoothing filter.
     *
     * @param result - Results of video processing
     * @param input - Current image texture
     * @returns True on success, false otherwise
     * @override
     */
    process(result: any, input: WebGLTexture): Promise<boolean>;
    /**
     * Set video size
     *
     * Adjusts shader and texture to a new size.
     *
     * @param size - Resolution of input video
     * @override
     */
    setupVideo(size: Size): void;
}

/**
 * Body patch plugin
 *
 * Plugin patches (inpaints/erases) foreground region of image defined by
 * body segmentation mask from {@link @geenee/bodyprocessors!PoseProcessor}.
 * It may be used in avatar virtual try to remove parts of a user's body
 * that stick out (not covered). Plugin depends on {@link MaskUploadPlugin}
 * that must be attached to the renderer to upload mask in an image texture.
 * One may utilize {@link MaskUpscalePlugin} that provides higher resolution
 * segmentation that significantly increases accuracy of patching and reduces
 * size of patch region. Other mask post-processing plugins may be attached.
 */
declare class BodyPatchPlugin extends ShaderPlugin<SegmentationResult> {
    protected thresh: number;
    protected radius: number;
    protected maskSize: Size;
    /** Background distance transform */
    private distShader?;
    /** Constructor
     *
     * @param thresh - Foreground threshold
     * @param radius - Radius of foreground search
     * @param maskSize - Size of segmentation mask
     */
    constructor(thresh?: number, radius?: number, maskSize?: Size);
    /**
     * Initialize plugin
     *
     * Initializes resources required for shader effect.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<SegmentationResult>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Process the image
     *
     * Patches (inpaints) foreground image pixels
     * according to provided segmentation mask.
     *
     * @param result - Results of video processing
     * @param input - Current image texture
     * @returns True on success, false otherwise
     * @override
     */
    process(result: SegmentationResult, input: WebGLTexture): Promise<boolean>;
}

/**
 * Brightness estimation plugin
 *
 * Plugin estimates parameters of lighting (brightness)
 * observed in the current image and calls the provided
 * callback with these parameters. This plugin can be
 * used for automatic adjustment of intensities of lights
 * on the scene, for example in callback user can scale
 * intensity properties of lights and environment map
 * according to estimated brightness. One can set output
 * range, estimated value will not go below the minimum
 * and [min..max] range will be scaled to [min..1.0].
 * Adaptive low pass smoothing is applied to the result.
 */
declare class BrightnessPlugin extends Plugin<any> {
    protected callback?: ((brightness: number) => void) | undefined;
    protected rangeMax: number;
    protected rangeMin: number;
    protected filterParams: FilterParams;
    /** Multilevel image texture */
    private image?;
    /** Texture reader */
    private reader?;
    /** Pending read */
    private pending?;
    /** Size of the image */
    private size;
    /** Ratio to scale brightness range */
    private rangeRatio;
    /** Smooth brightness value */
    private smooth?;
    /**
     * Constructor
     *
     * @param callback - Method when brightness has changed
     * @param rangeMax - Maximum brightness, range scales to [min..1.0]
     * @param rangeMin - Minimum brightness, range scales to [min..1.0]
     * @param filterParams - Parameters of reactive low-pass filter
     */
    constructor(callback?: ((brightness: number) => void) | undefined, rangeMax?: number, rangeMin?: number, filterParams?: FilterParams);
    /**
     * Initialize plugin
     *
     * Initializes resources for the brightness estimation.
     * Acquires webgl context of the main ShaderRenderer,
     * allocates multilevel texture for the input image.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     */
    load(renderer: Renderer<any>): Promise<void>;
    /**
     * Reset plugin
     *
     * Releases all resources and instances created in load().
     *
     * @override
     */
    unload(): void;
    /**
     * Update
     *
     * Plugin estimates current brightness and calls provided callback.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @returns Promise resolving when update is finished
     * @override
     */
    update(result: any, stream: HTMLCanvasElement): Promise<void>;
    /**
     * Set video size
     *
     * Resize multilevel texture
     *
     * @param size - Resolution of input video
     * @override
     */
    setupVideo(size: Size): boolean;
    /**
     * Set brightness change callback
     *
     * @param callback - Method when brightness has changed
     */
    setCallback(callback: typeof this.callback): void;
    /**
     * Adaptive low pass filtering
     *
     * @param val - Current estimation
     * @returns Smoothed value
     */
    private filter;
}
/** Parameters of the smoothing filter */
interface FilterParams {
    minCutOff: number;
    minCutOffD: number;
    beta: number;
}

/**
 * Callback plugin
 *
 * Simple plugin executing provided callback on processing
 * results. Useful when, for example, application needs to
 * show a message when no object is detected in camera's
 * field of view or pose is not optimal for virtual try on.
 */
declare class CallbackPlugin<ResultT extends {} = {}> extends Plugin<ResultT> {
    protected callback: (r: ResultT) => void;
    /**
     * Constructor
     *
     * @param callback - Callback method
     */
    constructor(callback: (r: ResultT) => void);
    /**
     * Update
     *
     * Override executes the callback on results of video processing.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @returns Promise resolving when update is finished
     * @override
     */
    update(result: ResultT, stream: HTMLCanvasElement): Promise<void>;
}
/**
 * Callback plugin for pose detection
 *
 * Specialization of {@link CallbackPlugin} for pose detection results.
 */
declare class PoseCallbackPlugin extends CallbackPlugin<PoseResult> {
}
/**
 * Callback plugin for face detection
 *
 * Specialization of {@link CallbackPlugin} for face detection results.
 */
declare class FaceCallbackPlugin extends CallbackPlugin<FaceResult> {
}

/**
 * Pose filter plugin
 *
 * Simple plugin filtering a list of detected poses
 * by the provided predicate. Useful when application
 * may need to ignore certain poses to provide the best
 * quality of virtual try-on. For example to ensure that
 * at least upper body of user is in the field of view.
 */
declare class PoseFilterPlugin extends Plugin<PoseResult> {
    protected predicate: (p: Pose) => boolean;
    /**
     * Constructor
     *
     * @param predicate - Predicate of pose filter
     */
    constructor(predicate: (p: Pose) => boolean);
    /**
     * Update
     *
     * Override filters detected poses in place
     * using predicate provided to constructor.
     *
     * @param result - Results of pose detection
     * @param stream - Captured video frame
     * @returns Promise resolving when update is finished
     * @override
     */
    update(result: PoseResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Face filter plugin
 *
 * Simple plugin filtering a list of detected faces
 * by the provided predicate. Useful when application
 * may need to ignore certain head poses, for example
 * when rotation angle is too big for virtual try-on.
 */
declare class FaceFilterPlugin extends Plugin<FaceResult> {
    protected predicate: (f: Face) => boolean;
    /**
     * Constructor
     *
     * @param predicate - Predicate of face filter
     */
    constructor(predicate: (f: Face) => boolean);
    /**
     * Update
     *
     * Override filters detected faces in place
     * using predicate provided to constructor.
     *
     * @param result - Results of face detection
     * @param stream - Captured video frame
     * @returns Promise resolving when update is finished
     * @override
     */
    update(result: FaceResult, stream: HTMLCanvasElement): Promise<void>;
}

/**
 * Factory function adding delay to a plugin
 *
 * In delayed plugin update() method is called with detection results
 * from one of the previous iterations of the tracking engine. This way
 * we achieve effect of object following its controller with some delay.
 * Delay may be used in combination with various twin plugins to achieve
 * less artificial behaviour of twins that will repeat user movements
 * without absolute synchronization in time and thus look more natural.
 *
 * @param plugin - Plugin to introduce delay to
 * @param delay - Number of updates to delay
 * @typeParam PluginT - Type of plugin
 * @typeParam ResultT - Type of processing results
 * @returns Plugin with delay added
 */
declare function DelayPlugin<PluginT extends Plugin<ResultT>, ResultT extends {} = {}>(plugin: PluginT, delay?: number): PluginT & {
    results: ResultT[];
    delay: number;
};

/**
 * Performance metrics plugin
 *
 * Simple plugin measuring basic performance metrics
 * of a renderer (fps). Executes provided callback
 * when metrics are updated (every 30 rendered frames).
 */
declare class PerfDevPlugin extends Plugin<any> {
    protected callback: (fps: number) => void;
    /** Start of measurement interval */
    protected fpsStart: number;
    /** Frame counter */
    protected fpsCount: number;
    /**
     * Constructor
     * @param callback - Callback method
     */
    constructor(callback: (fps: number) => void);
    /**
     * Initialize plugin
     *
     * Resets performance counters.
     *
     * @param renderer - Renderer this plugin is attached to
     * @returns Promise resolving when initialization is finished
     * @override
     */
    load(renderer: Renderer<any>): Promise<void>;
    /**
     * Update
     *
     * Evaluates metrics and increments counters.
     * Every N rendered frames executes callback on
     * current measurements of performance metrics.
     *
     * @param result - Results of video processing
     * @param stream - Captured video frame
     * @returns Promise resolving when update is finished
     * @override
     */
    update(result: any, stream: HTMLCanvasElement): Promise<void>;
}

export { BgBlurPlugin, BgReplacePlugin, BilateralPlugin, type BodyMaskTexture, BodyPatchPlugin, BrightnessPlugin, CallbackPlugin, DelayPlugin, DilationShader, ErosionShader, FaceCallbackPlugin, FaceFilterPlugin, type FilterParams, MaskBinaryPlugin, MaskDilationPlugin, MaskErosionPlugin, MaskFilterPlugin, MaskMorphPlugin, MaskSharpPlugin, MaskSmoothPlugin, MaskStepPlugin, MaskUploadPlugin, MaskUpscalePlugin, type OutfitParams, PerfDevPlugin, PoseCallbackPlugin, PoseFilterPlugin, type PoseTuneParams, type SegmentationResult, VideoMergePlugin, getMaskBuf, getMaskObj, getMaskTex, maskRectUniform };
