import {
  b0,
  i,
  x
} from "./chunk-QOBHKNUZ.js";
import {
  __commonJS
} from "./chunk-5WRI5ZAA.js";

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-fetch/browser.js
var require_browser = __commonJS({
  "node_modules/node-fetch/browser.js"(exports, module) {
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    };
    var globalObject = getGlobal();
    module.exports = exports = globalObject.fetch;
    if (globalObject.fetch) {
      exports.default = globalObject.fetch.bind(globalObject);
    }
    exports.Headers = globalObject.Headers;
    exports.Request = globalObject.Request;
    exports.Response = globalObject.Response;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports, module) {
    "use strict";
    module.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (var _ in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(obj, sym)
        );
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports, module) {
    "use strict";
    var hasSymbols = require_shams();
    module.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/es-object-atoms/index.js
var require_es_object_atoms = __commonJS({
  "node_modules/es-object-atoms/index.js"(exports, module) {
    "use strict";
    module.exports = Object;
  }
});

// node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "node_modules/es-errors/index.js"(exports, module) {
    "use strict";
    module.exports = Error;
  }
});

// node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "node_modules/es-errors/eval.js"(exports, module) {
    "use strict";
    module.exports = EvalError;
  }
});

// node_modules/es-errors/range.js
var require_range = __commonJS({
  "node_modules/es-errors/range.js"(exports, module) {
    "use strict";
    module.exports = RangeError;
  }
});

// node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "node_modules/es-errors/ref.js"(exports, module) {
    "use strict";
    module.exports = ReferenceError;
  }
});

// node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "node_modules/es-errors/syntax.js"(exports, module) {
    "use strict";
    module.exports = SyntaxError;
  }
});

// node_modules/es-errors/type.js
var require_type = __commonJS({
  "node_modules/es-errors/type.js"(exports, module) {
    "use strict";
    module.exports = TypeError;
  }
});

// node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "node_modules/es-errors/uri.js"(exports, module) {
    "use strict";
    module.exports = URIError;
  }
});

// node_modules/math-intrinsics/abs.js
var require_abs = __commonJS({
  "node_modules/math-intrinsics/abs.js"(exports, module) {
    "use strict";
    module.exports = Math.abs;
  }
});

// node_modules/math-intrinsics/floor.js
var require_floor = __commonJS({
  "node_modules/math-intrinsics/floor.js"(exports, module) {
    "use strict";
    module.exports = Math.floor;
  }
});

// node_modules/math-intrinsics/max.js
var require_max = __commonJS({
  "node_modules/math-intrinsics/max.js"(exports, module) {
    "use strict";
    module.exports = Math.max;
  }
});

// node_modules/math-intrinsics/min.js
var require_min = __commonJS({
  "node_modules/math-intrinsics/min.js"(exports, module) {
    "use strict";
    module.exports = Math.min;
  }
});

// node_modules/math-intrinsics/pow.js
var require_pow = __commonJS({
  "node_modules/math-intrinsics/pow.js"(exports, module) {
    "use strict";
    module.exports = Math.pow;
  }
});

// node_modules/math-intrinsics/round.js
var require_round = __commonJS({
  "node_modules/math-intrinsics/round.js"(exports, module) {
    "use strict";
    module.exports = Math.round;
  }
});

// node_modules/math-intrinsics/isNaN.js
var require_isNaN = __commonJS({
  "node_modules/math-intrinsics/isNaN.js"(exports, module) {
    "use strict";
    module.exports = Number.isNaN || function isNaN2(a2) {
      return a2 !== a2;
    };
  }
});

// node_modules/math-intrinsics/sign.js
var require_sign = __commonJS({
  "node_modules/math-intrinsics/sign.js"(exports, module) {
    "use strict";
    var $isNaN = require_isNaN();
    module.exports = function sign(number) {
      if ($isNaN(number) || number === 0) {
        return number;
      }
      return number < 0 ? -1 : 1;
    };
  }
});

// node_modules/gopd/gOPD.js
var require_gOPD = __commonJS({
  "node_modules/gopd/gOPD.js"(exports, module) {
    "use strict";
    module.exports = Object.getOwnPropertyDescriptor;
  }
});

// node_modules/gopd/index.js
var require_gopd = __commonJS({
  "node_modules/gopd/index.js"(exports, module) {
    "use strict";
    var $gOPD = require_gOPD();
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e2) {
        $gOPD = null;
      }
    }
    module.exports = $gOPD;
  }
});

// node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "node_modules/es-define-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = Object.defineProperty || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e2) {
        $defineProperty = false;
      }
    }
    module.exports = $defineProperty;
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports, module) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/get-proto/Reflect.getPrototypeOf.js
var require_Reflect_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Reflect.getPrototypeOf.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect.getPrototypeOf || null;
  }
});

// node_modules/get-proto/Object.getPrototypeOf.js
var require_Object_getPrototypeOf = __commonJS({
  "node_modules/get-proto/Object.getPrototypeOf.js"(exports, module) {
    "use strict";
    var $Object = require_es_object_atoms();
    module.exports = $Object.getPrototypeOf || null;
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports, module) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a2, b) {
      var arr = [];
      for (var i3 = 0; i3 < a2.length; i3 += 1) {
        arr[i3] = a2[i3];
      }
      for (var j2 = 0; j2 < b.length; j2 += 1) {
        arr[j2 + a2.length] = b[j2];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i3 = offset || 0, j2 = 0; i3 < arrLike.length; i3 += 1, j2 += 1) {
        arr[j2] = arrLike[i3];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i3 = 0; i3 < arr.length; i3 += 1) {
        str += arr[i3];
        if (i3 + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i3 = 0; i3 < boundLength; i3++) {
        boundArgs[i3] = "$" + i3;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports, module) {
    "use strict";
    var implementation = require_implementation();
    module.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/call-bind-apply-helpers/functionCall.js
var require_functionCall = __commonJS({
  "node_modules/call-bind-apply-helpers/functionCall.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.call;
  }
});

// node_modules/call-bind-apply-helpers/functionApply.js
var require_functionApply = __commonJS({
  "node_modules/call-bind-apply-helpers/functionApply.js"(exports, module) {
    "use strict";
    module.exports = Function.prototype.apply;
  }
});

// node_modules/call-bind-apply-helpers/reflectApply.js
var require_reflectApply = __commonJS({
  "node_modules/call-bind-apply-helpers/reflectApply.js"(exports, module) {
    "use strict";
    module.exports = typeof Reflect !== "undefined" && Reflect && Reflect.apply;
  }
});

// node_modules/call-bind-apply-helpers/actualApply.js
var require_actualApply = __commonJS({
  "node_modules/call-bind-apply-helpers/actualApply.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var $reflectApply = require_reflectApply();
    module.exports = $reflectApply || bind.call($call, $apply);
  }
});

// node_modules/call-bind-apply-helpers/index.js
var require_call_bind_apply_helpers = __commonJS({
  "node_modules/call-bind-apply-helpers/index.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $TypeError = require_type();
    var $call = require_functionCall();
    var $actualApply = require_actualApply();
    module.exports = function callBindBasic(args) {
      if (args.length < 1 || typeof args[0] !== "function") {
        throw new $TypeError("a function is required");
      }
      return $actualApply(bind, $call, args);
    };
  }
});

// node_modules/dunder-proto/get.js
var require_get = __commonJS({
  "node_modules/dunder-proto/get.js"(exports, module) {
    "use strict";
    var callBind = require_call_bind_apply_helpers();
    var gOPD = require_gopd();
    var hasProtoAccessor;
    try {
      hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */
      [].__proto__ === Array.prototype;
    } catch (e2) {
      if (!e2 || typeof e2 !== "object" || !("code" in e2) || e2.code !== "ERR_PROTO_ACCESS") {
        throw e2;
      }
    }
    var desc = !!hasProtoAccessor && gOPD && gOPD(
      Object.prototype,
      /** @type {keyof typeof Object.prototype} */
      "__proto__"
    );
    var $Object = Object;
    var $getPrototypeOf = $Object.getPrototypeOf;
    module.exports = desc && typeof desc.get === "function" ? callBind([desc.get]) : typeof $getPrototypeOf === "function" ? (
      /** @type {import('./get')} */
      function getDunder(value) {
        return $getPrototypeOf(value == null ? value : $Object(value));
      }
    ) : false;
  }
});

// node_modules/get-proto/index.js
var require_get_proto = __commonJS({
  "node_modules/get-proto/index.js"(exports, module) {
    "use strict";
    var reflectGetProto = require_Reflect_getPrototypeOf();
    var originalGetProto = require_Object_getPrototypeOf();
    var getDunderProto = require_get();
    module.exports = reflectGetProto ? function getProto(O3) {
      return reflectGetProto(O3);
    } : originalGetProto ? function getProto(O3) {
      if (!O3 || typeof O3 !== "object" && typeof O3 !== "function") {
        throw new TypeError("getProto: not an object");
      }
      return originalGetProto(O3);
    } : getDunderProto ? function getProto(O3) {
      return getDunderProto(O3);
    } : null;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports, module) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports, module) {
    "use strict";
    var undefined2;
    var $Object = require_es_object_atoms();
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var abs = require_abs();
    var floor = require_floor();
    var max = require_max();
    var min = require_min();
    var pow = require_pow();
    var round = require_round();
    var sign = require_sign();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e2) {
      }
    };
    var $gOPD = require_gopd();
    var $defineProperty = require_es_define_property();
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = require_get_proto();
    var $ObjectGPO = require_Object_getPrototypeOf();
    var $ReflectGPO = require_Reflect_getPrototypeOf();
    var $apply = require_functionApply();
    var $call = require_functionCall();
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float16Array%": typeof Float16Array === "undefined" ? undefined2 : Float16Array,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": $Object,
      "%Object.getOwnPropertyDescriptor%": $gOPD,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet,
      "%Function.prototype.call%": $call,
      "%Function.prototype.apply%": $apply,
      "%Object.defineProperty%": $defineProperty,
      "%Object.getPrototypeOf%": $ObjectGPO,
      "%Math.abs%": abs,
      "%Math.floor%": floor,
      "%Math.max%": max,
      "%Math.min%": min,
      "%Math.pow%": pow,
      "%Math.round%": round,
      "%Math.sign%": sign,
      "%Reflect.getPrototypeOf%": $ReflectGPO
    };
    if (getProto) {
      try {
        null.error;
      } catch (e2) {
        errorProto = getProto(getProto(e2));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn2 = doEval2("%AsyncGeneratorFunction%");
        if (fn2) {
          value = fn2.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call($call, Array.prototype.concat);
    var $spliceApply = bind.call($apply, Array.prototype.splice);
    var $replace = bind.call($call, String.prototype.replace);
    var $strSlice = bind.call($call, String.prototype.slice);
    var $exec = bind.call($call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first = $strSlice(string, 0, 1);
      var last = $strSlice(string, -1);
      if (first === "%" && last !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last === "%" && first !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i3 = 1, isOwn = true; i3 < parts.length; i3 += 1) {
        var part = parts[i3];
        var first = $strSlice(part, 0, 1);
        var last = $strSlice(part, -1);
        if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void undefined2;
          }
          if ($gOPD && i3 + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bound/index.js
var require_call_bound = __commonJS({
  "node_modules/call-bound/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBindBasic = require_call_bind_apply_helpers();
    var $indexOf = callBindBasic([GetIntrinsic("%String.prototype.indexOf%")]);
    module.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = (
        /** @type {(this: unknown, ...args: unknown[]) => unknown} */
        GetIntrinsic(name, !!allowMissing)
      );
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBindBasic(
          /** @type {const} */
          [intrinsic]
        );
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports, module) {
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_call_bound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && "length" in value && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && "callee" in value && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-regex/index.js
var require_is_regex = __commonJS({
  "node_modules/is-regex/index.js"(exports, module) {
    "use strict";
    var callBound = require_call_bound();
    var hasToStringTag = require_shams2()();
    var hasOwn = require_hasown();
    var gOPD = require_gopd();
    var fn2;
    if (hasToStringTag) {
      $exec = callBound("RegExp.prototype.exec");
      isRegexMarker = {};
      throwRegexMarker = function() {
        throw isRegexMarker;
      };
      badStringifier = {
        toString: throwRegexMarker,
        valueOf: throwRegexMarker
      };
      if (typeof Symbol.toPrimitive === "symbol") {
        badStringifier[Symbol.toPrimitive] = throwRegexMarker;
      }
      fn2 = function isRegex(value) {
        if (!value || typeof value !== "object") {
          return false;
        }
        var descriptor = (
          /** @type {NonNullable<typeof gOPD>} */
          gOPD(
            /** @type {{ lastIndex?: unknown }} */
            value,
            "lastIndex"
          )
        );
        var hasLastIndexDataProperty = descriptor && hasOwn(descriptor, "value");
        if (!hasLastIndexDataProperty) {
          return false;
        }
        try {
          $exec(
            value,
            /** @type {string} */
            /** @type {unknown} */
            badStringifier
          );
        } catch (e2) {
          return e2 === isRegexMarker;
        }
      };
    } else {
      $toString = callBound("Object.prototype.toString");
      regexClass = "[object RegExp]";
      fn2 = function isRegex(value) {
        if (!value || typeof value !== "object" && typeof value !== "function") {
          return false;
        }
        return $toString(value) === regexClass;
      };
    }
    var $exec;
    var isRegexMarker;
    var throwRegexMarker;
    var badStringifier;
    var $toString;
    var regexClass;
    module.exports = fn2;
  }
});

// node_modules/safe-regex-test/index.js
var require_safe_regex_test = __commonJS({
  "node_modules/safe-regex-test/index.js"(exports, module) {
    "use strict";
    var callBound = require_call_bound();
    var isRegex = require_is_regex();
    var $exec = callBound("RegExp.prototype.exec");
    var $TypeError = require_type();
    module.exports = function regexTester(regex) {
      if (!isRegex(regex)) {
        throw new $TypeError("`regex` must be a RegExp");
      }
      return function test(s3) {
        return $exec(regex, s3) !== null;
      };
    };
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports, module) {
    "use strict";
    var callBound = require_call_bound();
    var safeRegexTest = require_safe_regex_test();
    var isFnRegex = safeRegexTest(/^\s*(?:function)?\*/);
    var hasToStringTag = require_shams2()();
    var getProto = require_get_proto();
    var toStr = callBound("Object.prototype.toString");
    var fnToStr = callBound("Function.prototype.toString");
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e2) {
      }
    };
    var GeneratorFunction;
    module.exports = function isGeneratorFunction(fn2) {
      if (typeof fn2 !== "function") {
        return false;
      }
      if (isFnRegex(fnToStr(fn2))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr(fn2);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? (
          /** @type {GeneratorFunctionConstructor} */
          getProto(generatorFunc)
        ) : false;
      }
      return getProto(fn2) === GeneratorFunction;
    };
  }
});

// node_modules/is-callable/index.js
var require_is_callable = __commonJS({
  "node_modules/is-callable/index.js"(exports, module) {
    "use strict";
    var fnToStr = Function.prototype.toString;
    var reflectApply = typeof Reflect === "object" && Reflect !== null && Reflect.apply;
    var badArrayLike;
    var isCallableMarker;
    if (typeof reflectApply === "function" && typeof Object.defineProperty === "function") {
      try {
        badArrayLike = Object.defineProperty({}, "length", {
          get: function() {
            throw isCallableMarker;
          }
        });
        isCallableMarker = {};
        reflectApply(function() {
          throw 42;
        }, null, badArrayLike);
      } catch (_) {
        if (_ !== isCallableMarker) {
          reflectApply = null;
        }
      }
    } else {
      reflectApply = null;
    }
    var constructorRegex = /^\s*class\b/;
    var isES6ClassFn = function isES6ClassFunction(value) {
      try {
        var fnStr = fnToStr.call(value);
        return constructorRegex.test(fnStr);
      } catch (e2) {
        return false;
      }
    };
    var tryFunctionObject = function tryFunctionToStr(value) {
      try {
        if (isES6ClassFn(value)) {
          return false;
        }
        fnToStr.call(value);
        return true;
      } catch (e2) {
        return false;
      }
    };
    var toStr = Object.prototype.toString;
    var objectClass = "[object Object]";
    var fnClass = "[object Function]";
    var genClass = "[object GeneratorFunction]";
    var ddaClass = "[object HTMLAllCollection]";
    var ddaClass2 = "[object HTML document.all class]";
    var ddaClass3 = "[object HTMLCollection]";
    var hasToStringTag = typeof Symbol === "function" && !!Symbol.toStringTag;
    var isIE68 = !(0 in [,]);
    var isDDA = function isDocumentDotAll() {
      return false;
    };
    if (typeof document === "object") {
      all = document.all;
      if (toStr.call(all) === toStr.call(document.all)) {
        isDDA = function isDocumentDotAll(value) {
          if ((isIE68 || !value) && (typeof value === "undefined" || typeof value === "object")) {
            try {
              var str = toStr.call(value);
              return (str === ddaClass || str === ddaClass2 || str === ddaClass3 || str === objectClass) && value("") == null;
            } catch (e2) {
            }
          }
          return false;
        };
      }
    }
    var all;
    module.exports = reflectApply ? function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      try {
        reflectApply(value, null, badArrayLike);
      } catch (e2) {
        if (e2 !== isCallableMarker) {
          return false;
        }
      }
      return !isES6ClassFn(value) && tryFunctionObject(value);
    } : function isCallable(value) {
      if (isDDA(value)) {
        return true;
      }
      if (!value) {
        return false;
      }
      if (typeof value !== "function" && typeof value !== "object") {
        return false;
      }
      if (hasToStringTag) {
        return tryFunctionObject(value);
      }
      if (isES6ClassFn(value)) {
        return false;
      }
      var strClass = toStr.call(value);
      if (strClass !== fnClass && strClass !== genClass && !/^\[object HTML/.test(strClass)) {
        return false;
      }
      return tryFunctionObject(value);
    };
  }
});

// node_modules/for-each/index.js
var require_for_each = __commonJS({
  "node_modules/for-each/index.js"(exports, module) {
    "use strict";
    var isCallable = require_is_callable();
    var toStr = Object.prototype.toString;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var forEachArray = function forEachArray2(array, iterator, receiver) {
      for (var i3 = 0, len = array.length; i3 < len; i3++) {
        if (hasOwnProperty.call(array, i3)) {
          if (receiver == null) {
            iterator(array[i3], i3, array);
          } else {
            iterator.call(receiver, array[i3], i3, array);
          }
        }
      }
    };
    var forEachString = function forEachString2(string, iterator, receiver) {
      for (var i3 = 0, len = string.length; i3 < len; i3++) {
        if (receiver == null) {
          iterator(string.charAt(i3), i3, string);
        } else {
          iterator.call(receiver, string.charAt(i3), i3, string);
        }
      }
    };
    var forEachObject = function forEachObject2(object, iterator, receiver) {
      for (var k2 in object) {
        if (hasOwnProperty.call(object, k2)) {
          if (receiver == null) {
            iterator(object[k2], k2, object);
          } else {
            iterator.call(receiver, object[k2], k2, object);
          }
        }
      }
    };
    function isArray(x3) {
      return toStr.call(x3) === "[object Array]";
    }
    module.exports = function forEach(list, iterator, thisArg) {
      if (!isCallable(iterator)) {
        throw new TypeError("iterator must be a function");
      }
      var receiver;
      if (arguments.length >= 3) {
        receiver = thisArg;
      }
      if (isArray(list)) {
        forEachArray(list, iterator, receiver);
      } else if (typeof list === "string") {
        forEachString(list, iterator, receiver);
      } else {
        forEachObject(list, iterator, receiver);
      }
    };
  }
});

// node_modules/possible-typed-array-names/index.js
var require_possible_typed_array_names = __commonJS({
  "node_modules/possible-typed-array-names/index.js"(exports, module) {
    "use strict";
    module.exports = [
      "Float16Array",
      "Float32Array",
      "Float64Array",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports, module) {
    "use strict";
    var possibleNames = require_possible_typed_array_names();
    var g2 = typeof globalThis === "undefined" ? global : globalThis;
    module.exports = function availableTypedArrays() {
      var out = [];
      for (var i3 = 0; i3 < possibleNames.length; i3++) {
        if (typeof g2[possibleNames[i3]] === "function") {
          out[out.length] = possibleNames[i3];
        }
      }
      return out;
    };
  }
});

// node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "node_modules/define-data-property/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module.exports = function defineDataProperty(obj, property, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property !== "string" && typeof property !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property);
      if ($defineProperty) {
        $defineProperty(obj, property, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "node_modules/has-property-descriptors/index.js"(exports, module) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e2) {
        return true;
      }
    };
    module.exports = hasPropertyDescriptors;
  }
});

// node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "node_modules/set-function-length/index.js"(exports, module) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module.exports = function setFunctionLength(fn2, length) {
      if (typeof fn2 !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn2 && gOPD) {
        var desc = gOPD(fn2, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define(
            /** @type {Parameters<define>[0]} */
            fn2,
            "length",
            length,
            true,
            true
          );
        } else {
          define(
            /** @type {Parameters<define>[0]} */
            fn2,
            "length",
            length
          );
        }
      }
      return fn2;
    };
  }
});

// node_modules/call-bind-apply-helpers/applyBind.js
var require_applyBind = __commonJS({
  "node_modules/call-bind-apply-helpers/applyBind.js"(exports, module) {
    "use strict";
    var bind = require_function_bind();
    var $apply = require_functionApply();
    var actualApply = require_actualApply();
    module.exports = function applyBind() {
      return actualApply(bind, $apply, arguments);
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports, module) {
    "use strict";
    var setFunctionLength = require_set_function_length();
    var $defineProperty = require_es_define_property();
    var callBindBasic = require_call_bind_apply_helpers();
    var applyBind = require_applyBind();
    module.exports = function callBind(originalFunction) {
      var func = callBindBasic(arguments);
      var adjustedLength = originalFunction.length - (arguments.length - 1);
      return setFunctionLength(
        func,
        1 + (adjustedLength > 0 ? adjustedLength : 0),
        true
      );
    };
    if ($defineProperty) {
      $defineProperty(module.exports, "apply", { value: applyBind });
    } else {
      module.exports.apply = applyBind;
    }
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports, module) {
    "use strict";
    var forEach = require_for_each();
    var availableTypedArrays = require_available_typed_arrays();
    var callBind = require_call_bind();
    var callBound = require_call_bound();
    var gOPD = require_gopd();
    var getProto = require_get_proto();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g2 = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
      for (var i3 = 0; i3 < array.length; i3 += 1) {
        if (array[i3] === value) {
          return i3;
        }
      }
      return -1;
    };
    var cache = { __proto__: null };
    if (hasToStringTag && gOPD && getProto) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g2[typedArray]();
        if (Symbol.toStringTag in arr && getProto) {
          var proto = getProto(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor && proto) {
            var superProto = getProto(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          cache["$" + typedArray] = callBind(descriptor.get);
        }
      });
    } else {
      forEach(typedArrays, function(typedArray) {
        var arr = new g2[typedArray]();
        var fn2 = arr.slice || arr.set;
        if (fn2) {
          cache[
            /** @type {`$${import('.').TypedArrayName}`} */
            "$" + typedArray
          ] = /** @type {import('./types').BoundSlice | import('./types').BoundSet} */
          // @ts-expect-error TODO FIXME
          callBind(fn2);
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, typedArray) {
          if (!found) {
            try {
              if ("$" + getter(value) === typedArray) {
                found = /** @type {import('.').TypedArrayName} */
                $slice(typedArray, 1);
              }
            } catch (e2) {
            }
          }
        }
      );
      return found;
    };
    var trySlices = function tryAllSlices(value) {
      var found = false;
      forEach(
        /** @type {Record<`\$${import('.').TypedArrayName}`, Getter>} */
        cache,
        /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
        function(getter, name) {
          if (!found) {
            try {
              getter(value);
              found = /** @type {import('.').TypedArrayName} */
              $slice(name, 1);
            } catch (e2) {
            }
          }
        }
      );
      return found;
    };
    module.exports = function whichTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag) {
        var tag = $slice($toString(value), 8, -1);
        if ($indexOf(typedArrays, tag) > -1) {
          return tag;
        }
        if (tag !== "Object") {
          return false;
        }
        return trySlices(value);
      }
      if (!gOPD) {
        return null;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports, module) {
    "use strict";
    var whichTypedArray = require_which_typed_array();
    module.exports = function isTypedArray(value) {
      return !!whichTypedArray(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports) {
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f2) {
      return f2.call.bind(f2);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e2) {
        return false;
      }
    }
    exports.isArgumentsObject = isArgumentsObject;
    exports.isGeneratorFunction = isGeneratorFunction;
    exports.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(/* @__PURE__ */ new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(/* @__PURE__ */ new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(/* @__PURE__ */ new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(/* @__PURE__ */ new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports, module) {
    module.exports = function isBuffer(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/util/util.js
var require_util = __commonJS({
  "node_modules/util/util.js"(exports) {
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i3 = 0; i3 < keys.length; i3++) {
        descriptors[keys[i3]] = Object.getOwnPropertyDescriptor(obj, keys[i3]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f2) {
      if (!isString(f2)) {
        var objects = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          objects.push(inspect(arguments[i3]));
        }
        return objects.join(" ");
      }
      var i3 = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f2).replace(formatRegExp, function(x4) {
        if (x4 === "%%") return "%";
        if (i3 >= len) return x4;
        switch (x4) {
          case "%s":
            return String(args[i3++]);
          case "%d":
            return Number(args[i3++]);
          case "%j":
            try {
              return JSON.stringify(args[i3++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x4;
        }
      });
      for (var x3 = args[i3]; i3 < len; x3 = args[++i3]) {
        if (isNull(x3) || !isObject(x3)) {
          str += " " + x3;
        } else {
          str += " " + inspect(x3);
        }
      }
      return str;
    };
    exports.deprecate = function(fn2, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn2;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports.deprecate(fn2, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn2.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      // "name": intentionally not styling
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function(val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = "", array = false, braces = ["{", "}"];
      if (isArray(value)) {
        array = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n2 = value.name ? ": " + value.name : "";
        base = " [Function" + n2 + "]";
      }
      if (isRegExp(value)) {
        base = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base = " " + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i3 = 0, l2 = value.length; i3 < l2; ++i3) {
        if (hasOwnProperty(value, String(i3))) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            String(i3),
            true
          ));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(
            ctx,
            value,
            recurseTimes,
            visibleKeys,
            key,
            true
          ));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").slice(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify("" + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, -1);
          name = ctx.stylize(name, "name");
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, "string");
        }
      }
      return name + ": " + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base + " " + output.join(", ") + " " + braces[1];
    }
    exports.types = require_types();
    function isArray(ar2) {
      return Array.isArray(ar2);
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    exports.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d2) {
      return isObject(d2) && objectToString(d2) === "[object Date]";
    }
    exports.isDate = isDate;
    exports.types.isDate = isDate;
    function isError(e2) {
      return isObject(e2) && (objectToString(e2) === "[object Error]" || e2 instanceof Error);
    }
    exports.isError = isError;
    exports.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_isBufferBrowser();
    function objectToString(o3) {
      return Object.prototype.toString.call(o3);
    }
    function pad(n2) {
      return n2 < 10 ? "0" + n2.toString(10) : n2.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d2 = /* @__PURE__ */ new Date();
      var time = [
        pad(d2.getHours()),
        pad(d2.getMinutes()),
        pad(d2.getSeconds())
      ].join(":");
      return [d2.getDate(), months[d2.getMonth()], time].join(" ");
    }
    exports.log = function() {
      console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
    };
    exports.inherits = require_inherits_browser();
    exports._extend = function(origin, add) {
      if (!add || !isObject(add)) return origin;
      var keys = Object.keys(add);
      var i3 = keys.length;
      while (i3--) {
        origin[keys[i3]] = add[keys[i3]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn2 = original[kCustomPromisifiedSymbol];
        if (typeof fn2 !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
          value: fn2,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn2;
      }
      function fn2() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });
        var args = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          args.push(arguments[i3]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn2, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol) Object.defineProperty(fn2, kCustomPromisifiedSymbol, {
        value: fn2,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return Object.defineProperties(
        fn2,
        getOwnPropertyDescriptors(original)
      );
    };
    exports.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          args.push(arguments[i3]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(
          function(ret) {
            process.nextTick(cb.bind(null, null, ret));
          },
          function(rej) {
            process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
          }
        );
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(
        callbackified,
        getOwnPropertyDescriptors(original)
      );
      return callbackified;
    }
    exports.callbackify = callbackify;
  }
});

// node_modules/@geenee/bodytracking/dist/bodytracking.js
function q(qgu, qgj) {
  return qgj["forEach"](function(qgL) {
    qgL && typeof qgL != "string" && !Array["isArray"](qgL) && Object["keys"](qgL)["forEach"](function(qgI) {
      if (qgI !== "default" && !(qgI in qgu)) {
        var qgb = Object["getOwnPropertyDescriptor"](qgL, qgI);
        Object["defineProperty"](qgu, qgI, qgb["get"] ? qgb : { "enumerable": true, "get": function() {
          return qgL[qgI];
        } });
      }
    });
  }), Object["freeze"](qgu);
}
var n = 1e-7;
var p = 1e-4;
var g = class {
  constructor(qgu, qgj) {
    this["backend"] = qgu, this["dataMover"] = qgj, this["data"] = /* @__PURE__ */ new WeakMap(), this["dataIdsCount"] = 0;
  }
  ["get"](qgu) {
    return this["data"]["has"](qgu) || this["dataMover"]["moveData"](this["backend"], qgu), this["data"]["get"](qgu);
  }
  ["set"](qgu, qgj) {
    this["dataIdsCount"]++, this["data"]["set"](qgu, qgj);
  }
  ["has"](qgu) {
    return this["data"]["has"](qgu);
  }
  ["delete"](qgu) {
    return this["dataIdsCount"]--, this["data"]["delete"](qgu);
  }
  ["numDataIds"]() {
    return this["dataIdsCount"];
  }
};
var x2 = class {
  ["refCount"](qgu) {
    return s("refCount");
  }
  ["incRef"](qgu) {
    return s("incRef");
  }
  ["timerAvailable"]() {
    return true;
  }
  ["time"](qgu) {
    return s("time");
  }
  ["read"](qgu) {
    return s("read");
  }
  ["readSync"](qgu) {
    return s("readSync");
  }
  ["readToGPU"](qgu, qgj) {
    return s("readToGPU");
  }
  ["numDataIds"]() {
    return s("numDataIds");
  }
  ["disposeData"](qgu, qgj) {
    return s("disposeData");
  }
  ["write"](qgu, qgj, qgL) {
    return s("write");
  }
  ["move"](qgu, qgj, qgL, qgI, qgb) {
    return s("move");
  }
  ["createTensorFromGPUData"](qgu, qgj, qgL) {
    return s("createTensorFromGPUData");
  }
  ["memory"]() {
    return s("memory");
  }
  ["floatPrecision"]() {
    return s("floatPrecision");
  }
  ["epsilon"]() {
    return this["floatPrecision"]() === 32 ? n : p;
  }
  ["dispose"]() {
    return s("dispose");
  }
};
function s(qgu) {
  throw new Error("'" + qgu + "' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen");
}
function E(qgu, qgj, qgL) {
  return Math["max"](qgu, Math["min"](qgj, qgL));
}
function f(qgu) {
  return qgu % 2 === 0 ? qgu : qgu + 1;
}
function S(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  qgu[qgj] = qgu[qgL], qgu[qgL] = qgI;
}
function F(qgu) {
  let qgj = 0;
  for (let qgL = 0; qgL < qgu["length"]; qgL++) qgj += qgu[qgL];
  return qgj;
}
function k(qgu, qgj) {
  if (!qgu) throw new Error(typeof qgj == "string" ? qgj : qgj());
}
function O(qgu, qgj, qgL = "") {
  k(D(qgu, qgj), () => qgL + (" Shapes " + qgu + " and " + qgj + " must match"));
}
function W(qgu) {
  k(qgu != null, () => "The input to the tensor constructor must be a non-null value.");
}
function i2(qgu) {
  if (qgu["length"] === 0) return 1;
  let qgj = qgu[0];
  for (let qgL = 1; qgL < qgu["length"]; qgL++) qgj *= qgu[qgL];
  return qgj;
}
function D(qgu, qgj) {
  if (qgu === qgj) return true;
  if (qgu == null || qgj == null || qgu["length"] !== qgj["length"]) return false;
  for (let qgL = 0; qgL < qgu["length"]; qgL++) if (qgu[qgL] !== qgj[qgL]) return false;
  return true;
}
function m(qgu) {
  return qgu % 1 === 0;
}
function a(qgu) {
  const qgj = Math["ceil"](Math["sqrt"](qgu));
  return [qgj, Math["ceil"](qgu / qgj)];
}
function Z(qgu, qgj) {
  return qgj <= qgu["length"] ? qgu : qgu + " "["repeat"](qgj - qgu["length"]);
}
function w(qgu, qgj = (qgb) => 0, qgL, qgI) {
  return new Promise((qgb, qgR) => {
    let qgo = 0;
    const qgr = () => {
      if (qgu()) {
        qgb();
        return;
      }
      qgo++;
      const qgQ = qgj(qgo);
      if (qgL != null && qgo >= qgL) {
        qgR();
        return;
      }
      qgI != null ? qgI(qgr, qgQ) : setTimeout(qgr, qgQ);
    };
    qgr();
  });
}
function e(qgu, qgj) {
  let qgL = 1, qgI = -1;
  for (let qgR = 0; qgR < qgu["length"]; ++qgR) if (qgu[qgR] >= 0) qgL *= qgu[qgR];
  else {
    if (qgu[qgR] === -1) {
      if (qgI !== -1) throw Error("Shapes can only have 1 implicit size. Found -1 at dim " + qgI + " and dim " + qgR);
      qgI = qgR;
    } else {
      if (qgu[qgR] < 0) throw Error("Shapes can not be < 0. Found " + qgu[qgR] + " at dim " + qgR);
    }
  }
  if (qgI === -1) {
    if (qgj > 0 && qgj !== qgL) throw Error("Size(" + qgj + ") must match the product of shape " + qgu);
    return qgu;
  }
  if (qgL === 0) throw Error("Cannot infer the missing size in [" + qgu + "] when there are 0 elements");
  if (qgj % qgL !== 0) throw Error("The implicit shape can't be a fractional number. Got " + qgj + " / " + qgL);
  const qgb = qgu["slice"]();
  return qgb[qgI] = qgj / qgL, qgb;
}
function z(qgu, qgj) {
  const qgL = qgj["length"];
  return qgu = qgu == null ? qgj["map"]((qgI, qgb) => qgb) : []["concat"](qgu), k(qgu["every"]((qgI) => qgI >= -qgL && qgI < qgL), () => "All values in axis param must be in range [-" + qgL + ", " + qgL + ") but got axis " + qgu), k(qgu["every"]((qgI) => m(qgI)), () => "All values in axis param must be integers but got axis " + qgu), qgu["map"]((qgI) => qgI < 0 ? qgL + qgI : qgI);
}
function c(qgu, qgj) {
  const qgL = [], qgI = [], qgb = qgj != null && Array["isArray"](qgj) && qgj["length"] === 0, qgR = qgj == null || qgb ? null : z(qgj, qgu)["sort"]();
  let qgo = 0;
  for (let qgr = 0; qgr < qgu["length"]; ++qgr) {
    if (qgR != null) {
      if (qgR[qgo] === qgr && qgu[qgr] !== 1) throw new Error("Can't squeeze axis " + qgr + " since its dim '" + qgu[qgr] + "' is not 1");
      (qgR[qgo] == null || qgR[qgo] > qgr) && qgu[qgr] === 1 && (qgL["push"](qgu[qgr]), qgI["push"](qgr)), qgR[qgo] <= qgr && qgo++;
    }
    qgu[qgr] !== 1 && (qgL["push"](qgu[qgr]), qgI["push"](qgr));
  }
  return { "newShape": qgL, "keptDims": qgI };
}
function X(qgu, qgj) {
  return G(qgu, qgj);
}
function G(qgu, qgj) {
  let qgL = null;
  if (qgu == null || qgu === "float32") qgL = new Float32Array(qgj);
  else {
    if (qgu === "int32") qgL = new Int32Array(qgj);
    else {
      if (qgu === "bool") qgL = new Uint8Array(qgj);
      else {
        if (qgu === "string") qgL = new Array(qgj);
        else throw new Error("Unknown data type " + qgu);
      }
    }
  }
  return qgL;
}
function N(qgu, qgj) {
  for (let qgL = 0; qgL < qgu["length"]; qgL++) {
    const qgI = qgu[qgL];
    if (isNaN(qgI) || !isFinite(qgI)) throw Error("A tensor of type " + qgj + " being uploaded contains " + qgI + ".");
  }
}
function u(qgu) {
  return qgu === "bool" || qgu === "complex64" || qgu === "float32" || qgu === "int32" || qgu === "string";
}
function j(qgu, qgj) {
  return !(qgj === "complex64" || qgj === "float32" && qgu !== "complex64" || qgj === "int32" && qgu !== "float32" && qgu !== "complex64" || qgj === "bool" && qgu === "bool");
}
function L(qgu) {
  if (qgu === "float32" || qgu === "int32") return 4;
  if (qgu === "complex64") return 8;
  if (qgu === "bool") return 1;
  throw new Error("Unknown dtype " + qgu);
}
function I(qgu) {
  if (qgu == null) return 0;
  let qgj = 0;
  return qgu["forEach"]((qgL) => qgj += qgL["length"]), qgj;
}
function R(qgu) {
  return typeof qgu == "string" || qgu instanceof String;
}
function o(qgu) {
  return typeof qgu == "boolean";
}
function r(qgu) {
  return typeof qgu == "number";
}
function Q(qgu) {
  return Array["isArray"](qgu) ? Q(qgu[0]) : qgu instanceof Float32Array ? "float32" : qgu instanceof Int32Array || qgu instanceof Uint8Array || qgu instanceof Uint8ClampedArray ? "int32" : r(qgu) ? "float32" : R(qgu) ? "string" : o(qgu) ? "bool" : "float32";
}
function d(qgu) {
  return !!(qgu && qgu["constructor"] && qgu["call"] && qgu["apply"]);
}
function v(qgu, qgj) {
  for (let qgL = qgj; qgL < qgu; ++qgL) if (qgu % qgL === 0) return qgL;
  return qgu;
}
function y(qgu) {
  const qgj = qgu["length"];
  if (qgj < 2) return [];
  const qgL = new Array(qgj - 1);
  qgL[qgj - 2] = qgu[qgj - 1];
  for (let qgI = qgj - 3; qgI >= 0; --qgI) qgL[qgI] = qgL[qgI + 1] * qgu[qgI + 1];
  return qgL;
}
function C(qgu, qgj, qgL, qgI = false) {
  const qgb = new Array();
  if (qgj["length"] === 1) {
    const qgR = qgj[0] * (qgI ? 2 : 1);
    for (let qgo = 0; qgo < qgR; qgo++) qgb[qgo] = qgL[qgu + qgo];
  } else {
    const qgr = qgj[0], qgQ = qgj["slice"](1), qgd = qgQ["reduce"]((qgv, qgy) => qgv * qgy) * (qgI ? 2 : 1);
    for (let qgv = 0; qgv < qgr; qgv++) qgb[qgv] = C(qgu + qgv * qgd, qgQ, qgL, qgI);
  }
  return qgb;
}
function l(qgu, qgj, qgL = false) {
  if (qgu["length"] === 0) return qgj[0];
  const qgI = qgu["reduce"]((qgb, qgR) => qgb * qgR) * (qgL ? 2 : 1);
  if (qgI === 0) return [];
  if (qgI !== qgj["length"]) throw new Error("[" + qgu + "] does not match the input size " + qgj["length"] + (qgL ? " for a complex tensor" : "") + ".");
  return C(0, qgu, qgj, qgL);
}
function A(qgu, qgj) {
  if (Array["isArray"](qgu)) return qgu;
  if (qgj === "float32") return qgu instanceof Float32Array ? qgu : new Float32Array(qgu);
  if (qgj === "int32") return qgu instanceof Int32Array ? qgu : new Int32Array(qgu);
  if (qgj === "bool" || qgj === "string") return Uint8Array["from"](new Int32Array(qgu));
  throw new Error("Unknown dtype " + qgj);
}
function h(qgu, qgj) {
  const qgL = T(qgu, qgj);
  for (let qgI = 0; qgI < qgL["length"]; qgI++) qgL[qgI] = 1;
  return qgL;
}
function T(qgu, qgj) {
  if (qgj == null || qgj === "float32" || qgj === "complex64") return new Float32Array(qgu);
  if (qgj === "int32") return new Int32Array(qgu);
  if (qgj === "bool") return new Uint8Array(qgu);
  throw new Error("Unknown data type " + qgj);
}
function K(qgu) {
  qgu["forEach"]((qgj) => {
    k(Number["isInteger"](qgj) && qgj >= 0, () => "Tensor must have a shape comprised of positive integers but got shape [" + qgu + "].");
  });
}
function B(qgu, qgj, qgL) {
  if (qgj === 0) return 0;
  if (qgj === 1) return qgu[0];
  let qgI = qgu[qgu["length"] - 1];
  for (let qgb = 0; qgb < qgu["length"] - 1; ++qgb) qgI += qgL[qgb] * qgu[qgb];
  return qgI;
}
function V(qgu, qgj, qgL) {
  if (qgj === 0) return [];
  if (qgj === 1) return [qgu];
  const qgI = new Array(qgj);
  for (let qgb = 0; qgb < qgI["length"] - 1; ++qgb) qgI[qgb] = Math["floor"](qgu / qgL[qgb]), qgu -= qgI[qgb] * qgL[qgb];
  return qgI[qgI["length"] - 1] = qgu, qgI;
}
function J(qgu) {
  return qgu && qgu["then"] && typeof qgu["then"] == "function";
}
var Y = "tfjsflags";
var P = class {
  constructor(qgu) {
    this["global"] = qgu, this["flags"] = {}, this["flagRegistry"] = {}, this["urlFlags"] = {}, this["getQueryParams"] = U, this["populateURLFlags"]();
  }
  ["setPlatform"](qgu, qgj) {
    this["platform"] != null && (qM()["getBool"]("IS_TEST") || qM()["getBool"]("PROD") || console["warn"]("Platform " + this["platformName"] + " has already been set. Overwriting the platform with " + qgu + ".")), this["platformName"] = qgu, this["platform"] = qgj;
  }
  ["registerFlag"](qgu, qgj, qgL) {
    if (this["flagRegistry"][qgu] = { "evaluationFn": qgj, "setHook": qgL }, this["urlFlags"][qgu] != null) {
      const qgI = this["urlFlags"][qgu];
      qM()["getBool"]("IS_TEST") || qM()["getBool"]("PROD") || console["warn"]("Setting feature override from URL " + qgu + ": " + qgI + "."), this["set"](qgu, qgI);
    }
  }
  async ["getAsync"](qgu) {
    return qgu in this["flags"] ? this["flags"][qgu] : (this["flags"][qgu] = await this["evaluateFlag"](qgu), this["flags"][qgu]);
  }
  ["get"](qgu) {
    if (qgu in this["flags"]) return this["flags"][qgu];
    const qgj = this["evaluateFlag"](qgu);
    if (J(qgj)) throw new Error("Flag " + qgu + " cannot be synchronously evaluated. Please use getAsync() instead.");
    return this["flags"][qgu] = qgj, this["flags"][qgu];
  }
  ["getNumber"](qgu) {
    return this["get"](qgu);
  }
  ["getBool"](qgu) {
    return this["get"](qgu);
  }
  ["getString"](qgu) {
    return this["get"](qgu);
  }
  ["getFlags"]() {
    return this["flags"];
  }
  get ["features"]() {
    return this["flags"];
  }
  ["set"](qgu, qgj) {
    if (this["flagRegistry"][qgu] == null) throw new Error("Cannot set flag " + qgu + " as it has not been registered.");
    this["flags"][qgu] = qgj, this["flagRegistry"][qgu]["setHook"] != null && this["flagRegistry"][qgu]["setHook"](qgj);
  }
  ["evaluateFlag"](qgu) {
    if (this["flagRegistry"][qgu] == null) throw new Error("Cannot evaluate flag '" + qgu + "': no evaluation function found.");
    return this["flagRegistry"][qgu]["evaluationFn"]();
  }
  ["setFlags"](qgu) {
    this["flags"] = Object["assign"]({}, qgu);
  }
  ["reset"]() {
    this["flags"] = {}, this["urlFlags"] = {}, this["populateURLFlags"]();
  }
  ["populateURLFlags"]() {
    if (typeof this["global"] == "undefined" || typeof this["global"]["location"] == "undefined" || typeof this["global"]["location"]["search"] == "undefined") return;
    const qgu = this["getQueryParams"](this["global"]["location"]["search"]);
    Y in qgu && qgu[Y]["split"](",")["forEach"]((qgj) => {
      const [qgL, qgI] = qgj["split"](":");
      this["urlFlags"][qgL] = qq(qgL, qgI);
    });
  }
};
function U(qgu) {
  const qgj = {};
  return qgu["replace"](/[?&]([^=?&]+)(?:=([^&]*))?/g, (qgL, ...qgI) => (q6(qgj, qgI[0], qgI[1]), qgI["join"]("="))), qgj;
}
function q6(qgu, qgj, qgL) {
  qgu[decodeURIComponent(qgj)] = decodeURIComponent(qgL || "");
}
function qq(qgu, qgj) {
  const qgL = qgj["toLowerCase"]();
  return qgL === "true" || qgL === "false" ? qgL === "true" : "" + +qgL === qgL ? +qgL : qgj;
}
function qM() {
  return qF;
}
var qF = null;
function qW(qgu) {
  qF = qgu;
}
var qD;
function qa() {
  if (qD == null) {
    let qgu;
    if (typeof window != "undefined") qgu = window;
    else {
      if (typeof global != "undefined") qgu = global;
      else {
        if (typeof process != "undefined") qgu = process;
        else {
          if (typeof self != "undefined") qgu = self;
          else throw new Error("Could not find a global object");
        }
      }
    }
    qD = qgu;
  }
  return qD;
}
function qZ() {
  const qgu = qa();
  return qgu["_tfGlobals"] == null && (qgu["_tfGlobals"] = /* @__PURE__ */ new Map()), qgu["_tfGlobals"];
}
function qz(qgu, qgj) {
  const qgL = qZ();
  if (qgL["has"](qgu)) return qgL["get"](qgu);
  {
    const qgI = qgj();
    return qgL["set"](qgu, qgI), qgL["get"](qgu);
  }
}
var qX = "Abs";
var qG = "Add";
var qj = "AddN";
var qL = "Atan2";
var qR = "AvgPool";
var qo = "BatchMatMul";
var qQ = "Bincount";
var qH = "Cast";
var qK = "ClipByValue";
var qB = "Complex";
var qV = "ComplexAbs";
var qJ = "Concat";
var qY = "Conv2D";
var qP = "Conv2DBackpropFilter";
var qU = "Conv2DBackpropInput";
var nq = "Cos";
var nn = "CropAndResize";
var ns = "DepthToSpace";
var nM = "DepthwiseConv2dNative";
var nF = "DepthwiseConv2dNativeBackpropFilter";
var nt = "DepthwiseConv2dNativeBackpropInput";
var nW = "RealDiv";
var ni = "Einsum";
var nD = "Elu";
var nZ = "ExpandDims";
var ne = "Fill";
var nz = "FlipLeftRight";
var nX = "Floor";
var nG = "FloorDiv";
var nu = "GatherV2";
var nj = "Greater";
var nL = "GreaterEqual";
var no = "Identity";
var nQ = "Imag";
var nH = "LeakyRelu";
var nK = "Less";
var nB = "LessEqual";
var nV = "LogicalAnd";
var nJ = "LogicalOr";
var nY = "Max";
var nP = "Maximum";
var nU = "MaxPool";
var p1 = "Mean";
var pq = "Min";
var pM = "Minimum";
var pF = "Multiply";
var pt = "Neg";
var pW = "NonMaxSuppressionV3";
var pD = "NonMaxSuppressionV4";
var pa = "NonMaxSuppressionV5";
var pZ = "Pack";
var pe = "PadV2";
var pz = "Pow";
var pX = "Prelu";
var pG = "Range";
var pu = "Real";
var pj = "Relu";
var pL = "Reshape";
var po = "ResizeNearestNeighbor";
var pr = "ResizeBilinear";
var pQ = "Relu6";
var pH = "Round";
var pK = "TensorScatterUpdate";
var pB = "Select";
var pV = "Slice";
var pJ = "Sin";
var pY = "Sigmoid";
var pP = "Sqrt";
var pU = "Sum";
var gq = "SplitV";
var gn = "Square";
var gs = "StridedSlice";
var gM = "Sub";
var gF = "Tile";
var gW = "Transform";
var gD = "Transpose";
var ga = "Unpack";
var gZ = "ZerosLike";
var ge = "Step";
var gz = "FromPixels";
var gX = "RotateWithOffset";
var gG = "_FusedMatMul";
var gu = "FusedConv2D";
var gj = "FusedDepthwiseConv2D";
function gL(...qgu) {
  qM()["getBool"]("IS_TEST") || qM()["getBool"]("PROD") || console["warn"](...qgu);
}
function gQ(...qgu) {
  qM()["getBool"]("IS_TEST") || qM()["getBool"]("PROD") || console["log"](...qgu);
}
var gH = qz("kernelRegistry", () => /* @__PURE__ */ new Map());
var gK = qz("gradRegistry", () => /* @__PURE__ */ new Map());
function gB(qgu, qgj) {
  const qgL = gP(qgu, qgj);
  return gH["get"](qgL);
}
function gV(qgu) {
  return gK["get"](qgu);
}
function gJ(qgu) {
  const qgj = gH["entries"](), qgL = [];
  for (; ; ) {
    const { done: qgI, value: qgb } = qgj["next"]();
    if (qgI) break;
    const [qgR, qgo] = qgb, [qgr] = qgR["split"]("_");
    qgr === qgu && qgL["push"](qgo);
  }
  return qgL;
}
function gY(qgu) {
  const { kernelName: qgj, backendName: qgL } = qgu, qgI = gP(qgj, qgL);
  gH["has"](qgI) && gL("The kernel '" + qgj + "' for backend '" + qgL + "' is already registered"), gH["set"](qgI, qgu);
}
function gP(qgu, qgj) {
  return qgj + "_" + qgu;
}
function gU(qgu) {
  return qgu instanceof Float32Array || qgu instanceof Int32Array || qgu instanceof Uint8Array || qgu instanceof Uint8ClampedArray;
}
var xq = typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : {};
function xs(qgu) {
  return qgu && qgu["__esModule"] && Object["prototype"]["hasOwnProperty"]["call"](qgu, "default") ? qgu["default"] : qgu;
}
var xM = xt;
var xF = null;
try {
  xF = new WebAssembly["Instance"](new WebAssembly["Module"](new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {})["exports"];
} catch (qgC) {
}
function xt(qgu, qgj, qgL) {
  this["low"] = qgu | 0, this["high"] = qgj | 0, this["unsigned"] = !!qgL;
}
xt["prototype"]["__isLong__"], Object["defineProperty"](xt["prototype"], "__isLong__", { "value": true });
function xW(qgu) {
  return (qgu && qgu["__isLong__"]) === true;
}
xt["isLong"] = xW;
var xD = {};
var xZ = {};
function xz(qgu, qgj) {
  var qgL, qgI, qgb;
  return qgj ? (qgu >>>= 0, (qgb = 0 <= qgu && qgu < 256) && (qgI = xZ[qgu], qgI) ? qgI : (qgL = xG(qgu, (qgu | 0) < 0 ? -1 : 0, true), qgb && (xZ[qgu] = qgL), qgL)) : (qgu |= 0, (qgb = -128 <= qgu && qgu < 128) && (qgI = xD[qgu], qgI) ? qgI : (qgL = xG(qgu, qgu < 0 ? -1 : 0, false), qgb && (xD[qgu] = qgL), qgL));
}
xt["fromInt"] = xz;
function xX(qgu, qgj) {
  if (isNaN(qgu)) return qgj ? xP : xY;
  if (qgj) {
    if (qgu < 0) return xP;
    if (qgu >= xB) return st;
  } else {
    if (qgu <= -xV) return sW;
    if (qgu + 1 >= xV) return sF;
  }
  return qgu < 0 ? xX(-qgu, qgj)["neg"]() : xG(qgu % xK | 0, qgu / xK | 0, qgj);
}
xt["fromNumber"] = xX;
function xG(qgu, qgj, qgL) {
  return new xt(qgu, qgj, qgL);
}
xt["fromBits"] = xG;
var xu = Math["pow"];
function xj(qgu, qgj, qgL) {
  if (qgu["length"] === 0) throw Error("empty string");
  if (qgu === "NaN" || qgu === "Infinity" || qgu === "+Infinity" || qgu === "-Infinity") return xY;
  if (typeof qgj == "number" ? (qgL = qgj, qgj = false) : qgj = !!qgj, qgL = qgL || 10, qgL < 2 || 36 < qgL) throw RangeError("radix");
  var qgI;
  if ((qgI = qgu["indexOf"]("-")) > 0) throw Error("interior hyphen");
  if (qgI === 0) return xj(qgu["substring"](1), qgj, qgL)["neg"]();
  for (var qgb = xX(xu(qgL, 8)), qgR = xY, qgo = 0; qgo < qgu["length"]; qgo += 8) {
    var qgr = Math["min"](8, qgu["length"] - qgo), qgQ = parseInt(qgu["substring"](qgo, qgo + qgr), qgL);
    if (qgr < 8) {
      var qgd = xX(xu(qgL, qgr));
      qgR = qgR["mul"](qgd)["add"](xX(qgQ));
    } else qgR = qgR["mul"](qgb), qgR = qgR["add"](xX(qgQ));
  }
  return qgR["unsigned"] = qgj, qgR;
}
xt["fromString"] = xj;
function xL(qgu, qgj) {
  return typeof qgu == "number" ? xX(qgu, qgj) : typeof qgu == "string" ? xj(qgu, qgj) : xG(qgu["low"], qgu["high"], typeof qgj == "boolean" ? qgj : qgu["unsigned"]);
}
xt["fromValue"] = xL;
var xQ = 65536;
var xH = 1 << 24;
var xK = xQ * xQ;
var xB = xK * xK;
var xV = xB / 2;
var xJ = xz(xH);
var xY = xz(0);
xt["ZERO"] = xY;
var xP = xz(0, true);
xt["UZERO"] = xP;
var xU = xz(1);
xt["ONE"] = xU;
var sq = xz(1, true);
xt["UONE"] = sq;
var sM = xz(-1);
xt["NEG_ONE"] = sM;
var sF = xG(-1, 2147483647, false);
xt["MAX_VALUE"] = sF;
var st = xG(-1, -1, true);
xt["MAX_UNSIGNED_VALUE"] = st;
var sW = xG(0, -2147483648, false);
xt["MIN_VALUE"] = sW;
var sD = xt["prototype"];
sD["toInt"] = function() {
  return this["unsigned"] ? this["low"] >>> 0 : this["low"];
}, sD["toNumber"] = function() {
  return this["unsigned"] ? (this["high"] >>> 0) * xK + (this["low"] >>> 0) : this["high"] * xK + (this["low"] >>> 0);
}, sD["toString"] = function(qgu) {
  if (qgu = qgu || 10, qgu < 2 || 36 < qgu) throw RangeError("radix");
  if (this["isZero"]()) return "0";
  if (this["isNegative"]()) {
    if (this["eq"](sW)) {
      var qgj = xX(qgu), qgL = this["div"](qgj), qgI = qgL["mul"](qgj)["sub"](this);
      return qgL["toString"](qgu) + qgI["toInt"]()["toString"](qgu);
    } else return "-" + this["neg"]()["toString"](qgu);
  }
  for (var qgb = xX(xu(qgu, 6), this["unsigned"]), qgR = this, qgo = ""; ; ) {
    var qgr = qgR["div"](qgb), qgQ = qgR["sub"](qgr["mul"](qgb))["toInt"]() >>> 0, qgd = qgQ["toString"](qgu);
    if (qgR = qgr, qgR["isZero"]()) return qgd + qgo;
    for (; qgd["length"] < 6; ) qgd = "0" + qgd;
    qgo = "" + qgd + qgo;
  }
}, sD["getHighBits"] = function() {
  return this["high"];
}, sD["getHighBitsUnsigned"] = function() {
  return this["high"] >>> 0;
}, sD["getLowBits"] = function() {
  return this["low"];
}, sD["getLowBitsUnsigned"] = function() {
  return this["low"] >>> 0;
}, sD["getNumBitsAbs"] = function() {
  if (this["isNegative"]()) return this["eq"](sW) ? 64 : this["neg"]()["getNumBitsAbs"]();
  for (var qgu = this["high"] != 0 ? this["high"] : this["low"], qgj = 31; qgj > 0 && (qgu & 1 << qgj) == 0; qgj--) ;
  return this["high"] != 0 ? qgj + 33 : qgj + 1;
}, sD["isZero"] = function() {
  return this["high"] === 0 && this["low"] === 0;
}, sD["eqz"] = sD["isZero"], sD["isNegative"] = function() {
  return !this["unsigned"] && this["high"] < 0;
}, sD["isPositive"] = function() {
  return this["unsigned"] || this["high"] >= 0;
}, sD["isOdd"] = function() {
  return (this["low"] & 1) === 1;
}, sD["isEven"] = function() {
  return (this["low"] & 1) === 0;
}, sD["equals"] = function(qgu) {
  return xW(qgu) || (qgu = xL(qgu)), this["unsigned"] !== qgu["unsigned"] && this["high"] >>> 31 === 1 && qgu["high"] >>> 31 === 1 ? false : this["high"] === qgu["high"] && this["low"] === qgu["low"];
}, sD["eq"] = sD["equals"], sD["notEquals"] = function(qgu) {
  return !this["eq"](qgu);
}, sD["neq"] = sD["notEquals"], sD["ne"] = sD["notEquals"], sD["lessThan"] = function(qgu) {
  return this["comp"](qgu) < 0;
}, sD["lt"] = sD["lessThan"], sD["lessThanOrEqual"] = function(qgu) {
  return this["comp"](qgu) <= 0;
}, sD["lte"] = sD["lessThanOrEqual"], sD["le"] = sD["lessThanOrEqual"], sD["greaterThan"] = function(qgu) {
  return this["comp"](qgu) > 0;
}, sD["gt"] = sD["greaterThan"], sD["greaterThanOrEqual"] = function(qgu) {
  return this["comp"](qgu) >= 0;
}, sD["gte"] = sD["greaterThanOrEqual"], sD["ge"] = sD["greaterThanOrEqual"], sD["compare"] = function(qgu) {
  if (xW(qgu) || (qgu = xL(qgu)), this["eq"](qgu)) return 0;
  var qgj = this["isNegative"](), qgL = qgu["isNegative"]();
  return qgj && !qgL ? -1 : !qgj && qgL ? 1 : this["unsigned"] ? qgu["high"] >>> 0 > this["high"] >>> 0 || qgu["high"] === this["high"] && qgu["low"] >>> 0 > this["low"] >>> 0 ? -1 : 1 : this["sub"](qgu)["isNegative"]() ? -1 : 1;
}, sD["comp"] = sD["compare"], sD["negate"] = function() {
  return !this["unsigned"] && this["eq"](sW) ? sW : this["not"]()["add"](xU);
}, sD["neg"] = sD["negate"], sD["add"] = function(qgu) {
  xW(qgu) || (qgu = xL(qgu));
  var qgj = this["high"] >>> 16, qgL = this["high"] & 65535, qgI = this["low"] >>> 16, qgb = this["low"] & 65535, qgR = qgu["high"] >>> 16, qgo = qgu["high"] & 65535, qgr = qgu["low"] >>> 16, qgQ = qgu["low"] & 65535, qgd = 0, qgv = 0, qgy = 0, qgl = 0;
  return qgl += qgb + qgQ, qgy += qgl >>> 16, qgl &= 65535, qgy += qgI + qgr, qgv += qgy >>> 16, qgy &= 65535, qgv += qgL + qgo, qgd += qgv >>> 16, qgv &= 65535, qgd += qgj + qgR, qgd &= 65535, xG(qgy << 16 | qgl, qgd << 16 | qgv, this["unsigned"]);
}, sD["subtract"] = function(qgu) {
  return xW(qgu) || (qgu = xL(qgu)), this["add"](qgu["neg"]());
}, sD["sub"] = sD["subtract"], sD["multiply"] = function(qgu) {
  if (this["isZero"]()) return xY;
  if (xW(qgu) || (qgu = xL(qgu)), xF) {
    var qgj = xF["mul"](this["low"], this["high"], qgu["low"], qgu["high"]);
    return xG(qgj, xF["get_high"](), this["unsigned"]);
  }
  if (qgu["isZero"]()) return xY;
  if (this["eq"](sW)) return qgu["isOdd"]() ? sW : xY;
  if (qgu["eq"](sW)) return this["isOdd"]() ? sW : xY;
  if (this["isNegative"]()) return qgu["isNegative"]() ? this["neg"]()["mul"](qgu["neg"]()) : this["neg"]()["mul"](qgu)["neg"]();
  if (qgu["isNegative"]()) return this["mul"](qgu["neg"]())["neg"]();
  if (this["lt"](xJ) && qgu["lt"](xJ)) return xX(this["toNumber"]() * qgu["toNumber"](), this["unsigned"]);
  var qgL = this["high"] >>> 16, qgI = this["high"] & 65535, qgb = this["low"] >>> 16, qgR = this["low"] & 65535, qgo = qgu["high"] >>> 16, qgr = qgu["high"] & 65535, qgQ = qgu["low"] >>> 16, qgd = qgu["low"] & 65535, qgv = 0, qgy = 0, qgl = 0, qgH = 0;
  return qgH += qgR * qgd, qgl += qgH >>> 16, qgH &= 65535, qgl += qgb * qgd, qgy += qgl >>> 16, qgl &= 65535, qgl += qgR * qgQ, qgy += qgl >>> 16, qgl &= 65535, qgy += qgI * qgd, qgv += qgy >>> 16, qgy &= 65535, qgy += qgb * qgQ, qgv += qgy >>> 16, qgy &= 65535, qgy += qgR * qgr, qgv += qgy >>> 16, qgy &= 65535, qgv += qgL * qgd + qgI * qgQ + qgb * qgr + qgR * qgo, qgv &= 65535, xG(qgl << 16 | qgH, qgv << 16 | qgy, this["unsigned"]);
}, sD["mul"] = sD["multiply"], sD["divide"] = function(qgu) {
  if (xW(qgu) || (qgu = xL(qgu)), qgu["isZero"]()) throw Error("division by zero");
  if (xF) {
    if (!this["unsigned"] && this["high"] === -2147483648 && qgu["low"] === -1 && qgu["high"] === -1) return this;
    var qgj = (this["unsigned"] ? xF["div_u"] : xF["div_s"])(this["low"], this["high"], qgu["low"], qgu["high"]);
    return xG(qgj, xF["get_high"](), this["unsigned"]);
  }
  if (this["isZero"]()) return this["unsigned"] ? xP : xY;
  var qgL, qgI, qgb;
  if (this["unsigned"]) {
    if (qgu["unsigned"] || (qgu = qgu["toUnsigned"]()), qgu["gt"](this)) return xP;
    if (qgu["gt"](this["shru"](1))) return sq;
    qgb = xP;
  } else {
    if (this["eq"](sW)) {
      if (qgu["eq"](xU) || qgu["eq"](sM)) return sW;
      if (qgu["eq"](sW)) return xU;
      var qgR = this["shr"](1);
      return qgL = qgR["div"](qgu)["shl"](1), qgL["eq"](xY) ? qgu["isNegative"]() ? xU : sM : (qgI = this["sub"](qgu["mul"](qgL)), qgb = qgL["add"](qgI["div"](qgu)), qgb);
    } else {
      if (qgu["eq"](sW)) return this["unsigned"] ? xP : xY;
    }
    if (this["isNegative"]()) return qgu["isNegative"]() ? this["neg"]()["div"](qgu["neg"]()) : this["neg"]()["div"](qgu)["neg"]();
    if (qgu["isNegative"]()) return this["div"](qgu["neg"]())["neg"]();
    qgb = xY;
  }
  for (qgI = this; qgI["gte"](qgu); ) {
    qgL = Math["max"](1, Math["floor"](qgI["toNumber"]() / qgu["toNumber"]()));
    for (var qgo = Math["ceil"](Math["log"](qgL) / Math["LN2"]), qgr = qgo <= 48 ? 1 : xu(2, qgo - 48), qgQ = xX(qgL), qgd = qgQ["mul"](qgu); qgd["isNegative"]() || qgd["gt"](qgI); ) qgL -= qgr, qgQ = xX(qgL, this["unsigned"]), qgd = qgQ["mul"](qgu);
    qgQ["isZero"]() && (qgQ = xU), qgb = qgb["add"](qgQ), qgI = qgI["sub"](qgd);
  }
  return qgb;
}, sD["div"] = sD["divide"], sD["modulo"] = function(qgu) {
  if (xW(qgu) || (qgu = xL(qgu)), xF) {
    var qgj = (this["unsigned"] ? xF["rem_u"] : xF["rem_s"])(this["low"], this["high"], qgu["low"], qgu["high"]);
    return xG(qgj, xF["get_high"](), this["unsigned"]);
  }
  return this["sub"](this["div"](qgu)["mul"](qgu));
}, sD["mod"] = sD["modulo"], sD["rem"] = sD["modulo"], sD["not"] = function() {
  return xG(~this["low"], ~this["high"], this["unsigned"]);
}, sD["and"] = function(qgu) {
  return xW(qgu) || (qgu = xL(qgu)), xG(this["low"] & qgu["low"], this["high"] & qgu["high"], this["unsigned"]);
}, sD["or"] = function(qgu) {
  return xW(qgu) || (qgu = xL(qgu)), xG(this["low"] | qgu["low"], this["high"] | qgu["high"], this["unsigned"]);
}, sD["xor"] = function(qgu) {
  return xW(qgu) || (qgu = xL(qgu)), xG(this["low"] ^ qgu["low"], this["high"] ^ qgu["high"], this["unsigned"]);
}, sD["shiftLeft"] = function(qgu) {
  return xW(qgu) && (qgu = qgu["toInt"]()), (qgu &= 63) === 0 ? this : qgu < 32 ? xG(this["low"] << qgu, this["high"] << qgu | this["low"] >>> 32 - qgu, this["unsigned"]) : xG(0, this["low"] << qgu - 32, this["unsigned"]);
}, sD["shl"] = sD["shiftLeft"], sD["shiftRight"] = function(qgu) {
  return xW(qgu) && (qgu = qgu["toInt"]()), (qgu &= 63) === 0 ? this : qgu < 32 ? xG(this["low"] >>> qgu | this["high"] << 32 - qgu, this["high"] >> qgu, this["unsigned"]) : xG(this["high"] >> qgu - 32, this["high"] >= 0 ? 0 : -1, this["unsigned"]);
}, sD["shr"] = sD["shiftRight"], sD["shiftRightUnsigned"] = function(qgu) {
  if (xW(qgu) && (qgu = qgu["toInt"]()), qgu &= 63, qgu === 0) return this;
  var qgj = this["high"];
  if (qgu < 32) {
    var qgL = this["low"];
    return xG(qgL >>> qgu | qgj << 32 - qgu, qgj >>> qgu, this["unsigned"]);
  } else return qgu === 32 ? xG(qgj, 0, this["unsigned"]) : xG(qgj >>> qgu - 32, 0, this["unsigned"]);
}, sD["shru"] = sD["shiftRightUnsigned"], sD["shr_u"] = sD["shiftRightUnsigned"], sD["toSigned"] = function() {
  return this["unsigned"] ? xG(this["low"], this["high"], false) : this;
}, sD["toUnsigned"] = function() {
  return this["unsigned"] ? this : xG(this["low"], this["high"], true);
}, sD["toBytes"] = function(qgu) {
  return qgu ? this["toBytesLE"]() : this["toBytesBE"]();
}, sD["toBytesLE"] = function() {
  var qgu = this["high"], qgj = this["low"];
  return [qgj & 255, qgj >>> 8 & 255, qgj >>> 16 & 255, qgj >>> 24, qgu & 255, qgu >>> 8 & 255, qgu >>> 16 & 255, qgu >>> 24];
}, sD["toBytesBE"] = function() {
  var qgu = this["high"], qgj = this["low"];
  return [qgu >>> 24, qgu >>> 16 & 255, qgu >>> 8 & 255, qgu & 255, qgj >>> 24, qgj >>> 16 & 255, qgj >>> 8 & 255, qgj & 255];
}, xt["fromBytes"] = function(qgu, qgj, qgL) {
  return qgL ? xt["fromBytesLE"](qgu, qgj) : xt["fromBytesBE"](qgu, qgj);
}, xt["fromBytesLE"] = function(qgu, qgj) {
  return new xt(qgu[0] | qgu[1] << 8 | qgu[2] << 16 | qgu[3] << 24, qgu[4] | qgu[5] << 8 | qgu[6] << 16 | qgu[7] << 24, qgj);
}, xt["fromBytesBE"] = function(qgu, qgj) {
  return new xt(qgu[4] << 24 | qgu[5] << 16 | qgu[6] << 8 | qgu[7], qgu[0] << 24 | qgu[1] << 16 | qgu[2] << 8 | qgu[3], qgj);
};
var sZ = xs(xM);
var se = q({ "__proto__": null, "default": sZ }, [xM]);
var sz = sZ || se;
function sX(qgu) {
  return sz["fromString"](qgu, true, 16);
}
var sG = sX("c3a5c85c97cb3127");
var su = sX("b492b66fbe98f273");
var sj = sX("9ae16a3b2f90404f");
function sL(qgu) {
  return qgu["xor"](qgu["shru"](47));
}
function so(qgu, qgj, qgL) {
  const qgI = qgu["slice"](qgj, qgj + qgL);
  return sz["fromBytes"](Array["from"](qgI), true, true);
}
function sr(qgu, qgj) {
  return so(qgu, qgj, 8);
}
function sQ(qgu, qgj) {
  return so(qgu, qgj, 4);
}
function sH(qgu, qgj) {
  return qgj === 0 ? qgu : qgu["shru"](qgj)["or"](qgu["shl"](64 - qgj));
}
function sK(qgu, qgj, qgL = sX("9ddfea08eb382d69")) {
  let qgI = qgu["xor"](qgj)["mul"](qgL);
  qgI = qgI["xor"](qgI["shru"](47));
  let qgb = qgj["xor"](qgI)["mul"](qgL);
  return qgb = qgb["xor"](qgb["shru"](47)), qgb = qgb["mul"](qgL), qgb;
}
function sB(qgu, qgj, qgL, qgI, qgb, qgR) {
  qgb = qgb["add"](qgu), qgR = sH(qgR["add"](qgb)["add"](qgI), 21);
  const qgo = qgb;
  return qgb = qgb["add"](qgj), qgb = qgb["add"](qgL), qgR = qgR["add"](sH(qgb, 44)), [qgb["add"](qgI), qgR["add"](qgo)];
}
function sV(qgu, qgj, qgL, qgI) {
  return sB(sr(qgu, qgj), sr(qgu, qgj + 8), sr(qgu, qgj + 16), sr(qgu, qgj + 24), qgL, qgI);
}
function sJ(qgu, qgj = qgu["length"]) {
  if (qgj >= 8) {
    const qgL = sj["add"](qgj * 2), qgI = sr(qgu, 0)["add"](sj), qgb = sr(qgu, qgj - 8), qgR = sH(qgb, 37)["mul"](qgL)["add"](qgI), qgo = sH(qgI, 25)["add"](qgb)["mul"](qgL);
    return sK(qgR, qgo, qgL);
  }
  if (qgj >= 4) {
    const qgr = sj["add"](qgj * 2), qgQ = sQ(qgu, 0);
    return sK(qgQ["shl"](3)["add"](qgj), sQ(qgu, qgj - 4), qgr);
  }
  if (qgj > 0) {
    const qgd = qgu[0], qgv = qgu[qgj >> 1], qgy = qgu[qgj - 1], qgl = qgd + (qgv << 8), qgH = qgj + (qgy << 2);
    return sL(sj["mul"](qgl)["xor"](sG["mul"](qgH)))["mul"](sj);
  }
  return sj;
}
function sY(qgu, qgj = qgu["length"]) {
  const qgL = sj["add"](qgj * 2), qgI = sr(qgu, 0)["mul"](su), qgb = sr(qgu, 8), qgR = sr(qgu, qgj - 8)["mul"](qgL), qgo = sr(qgu, qgj - 16)["mul"](sj);
  return sK(sH(qgI["add"](qgb), 43)["add"](sH(qgR, 30))["add"](qgo), qgI["add"](sH(qgb["add"](sj), 18))["add"](qgR), qgL);
}
function sP(qgu, qgj = qgu["length"]) {
  const qgL = sj["add"](qgj * 2), qgI = sr(qgu, 0)["mul"](sj), qgb = sr(qgu, 8), qgR = sr(qgu, qgj - 8)["mul"](qgL), qgo = sr(qgu, qgj - 16)["mul"](sj), qgr = sH(qgI["add"](qgb), 43)["add"](sH(qgR, 30))["add"](qgo), qgQ = sK(qgr, qgI["add"](sH(qgb["add"](sj), 18))["add"](qgR), qgL), qgd = sr(qgu, 16)["mul"](qgL), qgv = sr(qgu, 24), qgy = qgr["add"](sr(qgu, qgj - 32))["mul"](qgL), qgl = qgQ["add"](sr(qgu, qgj - 24))["mul"](qgL);
  return sK(sH(qgd["add"](qgv), 43)["add"](sH(qgy, 30))["add"](qgl), qgd["add"](sH(qgv["add"](qgI), 18))["add"](qgy), qgL);
}
function sU(qgu, qgj = qgu["length"]) {
  const qgL = sz["fromNumber"](81, true);
  if (qgj <= 32) return qgj <= 16 ? sJ(qgu, qgj) : sY(qgu, qgj);
  if (qgj <= 64) return sP(qgu, qgj);
  let qgI = qgL, qgb = qgL["mul"](su)["add"](113), qgR = sL(qgb["mul"](sj)["add"](113))["mul"](sj), qgo = [sz["UZERO"], sz["UZERO"]], qgr = [sz["UZERO"], sz["UZERO"]];
  qgI = qgI["mul"](sj)["add"](sr(qgu, 0));
  let qgQ = 0;
  const qgd = (qgj - 1 >> 6) * 64, qgv = qgd + (qgj - 1 & 63) - 63;
  do
    qgI = sH(qgI["add"](qgb)["add"](qgo[0])["add"](sr(qgu, qgQ + 8)), 37)["mul"](su), qgb = sH(qgb["add"](qgo[1])["add"](sr(qgu, qgQ + 48)), 42)["mul"](su), qgI = qgI["xor"](qgr[1]), qgb = qgb["add"](qgo[0])["add"](sr(qgu, qgQ + 40)), qgR = sH(qgR["add"](qgr[0]), 33)["mul"](su), qgo = sV(qgu, qgQ, qgo[1]["mul"](su), qgI["add"](qgr[0])), qgr = sV(qgu, qgQ + 32, qgR["add"](qgr[1]), qgb["add"](sr(qgu, qgQ + 16))), [qgR, qgI] = [qgI, qgR], qgQ += 64;
  while (qgQ !== qgd);
  const qgy = su["add"](qgR["and"](255)["shl"](1));
  return qgQ = qgv, qgr[0] = qgr[0]["add"](qgj - 1 & 63), qgo[0] = qgo[0]["add"](qgr[0]), qgr[0] = qgr[0]["add"](qgo[0]), qgI = sH(qgI["add"](qgb)["add"](qgo[0])["add"](sr(qgu, qgQ + 8)), 37)["mul"](qgy), qgb = sH(qgb["add"](qgo[1])["add"](sr(qgu, qgQ + 48)), 42)["mul"](qgy), qgI = qgI["xor"](qgr[1]["mul"](9)), qgb = qgb["add"](qgo[0]["mul"](9)["add"](sr(qgu, qgQ + 40))), qgR = sH(qgR["add"](qgr[0]), 33)["mul"](qgy), qgo = sV(qgu, qgQ, qgo[1]["mul"](qgy), qgI["add"](qgr[0])), qgr = sV(qgu, qgQ + 32, qgR["add"](qgr[1]), qgb["add"](sr(qgu, qgQ + 16))), [qgR, qgI] = [qgI, qgR], sK(sK(qgo[0], qgr[0], qgy)["add"](sL(qgb)["mul"](sG))["add"](qgR), sK(qgo[1], qgr[1], qgy)["add"](qgI), qgy);
}
function Eq(qgu, qgj) {
  return qgj === "string" ? Et(qgu) : EM([qgu], qgj);
}
function En(qgu, qgj) {
  return qgu instanceof Float32Array && qgj === "float32" || qgu instanceof Int32Array && qgj === "int32" || qgu instanceof Uint8Array && qgj === "bool";
}
function EM(qgu, qgj) {
  if (qgj === "string") throw new Error("Cannot convert a string[] to a TypedArray");
  if (Array["isArray"](qgu) && (qgu = EZ(qgu)), qM()["getBool"]("DEBUG") && N(qgu, qgj), En(qgu, qgj)) return qgu;
  if (qgj == null || qgj === "float32" || qgj === "complex64") return new Float32Array(qgu);
  if (qgj === "int32") return new Int32Array(qgu);
  if (qgj === "bool") {
    const qgL = new Uint8Array(qgu["length"]);
    for (let qgI = 0; qgI < qgL["length"]; ++qgI) Math["round"](qgu[qgI]) !== 0 && (qgL[qgI] = 1);
    return qgL;
  } else throw new Error("Unknown data type " + qgj);
}
function EF() {
  return qM()["platform"]["now"]();
}
function Et(qgu, qgj = "utf-8") {
  return qgj = qgj || "utf-8", qM()["platform"]["encode"](qgu, qgj);
}
function EW(qgu, qgj = "utf-8") {
  return qgj = qgj || "utf-8", qM()["platform"]["decode"](qgu, qgj);
}
function ED(qgu) {
  return qM()["platform"]["isTypedArray"] != null ? qM()["platform"]["isTypedArray"](qgu) : gU(qgu);
}
function EZ(qgu, qgj = [], qgL = false) {
  if (qgj == null && (qgj = []), typeof qgu == "boolean" || typeof qgu == "number" || typeof qgu == "string" || J(qgu) || qgu == null || ED(qgu) && qgL) qgj["push"](qgu);
  else {
    if (Array["isArray"](qgu) || ED(qgu)) {
      for (let qgI = 0; qgI < qgu["length"]; ++qgI) EZ(qgu[qgI], qgj, qgL);
    } else {
      let qgb = -1;
      for (const qgR of Object["keys"](qgu)) /^([1-9]+[0-9]*|0)$/["test"](qgR) && (qgb = Math["max"](qgb, Number(qgR)));
      for (let qgo = 0; qgo <= qgb; qgo++) EZ(qgu[qgo], qgj, qgL);
    }
  }
  return qgj;
}
var Ez = class {
  constructor(qgu, qgj) {
    this["backendTimer"] = qgu, this["logger"] = qgj, qgj == null && (this["logger"] = new EG());
  }
  ["profileKernel"](qgu, qgj, qgL) {
    let qgI;
    const qgb = () => {
      qgI = qgL();
    };
    let qgR;
    const qgo = EF();
    if (this["backendTimer"]["timerAvailable"]()) qgR = this["backendTimer"]["time"](qgb);
    else {
      qgb();
      for (const qgr of qgI) qgr["dataSync"]();
      qgR = Promise["resolve"]({ "kernelMs": EF() - qgo });
    }
    if (qM()["getBool"]("CHECK_COMPUTATION_FOR_ERRORS")) for (let qgQ = 0; qgQ < qgI["length"]; qgQ++) {
      const qgd = qgI[qgQ];
      qgd["data"]()["then"]((qgv) => {
        EX(qgv, qgd["dtype"], qgu);
      });
    }
    return { "kernelName": qgu, "outputs": qgI, "inputs": qgj, "timeMs": qgR["then"]((qgv) => qgv["kernelMs"]), "extraInfo": qgR["then"]((qgv) => qgv["getExtraProfileInfo"] != null ? qgv["getExtraProfileInfo"]() : "") };
  }
  ["logKernelProfile"](qgu) {
    const { kernelName: qgj, outputs: qgL, timeMs: qgI, inputs: qgb, extraInfo: qgR } = qgu;
    qgL["forEach"]((qgo) => {
      Promise["all"]([qgo["data"](), qgI, qgR])["then"]((qgr) => {
        this["logger"]["logKernelProfile"](qgj, qgo, qgr[0], qgr[1], qgb, qgr[2]);
      });
    });
  }
};
function EX(qgu, qgj, qgL) {
  if (qgj !== "float32") return false;
  for (let qgI = 0; qgI < qgu["length"]; qgI++) {
    const qgb = qgu[qgI];
    if (isNaN(qgb) || !isFinite(qgb)) return console["warn"]("Found " + qgb + " in the result of '" + qgL + "'"), true;
  }
  return false;
}
var EG = class {
  ["logKernelProfile"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = typeof qgI == "number" ? Z(qgI + "ms", 9) : qgI["error"], qgr = Z(qgu, 25), qgQ = qgj["rank"], qgd = qgj["size"], qgv = Z(qgj["shape"]["toString"](), 14);
    let qgy = "";
    for (const qgl in qgb) {
      const qgH = qgb[qgl];
      if (qgH != null) {
        const qgA = qgH["shape"] || qgj["shape"], qgh = qgA["length"];
        qgy += qgl + ": " + qgh + "D " + (qgh > 0 ? qgA : "") + " ";
      }
    }
    console["log"]("%c" + qgr + "	%c" + qgo + "	%c" + qgQ + "D " + qgv + "	%c" + qgd + "	%c" + qgy + "	%c" + qgR, "font-weight:bold", "color:red", "color:blue", "color: orange", "color: green", "color: steelblue");
  }
};
function Eu(qgu, qgj, qgL) {
  const qgI = {}, qgb = {};
  for (let qgQ = 0; qgQ < qgj["length"]; qgQ++) qgI[qgj[qgQ]["id"]] = true;
  for (let qgd = 0; qgd < qgu["length"]; qgd++) {
    const qgv = qgu[qgd], qgy = qgv["inputs"];
    for (const qgl in qgy) {
      const qgH = qgy[qgl];
      let qgA = false;
      for (let qgh = 0; qgh < qgj["length"]; qgh++) if (qgI[qgH["id"]]) {
        qgv["outputs"]["forEach"]((qgT) => qgI[qgT["id"]] = true), qgA = true, qgb[qgv["id"]] = true;
        break;
      }
      if (qgA) break;
    }
  }
  const qgR = {};
  qgR[qgL["id"]] = true;
  const qgo = {};
  for (let qgT = qgu["length"] - 1; qgT >= 0; qgT--) {
    const qgK = qgu[qgT], qgB = qgK["inputs"];
    for (let qgV = 0; qgV < qgK["outputs"]["length"]; qgV++) if (qgR[qgK["outputs"][qgV]["id"]]) {
      for (const qgJ in qgB) qgR[qgB[qgJ]["id"]] = true, qgo[qgK["id"]] = true;
      break;
    }
  }
  const qgr = [];
  for (let qgY = 0; qgY < qgu["length"]; qgY++) {
    const qgP = qgu[qgY];
    if (qgb[qgP["id"]] && qgo[qgP["id"]]) {
      const qgU = {};
      for (const qx1 in qgP["inputs"]) {
        const qx2 = qgP["inputs"][qx1];
        qgI[qx2["id"]] && (qgU[qx1] = qx2);
      }
      const qx0 = Object["assign"]({}, qgP);
      qx0["inputs"] = qgU, qx0["outputs"] = qgP["outputs"], qgr["push"](qx0);
    }
  }
  return qgr;
}
function Ej(qgu, qgj, qgL, qgI) {
  for (let qgb = qgj["length"] - 1; qgb >= 0; qgb--) {
    const qgR = qgj[qgb], qgo = [];
    if (qgR["outputs"]["forEach"]((qgQ) => {
      const qgd = qgu[qgQ["id"]];
      qgd != null ? qgo["push"](qgd) : qgo["push"](null);
    }), qgR["gradient"] == null) throw new Error("Cannot compute gradient: gradient function not found for " + qgR["kernelName"] + ".");
    const qgr = qgR["gradient"](qgo);
    for (const qgQ in qgR["inputs"]) {
      if (!(qgQ in qgr)) throw new Error("Cannot backprop through input " + qgQ + ". Available gradients found: " + Object["keys"](qgr) + ".");
      const qgd = qgL(() => qgr[qgQ]());
      if (qgd["dtype"] !== "float32") throw new Error("Error in gradient for op " + qgR["kernelName"] + ". The gradient of input " + qgQ + " must have 'float32' dtype, but has '" + qgd["dtype"] + "'");
      const qgv = qgR["inputs"][qgQ];
      if (!D(qgd["shape"], qgv["shape"])) throw new Error("Error in gradient for op " + qgR["kernelName"] + ". The gradient of input '" + qgQ + "' has shape '" + qgd["shape"] + "', which does not match the shape of the input '" + qgv["shape"] + "'");
      if (qgu[qgv["id"]] == null) qgu[qgv["id"]] = qgd;
      else {
        const qgy = qgu[qgv["id"]];
        qgu[qgv["id"]] = qgI(qgy, qgd), qgy["dispose"]();
      }
    }
  }
}
var EL = 20;
var EQ = 3;
var EH = 7;
function EK(qgu, qgj, qgL, qgI) {
  const qgb = y(qgj), qgR = EB(qgu, qgj, qgL, qgb), qgo = qgj["length"], qgr = EY(qgu, qgj, qgL, qgb, qgR), qgQ = ["Tensor"];
  return qgI && (qgQ["push"]("  dtype: " + qgL), qgQ["push"]("  rank: " + qgo), qgQ["push"]("  shape: [" + qgj + "]"), qgQ["push"]("  values:")), qgQ["push"](qgr["map"]((qgd) => "    " + qgd)["join"]("\n")), qgQ["join"]("\n");
}
function EB(qgu, qgj, qgL, qgI) {
  const qgb = i2(qgj), qgR = qgI[qgI["length"] - 1], qgo = new Array(qgR)["fill"](0), qgr = qgj["length"], qgQ = qgL === "complex64" ? EP(qgu) : qgu;
  if (qgr > 1) for (let qgd = 0; qgd < qgb / qgR; qgd++) {
    const qgv = qgd * qgR;
    for (let qgy = 0; qgy < qgR; qgy++) qgo[qgy] = Math["max"](qgo[qgy], EV(qgQ[qgv + qgy], 0, qgL)["length"]);
  }
  return qgo;
}
function EV(qgu, qgj, qgL) {
  let qgI;
  return Array["isArray"](qgu) ? qgI = parseFloat(qgu[0]["toFixed"](EH)) + " + " + parseFloat(qgu[1]["toFixed"](EH)) + "j" : R(qgu) ? qgI = "'" + qgu + "'" : qgL === "bool" ? qgI = EJ(qgu) : qgI = parseFloat(qgu["toFixed"](EH))["toString"](), Z(qgI, qgj);
}
function EJ(qgu) {
  return qgu === 0 ? "false" : "true";
}
function EY(qgu, qgj, qgL, qgI, qgb, qgR = true) {
  const qgo = qgL === "complex64" ? 2 : 1, qgr = qgj[0], qgQ = qgj["length"];
  if (qgQ === 0) {
    if (qgL === "complex64") {
      const qgh = EP(qgu);
      return [EV(qgh[0], 0, qgL)];
    }
    return qgL === "bool" ? [EJ(qgu[0])] : [qgu[0]["toString"]()];
  }
  if (qgQ === 1) {
    if (qgr > EL) {
      const qgT = EQ * qgo;
      let qgK = Array["from"](qgu["slice"](0, qgT)), qgB = Array["from"](qgu["slice"]((qgr - EQ) * qgo, qgr * qgo));
      return qgL === "complex64" && (qgK = EP(qgK), qgB = EP(qgB)), ["[" + qgK["map"]((qgV, qgJ) => EV(qgV, qgb[qgJ], qgL))["join"](", ") + ", ..., " + qgB["map"]((qgV, qgJ) => EV(qgV, qgb[qgr - EQ + qgJ], qgL))["join"](", ") + "]"];
    }
    return ["[" + (qgL === "complex64" ? EP(qgu) : Array["from"](qgu))["map"]((qgV, qgJ) => EV(qgV, qgb[qgJ], qgL))["join"](", ") + "]"];
  }
  const qgd = qgj["slice"](1), qgv = qgI["slice"](1), qgy = qgI[0] * qgo, qgl = [];
  if (qgr > EL) {
    for (let qgV = 0; qgV < EQ; qgV++) {
      const qgJ = qgV * qgy, qgY = qgJ + qgy;
      qgl["push"](...EY(qgu["slice"](qgJ, qgY), qgd, qgL, qgv, qgb, false));
    }
    qgl["push"]("...");
    for (let qgP = qgr - EQ; qgP < qgr; qgP++) {
      const qgU = qgP * qgy, qx0 = qgU + qgy;
      qgl["push"](...EY(qgu["slice"](qgU, qx0), qgd, qgL, qgv, qgb, qgP === qgr - 1));
    }
  } else for (let qx1 = 0; qx1 < qgr; qx1++) {
    const qx2 = qx1 * qgy, qx3 = qx2 + qgy;
    qgl["push"](...EY(qgu["slice"](qx2, qx3), qgd, qgL, qgv, qgb, qx1 === qgr - 1));
  }
  const qgH = qgQ === 2 ? "," : "";
  qgl[0] = "[" + (qgr > 0 ? qgl[0] + qgH : "");
  for (let qx4 = 1; qx4 < qgl["length"] - 1; qx4++) qgl[qx4] = " " + qgl[qx4] + qgH;
  let qgA = ",\n";
  for (let qx5 = 2; qx5 < qgQ; qx5++) qgA += "\n";
  return qgl[qgl["length"] - 1] = " " + qgl[qgl["length"] - 1] + "]" + (qgR ? "" : qgA), qgl;
}
function EP(qgu) {
  const qgj = [];
  for (let qgL = 0; qgL < qgu["length"]; qgL += 2) qgj["push"]([qgu[qgL], qgu[qgL + 1]]);
  return qgj;
}
var EU = class {
  constructor(qgu, qgj, qgL) {
    if (this["dtype"] = qgj, this["shape"] = qgu["slice"](), this["size"] = i2(qgu), qgL != null) {
      const qgI = qgL["length"];
      k(qgI === this["size"], () => "Length of values '" + qgI + "' does not match the size inferred by the shape '" + this["size"] + "'.");
    }
    if (qgj === "complex64") throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");
    this["values"] = qgL || G(qgj, this["size"]), this["strides"] = y(qgu);
  }
  ["set"](qgu, ...qgj) {
    qgj["length"] === 0 && (qgj = [0]), k(qgj["length"] === this["rank"], () => "The number of provided coordinates (" + qgj["length"] + ") must match the rank (" + this["rank"] + ")");
    const qgL = this["locToIndex"](qgj);
    this["values"][qgL] = qgu;
  }
  ["get"](...qgu) {
    qgu["length"] === 0 && (qgu = [0]);
    let qgj = 0;
    for (const qgI of qgu) {
      if (qgI < 0 || qgI >= this["shape"][qgj]) {
        const qgb = "Requested out of range element at " + qgu + ".   Buffer shape=" + this["shape"];
        throw new Error(qgb);
      }
      qgj++;
    }
    let qgL = qgu[qgu["length"] - 1];
    for (let qgR = 0; qgR < qgu["length"] - 1; ++qgR) qgL += this["strides"][qgR] * qgu[qgR];
    return this["values"][qgL];
  }
  ["locToIndex"](qgu) {
    if (this["rank"] === 0) return 0;
    if (this["rank"] === 1) return qgu[0];
    let qgj = qgu[qgu["length"] - 1];
    for (let qgL = 0; qgL < qgu["length"] - 1; ++qgL) qgj += this["strides"][qgL] * qgu[qgL];
    return qgj;
  }
  ["indexToLoc"](qgu) {
    if (this["rank"] === 0) return [];
    if (this["rank"] === 1) return [qgu];
    const qgj = new Array(this["shape"]["length"]);
    for (let qgL = 0; qgL < qgj["length"] - 1; ++qgL) qgj[qgL] = Math["floor"](qgu / this["strides"][qgL]), qgu -= qgj[qgL] * this["strides"][qgL];
    return qgj[qgj["length"] - 1] = qgu, qgj;
  }
  get ["rank"]() {
    return this["shape"]["length"];
  }
  ["toTensor"]() {
    return Mq()["makeTensor"](this["values"], this["shape"], this["dtype"]);
  }
};
var Mq = null;
var Mn = null;
function Ms(qgu) {
  Mq = qgu;
}
function MM(qgu) {
  Mn = qgu;
}
var MF = class {
  constructor(qgu, qgj, qgL, qgI) {
    this["kept"] = false, this["isDisposedInternal"] = false, this["shape"] = qgu["slice"](), this["dtype"] = qgj || "float32", this["size"] = i2(qgu), this["strides"] = y(qgu), this["dataId"] = qgL, this["id"] = qgI, this["rankType"] = this["rank"] < 5 ? this["rank"]["toString"]() : "higher";
  }
  get ["rank"]() {
    return this["shape"]["length"];
  }
  async ["buffer"]() {
    const qgu = await this["data"]();
    return Mn["buffer"](this["shape"], this["dtype"], qgu);
  }
  ["bufferSync"]() {
    return Mn["buffer"](this["shape"], this["dtype"], this["dataSync"]());
  }
  async ["array"]() {
    const qgu = await this["data"]();
    return l(this["shape"], qgu, this["dtype"] === "complex64");
  }
  ["arraySync"]() {
    return l(this["shape"], this["dataSync"](), this["dtype"] === "complex64");
  }
  async ["data"]() {
    this["throwIfDisposed"]();
    const qgu = Mq()["read"](this["dataId"]);
    if (this["dtype"] === "string") {
      const qgj = await qgu;
      try {
        return qgj["map"]((qgL) => EW(qgL));
      } catch (qgL) {
        throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
      }
    }
    return qgu;
  }
  ["dataToGPU"](qgu) {
    return this["throwIfDisposed"](), Mq()["readToGPU"](this["dataId"], qgu);
  }
  ["dataSync"]() {
    this["throwIfDisposed"]();
    const qgu = Mq()["readSync"](this["dataId"]);
    if (this["dtype"] === "string") try {
      return qgu["map"]((qgj) => EW(qgj));
    } catch (qgj) {
      throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().");
    }
    return qgu;
  }
  async ["bytes"]() {
    this["throwIfDisposed"]();
    const qgu = await Mq()["read"](this["dataId"]);
    return this["dtype"] === "string" ? qgu : new Uint8Array(qgu["buffer"]);
  }
  ["dispose"]() {
    this["isDisposed"] || (this["kerasMask"] && this["kerasMask"]["dispose"](), Mq()["disposeTensor"](this), this["isDisposedInternal"] = true);
  }
  get ["isDisposed"]() {
    return this["isDisposedInternal"];
  }
  ["throwIfDisposed"]() {
    if (this["isDisposed"]) throw new Error("Tensor is disposed.");
  }
  ["print"](qgu = false) {
    return Mn["print"](this, qgu);
  }
  ["clone"]() {
    return this["throwIfDisposed"](), Mn["clone"](this);
  }
  ["toString"](qgu = false) {
    const qgj = this["dataSync"]();
    return EK(qgj, this["shape"], this["dtype"], qgu);
  }
  ["cast"](qgu) {
    return this["throwIfDisposed"](), Mn["cast"](this, qgu);
  }
  ["variable"](qgu = true, qgj, qgL) {
    return this["throwIfDisposed"](), Mq()["makeVariable"](this, qgu, qgj, qgL);
  }
};
Object["defineProperty"](MF, Symbol["hasInstance"], { "value": (qgu) => !!qgu && qgu["data"] != null && qgu["dataSync"] != null && qgu["throwIfDisposed"] != null });
function MW() {
  return qz("Tensor", () => MF);
}
MW();
var MD = class extends MF {
  constructor(qgu, qgj, qgL, qgI) {
    super(qgu["shape"], qgu["dtype"], qgu["dataId"], qgI), this["trainable"] = qgj, this["name"] = qgL;
  }
  ["assign"](qgu) {
    if (qgu["dtype"] !== this["dtype"]) throw new Error("dtype of the new value (" + qgu["dtype"] + ") and previous value (" + this["dtype"] + ") must match");
    if (!D(qgu["shape"], this["shape"])) throw new Error("shape of the new value (" + qgu["shape"] + ") and previous value (" + this["shape"] + ") must match");
    Mq()["disposeTensor"](this), this["dataId"] = qgu["dataId"], Mq()["incRef"](this, null);
  }
  ["dispose"]() {
    Mq()["disposeVariable"](this), this["isDisposedInternal"] = true;
  }
};
Object["defineProperty"](MD, Symbol["hasInstance"], { "value": (qgu) => qgu instanceof MF && qgu["assign"] != null && qgu["assign"] instanceof Function });
var MZ;
(function(qgu) {
  qgu["R0"] = "R0", qgu["R1"] = "R1", qgu["R2"] = "R2", qgu["R3"] = "R3", qgu["R4"] = "R4", qgu["R5"] = "R5", qgu["R6"] = "R6";
})(MZ || (MZ = {}));
var Me;
(function(qgu) {
  qgu["float32"] = "float32", qgu["int32"] = "int32", qgu["bool"] = "int32", qgu["complex64"] = "complex64";
})(Me || (Me = {}));
var Mz;
(function(qgu) {
  qgu["float32"] = "float32", qgu["int32"] = "int32", qgu["bool"] = "bool", qgu["complex64"] = "complex64";
})(Mz || (Mz = {}));
var MX;
(function(qgu) {
  qgu["float32"] = "float32", qgu["int32"] = "float32", qgu["bool"] = "float32", qgu["complex64"] = "complex64";
})(MX || (MX = {}));
var MG;
(function(qgu) {
  qgu["float32"] = "complex64", qgu["int32"] = "complex64", qgu["bool"] = "complex64", qgu["complex64"] = "complex64";
})(MG || (MG = {}));
var Mj = { "float32": MX, "int32": Me, "bool": Mz, "complex64": MG };
function ML(qgu, qgj) {
  if (qgu === "string" || qgj === "string") {
    if (qgu === "string" && qgj === "string") return "string";
    throw new Error("Can not upcast " + qgu + " with " + qgj);
  }
  return Mj[qgu][qgj];
}
function MR(qgu) {
  return ML(qgu, "int32");
}
function MQ(qgu) {
  return qgu != null && typeof qgu == "object" && "texture" in qgu && qgu["texture"] instanceof WebGLTexture;
}
function MH(qgu) {
  return typeof GPUBuffer != "undefined" && qgu != null && typeof qgu == "object" && "buffer" in qgu && qgu["buffer"] instanceof GPUBuffer;
}
function MK(qgu, qgj) {
  if (qgu["dtype"] === qgj["dtype"]) return [qgu, qgj];
  const qgL = ML(qgu["dtype"], qgj["dtype"]);
  return [qgu["cast"](qgL), qgj["cast"](qgL)];
}
function MB(qgu) {
  const qgj = [];
  return MV(qgu, qgj, /* @__PURE__ */ new Set()), qgj;
}
function MV(qgu, qgj, qgL) {
  if (qgu == null) return;
  if (qgu instanceof MF) {
    qgj["push"](qgu);
    return;
  }
  if (!MJ(qgu)) return;
  const qgI = qgu;
  for (const qgb in qgI) {
    const qgR = qgI[qgb];
    qgL["has"](qgR) || (qgL["add"](qgR), MV(qgR, qgj, qgL));
  }
}
function MJ(qgu) {
  return Array["isArray"](qgu) || typeof qgu == "object";
}
function MY(qgu) {
  return qgu["kernelName"] != null;
}
var MP = class {
  constructor() {
    this["registeredVariables"] = {}, this["nextTapeNodeId"] = 0, this["numBytes"] = 0, this["numTensors"] = 0, this["numStringTensors"] = 0, this["numDataBuffers"] = 0, this["gradientDepth"] = 0, this["kernelDepth"] = 0, this["scopeStack"] = [], this["numDataMovesStack"] = [], this["nextScopeId"] = 0, this["tensorInfo"] = /* @__PURE__ */ new WeakMap(), this["profiling"] = false, this["activeProfile"] = { "newBytes": 0, "newTensors": 0, "peakBytes": 0, "kernels": [], "result": null, get "kernelNames"() {
      return Array["from"](new Set(this["kernels"]["map"]((qgu) => qgu["name"])));
    } };
  }
  ["dispose"]() {
    for (const qgu in this["registeredVariables"]) this["registeredVariables"][qgu]["dispose"]();
  }
};
var MU = class _MU {
  constructor(qgu) {
    this["ENV"] = qgu, this["registry"] = {}, this["registryFactory"] = {}, this["pendingBackendInitId"] = 0, this["state"] = new MP();
  }
  async ["ready"]() {
    if (this["pendingBackendInit"] != null) return this["pendingBackendInit"]["then"](() => {
    });
    if (this["backendInstance"] != null) return;
    const qgu = this["getSortedBackends"]();
    for (let qgj = 0; qgj < qgu["length"]; qgj++) {
      const qgL = qgu[qgj];
      if (await this["initializeBackend"](qgL)["success"]) {
        await this["setBackend"](qgL);
        return;
      }
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  get ["backend"]() {
    if (this["pendingBackendInit"] != null) throw new Error("Backend '" + this["backendName"] + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
    if (this["backendInstance"] == null) {
      const { name: qgu, asyncInit: qgj } = this["initializeBackendsAndReturnBest"]();
      if (qgj) throw new Error("The highest priority backend '" + qgu + "' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");
      this["setBackend"](qgu);
    }
    return this["backendInstance"];
  }
  ["backendNames"]() {
    return Object["keys"](this["registryFactory"]);
  }
  ["findBackend"](qgu) {
    if (!(qgu in this["registry"])) {
      if (qgu in this["registryFactory"]) {
        const { asyncInit: qgj } = this["initializeBackend"](qgu);
        if (qgj) return null;
      } else return null;
    }
    return this["registry"][qgu];
  }
  ["findBackendFactory"](qgu) {
    return qgu in this["registryFactory"] ? this["registryFactory"][qgu]["factory"] : null;
  }
  ["registerBackend"](qgu, qgj, qgL = 1) {
    return qgu in this["registryFactory"] ? (gL(qgu + " backend was already registered. Reusing existing backend factory."), false) : (this["registryFactory"][qgu] = { "factory": qgj, "priority": qgL }, true);
  }
  async ["setBackend"](qgu) {
    if (this["registryFactory"][qgu] == null) throw new Error("Backend name '" + qgu + "' not found in registry");
    if (this["backendName"] = qgu, this["registry"][qgu] == null) {
      this["backendInstance"] = null;
      const { success: qgj, asyncInit: qgL } = this["initializeBackend"](qgu);
      if (!(qgL ? await qgj : qgj)) return false;
    }
    return this["backendInstance"] = this["registry"][qgu], this["setupRegisteredKernels"](), this["profiler"] = new Ez(this["backendInstance"]), true;
  }
  ["setupRegisteredKernels"]() {
    gJ(this["backendName"])["forEach"]((qgu) => {
      qgu["setupFunc"] != null && qgu["setupFunc"](this["backendInstance"]);
    });
  }
  ["disposeRegisteredKernels"](qgu) {
    gJ(qgu)["forEach"]((qgj) => {
      qgj["disposeFunc"] != null && qgj["disposeFunc"](this["registry"][qgu]);
    });
  }
  ["initializeBackend"](qgu) {
    const qgj = this["registryFactory"][qgu];
    if (qgj == null) throw new Error("Cannot initialize backend " + qgu + ", no registration found.");
    try {
      const qgL = qgj["factory"]();
      if (qgL && !(qgL instanceof x2) && typeof qgL["then"] == "function") {
        const qgI = ++this["pendingBackendInitId"], qgb = qgL["then"]((qgR) => qgI < this["pendingBackendInitId"] ? false : (this["registry"][qgu] = qgR, this["pendingBackendInit"] = null, true))["catch"]((qgR) => (qgI < this["pendingBackendInitId"] || (this["pendingBackendInit"] = null, gL("Initialization of backend " + qgu + " failed"), gL(qgR["stack"] || qgR["message"])), false));
        return this["pendingBackendInit"] = qgb, { "success": qgb, "asyncInit": true };
      } else return this["registry"][qgu] = qgL, { "success": true, "asyncInit": false };
    } catch (qgR) {
      return gL("Initialization of backend " + qgu + " failed"), gL(qgR["stack"] || qgR["message"]), { "success": false, "asyncInit": false };
    }
  }
  ["removeBackend"](qgu) {
    if (!(qgu in this["registryFactory"])) throw new Error(qgu + " backend not found in registry");
    this["backendName"] === qgu && this["pendingBackendInit"] != null && this["pendingBackendInitId"]++, qgu in this["registry"] && (this["disposeRegisteredKernels"](qgu), this["registry"][qgu]["dispose"](), delete this["registry"][qgu]), delete this["registryFactory"][qgu], this["backendName"] === qgu && (this["pendingBackendInit"] = null, this["backendName"] = null, this["backendInstance"] = null);
  }
  ["getSortedBackends"]() {
    if (Object["keys"](this["registryFactory"])["length"] === 0) throw new Error("No backend found in registry.");
    return Object["keys"](this["registryFactory"])["sort"]((qgu, qgj) => this["registryFactory"][qgj]["priority"] - this["registryFactory"][qgu]["priority"]);
  }
  ["initializeBackendsAndReturnBest"]() {
    const qgu = this["getSortedBackends"]();
    for (let qgj = 0; qgj < qgu["length"]; qgj++) {
      const qgL = qgu[qgj], { success: qgI, asyncInit: qgb } = this["initializeBackend"](qgL);
      if (qgb || qgI) return { "name": qgL, "asyncInit": qgb };
    }
    throw new Error("Could not initialize any backends, all backend initializations failed.");
  }
  ["moveData"](qgu, qgj) {
    const qgL = this["state"]["tensorInfo"]["get"](qgj), qgI = qgL["backend"], qgb = this["readSync"](qgj), qgR = qgI["refCount"](qgj);
    qgI["disposeData"](qgj, true), qgL["backend"] = qgu, qgu["move"](qgj, qgb, qgL["shape"], qgL["dtype"], qgR), this["shouldCheckForMemLeaks"]() && this["state"]["numDataMovesStack"][this["state"]["numDataMovesStack"]["length"] - 1]++;
  }
  ["tidy"](qgu, qgj) {
    let qgL = null;
    if (qgj == null) {
      if (typeof qgu != "function") throw new Error("Please provide a function to tidy()");
      qgj = qgu;
    } else {
      if (typeof qgu != "string" && !(qgu instanceof String)) throw new Error("When calling with two arguments, the first argument to tidy() must be a string");
      if (typeof qgj != "function") throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");
      qgL = qgu;
    }
    let qgI;
    return this["scopedRun"](() => this["startScope"](qgL), () => this["endScope"](qgI), () => (qgI = qgj(), qgI instanceof Promise && console["error"]("Cannot return a Promise inside of tidy."), qgI));
  }
  ["scopedRun"](qgu, qgj, qgL) {
    qgu();
    try {
      const qgI = qgL();
      return qgj(), qgI;
    } catch (qgb) {
      throw qgj(), qgb;
    }
  }
  ["nextTensorId"]() {
    return _MU["nextTensorId"]++;
  }
  ["nextVariableId"]() {
    return _MU["nextVariableId"]++;
  }
  ["clone"](qgu) {
    const qgj = fM["runKernel"](no, { "x": qgu }), qgL = { "x": qgu }, qgI = (qgR) => ({ "x": () => {
      const qgo = "float32", qgr = { "x": qgR }, qgQ = { "dtype": qgo };
      return fM["runKernel"](qH, qgr, qgQ);
    } }), qgb = [];
    return this["addTapeNode"](this["state"]["activeScope"]["name"], qgL, [qgj], qgI, qgb, {}), qgj;
  }
  ["runKernel"](qgu, qgj, qgL) {
    if (this["backendName"] == null && this["backend"], !(gB(qgu, this["backendName"]) != null)) throw new Error("Kernel '" + qgu + "' not registered for backend '" + this["backendName"] + "'");
    return this["runKernelFunc"]({ "kernelName": qgu, "inputs": qgj, "attrs": qgL });
  }
  ["shouldCheckForMemLeaks"]() {
    return this["ENV"]["getBool"]("IS_TEST");
  }
  ["checkKernelForMemLeak"](qgu, qgj, qgL) {
    const qgI = this["backend"]["numDataIds"]();
    let qgb = 0;
    qgL["forEach"]((qgr) => {
      qgb += qgr["dtype"] === "complex64" ? 3 : 1;
    });
    const qgR = this["state"]["numDataMovesStack"][this["state"]["numDataMovesStack"]["length"] - 1], qgo = qgI - qgj - qgb - qgR;
    if (qgo > 0) throw new Error("Backend '" + this["backendName"] + "' has an internal memory leak (" + qgo + " data ids) after running '" + qgu + "'");
  }
  ["runKernelFunc"](qgu) {
    let qgj, qgL = [];
    const qgI = this["isTapeOn"](), qgb = this["state"]["numBytes"], qgR = this["state"]["numTensors"];
    this["shouldCheckForMemLeaks"]() && this["state"]["numDataMovesStack"]["push"](0);
    let qgo;
    this["backendName"] == null && this["backend"];
    let qgr;
    const qgQ = MY(qgu) ? qgu["kernelName"] : this["state"]["activeScope"] != null ? this["state"]["activeScope"]["name"] : "";
    if (MY(qgu)) {
      const { kernelName: qgH, inputs: qgA, attrs: qgh } = qgu;
      this["backendName"] == null && this["backend"];
      const qgT = gB(qgH, this["backendName"]);
      k(qgT != null, () => "Cannot find registered kernel '" + qgH + "' for backend '" + this["backendName"] + "'"), qgo = () => {
        const qgK = this["backend"]["numDataIds"]();
        qgr = qgT["kernelFunc"]({ "inputs": qgA, "attrs": qgh, "backend": this["backend"] });
        const qgB = Array["isArray"](qgr) ? qgr : [qgr];
        this["shouldCheckForMemLeaks"]() && this["checkKernelForMemLeak"](qgH, qgK, qgB);
        const qgV = qgB["map"]((qgJ) => qgJ["rank"] != null ? qgJ : this["makeTensorFromTensorInfo"](qgJ));
        if (qgI) {
          const qgJ = this["getTensorsForGradient"](qgH, qgA, qgV);
          qgL = this["saveTensorsForBackwardMode"](qgJ);
        }
        return qgV;
      };
    } else {
      const { forwardFunc: qgK } = qgu, qgB = (qgV) => {
        qgI && (qgL = qgV["map"]((qgJ) => this["keep"](this["clone"](qgJ))));
      };
      qgo = () => {
        const qgV = this["backend"]["numDataIds"]();
        qgr = this["tidy"](() => qgK(this["backend"], qgB));
        const qgJ = Array["isArray"](qgr) ? qgr : [qgr];
        return this["shouldCheckForMemLeaks"]() && this["checkKernelForMemLeak"](qgQ, qgV, qgJ), qgJ;
      };
    }
    const { inputs: qgd, attrs: qgv } = qgu, qgy = MY(qgu) ? null : qgu["backwardsFunc"];
    let qgl;
    return this["scopedRun"](() => this["state"]["kernelDepth"]++, () => this["state"]["kernelDepth"]--, () => {
      !this["ENV"]["getBool"]("DEBUG") && !this["state"]["profiling"] ? qgj = qgo() : (qgl = this["profiler"]["profileKernel"](qgQ, qgd, () => qgo()), this["ENV"]["getBool"]("DEBUG") && this["profiler"]["logKernelProfile"](qgl), qgj = qgl["outputs"]);
    }), qgI && this["addTapeNode"](qgQ, qgd, qgj, qgy, qgL, qgv), this["state"]["profiling"] && this["state"]["activeProfile"]["kernels"]["push"]({ "name": qgQ, "bytesAdded": this["state"]["numBytes"] - qgb, "totalBytesSnapshot": this["state"]["numBytes"], "tensorsAdded": this["state"]["numTensors"] - qgR, "totalTensorsSnapshot": this["state"]["numTensors"], "inputShapes": Object["keys"](qgd)["map"]((qgV) => qgd[qgV] != null ? qgd[qgV]["shape"] : null), "outputShapes": qgj["map"]((qgV) => qgV["shape"]), "kernelTimeMs": qgl["timeMs"], "extraInfo": qgl["extraInfo"] }), Array["isArray"](qgr) ? qgj : qgj[0];
  }
  ["saveTensorsForBackwardMode"](qgu) {
    return qgu["map"]((qgj) => this["keep"](this["clone"](qgj)));
  }
  ["getTensorsForGradient"](qgu, qgj, qgL) {
    const qgI = gV(qgu);
    if (qgI != null) {
      const qgb = qgI["inputsToSave"] || [], qgR = qgI["outputsToSave"] || [];
      let qgo;
      qgI["saveAllInputs"] ? (k(Array["isArray"](qgj), () => "saveAllInputs is true, expected inputs to be an array."), qgo = Object["keys"](qgj)["map"]((qgQ) => qgj[qgQ])) : qgo = qgb["map"]((qgQ) => qgj[qgQ]);
      const qgr = qgL["filter"]((qgQ, qgd) => qgR[qgd]);
      return qgo["concat"](qgr);
    }
    return [];
  }
  ["makeTensor"](qgu, qgj, qgL, qgI) {
    if (qgu == null) throw new Error("Values passed to engine.makeTensor() are null");
    qgL = qgL || "float32", qgI = qgI || this["backend"];
    let qgb = qgu;
    qgL === "string" && R(qgu[0]) && (qgb = qgu["map"]((qgr) => Et(qgr)));
    const qgR = qgI["write"](qgb, qgj, qgL), qgo = new MF(qgj, qgL, qgR, this["nextTensorId"]());
    if (this["trackTensor"](qgo, qgI), qgL === "string") {
      const qgr = this["state"]["tensorInfo"]["get"](qgR), qgQ = I(qgb);
      this["state"]["numBytes"] += qgQ - qgr["bytes"], qgr["bytes"] = qgQ;
    }
    return qgo;
  }
  ["makeTensorFromDataId"](qgu, qgj, qgL, qgI) {
    qgL = qgL || "float32";
    const qgb = { "dataId": qgu, "shape": qgj, "dtype": qgL };
    return this["makeTensorFromTensorInfo"](qgb, qgI);
  }
  ["makeTensorFromTensorInfo"](qgu, qgj) {
    const { dataId: qgL, shape: qgI, dtype: qgb } = qgu, qgR = new MF(qgI, qgb, qgL, this["nextTensorId"]());
    return this["trackTensor"](qgR, qgj), qgR;
  }
  ["makeVariable"](qgu, qgj = true, qgL, qgI) {
    qgL = qgL || this["nextVariableId"]()["toString"](), qgI != null && qgI !== qgu["dtype"] && (qgu = qgu["cast"](qgI));
    const qgb = new MD(qgu, qgj, qgL, this["nextTensorId"]());
    if (this["state"]["registeredVariables"][qgb["name"]] != null) throw new Error("Variable with name " + qgb["name"] + " was already registered");
    return this["state"]["registeredVariables"][qgb["name"]] = qgb, this["incRef"](qgb, this["backend"]), qgb;
  }
  ["trackTensor"](qgu, qgj) {
    this["state"]["numTensors"]++, qgu["dtype"] === "string" && this["state"]["numStringTensors"]++;
    let qgL = 0;
    qgu["dtype"] !== "complex64" && qgu["dtype"] !== "string" && (qgL = qgu["size"] * L(qgu["dtype"])), this["state"]["numBytes"] += qgL, this["state"]["tensorInfo"]["has"](qgu["dataId"]) || (this["state"]["numDataBuffers"]++, this["state"]["tensorInfo"]["set"](qgu["dataId"], { "backend": qgj || this["backend"], "dtype": qgu["dtype"], "shape": qgu["shape"], "bytes": qgL })), qgu instanceof MD || this["track"](qgu);
  }
  ["incRef"](qgu, qgj) {
    this["trackTensor"](qgu, qgj), this["backend"]["incRef"](qgu["dataId"]);
  }
  ["removeDataId"](qgu, qgj) {
    this["state"]["tensorInfo"]["has"](qgu) && this["state"]["tensorInfo"]["get"](qgu)["backend"] === qgj && (this["state"]["tensorInfo"]["delete"](qgu), this["state"]["numDataBuffers"]--);
  }
  ["disposeTensor"](qgu) {
    if (!this["state"]["tensorInfo"]["has"](qgu["dataId"])) return;
    const qgj = this["state"]["tensorInfo"]["get"](qgu["dataId"]);
    if (this["state"]["numTensors"]--, qgu["dtype"] === "string" && (this["state"]["numStringTensors"]--, this["state"]["numBytes"] -= qgj["bytes"]), qgu["dtype"] !== "complex64" && qgu["dtype"] !== "string") {
      const qgL = qgu["size"] * L(qgu["dtype"]);
      this["state"]["numBytes"] -= qgL;
    }
    qgj["backend"]["disposeData"](qgu["dataId"]) && this["removeDataId"](qgu["dataId"], qgj["backend"]);
  }
  ["disposeVariables"]() {
    for (const qgu in this["state"]["registeredVariables"]) {
      const qgj = this["state"]["registeredVariables"][qgu];
      this["disposeVariable"](qgj);
    }
  }
  ["disposeVariable"](qgu) {
    this["disposeTensor"](qgu), this["state"]["registeredVariables"][qgu["name"]] != null && delete this["state"]["registeredVariables"][qgu["name"]];
  }
  ["memory"]() {
    const qgu = this["backend"]["memory"]();
    return qgu["numTensors"] = this["state"]["numTensors"], qgu["numDataBuffers"] = this["state"]["numDataBuffers"], qgu["numBytes"] = this["state"]["numBytes"], this["state"]["numStringTensors"] > 0 && (qgu["unreliable"] = true, qgu["reasons"] == null && (qgu["reasons"] = []), qgu["reasons"]["push"]("Memory usage by string tensors is approximate (2 bytes per character)")), qgu;
  }
  async ["profile"](qgu) {
    this["state"]["profiling"] = true;
    const qgj = this["state"]["numBytes"], qgL = this["state"]["numTensors"];
    this["state"]["activeProfile"]["kernels"] = [], this["state"]["activeProfile"]["result"] = await qgu(), this["state"]["profiling"] = false, this["state"]["activeProfile"]["peakBytes"] = Math["max"](...this["state"]["activeProfile"]["kernels"]["map"]((qgI) => qgI["totalBytesSnapshot"])), this["state"]["activeProfile"]["newBytes"] = this["state"]["numBytes"] - qgj, this["state"]["activeProfile"]["newTensors"] = this["state"]["numTensors"] - qgL;
    for (const qgI of this["state"]["activeProfile"]["kernels"]) qgI["kernelTimeMs"] = await qgI["kernelTimeMs"], qgI["extraInfo"] = await qgI["extraInfo"];
    return this["state"]["activeProfile"];
  }
  ["isTapeOn"]() {
    return this["state"]["gradientDepth"] > 0 && this["state"]["kernelDepth"] === 0;
  }
  ["addTapeNode"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = { "id": this["state"]["nextTapeNodeId"]++, "kernelName": qgu, "inputs": qgj, "outputs": qgL, "saved": qgb }, qgr = gV(qgu);
    qgr != null && (qgI = qgr["gradFunc"]), qgI != null && (qgo["gradient"] = (qgQ) => (qgQ = qgQ["map"]((qgd, qgv) => {
      if (qgd == null) {
        const qgy = qgL[qgv], qgl = T(qgy["size"], qgy["dtype"]);
        return this["makeTensor"](qgl, qgy["shape"], qgy["dtype"]);
      }
      return qgd;
    }), qgI(qgQ["length"] > 1 ? qgQ : qgQ[0], qgb, qgR))), this["state"]["activeTape"]["push"](qgo);
  }
  ["keep"](qgu) {
    return qgu["kept"] = true, qgu;
  }
  ["startTape"]() {
    this["state"]["gradientDepth"] === 0 && (this["state"]["activeTape"] = []), this["state"]["gradientDepth"]++;
  }
  ["endTape"]() {
    this["state"]["gradientDepth"]--;
  }
  ["startScope"](qgu) {
    const qgj = { "track": [], "name": "unnamed scope", "id": this["state"]["nextScopeId"]++ };
    qgu && (qgj["name"] = qgu), this["state"]["scopeStack"]["push"](qgj), this["state"]["activeScope"] = qgj;
  }
  ["endScope"](qgu) {
    const qgj = MB(qgu), qgL = new Set(qgj["map"]((qgb) => qgb["id"]));
    for (let qgb = 0; qgb < this["state"]["activeScope"]["track"]["length"]; qgb++) {
      const qgR = this["state"]["activeScope"]["track"][qgb];
      !qgR["kept"] && !qgL["has"](qgR["id"]) && qgR["dispose"]();
    }
    const qgI = this["state"]["scopeStack"]["pop"]();
    this["state"]["activeScope"] = this["state"]["scopeStack"]["length"] === 0 ? null : this["state"]["scopeStack"][this["state"]["scopeStack"]["length"] - 1], qgj["forEach"]((qgo) => {
      !qgo["kept"] && qgo["scopeId"] === qgI["id"] && this["track"](qgo);
    });
  }
  ["gradients"](qgu, qgj, qgL, qgI = false) {
    if (k(qgj["length"] > 0, () => "gradients() received an empty list of xs."), qgL != null && qgL["dtype"] !== "float32") throw new Error("dy must have 'float32' dtype, but has '" + qgL["dtype"] + "'");
    const qgb = this["scopedRun"](() => this["startTape"](), () => this["endTape"](), () => this["tidy"]("forward", qgu));
    k(qgb instanceof MF, () => "The result y returned by f() must be a tensor.");
    const qgR = Eu(this["state"]["activeTape"], qgj, qgb);
    if (!qgI && qgR["length"] === 0 && qgj["length"] > 0) throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");
    return this["tidy"]("backward", () => {
      const qgo = {};
      qgo[qgb["id"]] = qgL == null ? fq(qgb["shape"]) : qgL, Ej(qgo, qgR, (qgQ) => this["tidy"](qgQ), fF);
      const qgr = qgj["map"]((qgQ) => qgo[qgQ["id"]]);
      return this["state"]["gradientDepth"] === 0 && (this["state"]["activeTape"]["forEach"]((qgQ) => {
        for (const qgd of qgQ["saved"]) qgd["dispose"]();
      }), this["state"]["activeTape"] = null), { "value": qgb, "grads": qgr };
    });
  }
  ["customGrad"](qgu) {
    return k(d(qgu), () => "The f passed in customGrad(f) must be a function."), (...qgj) => {
      k(qgj["every"]((qgo) => qgo instanceof MF), () => "The args passed in customGrad(f)(x1, x2,...) must all be tensors");
      let qgL;
      const qgI = {};
      qgj["forEach"]((qgo, qgr) => {
        qgI[qgr] = qgo;
      });
      const qgb = (qgo, qgr) => (qgL = qgu(...qgj, qgr), k(qgL["value"] instanceof MF, () => "The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"), k(d(qgL["gradFunc"]), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."), qgL["value"]), qgR = (qgo, qgr) => {
        const qgQ = qgL["gradFunc"](qgo, qgr), qgd = Array["isArray"](qgQ) ? qgQ : [qgQ];
        k(qgd["length"] === qgj["length"], () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."), k(qgd["every"]((qgy) => qgy instanceof MF), () => "The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");
        const qgv = {};
        return qgd["forEach"]((qgy, qgl) => {
          qgv[qgl] = () => qgy;
        }), qgv;
      };
      return this["runKernelFunc"]({ "forwardFunc": qgb, "backwardsFunc": qgR, "inputs": qgI });
    };
  }
  ["readSync"](qgu) {
    return this["state"]["tensorInfo"]["get"](qgu)["backend"]["readSync"](qgu);
  }
  ["read"](qgu) {
    return this["state"]["tensorInfo"]["get"](qgu)["backend"]["read"](qgu);
  }
  ["readToGPU"](qgu, qgj) {
    return this["state"]["tensorInfo"]["get"](qgu)["backend"]["readToGPU"](qgu, qgj);
  }
  async ["time"](qgu) {
    const qgj = EF(), qgL = await this["backend"]["time"](qgu);
    return qgL["wallMs"] = EF() - qgj, qgL;
  }
  ["track"](qgu) {
    return this["state"]["activeScope"] != null && (qgu["scopeId"] = this["state"]["activeScope"]["id"], this["state"]["activeScope"]["track"]["push"](qgu)), qgu;
  }
  get ["registeredVariables"]() {
    return this["state"]["registeredVariables"];
  }
  ["reset"]() {
    this["pendingBackendInitId"]++, this["state"]["dispose"](), this["ENV"]["reset"](), this["state"] = new MP();
    for (const qgu in this["registry"]) this["disposeRegisteredKernels"](qgu), this["registry"][qgu]["dispose"](), delete this["registry"][qgu];
    this["backendName"] = null, this["backendInstance"] = null, this["pendingBackendInit"] = null;
  }
};
MU["nextTensorId"] = 0, MU["nextVariableId"] = 0;
function fq(qgu) {
  const qgj = h(i2(qgu), "float32");
  return fM["makeTensor"](qgj, qgu, "float32");
}
function fn() {
  const qgu = qa();
  if (qgu["_tfengine"] == null) {
    const qgj = new P(qgu);
    qgu["_tfengine"] = new MU(qgj);
  }
  return qW(qgu["_tfengine"]["ENV"]), Ms(() => qgu["_tfengine"]), qgu["_tfengine"];
}
var fM = fn();
function fF(qgu, qgj) {
  const qgL = { "a": qgu, "b": qgj };
  return fM["runKernel"](qG, qgL);
}
function ft() {
  return typeof navigator != "undefined" && navigator != null;
}
function fW(qgu) {
  if (qgu || ft()) {
    if (qgu || (qgu = navigator), qgu["product"] === "ReactNative") return true;
    const qgj = qgu["userAgent"] || qgu["vendor"] || (typeof window != "undefined" ? window["opera"] : "");
    if (!qgj) {
      const qgL = qgu;
      return qgL["userAgentData"] && qgL["userAgentData"]["mobile"];
    }
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i["test"](qgj) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i["test"](qgj["substr"](0, 4));
  }
  return false;
}
function fD() {
  return typeof window != "undefined" && window["document"] != null || typeof WorkerGlobalScope != "undefined";
}
var fa = qM();
fa["registerFlag"]("DEBUG", () => false, (qgu) => {
  qgu && console["warn"]("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.");
}), fa["registerFlag"]("IS_BROWSER", () => fD()), fa["registerFlag"]("IS_NODE", () => typeof process != "undefined" && typeof process["versions"] != "undefined" && typeof process["versions"]["node"] != "undefined"), fa["registerFlag"]("IS_CHROME", () => typeof navigator != "undefined" && navigator != null && navigator["userAgent"] != null && /Chrome/["test"](navigator["userAgent"]) && /Google Inc/["test"](navigator["vendor"])), fa["registerFlag"]("IS_SAFARI", () => typeof navigator != "undefined" && navigator != null && navigator["userAgent"] != null && /Safari/["test"](navigator["userAgent"]) && /Apple/["test"](navigator["vendor"])), fa["registerFlag"]("PROD", () => false), fa["registerFlag"]("TENSORLIKE_CHECK_SHAPE_CONSISTENCY", () => fa["getBool"]("DEBUG")), fa["registerFlag"]("DEPRECATION_WARNINGS_ENABLED", () => true), fa["registerFlag"]("IS_TEST", () => false), fa["registerFlag"]("CHECK_COMPUTATION_FOR_ERRORS", () => fa["getBool"]("DEBUG")), fa["registerFlag"]("WRAP_TO_IMAGEBITMAP", () => false), fa["registerFlag"]("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU", () => false), fa["registerFlag"]("USE_SETTIMEOUTCUSTOM", () => false);
function fZ(qgu, qgj) {
  let qgL = qgu;
  if (ED(qgu)) return qgj === "string" ? [] : [qgu["length"]];
  if (MQ(qgu)) {
    const qgb = qgu["channels"] || "RGBA";
    return [qgu["height"], qgu["width"] * qgb["length"]];
  } else {
    if (MH(qgu)) return [qgu["buffer"]["size"] / (qgj == null ? 4 : L(qgj))];
  }
  if (!Array["isArray"](qgu)) return [];
  const qgI = [];
  for (; Array["isArray"](qgL) || ED(qgL) && qgj !== "string"; ) qgI["push"](qgL["length"]), qgL = qgL[0];
  return Array["isArray"](qgu) && qM()["getBool"]("TENSORLIKE_CHECK_SHAPE_CONSISTENCY") && fz(qgu, qgI, []), qgI;
}
function fz(qgu, qgj, qgL) {
  if (qgL = qgL || [], !Array["isArray"](qgu) && !ED(qgu)) {
    k(qgj["length"] === 0, () => "Element arr[" + qgL["join"]("][") + "] is a primitive, but should be an array/TypedArray of " + qgj[0] + " elements");
    return;
  }
  k(qgj["length"] > 0, () => "Element arr[" + qgL["join"]("][") + "] should be a primitive, but is an array of " + qgu["length"] + " elements"), k(qgu["length"] === qgj[0], () => "Element arr[" + qgL["join"]("][") + "] should have " + qgj[0] + " elements, but has " + qgu["length"] + " elements");
  const qgI = qgj["slice"](1);
  for (let qgb = 0; qgb < qgu["length"]; ++qgb) fz(qgu[qgb], qgI, qgL["concat"](qgb));
}
function fX(qgu, qgj, qgL, qgI) {
  if (qgu !== "string_or_numeric") {
    if (qgu == null) throw new Error("Expected dtype cannot be null.");
    if (qgu !== "numeric" && qgu !== qgj || qgu === "numeric" && qgj === "string") throw new Error("Argument '" + qgL + "' passed to '" + qgI + "' must be " + qgu + " tensor, but got " + qgj + " tensor");
  }
}
function fG(qgu, qgj, qgL, qgI = "numeric") {
  if (qgu instanceof MW()) return fX(qgI, qgu["dtype"], qgj, qgL), qgu;
  let qgb = Q(qgu);
  if (qgb !== "string" && ["bool", "int32", "float32"]["indexOf"](qgI) >= 0 && (qgb = qgI), fX(qgI, qgb, qgj, qgL), qgu == null || !ED(qgu) && !Array["isArray"](qgu) && typeof qgu != "number" && typeof qgu != "boolean" && typeof qgu != "string") {
    const qgr = qgu == null ? "null" : qgu["constructor"]["name"];
    throw new Error("Argument '" + qgj + "' passed to '" + qgL + "' must be a Tensor or TensorLike, but got '" + qgr + "'");
  }
  const qgR = fZ(qgu, qgb);
  !ED(qgu) && !Array["isArray"](qgu) && (qgu = [qgu]);
  const qgo = qgb !== "string" ? EM(qgu, qgb) : EZ(qgu, [], true);
  return fM["makeTensor"](qgo, qgR, qgb);
}
function fu(qgu, qgj, qgL, qgI = "numeric") {
  if (!Array["isArray"](qgu)) throw new Error("Argument " + qgj + " passed to " + qgL + " must be a `Tensor[]` or `TensorLike[]`");
  return qgu["map"]((qgb, qgR) => fG(qgb, qgj + "[" + qgR + "]", qgL, qgI));
}
var fj = "__op";
function fL(qgu) {
  const qgj = Object["keys"](qgu);
  if (qgj["length"] !== 1) throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with " + qgj["length"] + " keys.");
  let qgL = qgj[0];
  const qgI = qgu[qgL];
  qgL["endsWith"]("_") && (qgL = qgL["substring"](0, qgL["length"] - 1)), qgL = qgL + fj;
  const qgb = (...qgR) => {
    fM["startScope"](qgL);
    try {
      const qgo = qgI(...qgR);
      return J(qgo) && console["error"]("Cannot return a Promise inside of tidy."), fM["endScope"](qgo), qgo;
    } catch (qgr) {
      throw fM["endScope"](null), qgr;
    }
  };
  return Object["defineProperty"](qgb, "name", { "value": qgL, "configurable": true }), qgb;
}
function fQ(qgu, qgj) {
  const qgL = fG(qgu, "real", "complex"), qgI = fG(qgj, "imag", "complex");
  O(qgL["shape"], qgI["shape"], "real and imag shapes, " + qgL["shape"] + " and " + qgI["shape"] + ", must match in call to tf.complex().");
  const qgb = { "real": qgL, "imag": qgI };
  return fM["runKernel"](qB, qgb);
}
var fH = fL({ "complex_": fQ });
function fK(qgu, qgj, qgL, qgI) {
  if (qgI == null) qgI = Q(qgu);
  else {
    if (qgI === "complex64") throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");
  }
  if (MH(qgu) || MQ(qgu)) {
    if (qgI !== "float32" && qgI !== "int32") throw new Error("Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is " + qgI + ".");
    return fM["backend"]["createTensorFromGPUData"](qgu, qgj || qgL, qgI);
  }
  if (!ED(qgu) && !Array["isArray"](qgu) && typeof qgu != "number" && typeof qgu != "boolean" && typeof qgu != "string") throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");
  if (qgj != null) {
    K(qgj);
    const qgb = i2(qgj), qgR = i2(qgL);
    k(qgb === qgR, () => "Based on the provided shape, [" + qgj + "], the tensor should have " + qgb + " values but has " + qgR);
    for (let qgo = 0; qgo < qgL["length"]; ++qgo) {
      const qgr = qgL[qgo], qgQ = qgo === qgL["length"] - 1 ? qgr !== i2(qgj["slice"](qgo)) : true;
      k(qgL[qgo] === qgj[qgo] || !qgQ, () => "Error creating a new Tensor. Inferred shape (" + qgL + ") does not match the provided shape (" + qgj + "). ");
    }
  }
  return !ED(qgu) && !Array["isArray"](qgu) && (qgu = [qgu]), qgj = qgj || qgL, qgu = qgI !== "string" ? EM(qgu, qgI) : EZ(qgu, [], true), fM["makeTensor"](qgu, qgj, qgI);
}
function fB(qgu, qgj, qgL) {
  const qgI = fZ(qgu, qgL);
  return fK(qgu, qgj, qgI, qgL);
}
var fV = { "float32": 4, "float16": 2, "int32": 4, "uint16": 2, "uint8": 1, "bool": 1, "complex64": 8 };
var fJ = class _fJ {
  static ["join"](qgu) {
    return new _fJ(qgu)["slice"]();
  }
  constructor(qgu) {
    if (this["shards"] = [], this["previousShardIndex"] = 0, qgu == null || (qgu instanceof Array || (qgu = [qgu]), qgu = qgu["map"]((qgL) => ED(qgL) ? qgL["buffer"] : qgL), qgu["length"] === 0)) return;
    this["bufferUniformSize"] = qgu[0]["byteLength"];
    let qgj = 0;
    for (let qgL = 0; qgL < qgu["length"]; qgL++) {
      const qgI = qgu[qgL];
      qgL !== qgu["length"] - 1 && qgI["byteLength"] !== this["bufferUniformSize"] && (this["bufferUniformSize"] = void 0);
      const qgb = qgj + qgI["byteLength"];
      this["shards"]["push"]({ "buffer": qgI, "start": qgj, "end": qgb }), qgj = qgb;
    }
    this["shards"]["length"] === 0 && (this["byteLength"] = 0), this["byteLength"] = this["shards"][this["shards"]["length"] - 1]["end"];
  }
  ["slice"](qgu = 0, qgj = this["byteLength"]) {
    if (this["shards"]["length"] === 0) return new ArrayBuffer(0);
    if (qgu = isNaN(Number(qgu)) ? 0 : qgu, qgj = isNaN(Number(qgj)) ? 0 : qgj, qgu = Math["max"](0, qgu), qgj = Math["min"](this["byteLength"], qgj), qgj <= qgu) return new ArrayBuffer(0);
    const qgL = this["findShardForByte"](qgu);
    if (qgL === -1) throw new Error("Could not find start shard for byte " + qgu);
    const qgI = qgj - qgu, qgb = new ArrayBuffer(qgI), qgR = new Uint8Array(qgb);
    let qgo = 0;
    for (let qgr = qgL; qgr < this["shards"]["length"]; qgr++) {
      const qgQ = this["shards"][qgr], qgd = qgu + qgo - qgQ["start"], qgv = qgo, qgy = Math["min"](qgj, qgQ["end"]) - qgQ["start"], qgl = new Uint8Array(qgQ["buffer"], qgd, qgy - qgd);
      if (qgR["set"](qgl, qgv), qgo += qgl["length"], qgj < qgQ["end"]) break;
    }
    return qgb;
  }
  ["findShardForByte"](qgu) {
    if (this["shards"]["length"] === 0 || qgu < 0 || qgu >= this["byteLength"]) return -1;
    if (this["bufferUniformSize"] != null) return this["previousShardIndex"] = Math["floor"](qgu / this["bufferUniformSize"]), this["previousShardIndex"];
    function qgj(qgI) {
      return qgu < qgI["start"] ? -1 : qgu >= qgI["end"] ? 1 : 0;
    }
    if (qgj(this["shards"][this["previousShardIndex"]]) === 0) return this["previousShardIndex"];
    const qgL = fY(this["shards"], qgj);
    return qgL === -1 ? -1 : (this["previousShardIndex"] = qgL, this["previousShardIndex"]);
  }
};
function fY(qgu, qgj) {
  let qgL = 0, qgI = qgu["length"];
  for (; qgL <= qgI; ) {
    const qgb = Math["floor"]((qgI - qgL) / 2) + qgL, qgR = qgj(qgu[qgb]);
    if (qgR === 0) return qgb;
    qgR < 0 ? qgI = qgb : qgL = qgb + 1;
  }
  return -1;
}
function fP() {
  qM()["set"]("PROD", true);
}
function fU() {
  return fM;
}
function Sq(qgu, qgj) {
  return fM["tidy"](qgu, qgj);
}
function Sn(qgu) {
  MB(qgu)["forEach"]((qgj) => qgj["dispose"]());
}
function SM(qgu) {
  return fM["keep"](qgu);
}
function SF(qgu) {
  return fM["setBackend"](qgu);
}
function St() {
  return fM["backendName"];
}
function SW(qgu, qgj, qgL = 1) {
  return fM["registerBackend"](qgu, qgj, qgL);
}
function SD() {
  return fM["backend"];
}
var SZ = 4;
async function Sz(qgu, qgj) {
  const qgL = [], qgI = [], qgb = Array["isArray"](qgu) ? qgu["map"]((qgo) => qgo["name"]) : Object["keys"](qgu);
  for (let qgo = 0; qgo < qgb["length"]; ++qgo) {
    const qgr = qgb[qgo], qgQ = Array["isArray"](qgu) ? qgu[qgo]["tensor"] : qgu[qgr];
    if (qgQ["dtype"] !== "float32" && qgQ["dtype"] !== "int32" && qgQ["dtype"] !== "bool" && qgQ["dtype"] !== "string" && qgQ["dtype"] !== "complex64") throw new Error("Unsupported dtype in weight '" + qgr + "': " + qgQ["dtype"]);
    const qgd = { "name": qgr, "shape": qgQ["shape"], "dtype": qgQ["dtype"] };
    if (qgQ["dtype"] === "string") {
      const qgv = new Promise(async (qgy) => {
        const qgl = await qgQ["bytes"](), qgH = qgl["reduce"]((qgT, qgK) => qgT + qgK["length"], 0) + SZ * qgl["length"], qgA = new Uint8Array(qgH);
        let qgh = 0;
        for (let qgT = 0; qgT < qgl["length"]; qgT++) {
          const qgK = qgl[qgT], qgB = new Uint8Array(new Uint32Array([qgK["length"]])["buffer"]);
          qgA["set"](qgB, qgh), qgh += SZ, qgA["set"](qgK, qgh), qgh += qgK["length"];
        }
        qgy(qgA);
      });
      qgI["push"](qgv);
    } else qgI["push"](qgQ["data"]());
    qgj != null && (qgd["group"] = qgj), qgL["push"](qgd);
  }
  const qgR = await Promise["all"](qgI);
  return { "data": SH(qgR), "specs": qgL };
}
function SX(qgu, qgj) {
  const qgL = new fJ(qgu), qgI = {};
  let qgb = 0;
  for (const qgR of qgj) {
    const qgo = SG(qgR, (qgr, qgQ) => qgL["slice"](qgb + qgr, qgb + qgQ));
    qgI[qgR["name"]] = Sj(qgR, qgL["slice"](qgb, qgb + qgo)), qgb += qgo;
  }
  return qgI;
}
function SG(qgu, qgj) {
  const qgL = i2(qgu["shape"]);
  let qgI;
  if ("quantization" in qgu) {
    const qgb = qgu["quantization"];
    qgI = fV[qgb["dtype"]];
  } else {
    if (qgu["dtype"] === "string") {
      let qgR = 0;
      for (let qgo = 0; qgo < qgL; qgo++) qgR += SZ + new Uint32Array(qgj(qgR, qgR + SZ))[0];
      return qgR;
    } else qgI = fV[qgu["dtype"]];
  }
  return qgL * qgI;
}
async function Su(qgu, qgj) {
  const qgL = i2(qgu["shape"]);
  let qgI;
  if ("quantization" in qgu) {
    const qgb = qgu["quantization"];
    qgI = fV[qgb["dtype"]];
  } else {
    if (qgu["dtype"] === "string") {
      let qgR = 0;
      for (let qgo = 0; qgo < qgL; qgo++) qgR += SZ + new Uint32Array(await qgj(qgR, qgR + SZ))[0];
      return qgR;
    } else qgI = fV[qgu["dtype"]];
  }
  return qgL * qgI;
}
function Sj(qgu, qgj) {
  const qgL = qgu["name"], qgI = qgu["dtype"], qgb = qgu["shape"], qgR = i2(qgb);
  let qgo, qgr = 0;
  if ("quantization" in qgu) {
    const qgQ = qgu["quantization"];
    if (qgQ["dtype"] === "uint8" || qgQ["dtype"] === "uint16") {
      if (!("min" in qgQ && "scale" in qgQ)) throw new Error("Weight " + qgu["name"] + " with quantization " + qgQ["dtype"] + " doesn't have corresponding metadata min and scale.");
    } else {
      if (qgQ["dtype"] === "float16") {
        if (qgI !== "float32") throw new Error("Weight " + qgu["name"] + " is quantized with " + qgQ["dtype"] + " which only supports weights of type float32 not " + qgI + ".");
      } else throw new Error("Weight " + qgu["name"] + " has unknown quantization dtype " + qgQ["dtype"] + ". Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");
    }
    const qgd = fV[qgQ["dtype"]], qgv = qgQ["dtype"] === "uint8" ? new Uint8Array(qgj) : new Uint16Array(qgj);
    if (qgI === "float32") {
      if (qgQ["dtype"] === "uint8" || qgQ["dtype"] === "uint16") {
        qgo = new Float32Array(qgv["length"]);
        for (let qgy = 0; qgy < qgv["length"]; qgy++) {
          const qgl = qgv[qgy];
          qgo[qgy] = qgl * qgQ["scale"] + qgQ["min"];
        }
      } else {
        if (qgQ["dtype"] === "float16") qgo = Fe()(qgv);
        else throw new Error("Unsupported quantization type " + qgQ["dtype"] + " for weight type float32.");
      }
    } else {
      if (qgI === "int32") {
        if (qgQ["dtype"] !== "uint8" && qgQ["dtype"] !== "uint16") throw new Error("Unsupported quantization type " + qgQ["dtype"] + " for weight type int32.");
        qgo = new Int32Array(qgv["length"]);
        for (let qgH = 0; qgH < qgv["length"]; qgH++) {
          const qgA = qgv[qgH];
          qgo[qgH] = Math["round"](qgA * qgQ["scale"] + qgQ["min"]);
        }
      } else throw new Error("Unsupported dtype in weight '" + qgL + "': " + qgI);
    }
    qgr += qgR * qgd;
  } else {
    if (qgI === "string") {
      const qgh = i2(qgu["shape"]);
      qgo = [];
      for (let qgT = 0; qgT < qgh; qgT++) {
        const qgK = new Uint32Array(qgj["slice"](qgr, qgr + SZ))[0];
        qgr += SZ;
        const qgB = new Uint8Array(qgj["slice"](qgr, qgr + qgK));
        qgo["push"](qgB), qgr += qgK;
      }
    } else {
      const qgV = fV[qgI];
      if (qgI === "float32") qgo = new Float32Array(qgj);
      else {
        if (qgI === "int32") qgo = new Int32Array(qgj);
        else {
          if (qgI === "bool") qgo = new Uint8Array(qgj);
          else {
            if (qgI === "complex64") {
              qgo = new Float32Array(qgj);
              const qgJ = new Float32Array(qgo["length"] / 2), qgY = new Float32Array(qgo["length"] / 2);
              for (let qx1 = 0; qx1 < qgJ["length"]; qx1++) qgJ[qx1] = qgo[qx1 * 2], qgY[qx1] = qgo[qx1 * 2 + 1];
              const qgP = fB(qgJ, qgb, "float32"), qgU = fB(qgY, qgb, "float32"), qx0 = fH(qgP, qgU);
              return qgP["dispose"](), qgU["dispose"](), qx0;
            } else throw new Error("Unsupported dtype in weight '" + qgL + "': " + qgI);
          }
        }
      }
      qgr += qgR * qgV;
    }
  }
  return fB(qgo, qgb, qgI);
}
async function SL(qgu, qgj, qgL) {
  let qgI = new Uint8Array(qgj);
  for (; qgI["byteLength"] < qgL; ) {
    const { done: qgb, value: qgR } = await qgu["read"]();
    if (qgb && qgR == null) {
      const qgr = qgL - qgI["byteLength"];
      throw new Error("Reader is done but " + qgr + " bytes are still expected");
    }
    const qgo = new Uint8Array(qgI["length"] + qgR["byteLength"]);
    qgo["set"](qgI, 0), qgo["set"](new Uint8Array(qgR), qgI["length"]), qgI = qgo;
  }
  return qgI["buffer"];
}
async function SQ(qgu, qgj) {
  const qgL = {}, qgI = qgu["getReader"]();
  let qgb = new ArrayBuffer(0);
  for (const qgR of qgj) {
    const qgo = await Su(qgR, async (qgd, qgv) => (qgb = await SL(qgI, qgb, qgv), qgb["slice"](qgd, qgv)));
    qgb = await SL(qgI, qgb, qgo);
    const qgr = qgb["slice"](0, qgo);
    qgb = qgb["slice"](qgo);
    const qgQ = Sj(qgR, qgr);
    if (qgL[qgR["name"]] = qgQ, St() === "webgpu") {
      const qgd = SD();
      "uploadToGPU" in qgd && i2(qgQ["shape"]) >= qM()["get"]("WEBGPU_CPU_HANDOFF_SIZE_THRESHOLD") && qgd["uploadToGPU"](qgQ["dataId"]);
    }
  }
  return qgL;
}
function SH(qgu) {
  if (qgu === null) throw new Error("Invalid input value: " + JSON["stringify"](qgu));
  let qgj = 0;
  const qgL = [];
  qgu["forEach"]((qgR) => {
    if (qgj += qgR["byteLength"], qgL["push"](qgR["byteLength"] === qgR["buffer"]["byteLength"] ? qgR : new qgR["constructor"](qgR)), !(qgR instanceof Float32Array || qgR instanceof Int32Array || qgR instanceof Uint8Array)) throw new Error("Unsupported TypedArray subtype: " + qgR["constructor"]["name"]);
  });
  const qgI = new Uint8Array(qgj);
  let qgb = 0;
  return qgL["forEach"]((qgR) => {
    qgI["set"](new Uint8Array(qgR["buffer"]), qgb), qgb += qgR["byteLength"];
  }), qgI["buffer"];
}
var SK = typeof Buffer != "undefined" && (typeof Blob == "undefined" || typeof atob == "undefined" || typeof btoa == "undefined");
function SB(qgu) {
  return SK ? Buffer["byteLength"](qgu, "utf8") : new Blob([qgu])["size"];
}
function SV(qgu) {
  if (SK) return Buffer["from"](qgu)["toString"]("base64");
  const qgj = new Uint8Array(qgu);
  let qgL = "";
  for (let qgI = 0, qgb = qgj["length"]; qgI < qgb; qgI++) qgL += String["fromCharCode"](qgj[qgI]);
  return btoa(qgL);
}
function SJ(qgu) {
  if (SK) {
    const qgI = Buffer["from"](qgu, "base64");
    return qgI["buffer"]["slice"](qgI["byteOffset"], qgI["byteOffset"] + qgI["byteLength"]);
  }
  const qgj = atob(qgu), qgL = new Uint8Array(qgj["length"]);
  for (let qgb = 0; qgb < qgj["length"]; ++qgb) qgL["set"]([qgj["charCodeAt"](qgb)], qgb);
  return qgL["buffer"];
}
function SY(qgu) {
  return fJ["join"](qgu);
}
function SP(qgu) {
  const qgj = "/";
  for (qgu = qgu["trim"](); qgu["endsWith"](qgj); ) qgu = qgu["slice"](0, qgu["length"] - 1);
  const qgL = qgu["split"](qgj);
  return qgL[qgL["length"] - 1];
}
function SU(qgu, qgj) {
  const qgL = { "modelTopology": qgu["modelTopology"], "format": qgu["format"], "generatedBy": qgu["generatedBy"], "convertedBy": qgu["convertedBy"], "weightsManifest": qgj };
  return qgu["signature"] != null && (qgL["signature"] = qgu["signature"]), qgu["userDefinedMetadata"] != null && (qgL["userDefinedMetadata"] = qgu["userDefinedMetadata"]), qgu["modelInitializer"] != null && (qgL["modelInitializer"] = qgu["modelInitializer"]), qgu["initializerSignature"] != null && (qgL["initializerSignature"] = qgu["initializerSignature"]), qgu["trainingConfig"] != null && (qgL["trainingConfig"] = qgu["trainingConfig"]), qgL;
}
function Fq(qgu, qgj, qgL) {
  const qgI = { "modelTopology": qgu["modelTopology"], "format": qgu["format"], "generatedBy": qgu["generatedBy"], "convertedBy": qgu["convertedBy"] };
  if (qgu["trainingConfig"] != null && (qgI["trainingConfig"] = qgu["trainingConfig"]), qgu["weightsManifest"] != null) {
    if (!qgj) throw new Error("modelJSON has weightsManifest but weightSpecs is null");
    if (!qgL) throw new Error("modelJSON has weightsManifest but weightData is null");
    qgI["weightSpecs"] = qgj, qgI["weightData"] = qgL;
  }
  return qgu["signature"] != null && (qgI["signature"] = qgu["signature"]), qgu["userDefinedMetadata"] != null && (qgI["userDefinedMetadata"] = qgu["userDefinedMetadata"]), qgu["modelInitializer"] != null && (qgI["modelInitializer"] = qgu["modelInitializer"]), qgu["initializerSignature"] != null && (qgI["initializerSignature"] = qgu["initializerSignature"]), qgI;
}
async function Fs(qgu, qgj) {
  let qgL, qgI;
  return qgu["weightsManifest"] != null && ([qgL, qgI] = await qgj(qgu["weightsManifest"])), Fq(qgu, qgL, qgI);
}
function FM(qgu) {
  if (qgu["modelTopology"] instanceof ArrayBuffer) throw new Error("Expected JSON model topology, received ArrayBuffer.");
  return { "dateSaved": /* @__PURE__ */ new Date(), "modelTopologyType": "JSON", "modelTopologyBytes": qgu["modelTopology"] == null ? 0 : SB(JSON["stringify"](qgu["modelTopology"])), "weightSpecsBytes": qgu["weightSpecs"] == null ? 0 : SB(JSON["stringify"](qgu["weightSpecs"])), "weightDataBytes": qgu["weightData"] == null ? 0 : new fJ(qgu["weightData"])["byteLength"] };
}
function FF(qgu) {
  const qgj = [];
  for (const qgL of qgu) qgj["push"](...qgL["weights"]);
  return qgj;
}
function FW() {
  const qgu = (qgL) => {
    let qgI = qgL << 13, qgb = 0;
    for (; (qgI & 8388608) === 0; ) qgb -= 8388608, qgI <<= 1;
    return qgI &= -8388609, qgb += 947912704, qgI | qgb;
  }, qgj = new Uint32Array(2048);
  qgj[0] = 0;
  for (let qgL = 1; qgL < 1024; qgL++) qgj[qgL] = qgu(qgL);
  for (let qgI = 1024; qgI < 2048; qgI++) qgj[qgI] = 939524096 + (qgI - 1024 << 13);
  return qgj;
}
function FD() {
  const qgu = new Uint32Array(64);
  qgu[0] = 0, qgu[31] = 1199570944, qgu[32] = 2147483648, qgu[63] = 3347054592;
  for (let qgj = 1; qgj < 31; qgj++) qgu[qgj] = qgj << 23;
  for (let qgL = 33; qgL < 63; qgL++) qgu[qgL] = 2147483648 + (qgL - 32 << 23);
  return qgu;
}
function FZ() {
  const qgu = new Uint32Array(64);
  for (let qgj = 0; qgj < 64; qgj++) qgu[qgj] = 1024;
  return qgu[0] = qgu[32] = 0, qgu;
}
function Fe() {
  const qgu = FW(), qgj = FD(), qgL = FZ();
  return (qgI) => {
    const qgb = new ArrayBuffer(4 * qgI["length"]), qgR = new Uint32Array(qgb);
    for (let qgo = 0; qgo < qgI["length"]; qgo++) {
      const qgr = qgI[qgo], qgQ = qgu[qgL[qgr >> 10] + (qgr & 1023)] + qgj[qgr >> 10];
      qgR[qgo] = qgQ;
    }
    return new Float32Array(qgb);
  };
}
var Fz = class _Fz {
  constructor() {
    this["saveRouters"] = [], this["loadRouters"] = [];
  }
  static ["getInstance"]() {
    return _Fz["instance"] == null && (_Fz["instance"] = new _Fz()), _Fz["instance"];
  }
  static ["registerSaveRouter"](qgu) {
    _Fz["getInstance"]()["saveRouters"]["push"](qgu);
  }
  static ["registerLoadRouter"](qgu) {
    _Fz["getInstance"]()["loadRouters"]["push"](qgu);
  }
  static ["getSaveHandlers"](qgu) {
    return _Fz["getHandlers"](qgu, "save");
  }
  static ["getLoadHandlers"](qgu, qgj) {
    return _Fz["getHandlers"](qgu, "load", qgj);
  }
  static ["getHandlers"](qgu, qgj, qgL) {
    const qgI = [];
    return (qgj === "load" ? _Fz["getInstance"]()["loadRouters"] : _Fz["getInstance"]()["saveRouters"])["forEach"]((qgb) => {
      const qgR = qgb(qgu, qgL);
      qgR !== null && qgI["push"](qgR);
    }), qgI;
  }
};
var FX = (qgu) => Fz["registerSaveRouter"](qgu);
var FG = (qgu) => Fz["registerLoadRouter"](qgu);
var Fu = (qgu) => Fz["getSaveHandlers"](qgu);
var Fj = (qgu, qgj) => Fz["getLoadHandlers"](qgu, qgj);
var FL = "tensorflowjs";
var FR = 1;
var FQ = "models_store";
var FH = "model_info_store";
function FK() {
  if (!qM()["getBool"]("IS_BROWSER")) throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");
  const qgu = typeof window == "undefined" ? self : window, qgj = qgu["indexedDB"] || qgu["mozIndexedDB"] || qgu["webkitIndexedDB"] || qgu["msIndexedDB"] || qgu["shimIndexedDB"];
  if (qgj == null) throw new Error("The current browser does not appear to support IndexedDB.");
  return qgj;
}
function FB(qgu) {
  const qgj = qgu["result"];
  qgj["createObjectStore"](FQ, { "keyPath": "modelPath" }), qgj["createObjectStore"](FH, { "keyPath": "modelPath" });
}
var FV = class {
  constructor(qgu) {
    if (this["indexedDB"] = FK(), qgu == null || !qgu) throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");
    this["modelPath"] = qgu;
  }
  async ["save"](qgu) {
    if (qgu["modelTopology"] instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    return this["databaseAction"](this["modelPath"], qgu);
  }
  async ["load"]() {
    return this["databaseAction"](this["modelPath"]);
  }
  ["databaseAction"](qgu, qgj) {
    return new Promise((qgL, qgI) => {
      const qgb = this["indexedDB"]["open"](FL, FR);
      qgb["onupgradeneeded"] = () => FB(qgb), qgb["onsuccess"] = () => {
        const qgR = qgb["result"];
        if (qgj == null) {
          const qgo = qgR["transaction"](FQ, "readonly"), qgr = qgo["objectStore"](FQ)["get"](this["modelPath"]);
          qgr["onsuccess"] = () => {
            if (qgr["result"] == null) return qgR["close"](), qgI(new Error("Cannot find model with path '" + this["modelPath"] + "' in IndexedDB."));
            qgL(qgr["result"]["modelArtifacts"]);
          }, qgr["onerror"] = (qgQ) => (qgR["close"](), qgI(qgr["error"])), qgo["oncomplete"] = () => qgR["close"]();
        } else {
          qgj["weightData"] = fJ["join"](qgj["weightData"]);
          const qgQ = FM(qgj), qgd = qgR["transaction"](FH, "readwrite");
          let qgv = qgd["objectStore"](FH), qgy;
          try {
            qgy = qgv["put"]({ "modelPath": this["modelPath"], "modelArtifactsInfo": qgQ });
          } catch (qgH) {
            return qgI(qgH);
          }
          let qgl;
          qgy["onsuccess"] = () => {
            qgl = qgR["transaction"](FQ, "readwrite");
            const qgA = qgl["objectStore"](FQ);
            let qgh;
            try {
              qgh = qgA["put"]({ "modelPath": this["modelPath"], "modelArtifacts": qgj, "modelArtifactsInfo": qgQ });
            } catch (qgT) {
              return qgI(qgT);
            }
            qgh["onsuccess"] = () => qgL({ "modelArtifactsInfo": qgQ }), qgh["onerror"] = (qgK) => {
              qgv = qgd["objectStore"](FH);
              const qgB = qgv["delete"](this["modelPath"]);
              qgB["onsuccess"] = () => (qgR["close"](), qgI(qgh["error"])), qgB["onerror"] = (qgV) => (qgR["close"](), qgI(qgh["error"]));
            };
          }, qgy["onerror"] = (qgA) => (qgR["close"](), qgI(qgy["error"])), qgd["oncomplete"] = () => {
            qgl == null ? qgR["close"]() : qgl["oncomplete"] = () => qgR["close"]();
          };
        }
      }, qgb["onerror"] = (qgR) => qgI(qgb["error"]);
    });
  }
};
FV["URL_SCHEME"] = "indexeddb://";
var FJ = (qgu) => qM()["getBool"]("IS_BROWSER") && !Array["isArray"](qgu) && qgu["startsWith"](FV["URL_SCHEME"]) ? FY(qgu["slice"](FV["URL_SCHEME"]["length"])) : null;
Fz["registerSaveRouter"](FJ), Fz["registerLoadRouter"](FJ);
function FY(qgu) {
  return new FV(qgu);
}
function FP(qgu) {
  return qgu["startsWith"](FV["URL_SCHEME"]) ? qgu["slice"](FV["URL_SCHEME"]["length"]) : qgu;
}
var FU = class {
  constructor() {
    this["indexedDB"] = FK();
  }
  async ["listModels"]() {
    return new Promise((qgu, qgj) => {
      const qgL = this["indexedDB"]["open"](FL, FR);
      qgL["onupgradeneeded"] = () => FB(qgL), qgL["onsuccess"] = () => {
        const qgI = qgL["result"], qgb = qgI["transaction"](FH, "readonly"), qgR = qgb["objectStore"](FH)["getAll"]();
        qgR["onsuccess"] = () => {
          const qgo = {};
          for (const qgr of qgR["result"]) qgo[qgr["modelPath"]] = qgr["modelArtifactsInfo"];
          qgu(qgo);
        }, qgR["onerror"] = (qgo) => (qgI["close"](), qgj(qgR["error"])), qgb["oncomplete"] = () => qgI["close"]();
      }, qgL["onerror"] = (qgI) => qgj(qgL["error"]);
    });
  }
  async ["removeModel"](qgu) {
    return qgu = FP(qgu), new Promise((qgj, qgL) => {
      const qgI = this["indexedDB"]["open"](FL, FR);
      qgI["onupgradeneeded"] = () => FB(qgI), qgI["onsuccess"] = () => {
        const qgb = qgI["result"], qgR = qgb["transaction"](FH, "readwrite"), qgo = qgR["objectStore"](FH), qgr = qgo["get"](qgu);
        let qgQ;
        qgr["onsuccess"] = () => {
          if (qgr["result"] == null) return qgb["close"](), qgL(new Error("Cannot find model with path '" + qgu + "' in IndexedDB."));
          {
            const qgd = qgo["delete"](qgu), qgv = () => {
              qgQ = qgb["transaction"](FQ, "readwrite");
              const qgy = qgQ["objectStore"](FQ)["delete"](qgu);
              qgy["onsuccess"] = () => qgj(qgr["result"]["modelArtifactsInfo"]), qgy["onerror"] = (qgl) => qgL(qgr["error"]);
            };
            qgd["onsuccess"] = qgv, qgd["onerror"] = (qgy) => (qgv(), qgb["close"](), qgL(qgr["error"]));
          }
        }, qgr["onerror"] = (qgd) => (qgb["close"](), qgL(qgr["error"])), qgR["oncomplete"] = () => {
          qgQ == null ? qgb["close"]() : qgQ["oncomplete"] = () => qgb["close"]();
        };
      }, qgI["onerror"] = (qgb) => qgL(qgI["error"]);
    });
  }
};
var tq = "/";
var tn = "tensorflowjs_models";
var ts = "info";
var tM = "model_topology";
var tF = "weight_specs";
var tW = "weight_data";
var ti = "model_metadata";
function tD(qgu) {
  return { "info": [tn, qgu, ts]["join"](tq), "topology": [tn, qgu, tM]["join"](tq), "weightSpecs": [tn, qgu, tF]["join"](tq), "weightData": [tn, qgu, tW]["join"](tq), "modelMetadata": [tn, qgu, ti]["join"](tq) };
}
function tZ(qgu) {
  for (const qgj of Object["values"](qgu)) window["localStorage"]["removeItem"](qgj);
}
function te(qgu) {
  const qgj = qgu["split"](tq);
  if (qgj["length"] < 3) throw new Error("Invalid key format: " + qgu);
  return qgj["slice"](1, qgj["length"] - 1)["join"](tq);
}
function tz(qgu) {
  return qgu["startsWith"](tX["URL_SCHEME"]) ? qgu["slice"](tX["URL_SCHEME"]["length"]) : qgu;
}
var tX = class {
  constructor(qgu) {
    if (!qM()["getBool"]("IS_BROWSER") || typeof window == "undefined" || typeof window["localStorage"] == "undefined") throw new Error("The current environment does not support local storage.");
    if (this["LS"] = window["localStorage"], qgu == null || !qgu) throw new Error("For local storage, modelPath must not be null, undefined or empty.");
    this["modelPath"] = qgu, this["keys"] = tD(this["modelPath"]);
  }
  async ["save"](qgu) {
    if (qgu["modelTopology"] instanceof ArrayBuffer) throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");
    {
      const qgj = JSON["stringify"](qgu["modelTopology"]), qgL = JSON["stringify"](qgu["weightSpecs"]), qgI = FM(qgu), qgb = fJ["join"](qgu["weightData"]);
      try {
        this["LS"]["setItem"](this["keys"]["info"], JSON["stringify"](qgI)), this["LS"]["setItem"](this["keys"]["topology"], qgj), this["LS"]["setItem"](this["keys"]["weightSpecs"], qgL), this["LS"]["setItem"](this["keys"]["weightData"], SV(qgb));
        const qgR = { "format": qgu["format"], "generatedBy": qgu["generatedBy"], "convertedBy": qgu["convertedBy"], "signature": qgu["signature"] != null ? qgu["signature"] : void 0, "userDefinedMetadata": qgu["userDefinedMetadata"] != null ? qgu["userDefinedMetadata"] : void 0, "modelInitializer": qgu["modelInitializer"] != null ? qgu["modelInitializer"] : void 0, "initializerSignature": qgu["initializerSignature"] != null ? qgu["initializerSignature"] : void 0, "trainingConfig": qgu["trainingConfig"] != null ? qgu["trainingConfig"] : void 0 };
        return this["LS"]["setItem"](this["keys"]["modelMetadata"], JSON["stringify"](qgR)), { "modelArtifactsInfo": qgI };
      } catch (qgo) {
        throw tZ(this["keys"]), new Error("Failed to save model '" + this["modelPath"] + "' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=" + qgI["modelTopologyBytes"] + ", weightSpecsBytes=" + qgI["weightSpecsBytes"] + ", weightDataBytes=" + qgI["weightDataBytes"] + ".");
      }
    }
  }
  async ["load"]() {
    const qgu = JSON["parse"](this["LS"]["getItem"](this["keys"]["info"]));
    if (qgu == null) throw new Error("In local storage, there is no model with name '" + this["modelPath"] + "'");
    if (qgu["modelTopologyType"] !== "JSON") throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");
    const qgj = {}, qgL = JSON["parse"](this["LS"]["getItem"](this["keys"]["topology"]));
    if (qgL == null) throw new Error("In local storage, the topology of model '" + this["modelPath"] + "' is missing.");
    qgj["modelTopology"] = qgL;
    const qgI = JSON["parse"](this["LS"]["getItem"](this["keys"]["weightSpecs"]));
    if (qgI == null) throw new Error("In local storage, the weight specs of model '" + this["modelPath"] + "' are missing.");
    qgj["weightSpecs"] = qgI;
    const qgb = this["LS"]["getItem"](this["keys"]["modelMetadata"]);
    if (qgb != null) {
      const qgo = JSON["parse"](qgb);
      qgj["format"] = qgo["format"], qgj["generatedBy"] = qgo["generatedBy"], qgj["convertedBy"] = qgo["convertedBy"], qgo["signature"] != null && (qgj["signature"] = qgo["signature"]), qgo["userDefinedMetadata"] != null && (qgj["userDefinedMetadata"] = qgo["userDefinedMetadata"]), qgo["modelInitializer"] != null && (qgj["modelInitializer"] = qgo["modelInitializer"]), qgo["initializerSignature"] != null && (qgj["initializerSignature"] = qgo["initializerSignature"]), qgo["trainingConfig"] != null && (qgj["trainingConfig"] = qgo["trainingConfig"]);
    }
    const qgR = this["LS"]["getItem"](this["keys"]["weightData"]);
    if (qgR == null) throw new Error("In local storage, the binary weight values of model '" + this["modelPath"] + "' are missing.");
    return qgj["weightData"] = SJ(qgR), qgj;
  }
};
tX["URL_SCHEME"] = "localstorage://";
var tG = (qgu) => qM()["getBool"]("IS_BROWSER") && !Array["isArray"](qgu) && qgu["startsWith"](tX["URL_SCHEME"]) ? tj(qgu["slice"](tX["URL_SCHEME"]["length"])) : null;
Fz["registerSaveRouter"](tG), Fz["registerLoadRouter"](tG);
function tj(qgu) {
  return new tX(qgu);
}
var tL = class {
  constructor() {
    k(qM()["getBool"]("IS_BROWSER"), () => "Current environment is not a web browser"), k(typeof window == "undefined" || typeof window["localStorage"] != "undefined", () => "Current browser does not appear to support localStorage"), this["LS"] = window["localStorage"];
  }
  async ["listModels"]() {
    const qgu = {}, qgj = tn + tq, qgL = tq + ts;
    for (let qgI = 0; qgI < this["LS"]["length"]; ++qgI) {
      const qgb = this["LS"]["key"](qgI);
      if (qgb["startsWith"](qgj) && qgb["endsWith"](qgL)) {
        const qgR = te(qgb);
        qgu[qgR] = JSON["parse"](this["LS"]["getItem"](qgb));
      }
    }
    return qgu;
  }
  async ["removeModel"](qgu) {
    qgu = tz(qgu);
    const qgj = tD(qgu);
    if (this["LS"]["getItem"](qgj["info"]) == null) throw new Error("Cannot find model at path '" + qgu + "'");
    const qgL = JSON["parse"](this["LS"]["getItem"](qgj["info"]));
    return tZ(qgj), qgL;
  }
};
var to = "model";
var tQ = ".json";
var tH = ".weights.bin";
function tK(qgu) {
  return new Promise((qgj) => setTimeout(qgj))["then"](qgu);
}
var tB = class _tB {
  constructor(qgu) {
    if (!qM()["getBool"]("IS_BROWSER")) throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");
    qgu["startsWith"](_tB["URL_SCHEME"]) && (qgu = qgu["slice"](_tB["URL_SCHEME"]["length"])), (qgu == null || qgu["length"] === 0) && (qgu = to), this["modelJsonFileName"] = qgu + tQ, this["weightDataFileName"] = qgu + tH;
  }
  async ["save"](qgu) {
    if (typeof document == "undefined") throw new Error("Browser downloads are not supported in this environment since `document` is not present");
    const qgj = fJ["join"](qgu["weightData"]), qgL = window["URL"]["createObjectURL"](new Blob([qgj], { "type": "application/octet-stream" }));
    if (qgu["modelTopology"] instanceof ArrayBuffer) throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");
    {
      const qgI = [{ "paths": ["./" + this["weightDataFileName"]], "weights": qgu["weightSpecs"] }], qgb = SU(qgu, qgI), qgR = window["URL"]["createObjectURL"](new Blob([JSON["stringify"](qgb)], { "type": "application/json" })), qgo = this["modelJsonAnchor"] == null ? document["createElement"]("a") : this["modelJsonAnchor"];
      if (qgo["download"] = this["modelJsonFileName"], qgo["href"] = qgR, await tK(() => qgo["dispatchEvent"](new MouseEvent("click"))), qgu["weightData"] != null) {
        const qgr = this["weightDataAnchor"] == null ? document["createElement"]("a") : this["weightDataAnchor"];
        qgr["download"] = this["weightDataFileName"], qgr["href"] = qgL, await tK(() => qgr["dispatchEvent"](new MouseEvent("click")));
      }
      return { "modelArtifactsInfo": FM(qgu) };
    }
  }
};
tB["URL_SCHEME"] = "downloads://";
var tV = class {
  constructor(qgu) {
    if (qgu == null || qgu["length"] < 1) throw new Error("When calling browserFiles, at least 1 file is required, but received " + qgu);
    this["jsonFile"] = qgu[0], this["weightsFiles"] = qgu["slice"](1);
  }
  async ["load"]() {
    return new Promise((qgu, qgj) => {
      const qgL = new FileReader();
      qgL["onload"] = (qgI) => {
        const qgb = JSON["parse"](qgI["target"]["result"]), qgR = qgb["modelTopology"];
        if (qgR == null) {
          qgj(new Error("modelTopology field is missing from file " + this["jsonFile"]["name"]));
          return;
        }
        if (qgb["weightsManifest"] == null) {
          qgj(new Error("weightManifest field is missing from file " + this["jsonFile"]["name"]));
          return;
        }
        if (this["weightsFiles"]["length"] === 0) {
          qgu({ "modelTopology": qgR });
          return;
        }
        const qgo = Fs(qgb, (qgr) => this["loadWeights"](qgr));
        qgu(qgo);
      }, qgL["onerror"] = (qgI) => qgj("Failed to read model topology and weights manifest JSON from file '" + this["jsonFile"]["name"] + "'. BrowserFiles supports loading Keras-style tf.Model artifacts only."), qgL["readAsText"](this["jsonFile"]);
    });
  }
  ["loadWeights"](qgu) {
    const qgj = [], qgL = [];
    for (const qgR of qgu) qgj["push"](...qgR["weights"]), qgL["push"](...qgR["paths"]);
    const qgI = this["checkManifestAndWeightFiles"](qgu), qgb = qgL["map"]((qgo) => this["loadWeightsFile"](qgo, qgI[qgo]));
    return Promise["all"](qgb)["then"]((qgo) => [qgj, qgo]);
  }
  ["loadWeightsFile"](qgu, qgj) {
    return new Promise((qgL, qgI) => {
      const qgb = new FileReader();
      qgb["onload"] = (qgR) => {
        const qgo = qgR["target"]["result"];
        qgL(qgo);
      }, qgb["onerror"] = (qgR) => qgI("Failed to weights data from file of path '" + qgu + "'."), qgb["readAsArrayBuffer"](qgj);
    });
  }
  ["checkManifestAndWeightFiles"](qgu) {
    const qgj = [], qgL = this["weightsFiles"]["map"]((qgb) => SP(qgb["name"])), qgI = {};
    for (const qgb of qgu) qgb["paths"]["forEach"]((qgR) => {
      const qgo = SP(qgR);
      if (qgj["indexOf"](qgo) !== -1) throw new Error("Duplicate file basename found in weights manifest: '" + qgo + "'");
      if (qgj["push"](qgo), qgL["indexOf"](qgo) === -1) throw new Error("Weight file with basename '" + qgo + "' is not provided.");
      qgI[qgR] = this["weightsFiles"][qgL["indexOf"](qgo)];
    });
    if (qgj["length"] !== this["weightsFiles"]["length"]) throw new Error("Mismatch in the number of files in weights manifest (" + qgj["length"] + ") and the number of weight files provided (" + this["weightsFiles"]["length"] + ").");
    return qgI;
  }
};
var tJ = (qgu) => qM()["getBool"]("IS_BROWSER") && !Array["isArray"](qgu) && qgu["startsWith"](tB["URL_SCHEME"]) ? tY(qgu["slice"](tB["URL_SCHEME"]["length"])) : null;
Fz["registerSaveRouter"](tJ);
function tY(qgu = "model") {
  return new tB(qgu);
}
function tP(qgu) {
  return new tV(qgu);
}
function tU(qgu, qgj, qgL, qgI) {
  qgo(qgu), qgL = qgL == null ? 0 : qgL, qgI = qgI == null ? 1 : qgI, qgr(qgL, qgI);
  let qgb = 0;
  const qgR = (qgQ) => (qgQ["then"]((qgd) => {
    const qgv = qgL + ++qgb / qgu["length"] * (qgI - qgL);
    return qgj(qgv), qgd;
  }), qgQ);
  function qgo(qgQ) {
    k(qgQ != null && Array["isArray"](qgQ) && qgQ["length"] > 0, () => "promises must be a none empty array");
  }
  function qgr(qgQ, qgd) {
    k(qgQ >= 0 && qgQ <= 1, () => "Progress fraction must be in range [0, 1], but got startFraction " + qgQ), k(qgd >= 0 && qgd <= 1, () => "Progress fraction must be in range [0, 1], but got endFraction " + qgd), k(qgd >= qgQ, () => "startFraction must be no more than endFraction, but got startFraction " + qgQ + " and endFraction " + qgd);
  }
  return Promise["all"](qgu["map"](qgR));
}
async function kq(qgu, qgj) {
  qgj == null && (qgj = {});
  const qgL = qgj["fetchFunc"] == null ? qM()["platform"]["fetch"] : qgj["fetchFunc"], qgI = qgu["map"]((qgR) => qgL(qgR, qgj["requestInit"], { "isBinary": true })), qgb = (qgj["onProgress"] == null ? await Promise["all"](qgI) : await tU(qgI, qgj["onProgress"], 0, 0.5))["map"]((qgR) => qgR["arrayBuffer"]());
  return qgj["onProgress"] == null ? await Promise["all"](qgb) : await tU(qgb, qgj["onProgress"], 0.5, 1);
}
function ks(qgu, qgj) {
  var qgL;
  const qgI = qgj["fetchFunc"] == null ? qM()["platform"]["fetch"] : qgj["fetchFunc"];
  let qgb = 0, qgR;
  return (qgL = qgj["onProgress"]) === null || qgL === void 0 || qgL["call"](qgj, 0), new ReadableStream({ "pull": async (qgo) => {
    for (var qgr; qgb < qgu["length"]; ) {
      qgR || (qgR = (await qgI(qgu[qgb], qgj["requestInit"], { "isBinary": true }))["body"]["getReader"]());
      const { done: qgQ, value: qgd } = await qgR["read"]();
      if (qgQ) {
        qgb++, qgR = void 0, (qgr = qgj["onProgress"]) === null || qgr === void 0 || qgr["call"](qgj, qgb / qgu["length"]);
        continue;
      }
      qgo["enqueue"](qgd);
      return;
    }
    qgo["close"]();
  } });
}
async function kM(qgu, qgj = "", qgL, qgI) {
  return kF((qgb) => kq(qgb, { "requestInit": qgI }))(qgu, qgj, qgL);
}
function kF(qgu) {
  return async (qgj, qgL = "", qgI) => {
    const qgb = qgj["map"](() => false), qgR = {}, qgo = qgI != null ? qgI["map"](() => false) : [], qgr = [];
    if (qgj["forEach"]((qgH, qgA) => {
      let qgh = 0;
      qgH["weights"]["forEach"]((qgT) => {
        const qgK = "quantization" in qgT ? qgT["quantization"]["dtype"] : qgT["dtype"], qgB = fV[qgK] * i2(qgT["shape"]), qgV = () => {
          qgb[qgA] = true, qgR[qgA] == null && (qgR[qgA] = []), qgR[qgA]["push"]({ "manifestEntry": qgT, "groupOffset": qgh, "sizeBytes": qgB });
        };
        qgI != null ? qgI["forEach"]((qgJ, qgY) => {
          qgJ === qgT["name"] && (qgV(), qgo[qgY] = true);
        }) : qgV(), qgr["push"](qgT["name"]), qgh += qgB;
      });
    }), !qgo["every"]((qgH) => qgH)) {
      const qgH = qgI["filter"]((qgA, qgh) => !qgo[qgh]);
      throw new Error("Could not find weights in manifest with names: " + qgH["join"](", ") + ". \nManifest JSON has weights with names: " + qgr["join"](", ") + ".");
    }
    const qgQ = qgb["reduce"]((qgA, qgh, qgT) => (qgh && qgA["push"](qgT), qgA), []), qgd = [];
    qgQ["forEach"]((qgA) => {
      qgj[qgA]["paths"]["forEach"]((qgh) => {
        const qgT = qgL + (qgL["endsWith"]("/") ? "" : "/") + qgh;
        qgd["push"](qgT);
      });
    });
    const qgv = await qgu(qgd), qgy = {};
    let qgl = 0;
    return qgQ["forEach"]((qgA) => {
      const qgh = qgj[qgA]["paths"]["length"], qgT = new fJ(qgv["slice"](qgl, qgl + qgh));
      qgR[qgA]["forEach"]((qgK) => {
        const qgB = qgT["slice"](qgK["groupOffset"], qgK["groupOffset"] + qgK["sizeBytes"]), qgV = SX(qgB, [qgK["manifestEntry"]]);
        for (const qgJ in qgV) qgy[qgJ] = qgV[qgJ];
      }), qgl += qgh;
    }), qgy;
  };
}
var kt = "application/octet-stream";
var kW = "application/json";
var kD = class {
  constructor(qgu, qgj) {
    if (this["DEFAULT_METHOD"] = "POST", qgj == null && (qgj = {}), this["weightPathPrefix"] = qgj["weightPathPrefix"], this["weightUrlConverter"] = qgj["weightUrlConverter"], qgj["fetchFunc"] != null ? (k(typeof qgj["fetchFunc"] == "function", () => "Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"), this["fetch"] = qgj["fetchFunc"]) : this["fetch"] = qM()["platform"]["fetch"], k(qgu != null && qgu["length"] > 0, () => "URL path for http must not be null, undefined or empty."), Array["isArray"](qgu) && k(qgu["length"] === 2, () => "URL paths for http must have a length of 2, (actual length is " + qgu["length"] + ")."), this["path"] = qgu, qgj["requestInit"] != null && qgj["requestInit"]["body"] != null) throw new Error("requestInit is expected to have no pre-existing body, but has one.");
    this["requestInit"] = qgj["requestInit"] || {}, this["loadOptions"] = qgj;
  }
  async ["save"](qgu) {
    if (qgu["modelTopology"] instanceof ArrayBuffer) throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");
    const qgj = Object["assign"]({ "method": this["DEFAULT_METHOD"] }, this["requestInit"]);
    qgj["body"] = new FormData();
    const qgL = [{ "paths": ["./model.weights.bin"], "weights": qgu["weightSpecs"] }], qgI = SU(qgu, qgL);
    if (qgj["body"]["append"]("model.json", new Blob([JSON["stringify"](qgI)], { "type": kW }), "model.json"), qgu["weightData"] != null) {
      const qgR = fJ["join"](qgu["weightData"]);
      qgj["body"]["append"]("model.weights.bin", new Blob([qgR], { "type": kt }), "model.weights.bin");
    }
    const qgb = await this["fetch"](this["path"], qgj);
    if (qgb["ok"]) return { "modelArtifactsInfo": FM(qgu), "responses": [qgb] };
    throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status " + qgb["status"] + ".");
  }
  async ["loadModelJSON"]() {
    const qgu = await this["fetch"](this["path"], this["requestInit"]);
    if (!qgu["ok"]) throw new Error("Request to " + this["path"] + " failed with status code " + qgu["status"] + ". Please verify this URL points to the model JSON of the model to load.");
    let qgj;
    try {
      qgj = await qgu["json"]();
    } catch (qgb) {
      let qgR = "Failed to parse model JSON of response from " + this["path"] + ".";
      throw this["path"]["endsWith"](".pb") ? qgR += " Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository." : qgR += " Please make sure the server is serving valid JSON for this request.", new Error(qgR);
    }
    const qgL = qgj["modelTopology"], qgI = qgj["weightsManifest"];
    if (qgL == null && qgI == null) throw new Error("The JSON from HTTP path " + this["path"] + " contains neither model topology or manifest for weights.");
    return qgj;
  }
  async ["load"]() {
    if (this["loadOptions"]["streamWeights"]) return this["loadStream"]();
    const qgu = await this["loadModelJSON"]();
    return Fs(qgu, (qgj) => this["loadWeights"](qgj));
  }
  async ["loadStream"]() {
    const qgu = await this["loadModelJSON"](), qgj = await this["getWeightUrls"](qgu["weightsManifest"]), qgL = FF(qgu["weightsManifest"]), qgI = () => ks(qgj, this["loadOptions"]);
    return Object["assign"](Object["assign"]({}, qgu), { "weightSpecs": qgL, "getWeightStream": qgI });
  }
  async ["getWeightUrls"](qgu) {
    const qgj = Array["isArray"](this["path"]) ? this["path"][1] : this["path"], [qgL, qgI] = kZ(qgj), qgb = this["weightPathPrefix"] || qgL, qgR = [], qgo = [];
    for (const qgr of qgu) for (const qgQ of qgr["paths"]) this["weightUrlConverter"] != null ? qgo["push"](this["weightUrlConverter"](qgQ)) : qgR["push"](qgb + qgQ + qgI);
    return this["weightUrlConverter"] && qgR["push"](...await Promise["all"](qgo)), qgR;
  }
  async ["loadWeights"](qgu) {
    const qgj = await this["getWeightUrls"](qgu), qgL = FF(qgu), qgI = await kq(qgj, this["loadOptions"]);
    return [qgL, qgI];
  }
};
kD["URL_SCHEME_REGEX"] = /^https?:\/\//;
function kZ(qgu) {
  const qgj = qgu["lastIndexOf"]("/"), qgL = qgu["lastIndexOf"]("?"), qgI = qgu["substring"](0, qgj), qgb = qgL > qgj ? qgu["substring"](qgL) : "";
  return [qgI + "/", qgb];
}
function ke(qgu) {
  return qgu["match"](kD["URL_SCHEME_REGEX"]) != null;
}
var kz = (qgu, qgj) => {
  if (typeof fetch == "undefined" && (qgj == null || qgj["fetchFunc"] == null)) return null;
  {
    let qgL = true;
    if (Array["isArray"](qgu) ? qgL = qgu["every"]((qgI) => ke(qgI)) : qgL = ke(qgu), qgL) return kc(qgu, qgj);
  }
  return null;
};
Fz["registerSaveRouter"](kz), Fz["registerLoadRouter"](kz);
function kc(qgu, qgj) {
  return new kD(qgu, qgj);
}
function kX(qgu, qgj) {
  return kc(qgu, qgj);
}
var kG = class {
  constructor(qgu) {
    this["modelArtifacts"] = qgu;
  }
  ["load"]() {
    return this["modelArtifacts"];
  }
};
var ku = class {
  constructor(qgu) {
    this["saveHandler"] = qgu;
  }
  ["save"](qgu) {
    return this["saveHandler"](qgu);
  }
};
var kj = class {
  constructor(qgu) {
    qgu["load"] && (this["load"] = () => Promise["resolve"](qgu["load"]())), qgu["save"] && (this["save"] = (qgj) => Promise["resolve"](qgu["save"](qgj)));
  }
};
function kL(qgu, qgj, qgL, qgI) {
  const qgb = arguments;
  return new kj(kR(...qgb));
}
function kR(qgu, qgj, qgL, qgI) {
  return arguments["length"] === 1 ? qgu["modelTopology"] != null || qgu["weightSpecs"] != null ? new kG(qgu) : (console["warn"]("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kG({ "modelTopology": qgu })) : (console["warn"]("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."), new kG({ "modelTopology": qgu, "weightSpecs": qgj, "weightData": qgL, "trainingConfig": qgI }));
}
function kr(qgu) {
  return new ku(qgu);
}
function kQ(qgu) {
  return new ku(qgu);
}
var kH = "://";
var kK = class _kK {
  constructor() {
    this["managers"] = {};
  }
  static ["getInstance"]() {
    return _kK["instance"] == null && (_kK["instance"] = new _kK()), _kK["instance"];
  }
  static ["registerManager"](qgu, qgj) {
    k(qgu != null, () => "scheme must not be undefined or null."), qgu["endsWith"](kH) && (qgu = qgu["slice"](0, qgu["indexOf"](kH))), k(qgu["length"] > 0, () => "scheme must not be an empty string.");
    const qgL = _kK["getInstance"]();
    k(qgL["managers"][qgu] == null, () => "A model store manager is already registered for scheme '" + qgu + "'."), qgL["managers"][qgu] = qgj;
  }
  static ["getManager"](qgu) {
    const qgj = _kK["getInstance"]()["managers"][qgu];
    if (qgj == null) throw new Error("Cannot find model manager for scheme '" + qgu + "'");
    return qgj;
  }
  static ["getSchemes"]() {
    return Object["keys"](_kK["getInstance"]()["managers"]);
  }
};
function kB(qgu) {
  if (qgu["indexOf"](kH) === -1) throw new Error("The url string provided does not contain a scheme. Supported schemes are: " + kK["getSchemes"]()["join"](","));
  return { "scheme": qgu["split"](kH)[0], "path": qgu["split"](kH)[1] };
}
async function kV(qgu, qgj, qgL = false) {
  k(qgu !== qgj, () => "Old path and new path are the same: '" + qgu + "'");
  const qgI = Fz["getLoadHandlers"](qgu);
  k(qgI["length"] > 0, () => "Copying failed because no load handler is found for source URL " + qgu + "."), k(qgI["length"] < 2, () => "Copying failed because more than one (" + qgI["length"] + ") load handlers for source URL " + qgu + ".");
  const qgb = qgI[0], qgR = Fz["getSaveHandlers"](qgj);
  k(qgR["length"] > 0, () => "Copying failed because no save handler is found for destination URL " + qgj + "."), k(qgR["length"] < 2, () => "Copying failed because more than one (" + qgI["length"] + ") save handlers for destination URL " + qgj + ".");
  const qgo = qgR[0], qgr = kB(qgu)["scheme"], qgQ = kB(qgu)["path"], qgd = qgr === kB(qgu)["scheme"], qgv = await qgb["load"]();
  qgL && qgd && await kK["getManager"](qgr)["removeModel"](qgQ);
  const qgy = await qgo["save"](qgv);
  return qgL && !qgd && await kK["getManager"](qgr)["removeModel"](qgQ), qgy["modelArtifactsInfo"];
}
async function kJ() {
  const qgu = kK["getSchemes"](), qgj = {};
  for (const qgL of qgu) {
    const qgI = await kK["getManager"](qgL)["listModels"]();
    for (const qgb in qgI) {
      const qgR = qgL + kH + qgb;
      qgj[qgR] = qgI[qgb];
    }
  }
  return qgj;
}
async function kY(qgu) {
  const qgj = kB(qgu);
  return kK["getManager"](qgj["scheme"])["removeModel"](qgj["path"]);
}
async function kP(qgu, qgj) {
  return kV(qgu, qgj, false);
}
async function kU(qgu, qgj) {
  return kV(qgu, qgj, true);
}
var Oq = Object["freeze"]({ "__proto__": null, "CompositeArrayBuffer": fJ, "browserFiles": tP, "browserHTTPRequest": kX, "concatenateArrayBuffers": SY, "copyModel": kP, "decodeWeights": SX, "decodeWeightsStream": SQ, "encodeWeights": Sz, "fromMemory": kL, "fromMemorySync": kR, "getLoadHandlers": Fj, "getModelArtifactsForJSON": Fs, "getModelArtifactsForJSONSync": Fq, "getModelArtifactsInfoForJSON": FM, "getSaveHandlers": Fu, "getWeightSpecs": FF, "http": kc, "isHTTPScheme": ke, "listModels": kJ, "loadWeights": kM, "moveModel": kU, "registerLoadRouter": FG, "registerSaveRouter": FX, "removeModel": kY, "weightsLoaderFactory": kF, "withSaveHandler": kr, "withSaveHandlerSync": kQ });
function Os(qgu, qgj) {
  const qgL = fG(qgu, "x", "cast");
  if (!u(qgj)) throw new Error("Failed to cast to unknown dtype " + qgj);
  if (qgj === "string" && qgL["dtype"] !== "string" || qgj !== "string" && qgL["dtype"] === "string") throw new Error("Only strings can be casted to strings");
  const qgI = { "x": qgL }, qgb = { "dtype": qgj };
  return fM["runKernel"](qH, qgI, qgb);
}
var OM = fL({ "cast_": Os });
function OF(qgu, qgj, qgL = false, qgI = false) {
  let qgb = fG(qgu, "a", "matMul"), qgR = fG(qgj, "b", "matMul");
  [qgb, qgR] = MK(qgb, qgR);
  const qgo = { "a": qgb, "b": qgR }, qgr = { "transposeA": qgL, "transposeB": qgI };
  return fM["runKernel"](qo, qgo, qgr);
}
var OW = fL({ "matMul_": OF });
function OD(qgu) {
  const qgj = { "input": fG(qgu, "input", "imag") };
  return fM["runKernel"](nQ, qgj);
}
var OZ = fL({ "imag_": OD });
function Oe(qgu) {
  const qgj = { "x": fG(qgu, "x", "neg") };
  return fM["runKernel"](pt, qgj);
}
var Oz = fL({ "neg_": Oe });
function Oc(qgu) {
  const qgj = { "input": fG(qgu, "input", "real") };
  return fM["runKernel"](pu, qgj);
}
var OX = fL({ "real_": Oc });
function OG(qgu, qgj, qgL) {
  const qgI = fG(qgu, "x", "transpose");
  if (qgj == null && (qgj = qgI["shape"]["map"]((qgo, qgr) => qgr)["reverse"]()), k(qgI["rank"] === qgj["length"], () => "Error in transpose: rank of input " + qgI["rank"] + " must match length of perm " + qgj + "."), qgj["forEach"]((qgo) => {
    k(qgo >= 0 && qgo < qgI["rank"], () => "All entries in 'perm' must be between 0 and " + (qgI["rank"] - 1) + " but got " + qgj);
  }), qgI["rank"] <= 1) return qgI["clone"]();
  const qgb = { "x": qgI }, qgR = { "perm": qgj };
  return qgI["dtype"] === "complex64" ? Sq(() => {
    let qgo = OX(qgI), qgr = OZ(qgI);
    return qgo = fM["runKernel"](gD, { "x": qgo }, qgR), qgr = fM["runKernel"](gD, { "x": qgr }, qgR), qgL && (qgr = Oz(qgr)), fH(qgo, qgr);
  }) : fM["runKernel"](gD, qgb, qgR);
}
var Ou = fL({ "transpose_": OG });
function Oj(qgu, qgj) {
  const qgL = qgu["length"], qgI = [];
  for (let qgb = 0; qgb < qgL; qgb++) {
    const qgR = qgL - 1 - qgb, qgo = qgu[qgR] || 1;
    (qgj[qgj["length"] - 1 - qgb] || 1) > 1 && qgo === 1 && qgI["unshift"](qgR);
  }
  return qgI;
}
function OL(qgu, qgj) {
  const qgL = [];
  for (let qgI = 0; qgI < qgj["length"]; qgI++) {
    const qgb = qgu[qgu["length"] - qgI - 1], qgR = qgj["length"] - qgI - 1, qgo = qgj[qgR];
    (qgb == null || qgb === 1 && qgo > 1) && qgL["unshift"](qgR);
  }
  return qgL;
}
function OR(qgu, qgj) {
  const qgL = Math["max"](qgu["length"], qgj["length"]), qgI = new Array(qgL);
  for (let qgb = 0; qgb < qgL; qgb++) {
    let qgR = qgu[qgu["length"] - qgb - 1];
    qgR == null && (qgR = 1);
    let qgo = qgj[qgj["length"] - qgb - 1];
    if (qgo == null && (qgo = 1), qgR === 1) qgI[qgL - qgb - 1] = qgo;
    else {
      if (qgo === 1) qgI[qgL - qgb - 1] = qgR;
      else {
        if (qgR !== qgo) {
          const qgr = "Operands could not be broadcast together with shapes " + qgu + " and " + qgj + ".";
          throw Error(qgr);
        } else qgI[qgL - qgb - 1] = qgR;
      }
    }
  }
  return qgI;
}
function Or(qgu, qgj, qgL) {
  if (W(qgu), qgj != null && qgj["length"] !== 3) throw new Error("tensor3d() requires shape to have three numbers");
  const qgI = fZ(qgu, qgL);
  if (qgI["length"] !== 3 && qgI["length"] !== 1) throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");
  if (qgI["length"] === 1 && qgj == null) throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");
  return fK(qgu, qgj, qgI, qgL);
}
var OQ;
function OH(qgu, qgj = 3) {
  if (qgj > 4) throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");
  if (qgu == null) throw new Error("pixels passed to tf.browser.fromPixels() can not be null");
  let qgL = false, qgI = false, qgb = false, qgR = false, qgo = false, qgr = false;
  if (qgu["data"] instanceof Uint8Array) qgL = true;
  else {
    if (typeof ImageData != "undefined" && qgu instanceof ImageData) qgI = true;
    else {
      if (typeof HTMLVideoElement != "undefined" && qgu instanceof HTMLVideoElement) qgb = true;
      else {
        if (typeof HTMLImageElement != "undefined" && qgu instanceof HTMLImageElement) qgR = true;
        else {
          if (qgu["getContext"] != null) qgo = true;
          else {
            if (typeof ImageBitmap != "undefined" && qgu instanceof ImageBitmap) qgr = true;
            else throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was " + qgu["constructor"]["name"]);
          }
        }
      }
    }
  }
  if (gB(gz, fM["backendName"]) != null) {
    const qgl = { "pixels": qgu }, qgH = { "numChannels": qgj };
    return fM["runKernel"](gz, qgl, qgH);
  }
  const [qgQ, qgd] = qgb ? [qgu["videoWidth"], qgu["videoHeight"]] : [qgu["width"], qgu["height"]];
  let qgv;
  if (qgo) qgv = qgu["getContext"]("2d")["getImageData"](0, 0, qgQ, qgd)["data"];
  else {
    if (qgI || qgL) qgv = qgu["data"];
    else {
      if (qgR || qgb || qgr) {
        if (OQ == null) {
          if (typeof document == "undefined") {
            if (typeof OffscreenCanvas != "undefined" && typeof OffscreenCanvasRenderingContext2D != "undefined") OQ = new OffscreenCanvas(1, 1)["getContext"]("2d");
            else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");
          } else OQ = document["createElement"]("canvas")["getContext"]("2d", { "willReadFrequently": true });
        }
        OQ["canvas"]["width"] = qgQ, OQ["canvas"]["height"] = qgd, OQ["drawImage"](qgu, 0, 0, qgQ, qgd), qgv = OQ["getImageData"](0, 0, qgQ, qgd)["data"];
      }
    }
  }
  let qgy;
  if (qgj === 4) qgy = new Int32Array(qgv);
  else {
    const qgA = qgQ * qgd;
    qgy = new Int32Array(qgA * qgj);
    for (let qgh = 0; qgh < qgA; qgh++) for (let qgT = 0; qgT < qgj; ++qgT) qgy[qgh * qgj + qgT] = qgv[qgh * 4 + qgT];
  }
  return Or(qgy, [qgd, qgQ, qgj], "int32");
}
var OK = fL({ "fromPixels_": OH });
function OB(qgu, qgj) {
  const qgL = qgu["shape"]["length"], qgI = qgj["shape"]["length"];
  if (qgL < 1) throw new Error("tf.gatherND() expects the input to be rank 1 or higher, but the rank was " + qgL + ".");
  if (qgI < 1) throw new Error("tf.gatherND() expects the indices to be rank 1 or higher, but the rank was " + qgI + ".");
  if (qgj["dtype"] !== "int32") throw new Error("tf.gatherND() expects the indices to be int32 type, but the dtype was " + qgj["dtype"] + ".");
  if (qgj["shape"][qgI - 1] > qgL) throw new Error("index innermost dimension length must be <= tensor rank; saw: " + qgj["shape"][qgI - 1] + " vs. " + qgL);
  if (i2(qgu["shape"]) === 0) throw new Error("Requested more than 0 entries, but input is empty. Input shape: " + qgu["shape"] + ".");
  const qgb = qgj["shape"], qgR = qgb[qgb["length"] - 1];
  let qgo = 1;
  for (let qgy = 0; qgy < qgb["length"] - 1; ++qgy) qgo *= qgb[qgy];
  const qgr = qgu["shape"], qgQ = qgb["slice"]();
  qgQ["pop"]();
  let qgd = 1;
  for (let qgl = qgR; qgl < qgL; ++qgl) qgd *= qgr[qgl], qgQ["push"](qgr[qgl]);
  const qgv = [...y(qgu["shape"])["map"]((qgH) => qgH / qgd), 1]["slice"](0, qgR);
  return [qgQ, qgo, qgd, qgv];
}
function OV(qgu, qgj, qgL) {
  const qgI = qgj["rank"] > 1 ? qgj["shape"][qgj["rank"] - 1] : 1, qgb = qgj["rank"] > 1 ? qgj["rank"] - 1 : 1, qgR = "Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: " + qgL["shape"] + ", indices.shape: " + qgj["shape"] + ", shape: " + qgu + ", sliceDim: " + qgI + ", and batchDim: " + qgb + ".";
  if (qgL["rank"] < qgb) throw new Error(qgR + (" update.rank < " + qgb + ". "));
  if (qgu["length"] < qgI + (qgL["rank"] - qgb)) throw new Error(qgR + (" Output shape length < " + (qgI + (qgL["rank"] - qgb))));
  if (qgL["rank"] !== qgb + qgu["length"] - qgI) throw new Error(qgR + (" update.rank != " + (qgb + qgu["length"] - qgI)));
  for (let qgo = 0; qgo < qgb; ++qgo) if (qgL["shape"][qgo] !== qgj["shape"][qgo]) throw new Error(qgR + (" updates.shape[" + qgo + "] (" + qgL["shape"][qgo] + ") != indices.shape[" + qgo + "] (" + qgj["shape"][qgo] + ")."));
  for (let qgr = 0; qgr < qgL["rank"] - qgb; ++qgr) if (qgL["shape"][qgr + qgb] !== qgu[qgr + qgI]) throw new Error(qgR + (" updates.shape[" + (qgr + qgb) + "] (" + qgL["shape"][qgr + qgb] + ") != shape[" + (qgr + qgb) + "] (" + qgu[qgr + qgb] + ")"));
}
function OJ(qgu, qgj, qgL) {
  if (qgj["rank"] < 1) throw new Error("tf.scatterND() expects the indices to be rank 1 or higher, but the rank was " + qgj["rank"] + ".");
  if (qgu["rank"] < 1) throw new Error("tf.scatterND() expects the updates to be rank 1 or higher, but the rank was " + qgu["rank"] + ".");
  if (qgj["dtype"] !== "int32") throw new Error("The dtype of 'indices' should be int32, but got dtype: " + qgj["dtype"]);
  if (qgL["length"] < 1) throw new Error("Output rank must be greater or equal to 1, but got shape: " + qgL);
  if (qgL["length"] === 0) {
    if (qgj["size"] === 0) throw new Error("Indices specified for empty output. indices shape: " + qgj["shape"]);
    if (qgu["size"] === 0) throw new Error("Updates specified for empty output. updates shape: " + qgu["shape"]);
  }
  OV(qgL, qgj, qgu);
}
function OY(qgu, qgj, qgL) {
  const qgI = qgj["shape"]["length"], qgb = qgI > 1 ? qgj["shape"][qgI - 1] : 1, qgR = qgL["length"];
  let qgo = 1;
  for (let qgy = qgb; qgy < qgR; ++qgy) qgo *= qgL[qgy];
  const qgr = qgb < 1 ? 1 : qgb, qgQ = i2(qgj["shape"]) / qgr, qgd = [...y(qgL["slice"](0, qgb)), 1], qgv = i2(qgL);
  return { "sliceRank": qgb, "numUpdates": qgQ, "sliceSize": qgo, "strides": qgd, "outputSize": qgv };
}
var OP = -2;
var OU = -1;
function Wq(qgu, qgj, qgL) {
  const qgI = qgu["shape"]["length"];
  k(qgI === qgj["length"], () => "Error in slice" + qgI + "D: Length of begin " + qgj + " must match the rank of the array (" + qgI + ")."), k(qgI === qgL["length"], () => "Error in slice" + qgI + "D: Length of size " + qgL + " must match the rank of the array (" + qgI + ").");
  for (let qgb = 0; qgb < qgI; ++qgb) k(qgj[qgb] + qgL[qgb] <= qgu["shape"][qgb], () => "Error in slice" + qgI + "D: begin[" + qgb + "] + size[" + qgb + "] (" + (qgj[qgb] + qgL[qgb]) + ") would overflow input.shape[" + qgb + "] (" + qgu["shape"][qgb] + ")");
}
function WM(qgu) {
  const qgj = [];
  let qgL = 0;
  for (; qgu > 0; ) qgu & 1 && qgj["push"](qgL), qgu /= 2, qgL++;
  return qgj;
}
function WF(qgu, qgj, qgL) {
  const qgI = [];
  for (let qgb = 0; qgb < qgu["length"]; qgb++) qgI[qgb] = Math["ceil"]((qgj[qgb] - qgu[qgb]) / qgL[qgb]);
  return qgI;
}
function Wt(qgu, qgj, qgL, qgI) {
  const qgb = [...qgu];
  for (let qgR = qgb["length"]; qgR < qgI["length"]; qgR++) qgb["push"](1);
  for (let qgo = 0; qgo < qgL; qgo++) qgo === 0 ? qgb[qgj] = 1 : (qgb["splice"](qgj, 0, 1), qgb["pop"]());
  return qgb;
}
function WW(qgu, qgj, qgL) {
  return qgL <= qgu ? qgL : qgL - (qgj - 1);
}
function WD(qgu, qgj) {
  const qgL = [];
  for (let qgI = 0; qgI < qgu; qgI++) qgL["push"](qgj + qgI);
  return qgL;
}
function WZ(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ) {
  const qgd = qgu["length"];
  let qgv = new Array(qgd), qgy = new Array(qgd), qgl = new Array(qgd);
  if (qgj["length"] && qgL > 0) {
    const qgH = qgj[0], qgA = qgL + 1;
    qgv = We(qgo, qgH, qgA, qgI, qgu), qgy = Wz(qgr, qgH, qgA, qgb, qgu), qgl = Wt(qgR, qgH, qgA, qgu);
  } else {
    for (let qgh = 0; qgh < qgd; qgh++) qgv[qgh] = WG(qgo, qgI, qgR, qgu, qgh, qgQ), qgy[qgh] = Wj(qgr, qgb, qgR, qgu, qgh, qgQ), qgl[qgh] = WX(qgR, qgh, qgQ);
  }
  return { "begin": qgv, "end": qgy, "strides": qgl };
}
function We(qgu, qgj, qgL, qgI, qgb) {
  const qgR = [...qgb], qgo = WD(qgL, qgj);
  for (let qgr = 0; qgr < qgR["length"]; qgr++) if (qgo["indexOf"](qgr) > -1) qgR[qgr] = 0;
  else {
    const qgQ = WW(qgj, qgL, qgr);
    let qgd = qgI[qgQ];
    qgu & 1 << qgQ && (qgd = 0), qgR[qgr] = qgd;
  }
  return qgR;
}
function Wz(qgu, qgj, qgL, qgI, qgb) {
  const qgR = [...qgb], qgo = WD(qgL, qgj);
  for (let qgr = 0; qgr < qgR["length"]; qgr++) if (qgo["indexOf"](qgr) > -1) qgR[qgr] = Number["MAX_SAFE_INTEGER"];
  else {
    const qgQ = WW(qgj, qgL, qgr);
    let qgd = qgI[qgQ];
    qgu & 1 << qgQ && (qgd = Number["MAX_SAFE_INTEGER"]), qgR[qgr] = qgd;
  }
  for (let qgv = 0; qgv < qgR["length"]; qgv++) {
    const qgy = qgb[qgv];
    qgR[qgv] < 0 && (qgR[qgv] += qgy), qgR[qgv] = E(0, qgR[qgv], qgb[qgv]);
  }
  return qgR;
}
function WX(qgu, qgj, qgL) {
  let qgI = qgu[qgj];
  return (qgL & 1 << qgj || qgI == null) && (qgI = 1), qgI;
}
function WG(qgu, qgj, qgL, qgI, qgb, qgR) {
  let qgo = qgj[qgb];
  const qgr = qgL[qgb] || 1;
  (qgu & 1 << qgb || qgR & 1 << qgb || qgo == null) && (qgr > 0 ? qgo = Number["MIN_SAFE_INTEGER"] : qgo = Number["MAX_SAFE_INTEGER"]);
  const qgQ = qgI[qgb];
  return qgo < 0 && (qgo += qgQ), qgo = E(0, qgo, qgQ - 1), qgo;
}
function Wj(qgu, qgj, qgL, qgI, qgb, qgR) {
  let qgo = qgj[qgb];
  const qgr = qgL[qgb] || 1;
  (qgu & 1 << qgb || qgR & 1 << qgb || qgo == null) && (qgr > 0 ? qgo = Number["MAX_SAFE_INTEGER"] : qgo = Number["MIN_SAFE_INTEGER"]);
  const qgQ = qgI[qgb];
  return qgo < 0 && (qgo += qgQ), qgr > 0 ? qgo = E(0, qgo, qgQ) : qgo = E(-1, qgo, qgQ - 1), qgo;
}
function WL(qgu, qgj, qgL) {
  let qgI = qgL["length"];
  for (let qgb = 0; qgb < qgL["length"]; qgb++) if (qgL[qgb] > 1) {
    qgI = qgb;
    break;
  }
  for (let qgR = qgI + 1; qgR < qgL["length"]; qgR++) if (qgj[qgR] > 0 || qgL[qgR] !== qgu[qgR]) return false;
  return true;
}
function WR(qgu, qgj) {
  let qgL = qgu["length"] > 0 ? qgu[qgu["length"] - 1] : 1;
  for (let qgI = 0; qgI < qgu["length"] - 1; qgI++) qgL += qgu[qgI] * qgj[qgI];
  return qgL;
}
function WQ(qgu, qgj, qgL) {
  let qgI;
  const qgb = qgu["shape"]["length"];
  typeof qgj == "number" ? qgI = [qgj, ...new Array(qgb - 1)["fill"](0)] : qgj["length"] < qgb ? qgI = qgj["concat"](new Array(qgb - qgj["length"])["fill"](0)) : qgI = qgj["slice"](), qgI["forEach"]((qgo) => {
    k(qgo !== -1, () => "slice() does not support negative begin indexing.");
  });
  let qgR;
  return qgL == null ? qgR = new Array(qgb)["fill"](-1) : typeof qgL == "number" ? qgR = [qgL, ...new Array(qgb - 1)["fill"](-1)] : qgL["length"] < qgb ? qgR = qgL["concat"](new Array(qgb - qgL["length"])["fill"](-1)) : qgR = qgL, qgR = qgR["map"]((qgo, qgr) => qgo >= 0 ? qgo : (k(qgo === -1, () => "Negative size values should be exactly -1 but got " + qgo + " for the slice() size at index " + qgr + "."), qgu["shape"][qgr] - qgI[qgr])), [qgI, qgR];
}
function WH(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ) {
  let qgd;
  if (qgI == null ? (qgd = new Array(qgj["length"]), qgd["fill"](1)) : qgd = qgI, qgo != null && (qgo & qgo - 1) !== 0) throw new Error("Multiple ellipses in slice is not allowed.");
  let qgv = false;
  const qgy = { "dims": qgd["length"], "numAddAxisAfterEllipsis": 0, "begin": qgj["slice"](), "end": qgL["slice"](), "strides": qgd["slice"](), "beginMask": qgb, "endMask": qgR, "ellipsisMask": qgo, "newAxisMask": qgr, "shrinkAxisMask": qgQ };
  for (let qgB = 0; qgB < qgy["dims"]; qgB++) qgv && (1 << qgB & qgr) !== 0 && qgy["numAddAxisAfterEllipsis"]++, 1 << qgB & qgo && (qgv = true);
  qgv || (qgy["ellipsisMask"] |= 1 << qgy["dims"], qgy["dims"]++);
  const qgl = { "dims": qgu["length"], "beginMask": 0, "endMask": 0, "beginValid": false, "endValid": false };
  WK(qgy, qgl);
  let qgH = true, qgA = true, qgh = true;
  const qgT = [], qgK = [];
  for (let qgV = 0; qgV < qgu["length"]; ++qgV) {
    if (qgl["strides"][qgV] === 0) throw Error("strides[" + qgV + "] must be non-zero");
    const qgJ = !!(qgl["shrinkAxisMask"] & 1 << qgV), qgY = qgu[qgV];
    if (qgY === -1) {
      qgT["push"](qgJ ? 1 : -1);
      continue;
    }
    const qgP = [qgl["beginMask"] & 1 << qgV, qgl["endMask"] & 1 << qgV], qgU = [qgl["strides"][qgV] > 0 ? 0 : -1, qgl["strides"][qgV] > 0 ? qgY : qgY - 1];
    if (qgJ && qgl["strides"][qgV] <= 0) throw Error("only stride 1 allowed on non-range indexing.");
    qgh = qgh && qgl["strides"][qgV] === 1;
    const qx0 = !!(qgl["beginMask"] & 1 << qgV && qgl["endMask"] & 1 << qgV);
    if (qgl["beginValid"] && qgl["endValid"]) {
      if (qgJ) {
        const qx4 = qgl["begin"][qgV] < 0 ? qgY + qgl["begin"][qgV] : qgl["begin"][qgV];
        if (qgl["begin"][qgV] = qx4, qgl["end"][qgV] = qgl["begin"][qgV] + 1, qx4 < 0 || qx4 >= qgY) throw Error("slice index " + qgl["begin"][qgV] + " of dimension " + qgV + " out of bounds.");
      } else qgl["begin"][qgV] = WB(qgl["begin"][qgV], 0, qgl["strides"][qgV], qgY, qgP, qgU), qgl["end"][qgV] = WB(qgl["end"][qgV], 1, qgl["strides"][qgV], qgY, qgP, qgU);
      const qx3 = qgl["strides"][qgV] === 1 && qgl["begin"][qgV] === 0 && qgl["end"][qgV] === qgY;
      qgH = qgH && qx3, qgA = qgA && (qgV === 0 && qgl["strides"][qgV] === 1 || qx3);
    } else qgH = qgH && qgl["strides"][qgV] === 1 && qx0, qgA = qgA && (qgV === 0 && qgl["strides"][qgV] === 1 || qx0);
    let qx1, qx2 = false;
    if (qgl["beginValid"] && qgl["endValid"] ? (qx1 = qgl["end"][qgV] - qgl["begin"][qgV], qx2 = true) : qgJ ? (qx1 = 1, qx2 = true) : qx0 && qgY >= 0 && (qgl["strides"][qgV] < 0 ? qx1 = -qgY : qx1 = qgY, qx2 = true), qx2) {
      let qx5;
      qx1 === 0 || qx1 < 0 != qgl["strides"][qgV] < 0 ? qx5 = 0 : qx5 = Math["trunc"](qx1 / qgl["strides"][qgV]) + (qx1 % qgl["strides"][qgV] !== 0 ? 1 : 0), qgT["push"](qx5);
    } else qgT["push"](-1);
  }
  for (let qx6 = 0; qx6 < qgl["finalShapeGatherIndices"]["length"]; ++qx6) {
    const qx7 = qgl["finalShapeGatherIndices"][qx6];
    qx7 >= 0 ? qgK["push"](qgT[qx7]) : qx7 === OP && qgK["push"](1);
  }
  return { "finalShapeSparse": qgK["filter"]((qx8, qx9) => qgl["finalShapeGatherIndices"][qx9] !== OP), "finalShape": qgK, "isIdentity": qgH, "sliceDim0": qgA, "isSimpleSlice": qgh, "begin": qgl["begin"], "end": qgl["end"], "strides": qgl["strides"] };
}
function WK(qgu, qgj) {
  qgj["beginMask"] = 0, qgj["endMask"] = 0, qgj["shrinkAxisMask"] = 0;
  let qgL = 0;
  qgj["beginValid"] = qgu["begin"] != null, qgj["endValid"] = qgu["end"] != null, qgj["begin"] = new Array(qgj["dims"]), qgj["end"] = new Array(qgj["dims"]), qgj["strides"] = new Array(qgj["dims"]), qgj["finalShapeGatherIndices"] = [], qgj["finalShapeGatherIndicesSparse"] = [], qgj["inputShapeGatherIndicesSparse"] = new Array(qgj["dims"]);
  for (let qgI = 0; qgI < qgu["dims"]; qgI++) if (1 << qgI & qgu["ellipsisMask"]) {
    const qgb = Math["min"](qgj["dims"] - (qgu["dims"] - qgI) + 1 + qgu["numAddAxisAfterEllipsis"], qgj["dims"]);
    for (; qgL < qgb; qgL++) qgj["begin"][qgL] = 0, qgj["end"][qgL] = 0, qgj["strides"][qgL] = 1, qgj["beginMask"] |= 1 << qgL, qgj["endMask"] |= 1 << qgL, qgj["finalShapeGatherIndices"]["push"](qgL), qgj["finalShapeGatherIndicesSparse"]["push"](-1), qgj["inputShapeGatherIndicesSparse"][qgL] = qgI;
  } else {
    if (1 << qgI & qgu["newAxisMask"]) qgj["finalShapeGatherIndices"]["push"](OP), qgj["finalShapeGatherIndicesSparse"]["push"](-1);
    else {
      if (qgL === qgj["begin"]["length"]) throw Error("Index out of range using input dim " + qgL + "; input has only " + qgj["dims"] + " dims, " + qgj["begin"]["length"] + ".");
      qgu["begin"] != null && (qgj["begin"][qgL] = qgu["begin"][qgI]), qgu["end"] != null && (qgj["end"][qgL] = qgu["end"][qgI]), qgj["strides"][qgL] = qgu["strides"][qgI], qgu["beginMask"] & 1 << qgI && (qgj["beginMask"] |= 1 << qgL), qgu["endMask"] & 1 << qgI && (qgj["endMask"] |= 1 << qgL), qgu["shrinkAxisMask"] & 1 << qgI ? (qgj["finalShapeGatherIndices"]["push"](OU), qgj["finalShapeGatherIndicesSparse"]["push"](-1), qgj["shrinkAxisMask"] |= 1 << qgL) : (qgj["finalShapeGatherIndices"]["push"](qgL), qgj["finalShapeGatherIndicesSparse"]["push"](qgI)), qgj["inputShapeGatherIndicesSparse"][qgL] = qgI, qgL++;
    }
  }
}
function WB(qgu, qgj, qgL, qgI, qgb, qgR) {
  if (qgb[qgj]) return qgL > 0 ? qgR[qgj] : qgR[qgj + 1 & 1];
  {
    const qgo = qgu < 0 ? qgI + qgu : qgu;
    return qgo < qgR[0] ? qgR[0] : qgo > qgR[1] ? qgR[1] : qgo;
  }
}
var WV = Object["freeze"]({ "__proto__": null, "assertParamsValid": Wq, "computeFlatOffset": WR, "computeOutShape": WF, "getNormalizedAxes": WZ, "isSliceContinous": WL, "maskToAxes": WM, "parseSliceParams": WQ, "sliceInfo": WH, "startForAxis": WG, "startIndicesWithElidedDims": We, "stopForAxis": Wj, "stopIndicesWithElidedDims": Wz, "stridesForAxis": WX, "stridesWithElidedDims": Wt });
function WJ(qgu, qgj) {
  let qgL = fG(qgu, "a", "add"), qgI = fG(qgj, "b", "add");
  [qgL, qgI] = MK(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](qG, qgb);
}
var WY = fL({ "add_": WJ });
function WP(qgu, qgj) {
  let qgL = fG(qgu, "a", "floorDiv"), qgI = fG(qgj, "b", "floorDiv");
  [qgL, qgI] = MK(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](nG, qgb);
}
var WU = fL({ "floorDiv_": WP });
function iq(qgu, qgj) {
  let qgL = fG(qgu, "a", "div"), qgI = fG(qgj, "b", "div");
  if ([qgL, qgI] = MK(qgL, qgI), qgL["dtype"] === "int32" && qgI["dtype"] === "int32") return WU(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI }, qgR = {};
  return fM["runKernel"](nW, qgb, qgR);
}
var iM = fL({ "div_": iq });
function iF(qgu, qgj) {
  let qgL = fG(qgu, "a", "mul"), qgI = fG(qgj, "b", "mul");
  [qgL, qgI] = MK(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](pF, qgb);
}
var it = fL({ "mul_": iF });
function iW(qgu) {
  const qgj = fG(qgu, "x", "abs");
  if (qgj["dtype"] === "complex64") {
    const qgL = { "x": qgj };
    return fM["runKernel"](qV, qgL);
  } else {
    const qgI = { "x": qgj };
    return fM["runKernel"](qX, qgI);
  }
}
var iD = fL({ "abs_": iW });
function ia(qgu) {
  k(Array["isArray"](qgu), () => "The argument passed to tf.addN() must be a list of tensors"), k(qgu["length"] >= 1, () => "Must pass at least one tensor to tf.addN(), but got " + qgu["length"]);
  const qgj = qgu["map"]((qgb, qgR) => fG(qgb, "tensors" + qgR, "addN")), qgL = qgj[0];
  qgj["forEach"]((qgb) => {
    if (qgb["dtype"] !== qgL["dtype"]) throw new Error("All tensors passed to tf.addN() must have the same dtype");
  }), qgj["forEach"]((qgb) => {
    if (!D(qgb["shape"], qgL["shape"])) throw new Error("All tensors passed to tf.addN() must have the same shape");
  });
  const qgI = qgj;
  return fM["runKernel"](qj, qgI);
}
var iZ = fL({ "addN_": ia });
function ie(qgu, qgj) {
  let qgL = fG(qgu, "a", "atan2"), qgI = fG(qgj, "b", "atan2");
  [qgL, qgI] = MK(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](qL, qgb);
}
var iz = fL({ "atan2_": ie });
function iX(qgu, qgj, qgL, qgI, qgb = "NHWC", qgR) {
  const qgo = qgu[3], qgr = [...qgj, qgo], qgQ = Ds(qgb);
  return ij(qgu, qgr, qgL, qgR, qgI, null, null, qgQ);
}
function iG(qgu, qgj, qgL, qgI, qgb, qgR, qgo = "channelsLast") {
  const [qgr, qgQ] = iH(qgj);
  let qgd;
  if (qgo === "channelsLast") qgd = [qgr, qgQ, qgu[3], qgu[3]];
  else {
    if (qgo === "channelsFirst") qgd = [qgr, qgQ, qgu[1], qgu[1]];
    else throw new Error("Unknown dataFormat " + qgo);
  }
  return ij(qgu, qgd, qgL, qgI, qgb, qgR, false, qgo);
}
function iu(qgu, qgj, qgL, qgI, qgb, qgR, qgo = "NDHWC") {
  const [qgr, qgQ, qgd] = iK(qgj);
  let qgv, qgy;
  if (qgo === "NDHWC") qgy = "channelsLast", qgv = [qgr, qgQ, qgd, qgu[4], qgu[4]];
  else {
    if (qgo === "NCDHW") qgy = "channelsFirst", qgv = [qgr, qgQ, qgd, qgu[1], qgu[1]];
    else throw new Error("Unknown dataFormat " + qgo);
  }
  return iL(qgu, qgv, qgL, qgI, qgb, false, qgy, qgR);
}
function ij(qgu, qgj, qgL, qgI, qgb, qgR, qgo = false, qgr = "channelsLast") {
  let [qgQ, qgd, qgv, qgy] = [-1, -1, -1, -1];
  if (qgr === "channelsLast") [qgQ, qgd, qgv, qgy] = qgu;
  else {
    if (qgr === "channelsFirst") [qgQ, qgy, qgd, qgv] = qgu;
    else throw new Error("Unknown dataFormat " + qgr);
  }
  const [qgl, qgH, , qgA] = qgj, [qgh, qgT] = iH(qgL), [qgK, qgB] = iH(qgI), qgV = iB(qgl, qgK), qgJ = iB(qgH, qgB), { padInfo: qgY, outHeight: qgP, outWidth: qgU } = iV(qgb, qgd, qgv, qgh, qgT, qgV, qgJ, qgR, qgr), qx0 = qgo ? qgA * qgy : qgA;
  let qx1;
  return qgr === "channelsFirst" ? qx1 = [qgQ, qx0, qgP, qgU] : qgr === "channelsLast" && (qx1 = [qgQ, qgP, qgU, qx0]), { "batchSize": qgQ, "dataFormat": qgr, "inHeight": qgd, "inWidth": qgv, "inChannels": qgy, "outHeight": qgP, "outWidth": qgU, "outChannels": qx0, "padInfo": qgY, "strideHeight": qgh, "strideWidth": qgT, "filterHeight": qgl, "filterWidth": qgH, "effectiveFilterHeight": qgV, "effectiveFilterWidth": qgJ, "dilationHeight": qgK, "dilationWidth": qgB, "inShape": qgu, "outShape": qx1, "filterShape": qgj };
}
function iL(qgu, qgj, qgL, qgI, qgb, qgR = false, qgo = "channelsLast", qgr) {
  let [qgQ, qgd, qgv, qgy, qgl] = [-1, -1, -1, -1, -1];
  if (qgo === "channelsLast") [qgQ, qgd, qgv, qgy, qgl] = qgu;
  else {
    if (qgo === "channelsFirst") [qgQ, qgl, qgd, qgv, qgy] = qgu;
    else throw new Error("Unknown dataFormat " + qgo);
  }
  const [qgH, qgA, qgh, , qgT] = qgj, [qgK, qgB, qgV] = iK(qgL), [qgJ, qgY, qgP] = iK(qgI), qgU = iB(qgH, qgJ), qx0 = iB(qgA, qgY), qx1 = iB(qgh, qgP), { padInfo: qx2, outDepth: qx3, outHeight: qx4, outWidth: qx5 } = iJ(qgb, qgd, qgv, qgy, qgK, qgB, qgV, qgU, qx0, qx1, qgr), qx6 = qgR ? qgT * qgl : qgT;
  let qx7;
  return qgo === "channelsFirst" ? qx7 = [qgQ, qx6, qx3, qx4, qx5] : qgo === "channelsLast" && (qx7 = [qgQ, qx3, qx4, qx5, qx6]), { "batchSize": qgQ, "dataFormat": qgo, "inDepth": qgd, "inHeight": qgv, "inWidth": qgy, "inChannels": qgl, "outDepth": qx3, "outHeight": qx4, "outWidth": qx5, "outChannels": qx6, "padInfo": qx2, "strideDepth": qgK, "strideHeight": qgB, "strideWidth": qgV, "filterDepth": qgH, "filterHeight": qgA, "filterWidth": qgh, "effectiveFilterDepth": qgU, "effectiveFilterHeight": qx0, "effectiveFilterWidth": qx1, "dilationDepth": qgJ, "dilationHeight": qgY, "dilationWidth": qgP, "inShape": qgu, "outShape": qx7, "filterShape": qgj };
}
function io(qgu, qgj, qgL, qgI, qgb) {
  qgI == null && (qgI = iQ(qgu, qgj, qgL));
  const qgR = qgu[0], qgo = qgu[1], qgr = iY((qgR - qgj + 2 * qgI) / qgL + 1, qgb), qgQ = iY((qgo - qgj + 2 * qgI) / qgL + 1, qgb);
  return [qgr, qgQ];
}
function ir(qgu, qgj, qgL, qgI, qgb, qgR) {
  qgb == null && (qgb = iQ(qgu, qgj[0], qgI[0]));
  const qgo = [0, 0, 0, qgL];
  for (let qgr = 0; qgr < 3; qgr++) qgu[qgr] + 2 * qgb >= qgj[qgr] && (qgo[qgr] = iY((qgu[qgr] - qgj[qgr] + 2 * qgb) / qgI[qgr] + 1, qgR));
  return qgo;
}
function iQ(qgu, qgj, qgL, qgI = 1) {
  const qgb = iB(qgj, qgI);
  return Math["floor"]((qgu[0] * (qgL - 1) - qgL + qgb) / 2);
}
function iH(qgu) {
  return typeof qgu == "number" ? [qgu, qgu, qgu] : qgu["length"] === 2 ? [qgu[0], qgu[1], 1] : qgu;
}
function iK(qgu) {
  return typeof qgu == "number" ? [qgu, qgu, qgu] : qgu;
}
function iB(qgu, qgj) {
  return qgj <= 1 ? qgu : qgu + (qgu - 1) * (qgj - 1);
}
function iV(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ) {
  let qgd, qgv, qgy;
  if (typeof qgu == "number") {
    qgd = { "top": qgu, "bottom": qgu, "left": qgu, "right": qgu, "type": qgu === 0 ? "VALID" : "NUMBER" };
    const qgl = io([qgj, qgL], qgR, qgI, qgu, qgr);
    qgv = qgl[0], qgy = qgl[1];
  } else {
    if (qgu === "same") {
      qgv = Math["ceil"](qgj / qgI), qgy = Math["ceil"](qgL / qgb);
      const qgH = Math["max"](0, (qgv - 1) * qgI + qgR - qgj), qgA = Math["max"](0, (qgy - 1) * qgb + qgo - qgL), qgh = Math["floor"](qgH / 2), qgT = qgH - qgh, qgK = Math["floor"](qgA / 2), qgB = qgA - qgK;
      qgd = { "top": qgh, "bottom": qgT, "left": qgK, "right": qgB, "type": "SAME" };
    } else {
      if (qgu === "valid") qgd = { "top": 0, "bottom": 0, "left": 0, "right": 0, "type": "VALID" }, qgv = Math["ceil"]((qgj - qgR + 1) / qgI), qgy = Math["ceil"]((qgL - qgo + 1) / qgb);
      else {
        if (typeof qgu == "object") {
          const qgV = qgQ === "channelsLast" ? qgu[1][0] : qgu[2][0], qgJ = qgQ === "channelsLast" ? qgu[1][1] : qgu[2][1], qgY = qgQ === "channelsLast" ? qgu[2][0] : qgu[3][0], qgP = qgQ === "channelsLast" ? qgu[2][1] : qgu[3][1];
          qgd = { "top": qgV, "bottom": qgJ, "left": qgY, "right": qgP, "type": qgV === 0 && qgJ === 0 && qgY === 0 && qgP === 0 ? "VALID" : "EXPLICIT" }, qgv = iY((qgj - qgR + qgV + qgJ) / qgI + 1, qgr), qgy = iY((qgL - qgo + qgY + qgP) / qgb + 1, qgr);
        } else throw Error("Unknown padding parameter: " + qgu);
      }
    }
  }
  return { "padInfo": qgd, "outHeight": qgv, "outWidth": qgy };
}
function iJ(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd, qgv) {
  let qgy, qgl, qgH, qgA;
  if (qgu === "valid" && (qgu = 0), typeof qgu == "number") {
    qgy = { "top": qgu, "bottom": qgu, "left": qgu, "right": qgu, "front": qgu, "back": qgu, "type": qgu === 0 ? "VALID" : "NUMBER" };
    const qgh = ir([qgj, qgL, qgI, 1], [qgr, qgQ, qgd], 1, [qgb, qgR, qgo], qgu, qgv);
    qgl = qgh[0], qgH = qgh[1], qgA = qgh[2];
  } else {
    if (qgu === "same") {
      qgl = Math["ceil"](qgj / qgb), qgH = Math["ceil"](qgL / qgR), qgA = Math["ceil"](qgI / qgo);
      const qgT = (qgl - 1) * qgb + qgr - qgj, qgK = (qgH - 1) * qgR + qgQ - qgL, qgB = (qgA - 1) * qgo + qgd - qgI, qgV = Math["floor"](qgT / 2), qgJ = qgT - qgV, qgY = Math["floor"](qgK / 2), qgP = qgK - qgY, qgU = Math["floor"](qgB / 2), qx0 = qgB - qgU;
      qgy = { "top": qgY, "bottom": qgP, "left": qgU, "right": qx0, "front": qgV, "back": qgJ, "type": "SAME" };
    } else throw Error("Unknown padding parameter: " + qgu);
  }
  return { "padInfo": qgy, "outDepth": qgl, "outHeight": qgH, "outWidth": qgA };
}
function iY(qgu, qgj) {
  if (!qgj) return Math["trunc"](qgu);
  switch (qgj) {
    case "round":
      return Math["round"](qgu);
    case "ceil":
      return Math["ceil"](qgu);
    case "floor":
      return Math["floor"](qgu);
    default:
      throw new Error("Unknown roundingMode " + qgj);
  }
}
function iP(qgu) {
  const [qgj, qgL, qgI] = iH(qgu);
  return qgj === 1 && qgL === 1 && qgI === 1;
}
function iU(qgu, qgj) {
  return iP(qgu) || iP(qgj);
}
function Dq(qgu) {
  return iH(qgu)["every"]((qgj) => qgj > 0);
}
function Ds(qgu) {
  if (qgu === "NHWC") return "channelsLast";
  if (qgu === "NCHW") return "channelsFirst";
  throw new Error("Unknown dataFormat " + qgu);
}
function DM(qgu, qgj, qgL) {
  if (qgL != null) {
    if (typeof qgj == "string") throw Error("Error in " + qgu + ": pad must be an integer when using dimRoundingMode " + qgL + " but got pad " + qgj + ".");
    if (typeof qgj == "number") k(m(qgj), () => "Error in " + qgu + ": pad must be an integer when using dimRoundingMode " + qgL + " but got pad " + qgj + ".");
    else {
      if (typeof qgj == "object") qgj["forEach"]((qgI) => {
        qgI["forEach"]((qgb) => {
          k(m(qgb), () => "Error in " + qgu + ": pad must be an integer when using dimRoundingMode " + qgL + " but got pad " + qgb + ".");
        });
      });
      else throw Error("Error in " + qgu + ": Unknown padding parameter: " + qgj);
    }
  }
}
function DF(qgu, qgj) {
  const qgL = { "x": fG(qgu, "x", "reshape", "string_or_numeric") }, qgI = { "shape": qgj };
  return fM["runKernel"](pL, qgL, qgI);
}
var DW = fL({ "reshape_": DF });
function DD(qgu, qgj, qgL, qgI, qgb) {
  const qgR = fG(qgu, "x", "avgPool", "float32"), qgo = 1;
  k(iU(qgL, qgo), () => "Error in avgPool: Either strides or dilations must be 1. Got strides " + qgL + " and dilations '" + qgo + "'");
  let qgr = qgR, qgQ = false;
  qgR["rank"] === 3 && (qgQ = true, qgr = DW(qgR, [1, qgR["shape"][0], qgR["shape"][1], qgR["shape"][2]])), k(qgr["rank"] === 4, () => "Error in avgPool: x must be rank 4 but got rank " + qgr["rank"] + "."), DM("avgPool", qgI, qgb);
  const qgd = { "x": qgr }, qgv = { "filterSize": qgj, "strides": qgL, "pad": qgI, "dimRoundingMode": qgb };
  let qgy = fM["runKernel"](qR, qgd, qgv);
  return qgy = OM(qgy, qgR["dtype"]), qgQ ? DW(qgy, [qgy["shape"][1], qgy["shape"][2], qgy["shape"][3]]) : qgy;
}
var DZ = fL({ "avgPool_": DD });
function Dz(qgu) {
  const qgj = { "x": fG(qgu, "x", "clone", "string_or_numeric") };
  return fM["runKernel"](no, qgj);
}
var DX = fL({ "clone_": Dz });
function DG(qgu, qgj = 0) {
  k(qgu["length"] >= 1, () => "Pass at least one tensor to concat");
  const qgL = fu(qgu, "tensors", "concat", "string_or_numeric");
  if (qgL[0]["dtype"] === "complex64" && qgL["forEach"]((qgR) => {
    if (qgR["dtype"] !== "complex64") throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype " + qgR["dtype"] + ". ");
  }), qgL["length"] === 1) return DX(qgL[0]);
  const qgI = qgL, qgb = { "axis": qgj };
  return fM["runKernel"](qJ, qgI, qgb);
}
var Dj = fL({ "concat_": DG });
function DL(qgu) {
  const qgj = { "x": fG(qgu, "x", "sigmoid", "float32") };
  return fM["runKernel"](pY, qgj);
}
var DR = fL({ "sigmoid_": DL });
function DQ(qgu, qgj, qgL) {
  const qgI = fG(qgu, "x", "slice", "string_or_numeric");
  if (qgI["rank"] === 0) throw new Error("Slicing scalar is not possible");
  const qgb = { "x": qgI }, qgR = { "begin": qgj, "size": qgL };
  return fM["runKernel"](pV, qgb, qgR);
}
var DH = fL({ "slice_": DQ });
function DK(qgu, qgj, qgL) {
  const qgI = fG(qgu, "x", "bincount"), qgb = fG(qgj, "weights", "bincount");
  k(qgI["dtype"] === "int32", () => "Error in bincount: input dtype must be int32, but got " + qgI["dtype"]), k(qgL >= 0, () => "size must be non-negative, but got " + qgL + "."), k(qgb["size"] === qgI["size"] || qgb["size"] === 0, () => "Error in bincount: weights must have the same size as input or0-length, but got input shape: " + qgI["shape"] + ", weights shape: " + qgb["shape"] + ".");
  const qgR = { "x": qgI, "weights": qgb }, qgo = { "size": qgL };
  return fM["runKernel"](qQ, qgR, qgo);
}
var DB = fL({ "bincount_": DK });
function DV(qgu, qgj) {
  let qgL = fG(qgu, "broadcastTo", "x");
  const qgI = qgL["shape"];
  if (K(qgj), qgj["length"] < qgL["rank"]) throw new Error("broadcastTo(): shape.length=" + qgj["length"] + " < input.rank=" + qgL["rank"] + ".");
  if (qgj["length"] > qgL["rank"]) {
    const qgQ = qgL["shape"]["slice"]();
    for (; qgQ["length"] < qgj["length"]; ) qgQ["unshift"](1);
    qgL = DW(qgL, qgQ);
  }
  const qgb = qgL["shape"], qgR = Array["from"](qgj);
  for (let qgd = qgj["length"] - 1; qgd >= 0; qgd--) if (qgb[qgd] === qgj[qgd]) qgR[qgd] = 1;
  else {
    if (qgL["shape"][qgd] !== 1) throw new Error("broadcastTo(): [" + qgI + "] cannot be broadcast to [" + qgj + "].");
  }
  if (qgR["map"]((qgv, qgy) => qgv > 1 ? qgy : -1)["filter"]((qgv) => qgv >= 0)["length"] === 0) return DX(qgL);
  const qgo = { "x": qgL }, qgr = { "reps": qgR };
  return fM["runKernel"](gF, qgo, qgr);
}
var DJ = fL({ "broadcastTo_": DV });
function DY(qgu, qgj = "float32", qgL) {
  return qgj = qgj || "float32", K(qgu), new EU(qgu, qgj, qgL);
}
function DP(qgu, qgj, qgL) {
  K(qgu), qgL = qgL || Q(qgj);
  const qgI = { "shape": qgu, "value": qgj, "dtype": qgL };
  return fM["runKernel"](ne, {}, qgI);
}
function DU(qgu, qgj, qgL) {
  const qgI = fG(qgu, "x", "clipByValue");
  if (k(qgj <= qgL, () => "Error in clip: min (" + qgj + ") must be less than or equal to max (" + qgL + ")."), qgj === qgL) return DP(qgI["shape"], qgj, qgI["dtype"]);
  const qgb = { "x": qgI }, qgR = { "clipValueMin": qgj, "clipValueMax": qgL };
  return fM["runKernel"](qK, qgb, qgR);
}
var mq = fL({ "clipByValue_": DU });
function mn(qgu, qgj) {
  return Dj(qgu, qgj);
}
var ms = fL({ "concat2d_": mn });
function mM(qgu, qgj, qgL, qgI, qgb = "NHWC", qgR = [1, 1], qgo) {
  const qgr = fG(qgu, "x", "conv2d", "float32"), qgQ = fG(qgj, "filter", "conv2d", "float32");
  let qgd = qgr, qgv = false;
  qgr["rank"] === 3 && (qgv = true, qgd = DW(qgr, [1, qgr["shape"][0], qgr["shape"][1], qgr["shape"][2]])), k(qgd["rank"] === 4, () => "Error in conv2d: input must be rank 4, but got rank " + qgd["rank"] + "."), k(qgQ["rank"] === 4, () => "Error in conv2d: filter must be rank 4, but got rank " + qgQ["rank"] + "."), DM("conv2d", qgI, qgo);
  const qgy = qgb === "NHWC" ? qgd["shape"][3] : qgd["shape"][1];
  k(qgy === qgQ["shape"][2], () => "Error in conv2d: depth of input (" + qgy + ") must match input depth for filter " + qgQ["shape"][2] + "."), k(iU(qgL, qgR), () => "Error in conv2D: Either strides or dilations must be 1. Got strides " + qgL + " and dilations '" + qgR + "'"), k(Dq(qgR), () => "Error in conv2D: Dilated rates should be larger than 0."), k(Dq(qgL), () => "Error in conv2D: Strides should be larger than 0.");
  const qgl = { "x": qgd, "filter": qgQ }, qgH = { "strides": qgL, "pad": qgI, "dataFormat": qgb, "dilations": qgR, "dimRoundingMode": qgo }, qgA = fM["runKernel"](qY, qgl, qgH);
  return qgv ? DW(qgA, [qgA["shape"][1], qgA["shape"][2], qgA["shape"][3]]) : qgA;
}
var mF = fL({ "conv2d_": mM });
function mW(qgu, qgj, qgL, qgI, qgb, qgR = "NHWC", qgo) {
  k(qgu["length"] === qgj["rank"], () => "Length of inShape (" + qgu["length"] + ") and rank of dy (" + qgj["rank"] + ") must match");
  let qgr = qgu, qgQ = qgj, qgd = false;
  qgj["rank"] === 3 && (qgd = true, qgQ = DW(qgj, [1, qgj["shape"][0], qgj["shape"][1], qgj["shape"][2]]), qgr = [1, qgu[0], qgu[1], qgu[2]]), k(qgr["length"] === 4, () => "Error in conv2dDerInput: inShape must be length 4, but got length " + qgr["length"] + "."), k(qgQ["rank"] === 4, () => "Error in conv2dDerInput: dy must be rank 4, but got rank " + qgQ["rank"]), k(qgL["rank"] === 4, () => "Error in conv2dDerInput: filter must be rank 4, but got rank " + qgL["rank"]);
  const qgv = qgR === "NHWC" ? qgr[3] : qgr[1], qgy = qgR === "NHWC" ? qgQ["shape"][3] : qgQ["shape"][1];
  k(qgv === qgL["shape"][2], () => "Error in conv2dDerInput: depth of input (" + qgv + ") must match input depth for filter " + qgL["shape"][2] + "."), k(qgy === qgL["shape"][3], () => "Error in conv2dDerInput: depth of output (" + qgy + ") must match output depth for filter " + qgL["shape"][3] + "."), DM("conv2dDerInput", qgb, qgo);
  const qgl = { "dy": qgQ, "filter": qgL }, qgH = { "strides": qgI, "pad": qgb, "dataFormat": qgR, "dimRoundingMode": qgo, "inputShape": qgr }, qgA = fM["runKernel"](qU, qgl, qgH);
  return qgd ? DW(qgA, [qgA["shape"][1], qgA["shape"][2], qgA["shape"][3]]) : qgA;
}
var mD = fL({ "conv2DBackpropInput_": mW });
function ma(qgu, qgj, qgL, qgI, qgb, qgR) {
  const qgo = fG(qgu, "x", "conv2dTranspose"), qgr = fG(qgj, "filter", "conv2dTranspose");
  return mD(qgL, qgo, qgr, qgI, qgb, "NHWC", qgR);
}
var mZ = fL({ "conv2dTranspose_": ma });
function me(qgu) {
  const qgj = { "x": fG(qgu, "x", "cos", "float32") };
  return fM["runKernel"](nq, qgj);
}
var mz = fL({ "cos_": me });
function mX(qgu, qgj, qgL = "NHWC") {
  const qgI = fG(qgu, "x", "depthToSpace", "float32"), qgb = qgL === "NHWC" ? qgI["shape"][1] : qgI["shape"][2], qgR = qgL === "NHWC" ? qgI["shape"][2] : qgI["shape"][3], qgo = qgL === "NHWC" ? qgI["shape"][3] : qgI["shape"][1];
  k(qgj > 1, () => "blockSize should be > 1 for depthToSpace, but was: " + qgj), k(qgb * qgj >= 0, () => "Negative dimension size caused by overflow when multiplying\n    " + qgb + " and " + qgj + "  for depthToSpace with input shape\n    " + qgI["shape"]), k(qgR * qgj >= 0, () => "Negative dimension size caused by overflow when multiplying\n    " + qgR + " and " + qgj + " for depthToSpace with input shape\n        " + qgI["shape"]), k(qgo % (qgj * qgj) === 0, () => "Dimension size must be evenly divisible by " + qgj * qgj + " but is " + qgo + " for depthToSpace with input shape " + qgI["shape"]);
  const qgr = { "x": qgI }, qgQ = { "blockSize": qgj, "dataFormat": qgL };
  return fM["runKernel"](ns, qgr, qgQ);
}
var mG = fL({ "depthToSpace_": mX });
function mu(qgu, qgj, qgL, qgI, qgb = "NHWC", qgR = [1, 1], qgo) {
  const qgr = fG(qgu, "x", "depthwiseConv2d", "float32"), qgQ = fG(qgj, "filter", "depthwiseConv2d", "float32");
  let qgd = qgr, qgv = false;
  qgr["rank"] === 3 && (qgv = true, qgd = DW(qgr, [1, qgr["shape"][0], qgr["shape"][1], qgr["shape"][2]])), k(qgd["rank"] === 4, () => "Error in depthwiseConv2d: input must be rank 4, but got rank " + qgd["rank"] + "."), k(qgQ["rank"] === 4, () => "Error in depthwiseConv2d: filter must be rank 4, but got rank " + qgQ["rank"] + ".");
  const qgy = qgb === "NHWC" ? qgd["shape"][3] : qgd["shape"][1];
  k(qgy === qgQ["shape"][2], () => "Error in depthwiseConv2d: number of input channels (" + qgy + ") must match the inChannels dimension in filter " + qgQ["shape"][2] + "."), DM("depthwiseConv2d", qgI, qgo);
  const qgl = { "x": qgd, "filter": qgQ }, qgH = { "strides": qgL, "pad": qgI, "dataFormat": qgb, "dilations": qgR, "dimRoundingMode": qgo }, qgA = fM["runKernel"](nM, qgl, qgH);
  return qgv ? DW(qgA, [qgA["shape"][1], qgA["shape"][2], qgA["shape"][3]]) : qgA;
}
var mj = fL({ "depthwiseConv2d_": mu });
function mL(qgu, qgj, qgL) {
  const qgI = fG(qgj, "a", "where"), qgb = fG(qgL, "b", "where"), qgR = fG(qgu, "condition", "where", "bool"), qgo = OR(OR(qgR["shape"], qgI["shape"]), qgb["shape"]), qgr = DJ(qgR, qgo), qgQ = DJ(qgI, qgo), qgd = DJ(qgb, qgo), qgv = { "condition": qgr, "t": qgQ, "e": qgd };
  return fM["runKernel"](pB, qgv);
}
var mQ = fL({ "where_": mL });
function mH(qgu) {
  const qgj = { "x": fG(qgu, "x", "zerosLike") };
  return fM["runKernel"](gZ, qgj);
}
var mK = fL({ "zerosLike_": mH });
function mB(qgu, ...qgj) {
  const qgL = qgj["map"]((qgb, qgR) => fG(qgb, "tensors" + qgR, "einsum")), qgI = { "equation": qgu };
  return fM["runKernel"](ni, qgL, qgI);
}
var mV = fL({ "einsum_": mB });
function mJ(qgu) {
  const qgj = { "x": fG(qgu, "x", "elu", "float32") };
  return fM["runKernel"](nD, qgj);
}
var mY = fL({ "elu_": mJ });
function mP(qgu, qgj) {
  for (let qgL = 0; qgL < qgu["length"]; ++qgL) if (qgu[qgu["length"] - qgL - 1] !== qgj - 1 - qgL) return false;
  return true;
}
function mU(qgu, qgj, qgL) {
  const qgI = qgu["length"] + qgj["length"], qgb = [];
  let qgR = 0, qgo = 0;
  for (let qgr = 0; qgr < qgI; qgr++) qgL["indexOf"](qgr) === -1 ? qgb["push"](qgu[qgR++]) : qgb["push"](qgj[qgo++]);
  return qgb;
}
function aq(qgu, qgj) {
  const qgL = [], qgI = qgu["length"];
  for (let qgR = 0; qgR < qgI; qgR++) qgj["indexOf"](qgR) === -1 && qgL["push"](qgu[qgR]);
  const qgb = qgj["map"]((qgo) => qgu[qgo]);
  return [qgL, qgb];
}
function aM(qgu, qgj) {
  const qgL = qgj["map"]((qgI) => 1);
  return mU(qgu, qgL, qgj);
}
function aF(qgu, qgj, qgL) {
  k(mP(qgj, qgL), () => qgu + " supports only inner-most axes for now. Got axes " + qgj + " and rank-" + qgL + " input.");
}
function at(qgu, qgj) {
  if (mP(qgu, qgj)) return null;
  const qgL = [];
  for (let qgI = 0; qgI < qgj; ++qgI) qgu["indexOf"](qgI) === -1 && qgL["push"](qgI);
  return qgu["forEach"]((qgb) => qgL["push"](qgb)), qgL;
}
function aW(qgu) {
  return qgu["map"]((qgj, qgL) => [qgL, qgj])["sort"]((qgj, qgL) => qgj[1] - qgL[1])["map"]((qgj) => qgj[0]);
}
function aD(qgu, qgj) {
  const qgL = [];
  for (let qgI = qgj - qgu; qgI < qgj; ++qgI) qgL["push"](qgI);
  return qgL;
}
function aZ(qgu, qgj = null, qgL = false) {
  const qgI = { "x": fG(qgu, "x", "max") }, qgb = { "reductionIndices": qgj, "keepDims": qgL };
  return fM["runKernel"](nY, qgI, qgb);
}
var az = fL({ "max_": aZ });
function aX(qgu, qgj = null, qgL = false) {
  const qgI = { "x": fG(qgu, "x", "min") }, qgb = { "axis": qgj, "keepDims": qgL };
  return fM["runKernel"](pq, qgI, qgb);
}
var aG = fL({ "min_": aX });
function au(qgu, qgj) {
  let qgL = fG(qgu, "base", "pow"), qgI = fG(qgj, "exp", "pow");
  [qgL, qgI] = MK(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](pz, qgb);
}
var aj = fL({ "pow_": au });
function aL(qgu, qgj) {
  if ((ED(qgu) && qgj !== "string" || Array["isArray"](qgu)) && qgj !== "complex64") throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");
  if (qgj === "string" && ED(qgu) && !(qgu instanceof Uint8Array)) throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");
  return fK(qgu, [], [], qgj);
}
function ao(qgu) {
  const qgj = { "x": fG(qgu, "x", "sqrt", "float32") };
  return fM["runKernel"](pP, qgj);
}
var ar = fL({ "sqrt_": ao });
function aQ(qgu) {
  const qgj = fG(qgu, "x", "square"), qgL = {};
  return fM["runKernel"]("Square", { "x": qgj }, qgL);
}
var aH = fL({ "square_": aQ });
function aK(qgu, qgj = null, qgL = false) {
  let qgI = fG(qgu, "x", "sum");
  qgI["dtype"] === "bool" && (qgI = OM(qgI, "int32"));
  const qgb = { "x": qgI }, qgR = { "axis": qgj, "keepDims": qgL };
  return fM["runKernel"](pU, qgb, qgR);
}
var aB = fL({ "sum_": aK });
function aV(qgu, qgj = "euclidean", qgL = null, qgI = false) {
  qgu = fG(qgu, "x", "norm");
  const qgb = aJ(qgu, qgj, qgL);
  let qgR = qgb["shape"];
  if (qgI) {
    const qgo = z(qgL, qgu["shape"]);
    qgR = aM(qgb["shape"], qgo);
  }
  return DW(qgb, qgR);
}
function aJ(qgu, qgj, qgL = null) {
  if (qgu["rank"] === 0) return iD(qgu);
  if (qgu["rank"] !== 1 && qgL === null) return aJ(DW(qgu, [-1]), qgj, qgL);
  if (qgu["rank"] === 1 || typeof qgL == "number" || Array["isArray"](qgL) && qgL["length"] === 1) {
    if (qgj === 1) return aB(iD(qgu), qgL);
    if (qgj === 1 / 0) return az(iD(qgu), qgL);
    if (qgj === -1 / 0) return aG(iD(qgu), qgL);
    if (qgj === "euclidean" || qgj === 2) return ar(aB(aj(iD(qgu), aL(2, "int32")), qgL));
    throw new Error("Error in norm: invalid ord value: " + qgj);
  }
  if (Array["isArray"](qgL) && qgL["length"] === 2) {
    if (qgj === 1) return az(aB(iD(qgu), qgL[0]), qgL[1] - 1);
    if (qgj === 1 / 0) return az(aB(iD(qgu), qgL[1]), qgL[0]);
    if (qgj === -1 / 0) return aG(aB(iD(qgu), qgL[1]), qgL[0]);
    if (qgj === "fro" || qgj === "euclidean") return ar(aB(aH(qgu), qgL));
    throw new Error("Error in norm: invalid ord value: " + qgj);
  }
  throw new Error("Error in norm: invalid axis: " + qgL);
}
var aY = fL({ "norm_": aV });
function aP(qgu, qgj = null, qgL = false) {
  return aY(qgu, "euclidean", qgj, qgL);
}
var aU = fL({ "euclideanNorm_": aP });
function Zq(qgu, qgj = 0) {
  const qgL = fG(qgu, "x", "expandDims", "string_or_numeric");
  k(qgj <= qgL["rank"], () => "Axis must be <= rank of the tensor");
  const qgI = { "input": qgL }, qgb = { "dim": qgj };
  return fM["runKernel"](nZ, qgI, qgb);
}
var ZM = fL({ "expandDims_": Zq });
function ZF(qgu, qgj) {
  const qgL = fG(qgu, "x", "tile", "string_or_numeric");
  k(qgL["rank"] === qgj["length"], () => "Error in transpose: rank of input " + qgL["rank"] + " must match length of reps " + qgj + ".");
  const qgI = { "x": qgL }, qgb = { "reps": qgj };
  return fM["runKernel"](gF, qgI, qgb);
}
var ZW = fL({ "tile_": ZF });
function ZD(qgu) {
  const qgj = { "x": fG(qgu, "x", "floor", "float32") };
  return fM["runKernel"](nX, qgj);
}
var Za = fL({ "floor_": ZD });
function ZZ(qgu, qgj, qgL = 0, qgI = 0) {
  const qgb = fG(qgu, "x", "gather"), qgR = fG(qgj, "indices", "gather", "int32"), qgo = { "x": qgb, "indices": qgR }, qgr = { "axis": qgL, "batchDims": qgI };
  return fM["runKernel"](nu, qgo, qgr);
}
var Ze = fL({ "gather_": ZZ });
function Zz(qgu, qgj) {
  let qgL = fG(qgu, "a", "greater", "string_or_numeric"), qgI = fG(qgj, "b", "greater", "string_or_numeric");
  [qgL, qgI] = MK(qgL, qgI), OR(qgL["shape"], qgI["shape"]);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](nj, qgb);
}
var ZX = fL({ "greater_": Zz });
function ZG(qgu, qgj) {
  let qgL = fG(qgu, "a", "greaterEqual", "string_or_numeric"), qgI = fG(qgj, "b", "greaterEqual", "string_or_numeric");
  [qgL, qgI] = MK(qgL, qgI), OR(qgL["shape"], qgI["shape"]);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](nL, qgb);
}
var Zj = fL({ "greaterEqual_": ZG });
function ZL(qgu, qgj = 0.2) {
  const qgL = { "x": fG(qgu, "x", "leakyRelu") }, qgI = { "alpha": qgj };
  return fM["runKernel"](nH, qgL, qgI);
}
var ZR = fL({ "leakyRelu_": ZL });
function Zo(qgu, qgj) {
  let qgL = fG(qgu, "a", "lessEqual", "string_or_numeric"), qgI = fG(qgj, "b", "lessEqual", "string_or_numeric");
  [qgL, qgI] = MK(qgL, qgI), OR(qgL["shape"], qgI["shape"]);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](nB, qgb);
}
var Zr = fL({ "lessEqual_": Zo });
function ZQ(qgu) {
  return fM["customGrad"](qgu);
}
function ZH(qgu, qgj) {
  let qgL = fG(qgu, "a", "sub"), qgI = fG(qgj, "b", "sub");
  [qgL, qgI] = MK(qgL, qgI);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](gM, qgb);
}
var ZK = fL({ "sub_": ZH });
function ZB(qgu, qgj) {
  const qgL = fG(qgu, "a", "logicalAnd", "bool"), qgI = fG(qgj, "b", "logicalAnd", "bool");
  OR(qgL["shape"], qgI["shape"]);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](nV, qgb);
}
var ZV = fL({ "logicalAnd_": ZB });
function ZJ(qgu, qgj, qgL, qgI, qgb) {
  const qgR = fG(qgu, "x", "maxPool"), qgo = 1;
  let qgr = qgR, qgQ = false;
  qgR["rank"] === 3 && (qgQ = true, qgr = DW(qgR, [1, qgR["shape"][0], qgR["shape"][1], qgR["shape"][2]])), k(qgr["rank"] === 4, () => "Error in maxPool: input must be rank 4 but got rank " + qgr["rank"] + "."), k(iU(qgL, qgo), () => "Error in maxPool: Either strides or dilations must be 1. Got strides " + qgL + " and dilations '" + qgo + "'"), DM("maxPool", qgI, qgb);
  const qgd = { "x": qgr }, qgv = { "filterSize": qgj, "strides": qgL, "pad": qgI, "dimRoundingMode": qgb }, qgy = fM["runKernel"](nU, qgd, qgv);
  return qgQ ? DW(qgy, [qgy["shape"][1], qgy["shape"][2], qgy["shape"][3]]) : qgy;
}
var ZY = fL({ "maxPool_": ZJ });
function ZP(qgu, qgj) {
  let qgL = fG(qgu, "a", "maximum"), qgI = fG(qgj, "b", "maximum");
  [qgL, qgI] = MK(qgL, qgI), qgL["dtype"] === "bool" && (qgL = OM(qgL, "int32"), qgI = OM(qgI, "int32")), OR(qgL["shape"], qgI["shape"]);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](nP, qgb);
}
var ZU = fL({ "maximum_": ZP });
function wq(qgu, qgj = null, qgL = false) {
  const qgI = { "x": fG(qgu, "x", "mean") }, qgb = { "axis": qgj, "keepDims": qgL };
  return fM["runKernel"](p1, qgI, qgb);
}
var wM = fL({ "mean_": wq });
function wF(qgu, qgj = "float32") {
  if (K(qgu), qgj === "complex64") {
    const qgI = wF(qgu, "float32"), qgb = wF(qgu, "float32");
    return fH(qgI, qgb);
  }
  const qgL = T(i2(qgu), qgj);
  return fM["makeTensor"](qgL, qgu, qgj);
}
function wW(qgu, qgj = "float32") {
  if (K(qgu), qgj === "complex64") {
    const qgI = wW(qgu, "float32"), qgb = wF(qgu, "float32");
    return fH(qgI, qgb);
  }
  const qgL = h(i2(qgu), qgj);
  return fM["makeTensor"](qgL, qgu, qgj);
}
function wD(qgu, qgj) {
  let qgL = fG(qgu, "a", "minimum"), qgI = fG(qgj, "b", "minimum");
  [qgL, qgI] = MK(qgL, qgI), qgL["dtype"] === "bool" && (qgL = OM(qgL, "int32"), qgI = OM(qgI, "int32")), OR(qgL["shape"], qgI["shape"]);
  const qgb = { "a": qgL, "b": qgI };
  return fM["runKernel"](pM, qgb);
}
var wZ = fL({ "minimum_": wD });
function we(qgu, qgj, qgL = 0) {
  const qgI = fG(qgu, "x", "pad");
  if (qgI["rank"] === 0) throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");
  const qgb = { "paddings": qgj, "constantValue": qgL }, qgR = { "x": qgI };
  return fM["runKernel"](pe, qgR, qgb);
}
var wz = fL({ "pad_": we });
function wX(qgu, qgj) {
  const qgL = fG(qgu, "x", "prelu"), qgI = fG(qgj, "alpha", "prelu"), qgb = { "x": qgL, "alpha": qgI };
  return fM["runKernel"](pX, qgb);
}
var wG = fL({ "prelu_": wX });
function wu(qgu, qgj = false) {
  console["log"](qgu["toString"](qgj));
}
var wj = { "exports": {} };
wj["exports"], function(qgu) {
  (function(qgj, qgL, qgI) {
    function qgb(qgQ) {
      var qgd = this, qgv = qgr();
      qgd["next"] = function() {
        var qgy = 2091639 * qgd["s0"] + qgd["c"] * 23283064365386963e-26;
        return qgd["s0"] = qgd["s1"], qgd["s1"] = qgd["s2"], qgd["s2"] = qgy - (qgd["c"] = qgy | 0);
      }, qgd["c"] = 1, qgd["s0"] = qgv(" "), qgd["s1"] = qgv(" "), qgd["s2"] = qgv(" "), qgd["s0"] -= qgv(qgQ), qgd["s0"] < 0 && (qgd["s0"] += 1), qgd["s1"] -= qgv(qgQ), qgd["s1"] < 0 && (qgd["s1"] += 1), qgd["s2"] -= qgv(qgQ), qgd["s2"] < 0 && (qgd["s2"] += 1), qgv = null;
    }
    function qgR(qgQ, qgd) {
      return qgd["c"] = qgQ["c"], qgd["s0"] = qgQ["s0"], qgd["s1"] = qgQ["s1"], qgd["s2"] = qgQ["s2"], qgd;
    }
    function qgo(qgQ, qgd) {
      var qgv = new qgb(qgQ), qgy = qgd && qgd["state"], qgl = qgv["next"];
      return qgl["int32"] = function() {
        return qgv["next"]() * 4294967296 | 0;
      }, qgl["double"] = function() {
        return qgl() + (qgl() * 2097152 | 0) * 11102230246251565e-32;
      }, qgl["quick"] = qgl, qgy && (typeof qgy == "object" && qgR(qgy, qgv), qgl["state"] = function() {
        return qgR(qgv, {});
      }), qgl;
    }
    function qgr() {
      var qgQ = 4022871197, qgd = function(qgv) {
        qgv = String(qgv);
        for (var qgy = 0; qgy < qgv["length"]; qgy++) {
          qgQ += qgv["charCodeAt"](qgy);
          var qgl = 0.02519603282416938 * qgQ;
          qgQ = qgl >>> 0, qgl -= qgQ, qgl *= qgQ, qgQ = qgl >>> 0, qgl -= qgQ, qgQ += qgl * 4294967296;
        }
        return (qgQ >>> 0) * 23283064365386963e-26;
      };
      return qgd;
    }
    qgL && qgL["exports"] ? qgL["exports"] = qgo : this["alea"] = qgo;
  })(xq, qgu);
}(wj);
var wL = wj["exports"];
var wQ = { "exports": {} };
wQ["exports"], function(qgu) {
  (function(qgj, qgL, qgI) {
    function qgb(qgr) {
      var qgQ = this, qgd = "";
      qgQ["x"] = 0, qgQ["y"] = 0, qgQ["z"] = 0, qgQ["w"] = 0, qgQ["next"] = function() {
        var qgy = qgQ["x"] ^ qgQ["x"] << 11;
        return qgQ["x"] = qgQ["y"], qgQ["y"] = qgQ["z"], qgQ["z"] = qgQ["w"], qgQ["w"] ^= qgQ["w"] >>> 19 ^ qgy ^ qgy >>> 8;
      }, qgr === (qgr | 0) ? qgQ["x"] = qgr : qgd += qgr;
      for (var qgv = 0; qgv < qgd["length"] + 64; qgv++) qgQ["x"] ^= qgd["charCodeAt"](qgv) | 0, qgQ["next"]();
    }
    function qgR(qgr, qgQ) {
      return qgQ["x"] = qgr["x"], qgQ["y"] = qgr["y"], qgQ["z"] = qgr["z"], qgQ["w"] = qgr["w"], qgQ;
    }
    function qgo(qgr, qgQ) {
      var qgd = new qgb(qgr), qgv = qgQ && qgQ["state"], qgy = function() {
        return (qgd["next"]() >>> 0) / 4294967296;
      };
      return qgy["double"] = function() {
        do
          var qgl = qgd["next"]() >>> 11, qgH = (qgd["next"]() >>> 0) / 4294967296, qgA = (qgl + qgH) / (1 << 21);
        while (qgA === 0);
        return qgA;
      }, qgy["int32"] = qgd["next"], qgy["quick"] = qgy, qgv && (typeof qgv == "object" && qgR(qgv, qgd), qgy["state"] = function() {
        return qgR(qgd, {});
      }), qgy;
    }
    qgL && qgL["exports"] ? qgL["exports"] = qgo : this["xor128"] = qgo;
  })(xq, qgu);
}(wQ);
var wH = wQ["exports"];
var wK = { "exports": {} };
wK["exports"], function(qgu) {
  (function(qgj, qgL, qgI) {
    function qgb(qgr) {
      var qgQ = this, qgd = "";
      qgQ["next"] = function() {
        var qgy = qgQ["x"] ^ qgQ["x"] >>> 2;
        return qgQ["x"] = qgQ["y"], qgQ["y"] = qgQ["z"], qgQ["z"] = qgQ["w"], qgQ["w"] = qgQ["v"], (qgQ["d"] = qgQ["d"] + 362437 | 0) + (qgQ["v"] = qgQ["v"] ^ qgQ["v"] << 4 ^ (qgy ^ qgy << 1)) | 0;
      }, qgQ["x"] = 0, qgQ["y"] = 0, qgQ["z"] = 0, qgQ["w"] = 0, qgQ["v"] = 0, qgr === (qgr | 0) ? qgQ["x"] = qgr : qgd += qgr;
      for (var qgv = 0; qgv < qgd["length"] + 64; qgv++) qgQ["x"] ^= qgd["charCodeAt"](qgv) | 0, qgv == qgd["length"] && (qgQ["d"] = qgQ["x"] << 10 ^ qgQ["x"] >>> 4), qgQ["next"]();
    }
    function qgR(qgr, qgQ) {
      return qgQ["x"] = qgr["x"], qgQ["y"] = qgr["y"], qgQ["z"] = qgr["z"], qgQ["w"] = qgr["w"], qgQ["v"] = qgr["v"], qgQ["d"] = qgr["d"], qgQ;
    }
    function qgo(qgr, qgQ) {
      var qgd = new qgb(qgr), qgv = qgQ && qgQ["state"], qgy = function() {
        return (qgd["next"]() >>> 0) / 4294967296;
      };
      return qgy["double"] = function() {
        do
          var qgl = qgd["next"]() >>> 11, qgH = (qgd["next"]() >>> 0) / 4294967296, qgA = (qgl + qgH) / (1 << 21);
        while (qgA === 0);
        return qgA;
      }, qgy["int32"] = qgd["next"], qgy["quick"] = qgy, qgv && (typeof qgv == "object" && qgR(qgv, qgd), qgy["state"] = function() {
        return qgR(qgd, {});
      }), qgy;
    }
    qgL && qgL["exports"] ? qgL["exports"] = qgo : this["xorwow"] = qgo;
  })(xq, qgu);
}(wK);
var wB = wK["exports"];
var wV = { "exports": {} };
wV["exports"], function(qgu) {
  (function(qgj, qgL, qgI) {
    function qgb(qgr) {
      var qgQ = this;
      qgQ["next"] = function() {
        var qgv = qgQ["x"], qgy = qgQ["i"], qgl, qgH;
        return qgl = qgv[qgy], qgl ^= qgl >>> 7, qgH = qgl ^ qgl << 24, qgl = qgv[qgy + 1 & 7], qgH ^= qgl ^ qgl >>> 10, qgl = qgv[qgy + 3 & 7], qgH ^= qgl ^ qgl >>> 3, qgl = qgv[qgy + 4 & 7], qgH ^= qgl ^ qgl << 7, qgl = qgv[qgy + 7 & 7], qgl = qgl ^ qgl << 13, qgH ^= qgl ^ qgl << 9, qgv[qgy] = qgH, qgQ["i"] = qgy + 1 & 7, qgH;
      };
      function qgd(qgv, qgy) {
        var qgl, qgH = [];
        if (qgy === (qgy | 0)) qgH[0] = qgy;
        else {
          for (qgy = "" + qgy, qgl = 0; qgl < qgy["length"]; ++qgl) qgH[qgl & 7] = qgH[qgl & 7] << 15 ^ qgy["charCodeAt"](qgl) + qgH[qgl + 1 & 7] << 13;
        }
        for (; qgH["length"] < 8; ) qgH["push"](0);
        for (qgl = 0; qgl < 8 && qgH[qgl] === 0; ++qgl) ;
        for (qgl == 8 ? qgH[7] = -1 : qgH[qgl], qgv["x"] = qgH, qgv["i"] = 0, qgl = 256; qgl > 0; --qgl) qgv["next"]();
      }
      qgd(qgQ, qgr);
    }
    function qgR(qgr, qgQ) {
      return qgQ["x"] = qgr["x"]["slice"](), qgQ["i"] = qgr["i"], qgQ;
    }
    function qgo(qgr, qgQ) {
      qgr == null && (qgr = +/* @__PURE__ */ new Date());
      var qgd = new qgb(qgr), qgv = qgQ && qgQ["state"], qgy = function() {
        return (qgd["next"]() >>> 0) / 4294967296;
      };
      return qgy["double"] = function() {
        do
          var qgl = qgd["next"]() >>> 11, qgH = (qgd["next"]() >>> 0) / 4294967296, qgA = (qgl + qgH) / (1 << 21);
        while (qgA === 0);
        return qgA;
      }, qgy["int32"] = qgd["next"], qgy["quick"] = qgy, qgv && (qgv["x"] && qgR(qgv, qgd), qgy["state"] = function() {
        return qgR(qgd, {});
      }), qgy;
    }
    qgL && qgL["exports"] ? qgL["exports"] = qgo : this["xorshift7"] = qgo;
  })(xq, qgu);
}(wV);
var wJ = wV["exports"];
var wY = { "exports": {} };
wY["exports"], function(qgu) {
  (function(qgj, qgL, qgI) {
    function qgb(qgr) {
      var qgQ = this;
      qgQ["next"] = function() {
        var qgv = qgQ["w"], qgy = qgQ["X"], qgl = qgQ["i"], qgH, qgA;
        return qgQ["w"] = qgv = qgv + 1640531527 | 0, qgA = qgy[qgl + 34 & 127], qgH = qgy[qgl = qgl + 1 & 127], qgA ^= qgA << 13, qgH ^= qgH << 17, qgA ^= qgA >>> 15, qgH ^= qgH >>> 12, qgA = qgy[qgl] = qgA ^ qgH, qgQ["i"] = qgl, qgA + (qgv ^ qgv >>> 16) | 0;
      };
      function qgd(qgv, qgy) {
        var qgl, qgH, qgA, qgh, qgT, qgK = [], qgB = 128;
        for (qgy === (qgy | 0) ? (qgH = qgy, qgy = null) : (qgy = qgy + "\0", qgH = 0, qgB = Math["max"](qgB, qgy["length"])), qgA = 0, qgh = -32; qgh < qgB; ++qgh) qgy && (qgH ^= qgy["charCodeAt"]((qgh + 32) % qgy["length"])), qgh === 0 && (qgT = qgH), qgH ^= qgH << 10, qgH ^= qgH >>> 15, qgH ^= qgH << 4, qgH ^= qgH >>> 13, qgh >= 0 && (qgT = qgT + 1640531527 | 0, qgl = qgK[qgh & 127] ^= qgH + qgT, qgA = qgl == 0 ? qgA + 1 : 0);
        for (qgA >= 128 && (qgK[(qgy && qgy["length"] || 0) & 127] = -1), qgA = 127, qgh = 4 * 128; qgh > 0; --qgh) qgH = qgK[qgA + 34 & 127], qgl = qgK[qgA = qgA + 1 & 127], qgH ^= qgH << 13, qgl ^= qgl << 17, qgH ^= qgH >>> 15, qgl ^= qgl >>> 12, qgK[qgA] = qgH ^ qgl;
        qgv["w"] = qgT, qgv["X"] = qgK, qgv["i"] = qgA;
      }
      qgd(qgQ, qgr);
    }
    function qgR(qgr, qgQ) {
      return qgQ["i"] = qgr["i"], qgQ["w"] = qgr["w"], qgQ["X"] = qgr["X"]["slice"](), qgQ;
    }
    function qgo(qgr, qgQ) {
      qgr == null && (qgr = +/* @__PURE__ */ new Date());
      var qgd = new qgb(qgr), qgv = qgQ && qgQ["state"], qgy = function() {
        return (qgd["next"]() >>> 0) / 4294967296;
      };
      return qgy["double"] = function() {
        do
          var qgl = qgd["next"]() >>> 11, qgH = (qgd["next"]() >>> 0) / 4294967296, qgA = (qgl + qgH) / (1 << 21);
        while (qgA === 0);
        return qgA;
      }, qgy["int32"] = qgd["next"], qgy["quick"] = qgy, qgv && (qgv["X"] && qgR(qgv, qgd), qgy["state"] = function() {
        return qgR(qgd, {});
      }), qgy;
    }
    qgL && qgL["exports"] ? qgL["exports"] = qgo : this["xor4096"] = qgo;
  })(xq, qgu);
}(wY);
var wP = wY["exports"];
var wU = { "exports": {} };
wU["exports"], function(qgu) {
  (function(qgj, qgL, qgI) {
    function qgb(qgr) {
      var qgQ = this, qgd = "";
      qgQ["next"] = function() {
        var qgy = qgQ["b"], qgl = qgQ["c"], qgH = qgQ["d"], qgA = qgQ["a"];
        return qgy = qgy << 25 ^ qgy >>> 7 ^ qgl, qgl = qgl - qgH | 0, qgH = qgH << 24 ^ qgH >>> 8 ^ qgA, qgA = qgA - qgy | 0, qgQ["b"] = qgy = qgy << 20 ^ qgy >>> 12 ^ qgl, qgQ["c"] = qgl = qgl - qgH | 0, qgQ["d"] = qgH << 16 ^ qgl >>> 16 ^ qgA, qgQ["a"] = qgA - qgy | 0;
      }, qgQ["a"] = 0, qgQ["b"] = 0, qgQ["c"] = -1640531527, qgQ["d"] = 1367130551, qgr === Math["floor"](qgr) ? (qgQ["a"] = qgr / 4294967296 | 0, qgQ["b"] = qgr | 0) : qgd += qgr;
      for (var qgv = 0; qgv < qgd["length"] + 20; qgv++) qgQ["b"] ^= qgd["charCodeAt"](qgv) | 0, qgQ["next"]();
    }
    function qgR(qgr, qgQ) {
      return qgQ["a"] = qgr["a"], qgQ["b"] = qgr["b"], qgQ["c"] = qgr["c"], qgQ["d"] = qgr["d"], qgQ;
    }
    function qgo(qgr, qgQ) {
      var qgd = new qgb(qgr), qgv = qgQ && qgQ["state"], qgy = function() {
        return (qgd["next"]() >>> 0) / 4294967296;
      };
      return qgy["double"] = function() {
        do
          var qgl = qgd["next"]() >>> 11, qgH = (qgd["next"]() >>> 0) / 4294967296, qgA = (qgl + qgH) / (1 << 21);
        while (qgA === 0);
        return qgA;
      }, qgy["int32"] = qgd["next"], qgy["quick"] = qgy, qgv && (typeof qgv == "object" && qgR(qgv, qgd), qgy["state"] = function() {
        return qgR(qgd, {});
      }), qgy;
    }
    qgL && qgL["exports"] ? qgL["exports"] = qgo : this["tychei"] = qgo;
  })(xq, qgu);
}(wU);
var eq = wU["exports"];
var es = { "exports": {} };
(function(qgu) {
  (function(qgj, qgL, qgI) {
    var qgb = 256, qgR = 6, qgo = 52, qgr = "random", qgQ = qgI["pow"](qgb, qgR), qgd = qgI["pow"](2, qgo), qgv = qgd * 2, qgy = qgb - 1, qgl;
    function qgH(qgJ, qgY, qgP) {
      var qgU = [];
      qgY = qgY == true ? { "entropy": true } : qgY || {};
      var qx0 = qgK(qgT(qgY["entropy"] ? [qgJ, qgV(qgL)] : qgJ == null ? qgB() : qgJ, 3), qgU), qx1 = new qgA(qgU), qx2 = function() {
        for (var qx3 = qx1["g"](qgR), qx4 = qgQ, qx5 = 0; qx3 < qgd; ) qx3 = (qx3 + qx5) * qgb, qx4 *= qgb, qx5 = qx1["g"](1);
        for (; qx3 >= qgv; ) qx3 /= 2, qx4 /= 2, qx5 >>>= 1;
        return (qx3 + qx5) / qx4;
      };
      return qx2["int32"] = function() {
        return qx1["g"](4) | 0;
      }, qx2["quick"] = function() {
        return qx1["g"](4) / 4294967296;
      }, qx2["double"] = qx2, qgK(qgV(qx1["S"]), qgL), (qgY["pass"] || qgP || function(qx3, qx4, qx5, qx6) {
        return qx6 && (qx6["S"] && qgh(qx6, qx1), qx3["state"] = function() {
          return qgh(qx1, {});
        }), qx5 ? (qgI[qgr] = qx3, qx4) : qx3;
      })(qx2, qx0, "global" in qgY ? qgY["global"] : this == qgI, qgY["state"]);
    }
    function qgA(qgJ) {
      var qgY, qgP = qgJ["length"], qgU = this, qx0 = 0, qx1 = qgU["i"] = qgU["j"] = 0, qx2 = qgU["S"] = [];
      for (qgP || (qgJ = [qgP++]); qx0 < qgb; ) qx2[qx0] = qx0++;
      for (qx0 = 0; qx0 < qgb; qx0++) qx2[qx0] = qx2[qx1 = qgy & qx1 + qgJ[qx0 % qgP] + (qgY = qx2[qx0])], qx2[qx1] = qgY;
      (qgU["g"] = function(qx3) {
        for (var qx4, qx5 = 0, qx6 = qgU["i"], qx7 = qgU["j"], qx8 = qgU["S"]; qx3--; ) qx4 = qx8[qx6 = qgy & qx6 + 1], qx5 = qx5 * qgb + qx8[qgy & (qx8[qx6] = qx8[qx7 = qgy & qx7 + qx4]) + (qx8[qx7] = qx4)];
        return qgU["i"] = qx6, qgU["j"] = qx7, qx5;
      })(qgb);
    }
    function qgh(qgJ, qgY) {
      return qgY["i"] = qgJ["i"], qgY["j"] = qgJ["j"], qgY["S"] = qgJ["S"]["slice"](), qgY;
    }
    function qgT(qgJ, qgY) {
      var qgP = [], qgU = typeof qgJ, qx0;
      if (qgY && qgU == "object") {
        for (qx0 in qgJ) try {
          qgP["push"](qgT(qgJ[qx0], qgY - 1));
        } catch (qx1) {
        }
      }
      return qgP["length"] ? qgP : qgU == "string" ? qgJ : qgJ + "\0";
    }
    function qgK(qgJ, qgY) {
      for (var qgP = qgJ + "", qgU, qx0 = 0; qx0 < qgP["length"]; ) qgY[qgy & qx0] = qgy & (qgU ^= qgY[qgy & qx0] * 19) + qgP["charCodeAt"](qx0++);
      return qgV(qgY);
    }
    function qgB() {
      try {
        var qgJ;
        return qgl && (qgJ = qgl["randomBytes"]) ? qgJ = qgJ(qgb) : (qgJ = new Uint8Array(qgb), (qgj["crypto"] || qgj["msCrypto"])["getRandomValues"](qgJ)), qgV(qgJ);
      } catch (qgU) {
        var qgY = qgj["navigator"], qgP = qgY && qgY["plugins"];
        return [+/* @__PURE__ */ new Date(), qgj, qgP, qgj["screen"], qgV(qgL)];
      }
    }
    function qgV(qgJ) {
      return String["fromCharCode"]["apply"](0, qgJ);
    }
    if (qgK(qgI["random"](), qgL), qgu["exports"]) {
      qgu["exports"] = qgH;
      try {
        qgl = require_crypto();
      } catch (qgJ) {
      }
    } else qgI["seed" + qgr] = qgH;
  })(typeof self != "undefined" ? self : xq, [], Math);
})(es);
var eM = es["exports"];
var eF = wL;
var et = wH;
var eW = wB;
var ei = wJ;
var eD = wP;
var eZ = eq;
var ez = eM;
ez["alea"] = eF, ez["xor128"] = et, ez["xorwow"] = eW, ez["xorshift7"] = ei, ez["xor4096"] = eD, ez["tychei"] = eZ;
function eX(qgu, qgj, qgL = 1, qgI = "float32") {
  if (qgL === 0) throw new Error("Cannot have a step of zero");
  const qgb = { "start": qgu, "stop": qgj, "step": qgL, "dtype": qgI };
  return fM["runKernel"](pG, {}, qgb);
}
function eG(qgu) {
  const qgj = { "x": fG(qgu, "x", "relu") };
  return fM["runKernel"](pj, qgj);
}
var ej = fL({ "relu_": eG });
function eL(qgu) {
  const qgj = { "x": fG(qgu, "x", "relu6") };
  return fM["runKernel"](pQ, qgj);
}
var eo = fL({ "relu6_": eL });
function eQ(qgu) {
  const qgj = { "x": fG(qgu, "x", "round") };
  return fM["runKernel"](pH, qgj);
}
var eH = fL({ "round_": eQ });
function eK(qgu) {
  const qgj = { "x": fG(qgu, "x", "sin", "float32") };
  return fM["runKernel"](pJ, qgj);
}
var eB = fL({ "sin_": eK });
function eV(qgu, qgj, qgL) {
  const qgI = fG(qgu, "x", "slice3d");
  return k(qgI["rank"] === 3, () => "slice3d expects a rank-3 tensor, but got a rank-" + qgI["rank"] + " tensor"), DH(qgI, qgj, qgL);
}
var eJ = fL({ "slice3d_": eV });
function eY(qgu, qgj, qgL = 0) {
  const qgI = { "x": fG(qgu, "x", "split") }, qgb = { "numOrSizeSplits": qgj, "axis": qgL };
  return fM["runKernel"](gq, qgI, qgb);
}
var eP = fL({ "split_": eY });
function eU(qgu, qgj) {
  const qgL = fG(qgu, "x", "squeeze", "string_or_numeric");
  return DW(qgL, c(qgL["shape"], qgj)["newShape"]);
}
var zq = fL({ "squeeze_": eU });
function zM(qgu, qgj = 0) {
  const qgL = fu(qgu, "tensors", "stack", "string_or_numeric");
  k(qgL["length"] >= 1, () => "Pass at least one tensor to tf.stack"), qgL["length"] > 0 && k(qgj <= qgL[0]["rank"], () => "Axis must be <= rank of the tensor");
  const qgI = qgL, qgb = { "axis": qgj };
  return fM["runKernel"](pZ, qgI, qgb);
}
var zF = fL({ "stack_": zM });
function zW(qgu, qgj = 0) {
  const qgL = { "x": fG(qgu, "x", "step") }, qgI = { "alpha": qgj };
  return fM["runKernel"](ge, qgL, qgI);
}
var zD = fL({ "step_": zW });
function zZ(qgu, qgj, qgL, qgI, qgb = 0, qgR = 0, qgo = 0, qgr = 0, qgQ = 0) {
  const qgd = { "x": fG(qgu, "x", "stridedSlice", "string_or_numeric") }, qgv = { "begin": qgj, "end": qgL, "strides": qgI, "beginMask": qgb, "endMask": qgR, "ellipsisMask": qgo, "newAxisMask": qgr, "shrinkAxisMask": qgQ };
  return fM["runKernel"](gs, qgd, qgv);
}
var ze = fL({ "stridedSlice_": zZ });
function zz(qgu, qgj) {
  W(qgu);
  const qgL = fZ(qgu, qgj);
  if (qgL["length"] !== 1) throw new Error("tensor1d() requires values to be a flat/TypedArray");
  return fK(qgu, null, qgL, qgj);
}
function zX(qgu, qgj, qgL) {
  W(qgu);
  const qgI = fZ(qgu, qgL);
  if (qgI["length"] !== 2 && qgI["length"] !== 1) throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");
  if (qgI["length"] === 1 && qgj == null) throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");
  return fK(qgu, qgj, qgI, qgL);
}
function zG(qgu, qgj, qgL) {
  const qgI = fG(qgu, "tensor", "tensorScatterupdate"), qgb = fG(qgj, "indices", "tensorScatterupdate", "int32"), qgR = fG(qgL, "updates", "tensorScatterupdate");
  if (OJ(qgR, qgb, qgI["shape"]), qgI["dtype"] !== qgR["dtype"]) throw new Error("tensor and updates must have the same dtype, instead they are " + qgI["dtype"] + " and " + qgR["dtype"] + ".");
  const qgo = { "tensor": qgI, "indices": qgb, "updates": qgR }, qgr = {};
  return fM["runKernel"](pK, qgo, qgr);
}
fL({ "tensorScatterUpdate_": zG });
function zj(qgu, qgj = 0) {
  const qgL = fG(qgu, "x", "unstack", "string_or_numeric");
  k(qgj >= -qgL["shape"]["length"] && qgj < qgL["shape"]["length"], () => "Axis = " + qgj + " is not in [-" + qgL["shape"]["length"] + ", " + qgL["shape"]["length"] + ")");
  const qgI = { "value": qgL }, qgb = { "axis": qgj };
  return fM["runKernel"](ga, qgI, qgb);
}
var zL = fL({ "unstack_": zj });
function zR(qgu, qgj) {
  const qgL = [];
  for (let qgR = 0; qgR < qgj["length"]; qgR++) qgj[qgR] && qgL["push"](qgR);
  const qgI = DY(qgu, "int32"), qgb = DY([qgL["length"], qgu["length"]], "int32");
  for (let qgo = 0; qgo < qgL["length"]; qgo++) {
    const qgr = qgI["indexToLoc"](qgL[qgo]), qgQ = qgo * qgu["length"];
    qgb["values"]["set"](qgr, qgQ);
  }
  return qgb["toTensor"]();
}
function zQ(qgu, qgj, qgL, qgI, qgb, qgR = "NHWC", qgo) {
  let qgr = qgu;
  qgu["rank"] === 3 && (qgr = DW(qgu, [1, qgu["shape"][0], qgu["shape"][1], qgu["shape"][2]]));
  let qgQ = qgj;
  qgQ["rank"] === 3 && (qgQ = DW(qgj, [1, qgj["shape"][0], qgj["shape"][1], qgj["shape"][2]])), k(qgr["rank"] === 4, () => "Error in conv2dDerFilter: input must be rank 4, but got shape " + qgr["shape"] + "."), k(qgQ["rank"] === 4, () => "Error in conv2dDerFilter: dy must be rank 4, but got shape " + qgQ["shape"] + "."), k(qgL["length"] === 4, () => "Error in conv2dDerFilter: filterShape must be length 4, but got " + qgL + ".");
  const qgd = qgR === "NHWC" ? qgr["shape"][3] : qgr["shape"][1], qgv = qgR === "NHWC" ? qgQ["shape"][3] : qgQ["shape"][1];
  k(qgd === qgL[2], () => "Error in conv2dDerFilter: depth of input " + qgd + ") must match input depth in filter (" + qgL[2] + "."), k(qgv === qgL[3], () => "Error in conv2dDerFilter: depth of dy (" + qgv + ") must match output depth for filter (" + qgL[3] + ")."), DM("conv2dDerFilter", qgb, qgo);
  const qgy = { "x": qgr, "dy": qgQ }, qgl = { "strides": qgI, "pad": qgb, "dataFormat": qgR, "dimRoundingMode": qgo, "filterShape": qgL };
  return fM["runKernel"](qP, qgy, qgl);
}
var zH = fL({ "conv2DBackpropFilter_": zQ });
function zK(qgu, qgj, qgL) {
  if (qgL == null || qgL === "linear") return qgu;
  if (qgL === "relu") return it(qgu, zD(qgj));
  throw new Error("Cannot compute gradient for fused activation " + qgL + ".");
}
function zB(qgu, qgj) {
  let qgL = qgj;
  const qgI = OL(qgu["shape"], qgj["shape"]);
  return qgI["length"] > 0 && (qgL = aB(qgL, qgI)), DW(qgL, qgu["shape"]);
}
function zV(qgu, qgj, qgL, qgI) {
  if (qgj === "linear") return qgu;
  if (qgj === "relu") return ej(qgu);
  if (qgj === "elu") return mY(qgu);
  if (qgj === "relu6") return eo(qgu);
  if (qgj === "prelu") return wG(qgu, qgL);
  if (qgj === "leakyrelu") return ZR(qgu, qgI);
  if (qgj === "sigmoid") return DR(qgu);
  throw new Error("Unknown fused activation " + qgj + ".");
}
var zJ = (qgu, qgj) => !(qgu > 0) || qgj === "linear";
function zY({ x: qgu, filter: qgj, strides: qgL, pad: qgI, dataFormat: qgb = "NHWC", dilations: qgR = [1, 1], dimRoundingMode: qgo, bias: qgr, activation: qgQ = "linear", preluActivationWeights: qgd, leakyreluAlpha: qgv }) {
  if (qgQ = qgQ || "linear", zJ(fM["state"]["gradientDepth"], qgQ) === false) {
    k(qgb === "NHWC", () => "Error in fused conv2d: got dataFormat of " + qgb + " but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.");
    let qgP = mF(qgu, qgj, qgL, qgI, qgb, qgR, qgo);
    return qgr != null && (qgP = WY(qgP, qgr)), zV(qgP, qgQ, qgd, qgv);
  }
  const qgy = fG(qgu, "x", "conv2d", "float32"), qgl = fG(qgj, "filter", "conv2d", "float32");
  let qgH = qgy, qgA = false;
  qgy["rank"] === 3 && (qgA = true, qgH = DW(qgy, [1, qgy["shape"][0], qgy["shape"][1], qgy["shape"][2]])), k(qgH["rank"] === 4, () => "Error in fused conv2d: input must be rank 4, but got rank " + qgH["rank"] + "."), k(qgl["rank"] === 4, () => "Error in fused conv2d: filter must be rank 4, but got rank " + qgl["rank"] + "."), DM("fused conv2d", qgI, qgo);
  const qgh = qgb === "NHWC" ? qgH["shape"][3] : qgH["shape"][1];
  k(qgl["shape"][2] === qgh, () => "Error in conv2d: depth of input (" + qgh + ") must match input depth for filter " + qgl["shape"][2] + "."), k(iU(qgL, qgR), () => "Error in conv2D: Either strides or dilations must be 1. Got strides " + qgL + " and dilations '" + qgR + "'");
  const qgT = ij(qgH["shape"], qgl["shape"], qgL, qgR, qgI, qgo);
  let qgK;
  qgr != null && (qgK = fG(qgr, "bias", "fused conv2d"), [qgK] = MK(qgK, qgy), qgb === "NHWC" ? OR(qgT["outShape"], qgK["shape"]) : (k(qgK["shape"]["length"] <= 1, () => "Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-" + qgK["shape"]["length"] + "."), k(qgK["shape"]["length"] === 0 || qgK["shape"][0] === qgT["outChannels"] || qgK["shape"][0] === 1, () => "Error in fused conv2d: bias shape (" + qgK["shape"] + ") is not compatible with the number of output channels (" + qgT["outChannels"] + ")")));
  let qgB;
  if (qgd != null) {
    const qgU = qgd["shape"];
    if (k(qgU["length"] <= 1 || qgU["length"] === 3, () => "Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-" + qgU["length"] + "."), qgU["length"] === 1) k(qgU[0] === 1 || qgU[0] === qgT["outChannels"], () => "Error in fused conv2d: PReLU activation weights (" + qgU + ") is not compatible with the number of output channels (" + qgT["outChannels"] + ").");
    else {
      if (qgU["length"] === 3) try {
        OR(qgU, qgT["outShape"]);
      } catch (qx0) {
        const qx1 = "Error in fused conv2d: PReLU activation weights (" + qgU + ") is not compatible with the output shape of the conv2d (" + qgT["outShape"] + ").";
        throw Error(qx1);
      }
    }
    qgB = fG(qgd, "prelu weights", "fused conv2d");
  }
  const qgV = (qx2, qx3) => {
    k(qgb === "NHWC", () => "Error in gradient of fused conv2D: got dataFormat of " + qgb + " but only NHWC is currently supported.");
    const [qx4, qx5, qx6, qx7] = qx3, qx8 = zK(qx2, qx6, qgQ);
    k(iP(qgR), () => "Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '" + qgR + "'");
    const qx9 = mD(qx5["shape"], qx8, qx4, qgL, qgI), qxq = zH(qx5, qx8, qx4["shape"], qgL, qgI), qxn = [qx9, qxq];
    if (qx7 != null) {
      const qxp = zB(qx7, qx8);
      qxn["push"](qxp);
    }
    return qxn;
  }, qgJ = { "x": qgH, "filter": qgl, "bias": qgK, "preluActivationWeights": qgB }, qgY = { "strides": qgL, "pad": qgI, "dataFormat": qgb, "dilations": qgR, "dimRoundingMode": qgo, "activation": qgQ, "leakyreluAlpha": qgv };
  return qgr == null ? ZQ((qx2, qx3, qx4) => {
    let qx5 = fM["runKernel"](gu, qgJ, qgY);
    return qx4([qx3, qx2, qx5]), qgA && (qx5 = DW(qx5, [qx5["shape"][1], qx5["shape"][2], qx5["shape"][3]])), { "value": qx5, "gradFunc": qgV };
  })(qgH, qgl) : ZQ((qx2, qx3, qx4, qx5) => {
    let qx6 = fM["runKernel"](gu, qgJ, qgY);
    return qx5([qx3, qx2, qx6, qx4]), qgA && (qx6 = DW(qx6, [qx6["shape"][1], qx6["shape"][2], qx6["shape"][3]])), { "value": qx6, "gradFunc": qgV };
  })(qgH, qgl, qgK);
}
var zP = fL({ "fusedConv2d_": zY });
function zU(qgu, qgj, qgL, qgI, qgb, qgR = [1, 1], qgo) {
  let qgr = qgu;
  qgu["rank"] === 3 && (qgr = DW(qgu, [1, qgu["shape"][0], qgu["shape"][1], qgu["shape"][2]]));
  let qgQ = qgj;
  qgQ["rank"] === 3 && (qgQ = DW(qgj, [1, qgj["shape"][0], qgj["shape"][1], qgj["shape"][2]]));
  const qgd = { "x": qgr, "dy": qgQ }, qgv = { "strides": qgI, "pad": qgb, "dimRoundingMode": qgo, "dilations": qgR, "filterShape": qgL };
  return fM["runKernel"](nF, qgd, qgv);
}
var cq = fL({ "depthwiseConv2dNativeBackpropFilter_": zU });
function cM(qgu, qgj, qgL, qgI, qgb, qgR = [1, 1], qgo) {
  let qgr = qgj, qgQ = false;
  qgj["rank"] === 3 && (qgQ = true, qgr = DW(qgj, [1, qgj["shape"][0], qgj["shape"][1], qgj["shape"][2]]));
  const qgd = { "dy": qgr, "filter": qgL }, qgv = { "strides": qgI, "pad": qgb, "dimRoundingMode": qgo, "dilations": qgR, "inputShape": qgu }, qgy = fM["runKernel"](nt, qgd, qgv);
  return qgQ ? DW(qgy, [qgy["shape"][1], qgy["shape"][2], qgy["shape"][3]]) : qgy;
}
var cF = fL({ "depthwiseConv2dNativeBackpropInput_": cM });
function cW({ x: qgu, filter: qgj, strides: qgL, pad: qgI, dataFormat: qgb = "NHWC", dilations: qgR = [1, 1], dimRoundingMode: qgo, bias: qgr, activation: qgQ = "linear", preluActivationWeights: qgd, leakyreluAlpha: qgv }) {
  if (zJ(fM["state"]["gradientDepth"], qgQ) === false) {
    let qgY = mj(qgu, qgj, qgL, qgI, qgb, qgR, qgo);
    return qgr != null && (qgY = WY(qgY, qgr)), zV(qgY, qgQ, qgd, qgv);
  }
  const qgy = fG(qgu, "x", "depthwiseConv2d", "float32"), qgl = fG(qgj, "filter", "depthwiseConv2d", "float32");
  let qgH = qgy, qgA = false;
  qgy["rank"] === 3 && (qgA = true, qgH = DW(qgy, [1, qgy["shape"][0], qgy["shape"][1], qgy["shape"][2]])), k(qgH["rank"] === 4, () => "Error in fused depthwiseConv2d: input must be rank 4, but got rank " + qgH["rank"] + "."), k(qgl["rank"] === 4, () => "Error in fused depthwiseConv2d: filter must be rank 4, but got rank " + qgl["rank"] + "."), k(qgH["shape"][3] === qgl["shape"][2], () => "Error in fused depthwiseConv2d: number of input channels (" + qgH["shape"][3] + ") must match the inChannels dimension in filter " + qgl["shape"][2] + "."), qgR == null && (qgR = [1, 1]), k(iU(qgL, qgR), () => "Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides " + qgL + " and dilations '" + qgR + "'"), DM("fused depthwiseConv2d", qgI, qgo);
  const qgh = ij(qgH["shape"], qgl["shape"], qgL, qgR, qgI, qgo, true);
  let qgT;
  qgr != null && (qgT = fG(qgr, "bias", "fused conv2d"), [qgT] = MK(qgT, qgy), OR(qgh["outShape"], qgT["shape"]));
  let qgK;
  qgd != null && (qgK = fG(qgd, "prelu weights", "fused depthwiseConv2d"));
  const qgB = (qgP, qgU) => {
    k(iP(qgR), () => "Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '" + qgR + "'");
    const [qx0, qx1, qx2, qx3] = qgU, qx4 = zK(qgP, qx2, qgQ), qx5 = cF(qx1["shape"], qx4, qx0, qgL, qgI, qgR, qgo), qx6 = cq(qx1, qx4, qx0["shape"], qgL, qgI, qgR, qgo);
    if (qx3 != null) {
      const qx7 = zB(qgT, qx4);
      return [qx5, qx6, qx7];
    }
    return [qx5, qx6];
  }, qgV = { "x": qgH, "filter": qgl, "bias": qgT, "preluActivationWeights": qgK }, qgJ = { "strides": qgL, "pad": qgI, "dataFormat": qgb, "dilations": qgR, "dimRoundingMode": qgo, "activation": qgQ, "leakyreluAlpha": qgv };
  return qgr == null ? ZQ((qgP, qgU, qx0) => {
    let qx1 = fM["runKernel"](gj, qgV, qgJ);
    return qx0([qgU, qgP, qx1]), qgA && (qx1 = DW(qx1, [qx1["shape"][1], qx1["shape"][2], qx1["shape"][3]])), { "value": qx1, "gradFunc": qgB };
  })(qgH, qgl) : ZQ((qgP, qgU, qx0, qx1) => {
    let qx2 = fM["runKernel"](gj, qgV, qgJ);
    return qx1([qgU, qgP, qx2, qx0]), qgA && (qx2 = DW(qx2, [qx2["shape"][1], qx2["shape"][2], qx2["shape"][3]])), { "value": qx2, "gradFunc": qgB };
  })(qgH, qgl, qgT);
}
var cD = fL({ "fusedDepthwiseConv2d_": cW });
function ca({ a: qgu, b: qgj, transposeA: qgL = false, transposeB: qgI = false, bias: qgb, activation: qgR = "linear", preluActivationWeights: qgo, leakyreluAlpha: qgr = 0.2 }) {
  if (zJ(fM["state"]["gradientDepth"], qgR) === false) {
    let qx2 = OW(qgu, qgj, qgL, qgI);
    return qgb != null && (qx2 = WY(qx2, qgb)), zV(qx2, qgR, qgo, qgr);
  }
  let qgQ = fG(qgu, "a", "fused matMul"), qgd = fG(qgj, "b", "fused matMul");
  [qgQ, qgd] = MK(qgQ, qgd);
  const qgv = qgL ? qgQ["shape"][qgQ["rank"] - 2] : qgQ["shape"][qgQ["rank"] - 1], qgy = qgI ? qgd["shape"][qgd["rank"] - 1] : qgd["shape"][qgd["rank"] - 2], qgl = qgL ? qgQ["shape"][qgQ["rank"] - 1] : qgQ["shape"][qgQ["rank"] - 2], qgH = qgI ? qgd["shape"][qgd["rank"] - 2] : qgd["shape"][qgd["rank"] - 1], qgA = qgQ["shape"]["slice"](0, -2), qgh = qgd["shape"]["slice"](0, -2), qgT = i2(qgA), qgK = i2(qgh);
  k(qgv === qgy, () => "Error in fused matMul: inner shapes (" + qgv + ") and (" + qgy + ") of Tensors with shapes " + qgQ["shape"] + " and " + qgd["shape"] + " and transposeA=" + qgL + " and transposeB=" + qgI + " must match.");
  const qgB = OR(qgQ["shape"]["slice"](0, -2), qgd["shape"]["slice"](0, -2))["concat"]([qgl, qgH]), qgV = qgL ? DW(qgQ, [qgT, qgv, qgl]) : DW(qgQ, [qgT, qgl, qgv]), qgJ = qgI ? DW(qgd, [qgK, qgH, qgy]) : DW(qgd, [qgK, qgy, qgH]);
  let qgY;
  qgb != null && (qgY = fG(qgb, "bias", "fused matMul"), [qgY] = MK(qgY, qgQ), OR(qgB, qgY["shape"]));
  let qgP;
  qgo != null && (qgP = fG(qgo, "prelu weights", "fused matMul"));
  const qgU = (qx3, qx4) => {
    const [qx5, qx6, qx7, qx8] = qx4, qx9 = zK(DW(qx3, qx7["shape"]), qx7, qgR);
    let qxq, qxn;
    if (!qgL && !qgI ? (qxq = OW(qx9, qx6, false, true), qxn = OW(qx5, qx9, true, false)) : !qgL && qgI ? (qxq = OW(qx9, qx6, false, false), qxn = OW(qx9, qx5, true, false)) : qgL && !qgI ? (qxq = OW(qx6, qx9, false, true), qxn = OW(qx5, qx9, false, false)) : (qxq = OW(qx6, qx9, true, true), qxn = OW(qx9, qx5, true, true)), qgb != null) {
      const qxp = zB(qx8, qx9);
      return [qxq, qxn, qxp];
    } else return [qxq, qxn];
  }, qx0 = { "a": qgV, "b": qgJ, "bias": qgY, "preluActivationWeights": qgP }, qx1 = { "transposeA": qgL, "transposeB": qgI, "activation": qgR, "leakyreluAlpha": qgr };
  return qgb == null ? ZQ((qx3, qx4, qx5) => {
    const qx6 = fM["runKernel"](gG, qx0, qx1);
    return qx5([qx3, qx4, qx6]), { "value": DW(qx6, qgB), "gradFunc": qgU };
  })(qgV, qgJ) : ZQ((qx3, qx4, qx5, qx6) => {
    const qx7 = fM["runKernel"](gG, qx0, qx1);
    return qx6([qx3, qx4, qx7, qx5]), { "value": DW(qx7, qgB), "gradFunc": qgU };
  })(qgV, qgJ, qgY);
}
var cZ = fL({ "fusedMatMul_": ca });
function ce(qgu, qgj, qgL, qgI, qgb = "bilinear", qgR = 0) {
  const qgo = fG(qgu, "image", "cropAndResize"), qgr = fG(qgj, "boxes", "cropAndResize", "float32"), qgQ = fG(qgL, "boxInd", "cropAndResize", "int32"), qgd = qgr["shape"][0];
  k(qgo["rank"] === 4, () => "Error in cropAndResize: image must be rank 4,but got rank " + qgo["rank"] + "."), k(qgr["rank"] === 2 && qgr["shape"][1] === 4, () => "Error in cropAndResize: boxes must be have size [" + qgd + ",4] but had shape " + qgr["shape"] + "."), k(qgQ["rank"] === 1 && qgQ["shape"][0] === qgd, () => "Error in cropAndResize: boxInd must be have size [" + qgd + "] but had shape " + qgr["shape"] + "."), k(qgI["length"] === 2, () => "Error in cropAndResize: cropSize must be of length 2, but got length " + qgI["length"] + "."), k(qgI[0] >= 1 && qgI[1] >= 1, () => "cropSize must be atleast [1,1], but was " + qgI), k(qgb === "bilinear" || qgb === "nearest", () => "method must be bilinear or nearest, but was " + qgb);
  const qgv = { "image": qgo, "boxes": qgr, "boxInd": qgQ }, qgy = { "method": qgb, "extrapolationValue": qgR, "cropSize": qgI };
  return fM["runKernel"](nn, qgv, qgy);
}
var cz = fL({ "cropAndResize_": ce });
function cX(qgu) {
  const qgj = fG(qgu, "image", "flipLeftRight", "float32");
  k(qgj["rank"] === 4, () => "Error in flipLeftRight: image must be rank 4,but got rank " + qgj["rank"] + ".");
  const qgL = { "image": qgj };
  return fM["runKernel"](nz, qgL, {});
}
var cG = fL({ "flipLeftRight_": cX });
function cu(qgu) {
  const qgj = fG(qgu, "image", "grayscaleToRGB"), qgL = qgj["rank"] - 1, qgI = qgj["shape"][qgL];
  k(qgj["rank"] >= 2, () => "Error in grayscaleToRGB: images must be at least rank 2, but got rank " + qgj["rank"] + "."), k(qgI === 1, () => "Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size " + qgI + ".");
  const qgb = new Array(qgj["rank"]);
  return qgb["fill"](1, 0, qgL), qgb[qgL] = 3, ZW(qgj, qgb);
}
var cj = fL({ "grayscaleToRGB_": cu });
function cL(qgu) {
  const qgj = fG(qgu, "image", "RGBToGrayscale"), qgL = qgj["rank"] - 1, qgI = qgj["shape"][qgL];
  k(qgj["rank"] >= 2, () => "Error in RGBToGrayscale: images must be at least rank 2, but got rank " + qgj["rank"] + "."), k(qgI === 3, () => "Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size " + qgI + ".");
  const qgb = qgj["dtype"], qgR = OM(qgj, "float32"), qgo = zz([0.2989, 0.587, 0.114]);
  let qgr;
  switch (qgj["rank"]) {
    case 2:
      qgr = mV("ij,j->i", qgR, qgo);
      break;
    case 3:
      qgr = mV("ijk,k->ij", qgR, qgo);
      break;
    case 4:
      qgr = mV("ijkl,l->ijk", qgR, qgo);
      break;
    case 5:
      qgr = mV("ijklm,m->ijkl", qgR, qgo);
      break;
    case 6:
      qgr = mV("ijklmn,n->ijklm", qgR, qgo);
      break;
    default:
      throw new Error("Not a valid tensor rank.");
  }
  return qgr = ZM(qgr, -1), OM(qgr, qgb);
}
var co = fL({ "rgbToGrayscale_": cL });
function cr(qgu, qgj, qgL = 0, qgI = 0.5) {
  const qgb = fG(qgu, "image", "rotateWithOffset", "float32");
  k(qgb["rank"] === 4, () => "Error in rotateWithOffset: image must be rank 4,but got rank " + qgb["rank"] + ".");
  const qgR = { "image": qgb }, qgo = { "radians": qgj, "fillValue": qgL, "center": qgI };
  return fM["runKernel"](gX, qgR, qgo);
}
var cQ = fL({ "rotateWithOffset_": cr });
function cH(qgu, qgj, qgL, qgI, qgb, qgR) {
  qgI == null && (qgI = 0.5), qgb == null && (qgb = Number["NEGATIVE_INFINITY"]), qgR == null && (qgR = 0);
  const qgo = qgu["shape"][0];
  return qgL = Math["min"](qgL, qgo), k(0 <= qgI && qgI <= 1, () => "iouThreshold must be in [0, 1], but was '" + qgI + "'"), k(qgu["rank"] === 2, () => "boxes must be a 2D tensor, but was of rank '" + qgu["rank"] + "'"), k(qgu["shape"][1] === 4, () => "boxes must have 4 columns, but 2nd dimension was " + qgu["shape"][1]), k(qgj["rank"] === 1, () => "scores must be a 1D tensor"), k(qgj["shape"][0] === qgo, () => "scores has incompatible shape with boxes. Expected " + qgo + ", but was " + qgj["shape"][0]), k(0 <= qgR && qgR <= 1, () => "softNmsSigma must be in [0, 1], but was '" + qgR + "'"), { "maxOutputSize": qgL, "iouThreshold": qgI, "scoreThreshold": qgb, "softNmsSigma": qgR };
}
function cK(qgu, qgj, qgL, qgI = 0.5, qgb = Number["NEGATIVE_INFINITY"]) {
  const qgR = fG(qgu, "boxes", "nonMaxSuppression", "float32"), qgo = fG(qgj, "scores", "nonMaxSuppression", "float32"), qgr = cH(qgR, qgo, qgL, qgI, qgb);
  qgL = qgr["maxOutputSize"], qgI = qgr["iouThreshold"], qgb = qgr["scoreThreshold"];
  const qgQ = { "maxOutputSize": qgL, "iouThreshold": qgI, "scoreThreshold": qgb };
  return fM["runKernel"](pW, { "boxes": qgR, "scores": qgo }, qgQ);
}
var cB = fL({ "nonMaxSuppression_": cK });
function cV(qgu, qgj, qgL) {
  const qgI = cJ(qgu, qgj, qgL), qgb = qgI < 0 ? -(qgI + 1) : qgI;
  qgu["splice"](qgb, 0, qgj);
}
function cJ(qgu, qgj, qgL) {
  return cP(qgu, qgj, qgL || cY);
}
function cY(qgu, qgj) {
  return qgu > qgj ? 1 : qgu < qgj ? -1 : 0;
}
function cP(qgu, qgj, qgL) {
  let qgI = 0, qgb = qgu["length"], qgR = 0, qgo = false;
  for (; qgI < qgb; ) {
    qgR = qgI + (qgb - qgI >>> 1);
    const qgr = qgL(qgj, qgu[qgR]);
    qgr > 0 ? qgI = qgR + 1 : (qgb = qgR, qgo = !qgr);
  }
  return qgo ? qgI : -qgI - 1;
}
function cU(qgu, qgj, qgL, qgI, qgb) {
  return Xn(qgu, qgj, qgL, qgI, qgb, 0);
}
function X6(qgu, qgj, qgL, qgI, qgb, qgR) {
  return Xn(qgu, qgj, qgL, qgI, qgb, 0, false, qgR, true);
}
function Xq(qgu, qgj, qgL, qgI, qgb, qgR) {
  return Xn(qgu, qgj, qgL, qgI, qgb, qgR, true);
}
function Xn(qgu, qgj, qgL, qgI, qgb, qgR, qgo = false, qgr = false, qgQ = false) {
  const qgd = [];
  for (let qgT = 0; qgT < qgj["length"]; qgT++) qgj[qgT] > qgb && qgd["push"]({ "score": qgj[qgT], "boxIndex": qgT, "suppressBeginIndex": 0 });
  qgd["sort"](Xt);
  const qgv = qgR > 0 ? -0.5 / qgR : 0, qgy = [], qgl = [];
  for (; qgy["length"] < qgL && qgd["length"] > 0; ) {
    const qgK = qgd["pop"](), { score: qgB, boxIndex: qgV, suppressBeginIndex: qgJ } = qgK;
    if (qgB < qgb) break;
    let qgY = false;
    for (let qgP = qgy["length"] - 1; qgP >= qgJ; --qgP) {
      const qgU = XM(qgu, qgV, qgy[qgP]);
      if (qgU >= qgI) {
        qgY = true;
        break;
      }
      if (qgK["score"] = qgK["score"] * XF(qgI, qgv, qgU), qgK["score"] <= qgb) break;
    }
    qgK["suppressBeginIndex"] = qgy["length"], qgY || (qgK["score"] === qgB ? (qgy["push"](qgV), qgl["push"](qgK["score"])) : qgK["score"] > qgb && cV(qgd, qgK, Xt));
  }
  const qgH = qgy["length"], qgA = qgL - qgH;
  qgr && qgA > 0 && (qgy["push"](...new Array(qgA)["fill"](0)), qgl["push"](...new Array(qgA)["fill"](0)));
  const qgh = { "selectedIndices": qgy };
  return qgo && (qgh["selectedScores"] = qgl), qgQ && (qgh["validOutputs"] = qgH), qgh;
}
function XM(qgu, qgj, qgL) {
  const qgI = qgu["subarray"](qgj * 4, qgj * 4 + 4), qgb = qgu["subarray"](qgL * 4, qgL * 4 + 4), qgR = Math["min"](qgI[0], qgI[2]), qgo = Math["min"](qgI[1], qgI[3]), qgr = Math["max"](qgI[0], qgI[2]), qgQ = Math["max"](qgI[1], qgI[3]), qgd = Math["min"](qgb[0], qgb[2]), qgv = Math["min"](qgb[1], qgb[3]), qgy = Math["max"](qgb[0], qgb[2]), qgl = Math["max"](qgb[1], qgb[3]), qgH = (qgr - qgR) * (qgQ - qgo), qgA = (qgy - qgd) * (qgl - qgv);
  if (qgH <= 0 || qgA <= 0) return 0;
  const qgh = Math["max"](qgR, qgd), qgT = Math["max"](qgo, qgv), qgK = Math["min"](qgr, qgy), qgB = Math["min"](qgQ, qgl), qgV = Math["max"](qgK - qgh, 0) * Math["max"](qgB - qgT, 0);
  return qgV / (qgH + qgA - qgV);
}
function XF(qgu, qgj, qgL) {
  const qgI = Math["exp"](qgj * qgL * qgL);
  return qgL <= qgu ? qgI : 0;
}
function Xt(qgu, qgj) {
  return qgu["score"] - qgj["score"] || qgu["score"] === qgj["score"] && qgj["boxIndex"] - qgu["boxIndex"];
}
async function XW(qgu, qgj, qgL, qgI = 0.5, qgb = Number["NEGATIVE_INFINITY"]) {
  const qgR = fG(qgu, "boxes", "nonMaxSuppressionAsync"), qgo = fG(qgj, "scores", "nonMaxSuppressionAsync"), qgr = cH(qgR, qgo, qgL, qgI, qgb);
  qgL = qgr["maxOutputSize"], qgI = qgr["iouThreshold"], qgb = qgr["scoreThreshold"];
  const qgQ = await Promise["all"]([qgR["data"](), qgo["data"]()]), qgd = qgQ[0], qgv = qgQ[1], { selectedIndices: qgy } = cU(qgd, qgv, qgL, qgI, qgb);
  return qgR !== qgu && qgR["dispose"](), qgo !== qgj && qgo["dispose"](), zz(qgy, "int32");
}
var XD = XW;
function Xa(qgu, qgj, qgL, qgI = 0.5, qgb = Number["NEGATIVE_INFINITY"], qgR = 0) {
  const qgo = fG(qgu, "boxes", "nonMaxSuppression"), qgr = fG(qgj, "scores", "nonMaxSuppression"), qgQ = cH(qgo, qgr, qgL, qgI, qgb, qgR);
  qgL = qgQ["maxOutputSize"], qgI = qgQ["iouThreshold"], qgb = qgQ["scoreThreshold"], qgR = qgQ["softNmsSigma"];
  const qgd = { "boxes": qgo, "scores": qgr }, qgv = { "maxOutputSize": qgL, "iouThreshold": qgI, "scoreThreshold": qgb, "softNmsSigma": qgR }, qgy = fM["runKernel"](pa, qgd, qgv);
  return { "selectedIndices": qgy[0], "selectedScores": qgy[1] };
}
var XZ = fL({ "nonMaxSuppressionWithScore_": Xa });
async function Xz(qgu, qgj, qgL, qgI = 0.5, qgb = Number["NEGATIVE_INFINITY"], qgR = 0) {
  const qgo = fG(qgu, "boxes", "nonMaxSuppressionAsync"), qgr = fG(qgj, "scores", "nonMaxSuppressionAsync"), qgQ = cH(qgo, qgr, qgL, qgI, qgb, qgR);
  qgL = qgQ["maxOutputSize"], qgI = qgQ["iouThreshold"], qgb = qgQ["scoreThreshold"], qgR = qgQ["softNmsSigma"];
  const qgd = await Promise["all"]([qgo["data"](), qgr["data"]()]), qgv = qgd[0], qgy = qgd[1], { selectedIndices: qgl, selectedScores: qgH } = Xq(qgv, qgy, qgL, qgI, qgb, qgR);
  return qgo !== qgu && qgo["dispose"](), qgr !== qgj && qgr["dispose"](), { "selectedIndices": zz(qgl, "int32"), "selectedScores": zz(qgH) };
}
var XX = Xz;
function XG(qgu, qgj, qgL, qgI = 0.5, qgb = Number["NEGATIVE_INFINITY"], qgR = false) {
  const qgo = fG(qgu, "boxes", "nonMaxSuppression"), qgr = fG(qgj, "scores", "nonMaxSuppression"), qgQ = cH(qgo, qgr, qgL, qgI, qgb, null), qgd = qgQ["maxOutputSize"], qgv = qgQ["iouThreshold"], qgy = qgQ["scoreThreshold"], qgl = { "boxes": qgo, "scores": qgr }, qgH = { "maxOutputSize": qgd, "iouThreshold": qgv, "scoreThreshold": qgy, "padToMaxOutputSize": qgR }, qgA = fM["runKernel"](pD, qgl, qgH);
  return { "selectedIndices": qgA[0], "validOutputs": qgA[1] };
}
var Xj = fL({ "nonMaxSuppressionPadded_": XG });
async function XL(qgu, qgj, qgL, qgI = 0.5, qgb = Number["NEGATIVE_INFINITY"], qgR = false) {
  const qgo = fG(qgu, "boxes", "nonMaxSuppressionAsync"), qgr = fG(qgj, "scores", "nonMaxSuppressionAsync"), qgQ = cH(qgo, qgr, qgL, qgI, qgb, null), qgd = qgQ["maxOutputSize"], qgv = qgQ["iouThreshold"], qgy = qgQ["scoreThreshold"], [qgl, qgH] = await Promise["all"]([qgo["data"](), qgr["data"]()]), { selectedIndices: qgA, validOutputs: qgh } = X6(qgl, qgH, qgd, qgv, qgy, qgR);
  return qgo !== qgu && qgo["dispose"](), qgr !== qgj && qgr["dispose"](), { "selectedIndices": zz(qgA, "int32"), "validOutputs": aL(qgh, "int32") };
}
var XR = XL;
function Xo(qgu, qgj, qgL = false, qgI = false) {
  const qgb = fG(qgu, "images", "resizeBilinear");
  k(qgb["rank"] === 3 || qgb["rank"] === 4, () => "Error in resizeBilinear: x must be rank 3 or 4, but got rank " + qgb["rank"] + "."), k(qgj["length"] === 2, () => "Error in resizeBilinear: new shape must 2D, but got shape " + qgj + "."), k(qgI === false || qgL === false, () => "Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");
  let qgR = qgb, qgo = false;
  qgb["rank"] === 3 && (qgo = true, qgR = DW(qgb, [1, qgb["shape"][0], qgb["shape"][1], qgb["shape"][2]]));
  const qgr = { "images": qgR }, qgQ = { "alignCorners": qgL, "halfPixelCenters": qgI, "size": qgj }, qgd = fM["runKernel"](pr, qgr, qgQ);
  return qgo ? DW(qgd, [qgd["shape"][1], qgd["shape"][2], qgd["shape"][3]]) : qgd;
}
var XQ = fL({ "resizeBilinear_": Xo });
function XH(qgu, qgj, qgL = false, qgI = false) {
  const qgb = fG(qgu, "images", "resizeNearestNeighbor");
  k(qgb["rank"] === 3 || qgb["rank"] === 4, () => "Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank " + qgb["rank"] + "."), k(qgj["length"] === 2, () => "Error in resizeNearestNeighbor: new shape must 2D, but got shape " + qgj + "."), k(qgb["dtype"] === "float32" || qgb["dtype"] === "int32", () => "`images` must have `int32` or `float32` as dtype"), k(qgI === false || qgL === false, () => "Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");
  let qgR = qgb, qgo = false;
  qgb["rank"] === 3 && (qgo = true, qgR = DW(qgb, [1, qgb["shape"][0], qgb["shape"][1], qgb["shape"][2]]));
  const qgr = { "images": qgR }, qgQ = { "alignCorners": qgL, "halfPixelCenters": qgI, "size": qgj }, qgd = fM["runKernel"](po, qgr, qgQ);
  return qgo ? DW(qgd, [qgd["shape"][1], qgd["shape"][2], qgd["shape"][3]]) : qgd;
}
var XK = fL({ "resizeNearestNeighbor_": XH });
function XB(qgu, qgj = "binary", qgL = false, qgI = 0.5) {
  const qgb = fG(qgu, "image", "threshold"), qgR = 0.2989, qgo = 0.587, qgr = 0.114, qgQ = qgb["shape"][0] * qgb["shape"][1];
  let qgd = it(zz([qgI]), 255), qgv, qgy, qgl, qgH;
  if (k(qgb["rank"] === 3, () => "Error in threshold: image must be rank 3,but got rank " + qgb["rank"] + "."), k(qgb["shape"][2] === 3 || qgb["shape"][2] === 1, () => "Error in threshold: image color channel must be equal to 3 or 1but got " + qgb["shape"][2] + "."), k(qgb["dtype"] === "int32" || qgb["dtype"] === "float32", () => "Error in dtype: image dtype must be int32 or float32,but got dtype " + qgb["dtype"] + "."), k(qgj === "otsu" || qgj === "binary", () => "Method must be binary or otsu, but was " + qgj), qgb["shape"][2] === 3) {
    [qgv, qgy, qgl] = eP(qgb, [1, 1, 1], -1);
    const qgh = it(qgv, qgR), qgT = it(qgy, qgo), qgK = it(qgl, qgr);
    qgH = WY(WY(qgh, qgT), qgK);
  } else qgH = qgu;
  if (qgj === "otsu") {
    const qgB = DB(OM(eH(qgH), "int32"), fB([]), 256);
    qgd = XV(qgB, qgQ);
  }
  const qgA = qgL ? Zr(qgH, qgd) : ZX(qgH, qgd);
  return OM(it(qgA, 255), "int32");
}
function XV(qgu, qgj) {
  let qgL = zz([-1]), qgI = zz([0]), qgb = zz([0]), qgR, qgo, qgr, qgQ, qgd, qgv;
  for (let qgy = 0; qgy < qgu["size"] - 1; qgy++) {
    qgR = DH(qgu, 0, qgy + 1), qgo = DH(qgu, qgy + 1), qgd = iM(aB(qgR), qgj), qgv = iM(aB(qgo), qgj);
    const qgl = aB(it(qgR, eX(0, qgR["size"])));
    qgr = iM(qgl, aB(qgR));
    const qgH = DP(qgo["shape"], qgR["size"]), qgA = WY(eX(0, qgo["size"]), qgH), qgh = it(qgo, qgA);
    qgQ = iM(aB(qgh), aB(qgo));
    const qgT = ZK(qgr, qgQ), qgK = ZK(qgr, qgQ), qgB = it(qgd, qgv);
    qgb = it(it(qgB, qgT), qgK);
    const qgV = ZX(qgb, qgI);
    qgI = mQ(qgV, qgb, qgI), qgL = mQ(qgV, zz([qgy]), qgL);
  }
  return qgL;
}
var XJ = fL({ "threshold_": XB });
function XY(qgu, qgj, qgL = "nearest", qgI = "constant", qgb = 0, qgR) {
  const qgo = fG(qgu, "image", "transform", "float32"), qgr = fG(qgj, "transforms", "transform", "float32");
  k(qgo["rank"] === 4, () => "Error in transform: image must be rank 4,but got rank " + qgo["rank"] + "."), k(qgr["rank"] === 2 && (qgr["shape"][0] === qgo["shape"][0] || qgr["shape"][0] === 1) && qgr["shape"][1] === 8, () => "Error in transform: Input transform should be batch x 8 or 1 x 8"), k(qgR == null || qgR["length"] === 2, () => "Error in transform: outputShape must be [height, width] or null, but got " + qgR + ".");
  const qgQ = { "image": qgo, "transforms": qgr }, qgd = { "interpolation": qgL, "fillMode": qgI, "fillValue": qgb, "outputShape": qgR };
  return fM["runKernel"](gW, qgQ, qgd);
}
var XP = fL({ "transform_": XY });
var XU;
(function(qgu) {
  qgu[qgu["NONE"] = 0] = "NONE", qgu[qgu["MEAN"] = 1] = "MEAN", qgu[qgu["SUM"] = 2] = "SUM", qgu[qgu["SUM_BY_NONZERO_WEIGHTS"] = 3] = "SUM_BY_NONZERO_WEIGHTS";
})(XU || (XU = {}));
var Gq = { "flipLeftRight": cG, "grayscaleToRGB": cj, "resizeNearestNeighbor": XK, "resizeBilinear": XQ, "rgbToGrayscale": co, "rotateWithOffset": cQ, "cropAndResize": cz, "nonMaxSuppression": cB, "nonMaxSuppressionAsync": XD, "nonMaxSuppressionWithScore": XZ, "nonMaxSuppressionWithScoreAsync": XX, "nonMaxSuppressionPadded": Xj, "nonMaxSuppressionPaddedAsync": XR, "threshold": XJ, "transform": XP };
var GM = typeof requestAnimationFrame != "undefined" ? requestAnimationFrame : typeof setImmediate != "undefined" ? setImmediate : (qgu) => qgu();
function GF() {
  return new Promise((qgu) => GM(() => qgu()));
}
function GW(qgu, qgj) {
  const qgL = qgu[0]["length"];
  qgu["forEach"]((qgb, qgR) => {
    k(qgb["length"] === qgL, () => "Error in concat" + qgL + "D: rank of tensors[" + qgR + "] must be the same as the rank of the rest (" + qgL + ")");
  }), k(qgj >= 0 && qgj < qgL, () => "Error in concat" + qgL + "D: axis must be between 0 and " + (qgL - 1) + ".");
  const qgI = qgu[0];
  qgu["forEach"]((qgb, qgR) => {
    for (let qgo = 0; qgo < qgL; qgo++) k(qgo === qgj || qgb[qgo] === qgI[qgo], () => "Error in concat" + qgL + "D: Shape of tensors[" + qgR + "] (" + qgb + ") does not match the shape of the rest (" + qgI + ") along the non-concatenated axis " + qgR + ".");
  });
}
function GD(qgu, qgj) {
  const qgL = qgu[0]["slice"]();
  for (let qgI = 1; qgI < qgu["length"]; qgI++) qgL[qgj] += qgu[qgI][qgj];
  return qgL;
}
var GZ;
(function(qgu) {
  qgu[qgu["FIRST_DIM_SIZE"] = 0] = "FIRST_DIM_SIZE", qgu[qgu["VALUE_ROWIDS"] = 1] = "VALUE_ROWIDS", qgu[qgu["ROW_LENGTHS"] = 2] = "ROW_LENGTHS", qgu[qgu["ROW_SPLITS"] = 3] = "ROW_SPLITS", qgu[qgu["ROW_LIMITS"] = 4] = "ROW_LIMITS", qgu[qgu["ROW_STARTS"] = 5] = "ROW_STARTS";
})(GZ || (GZ = {}));
function Ge(qgu, qgj, qgL) {
  let qgI = new Array();
  if (qgL == null && qgj == null) return qgI;
  if (qgj == null) {
    for (; qgI["length"] < qgu + qgL["length"]; ) qgI["push"](-1);
  } else qgI = qgj["slice"]();
  if (qgL == null) return qgI;
  if (qgu + qgL["length"] !== qgI["length"]) throw new Error("rt input.shape and shape=" + qgj + " are incompatible: rt input.rank = " + (qgu + qgL["length"]) + ", but shape.rank = " + qgI["length"]);
  for (let qgb = 1; qgb < qgL["length"]; ++qgb) {
    const qgR = qgL[qgb], qgo = qgI[qgI["length"] - qgL["length"] + qgb], qgr = qgI[qgo];
    if (qgR >= 0) {
      if (qgr >= 0) {
        if (qgr !== qgR) throw new Error("rt input.shape and shape=" + qgj + " are incompatible: rt input.shape[" + (qgb + qgu) + "] = " + qgR + " but shape[" + (qgb + qgu) + "] = " + qgr);
      } else qgI[qgo] = qgR;
    }
  }
  return qgI;
}
function Gz(qgu) {
  const qgj = { "FIRST_DIM_SIZE": GZ["FIRST_DIM_SIZE"], "VALUE_ROWIDS": GZ["VALUE_ROWIDS"], "ROW_LENGTHS": GZ["ROW_LENGTHS"], "ROW_SPLITS": GZ["ROW_SPLITS"], "ROW_LIMITS": GZ["ROW_LIMITS"], "ROW_STARTS": GZ["ROW_STARTS"] }, qgL = [];
  for (const qgI of qgu) if (qgI in qgj) qgL["push"](qgj[qgI]);
  else break;
  return qgL;
}
function GX(qgu) {
  return qgu["length"] === 0 ? 0 : qgu[0] === GZ["FIRST_DIM_SIZE"] ? qgu["length"] - 1 : qgu["length"];
}
function GG(qgu, qgj) {
  if (qgu == null || qgj == null) return;
  const qgL = qgu["length"], qgI = qgj["length"];
  if (qgL >= qgI) throw new Error("defaultValue.shape=" + qgu + " and ragged tensor flatValues.shape=" + qgj + ", are incompatible: defaultValue.rank = " + qgL + " must be less than ragged tensor input flatValues.rank = " + qgI + ")");
  for (let qgb = 0; qgb < Math["min"](qgL, qgI - 1); ++qgb) {
    const qgR = qgu[qgb], qgo = qgj[qgb + 1];
    if (qgR >= 0 && qgo >= 0 && qgR !== 1 && qgR !== qgo) throw new Error("defaultValue.shape=" + qgu + ", and ragged tensor input flatValues.shape=" + qgj + " are incompatible: defaultValue.shape[" + (qgb - qgu["length"]) + "] = " + qgR + " but ragged tensor input.flatValues.shape[" + (qgb - qgu["length"]) + "] = " + qgo);
  }
}
var Gj = 30;
function GL(qgu) {
  return qgu <= Gj ? qgu : v(qgu, Math["floor"](Math["sqrt"](qgu)));
}
function GR(qgu, qgj, qgL) {
  const qgI = qgL * (typeof qgu == "number" ? qgu : qgu[0]), qgb = qgj * (typeof qgu == "number" ? qgu : qgu[1]);
  return [qgI, qgb];
}
function GQ(qgu, qgj, qgL, qgI = true) {
  let qgb = [];
  if (qgI) qgb = qgb["concat"](qgj["slice"](0)), qgb["push"](qgu[0] / qgL), qgb = qgb["concat"](qgu["slice"](1));
  else {
    qgb = qgb["concat"](qgu[0]);
    const qgR = qgj["length"];
    for (let qgo = 0; qgo < qgR; ++qgo) qgb = qgb["concat"]([qgu[qgo + 1] / qgj[qgo], qgj[qgo]]);
    qgb = qgb["concat"](qgu["slice"](qgR + 1));
  }
  return qgb;
}
function GH(qgu, qgj, qgL = true) {
  const qgI = [];
  if (qgL) {
    qgI["push"](qgj);
    for (let qgb = qgj + 1; qgb < qgu; ++qgb) qgb <= 2 * qgj ? (qgI["push"](qgb), qgI["push"](qgb - (qgj + 1))) : qgI["push"](qgb);
  } else {
    const qgR = [], qgo = [];
    for (let qgr = 1; qgr < qgu; ++qgr) qgr >= qgj * 2 + 1 || qgr % 2 === 1 ? qgo["push"](qgr) : qgR["push"](qgr);
    qgI["push"](...qgR), qgI["push"](0), qgI["push"](...qgo);
  }
  return qgI;
}
function GK(qgu, qgj, qgL, qgI = true) {
  const qgb = [];
  qgI ? qgb["push"](qgu[0] / qgL) : qgb["push"](qgu[0] * qgL);
  for (let qgR = 1; qgR < qgu["length"]; ++qgR) qgR <= qgj["length"] ? qgI ? qgb["push"](qgj[qgR - 1] * qgu[qgR]) : qgb["push"](qgu[qgR] / qgj[qgR - 1]) : qgb["push"](qgu[qgR]);
  return qgb;
}
function GB(qgu, qgj) {
  const qgL = [0];
  for (let qgI = 0; qgI < qgj; ++qgI) qgL["push"](qgu[qgI][0]);
  return qgL;
}
function GV(qgu, qgj, qgL) {
  const qgI = qgu["slice"](0, 1);
  for (let qgb = 0; qgb < qgL; ++qgb) qgI["push"](qgu[qgb + 1] - qgj[qgb][0] - qgj[qgb][1]);
  return qgI;
}
var GJ = 1.7580993408473768;
var GY = 1.0507009873554805;
var GP = 0.3275911;
var GU = 0.254829592;
var Nq = -0.284496736;
var Nn = 1.421413741;
var NM = -1.453152027;
var NF = 1.061405429;
function Nt(qgu, qgj) {
  if (qgu["length"] !== qgj["length"]) throw new Error("Cannot merge real and imag arrays of different lengths. real:" + qgu["length"] + ", imag: " + qgj["length"] + ".");
  const qgL = new Float32Array(qgu["length"] * 2);
  for (let qgI = 0; qgI < qgL["length"]; qgI += 2) qgL[qgI] = qgu[qgI / 2], qgL[qgI + 1] = qgj[qgI / 2];
  return qgL;
}
function NW(qgu) {
  const qgj = new Float32Array(qgu["length"] / 2), qgL = new Float32Array(qgu["length"] / 2);
  for (let qgI = 0; qgI < qgu["length"]; qgI += 2) qgj[qgI / 2] = qgu[qgI], qgL[qgI / 2] = qgu[qgI + 1];
  return { "real": qgj, "imag": qgL };
}
function ND(qgu) {
  const qgj = Math["ceil"](qgu["length"] / 4), qgL = new Float32Array(qgj), qgI = new Float32Array(qgj);
  for (let qgb = 0; qgb < qgu["length"]; qgb += 4) qgL[Math["floor"](qgb / 4)] = qgu[qgb], qgI[Math["floor"](qgb / 4)] = qgu[qgb + 1];
  return { "real": qgL, "imag": qgI };
}
function NZ(qgu) {
  const qgj = Math["floor"](qgu["length"] / 4), qgL = new Float32Array(qgj), qgI = new Float32Array(qgj);
  for (let qgb = 2; qgb < qgu["length"]; qgb += 4) qgL[Math["floor"](qgb / 4)] = qgu[qgb], qgI[Math["floor"](qgb / 4)] = qgu[qgb + 1];
  return { "real": qgL, "imag": qgI };
}
function Nz(qgu, qgj) {
  const qgL = qgu[qgj * 2], qgI = qgu[qgj * 2 + 1];
  return { "real": qgL, "imag": qgI };
}
function NX(qgu, qgj, qgL, qgI) {
  qgu[qgI * 2] = qgj, qgu[qgI * 2 + 1] = qgL;
}
function NG(qgu, qgj) {
  const qgL = new Float32Array(qgu / 2), qgI = new Float32Array(qgu / 2);
  for (let qgb = 0; qgb < Math["ceil"](qgu / 2); qgb++) {
    const qgR = (qgj ? 2 : -2) * Math["PI"] * (qgb / qgu);
    qgL[qgb] = Math["cos"](qgR), qgI[qgb] = Math["sin"](qgR);
  }
  return { "real": qgL, "imag": qgI };
}
function Nu(qgu, qgj, qgL) {
  const qgI = (qgL ? 2 : -2) * Math["PI"] * (qgu / qgj), qgb = Math["cos"](qgI), qgR = Math["sin"](qgI);
  return { "real": qgb, "imag": qgR };
}
var Nj = "->";
var NL = /->/g;
var NR = ",";
var NQ = "...";
function NH(qgu, qgj) {
  qgu = qgu["replace"](/\s/g, "");
  const qgL = (qgu["length"] - qgu["replace"](NL, "")["length"]) / Nj["length"];
  if (qgL < 1) throw new Error("Equations without an arrow are not supported.");
  if (qgL > 1) throw new Error('Equation must contain exactly one arrow ("' + Nj + '").');
  const [qgI, qgb] = qgu["split"](Nj);
  k(qgI["indexOf"](NQ) === -1, () => 'The ellipsis notation ("' + NQ + '") is not supported yet.');
  const qgR = qgI["split"](NR), qgo = qgR["length"];
  if (qgj !== qgo) throw new Error("Expected " + qgo + " input tensors, received " + qgj);
  if (qgo > 2) throw new Error("Support for more than 2 input tensors is not implemented yet.");
  const qgr = [];
  for (let qgl = 0; qgl < qgb["length"]; ++qgl) {
    const qgH = qgb[qgl];
    if (!qgR["some"]((qgA) => qgA["indexOf"](qgH) !== -1)) throw new Error("Output subscripts contain the label " + qgH + " not present in the input subscripts.");
    qgr["indexOf"](qgH) === -1 && qgr["push"](qgH);
  }
  for (let qgA = 0; qgA < qgI["length"]; ++qgA) {
    const qgh = qgI[qgA];
    qgr["indexOf"](qgh) === -1 && qgh !== NR && qgr["push"](qgh);
  }
  const qgQ = new Array(qgR["length"]);
  for (let qgT = 0; qgT < qgo; ++qgT) {
    if (new Set(qgR[qgT]["split"](""))["size"] !== qgR[qgT]["length"]) throw new Error("Found duplicate axes in input component " + qgR[qgT] + ". Support for duplicate axes in input is not implemented yet.");
    qgQ[qgT] = [];
    for (let qgK = 0; qgK < qgR[qgT]["length"]; ++qgK) qgQ[qgT]["push"](qgr["indexOf"](qgR[qgT][qgK]));
  }
  const qgd = qgr["length"], qgv = qgb["length"], qgy = [];
  for (let qgB = qgv; qgB < qgd; ++qgB) qgy["push"](qgB);
  return { "allDims": qgr, "summedDims": qgy, "idDims": qgQ };
}
function NK(qgu, qgj) {
  let qgL = new Array(qgu);
  qgL["fill"](-1);
  for (let qgb = 0; qgb < qgj["length"]; ++qgb) qgL[qgj[qgb]] = qgb;
  const qgI = [];
  for (let qgR = 0; qgR < qgu; ++qgR) qgL[qgR] === -1 && qgI["push"](qgR);
  return qgL = qgL["filter"]((qgo) => qgo !== -1), { "permutationIndices": qgL, "expandDims": qgI };
}
function NB(qgu, qgj, qgL) {
  const qgI = new Array(qgu);
  for (let qgb = 0; qgb < qgL["length"]; ++qgb) {
    const qgR = qgL[qgb]["shape"];
    for (let qgo = 0; qgo < qgj[qgb]["length"]; ++qgo) qgI[qgj[qgb][qgo]] === void 0 ? qgI[qgj[qgb][qgo]] = qgR[qgo] : k(qgI[qgj[qgb][qgo]] === qgR[qgo], () => "Expected dimension " + qgI[qgj[qgb][qgo]] + " at axis " + qgo + " of input shaped " + JSON["stringify"](qgR) + ", but got dimension " + qgR[qgo]);
  }
}
function NV(qgu, qgj) {
  const qgL = qgu, qgI = [];
  let qgb = 0;
  qgu["length"] === 0 && qgL["push"](-1), qgb = qgu["length"] + 1;
  for (let qgo = 0; qgo < qgb; ++qgo) qgI["push"]([]);
  const qgR = [];
  for (let qgr = 0; qgr < qgL["length"]; ++qgr) {
    const qgQ = qgL[qgr], qgd = NY(qgj, qgQ);
    for (const qgv of qgd) qgR["indexOf"](qgv) === -1 && (qgI[qgr]["push"](qgv), qgR["push"](qgv));
  }
  return { "path": qgL, "steps": qgI };
}
function NJ(qgu) {
  return qgu["every"]((qgj, qgL) => qgj === qgL);
}
function NY(qgu, qgj) {
  const qgL = [];
  for (let qgI = 0; qgI < qgu["length"]; ++qgI) (qgu[qgI]["length"] === 0 || qgu[qgI]["indexOf"](qgj) !== -1 || qgj === -1) && qgL["push"](qgI);
  return qgL;
}
function NP(qgu, qgj, qgL = 0) {
  let qgI = [];
  if (typeof qgj == "number") k(qgu["shape"][qgL] % qgj === 0, () => "Number of splits must evenly divide the axis."), qgI = new Array(qgj)["fill"](qgu["shape"][qgL] / qgj);
  else {
    const qgb = qgj["reduce"]((qgo, qgr) => (qgr === -1 && (qgo += 1), qgo), 0);
    k(qgb <= 1, () => "There should be only one negative value in split array.");
    const qgR = qgj["indexOf"](-1);
    if (qgR !== -1) {
      const qgo = qgj["reduce"]((qgr, qgQ) => qgQ > 0 ? qgr + qgQ : qgr);
      qgj[qgR] = qgu["shape"][qgL] - qgo;
    }
    k(qgu["shape"][qgL] === qgj["reduce"]((qgr, qgQ) => qgr + qgQ), () => "The sum of sizes must match the size of the axis dimension."), qgI = qgj;
  }
  return qgI;
}
function NU(qgu) {
  return "Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = " + qgu;
}
function uq(qgu, qgj) {
  return "indices(" + qgu + ", 0) is invalid: " + qgj + " < 0";
}
function uM(qgu, qgj, qgL) {
  return "indices(" + qgu + ", 0) is invalid: " + qgj + " >= " + qgL;
}
function uF(qgu, qgj) {
  return "only one output dimension may be -1, not both " + qgu + " and " + qgj;
}
function ut(qgu, qgj) {
  return "size " + qgu + " must be non-negative, not " + qgj;
}
function uW() {
  return "reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero";
}
function uD(qgu, qgj) {
  const qgL = i2(qgu), qgI = i2(qgj);
  return "Input to reshape is a SparseTensor with " + qgL + "\n  dense values, but the requested shape requires a multiple of " + qgI + ". inputShape=" + qgu + " outputShape= " + qgj;
}
function ua(qgu, qgj) {
  const qgL = i2(qgu), qgI = i2(qgj);
  return "Input to reshape is a tensor with " + qgL + " dense values, but the requested shape has " + qgI + ". inputShape=" + qgu + " outputShape=" + qgj;
}
function uZ() {
  return "segment ids must be >= 0";
}
function ue() {
  return "segment ids are not increasing";
}
function uz(qgu, qgj) {
  return "Segment id " + qgu + " out of range [0, " + qgj + "), possibly because segmentIds input is not sorted.";
}
function uX(qgu, qgj, qgL) {
  return "Bad: indices[" + qgu + "] == " + qgj + " out of range [0, " + qgL + ")";
}
function uG(qgu, qgj) {
  let qgL = false, qgI;
  for (qgu <= Gj ? (qgI = qgu, qgL = true) : qgI = v(qgu, Math["floor"](Math["sqrt"](qgu))); !qgL; ) qgI > qgj || qgI === qgu ? qgL = true : qgI = v(qgu, qgI + 1);
  return qgI;
}
function uu(qgu, qgj, qgL) {
  const qgI = [], qgb = qgu["length"];
  for (let qgR = 0; qgR < qgb; qgR++) qgR !== qgj ? qgI["push"](qgu[qgR]) : qgI["push"](qgL);
  return qgI;
}
function uj(qgu, qgj, qgL, qgI) {
  const qgb = qgj["shape"]["length"], qgR = qgu["shape"]["length"];
  if (qgI !== 0 && (qgI < -qgb || qgI > qgb)) throw new Error("Expect batchDims in the range of [-" + qgb + ", " + qgb + "], but got " + qgI);
  if (qgI < 0 && (qgI += qgb), qgI > qgR) throw new Error("batchDims (" + qgI + ") must be less than rank(x) (\n    " + qgR + ").");
  if (qgL < qgI) throw new Error("batchDims (" + qgI + ") must be less than or equal to axis (" + qgL + ").");
  for (let qgy = 0; qgy < qgI; ++qgy) if (qgu["shape"][qgy] !== qgj["shape"][qgy]) throw new Error("x.shape[" + qgy + "]: " + qgu["shape"][qgy] + " should be equal to indices.shape[" + qgy + "]: " + qgj["shape"][qgy] + ".");
  const qgo = qgu["shape"][qgL], qgr = [];
  let qgQ = 1, qgd = 1, qgv = 1;
  for (let qgl = 0; qgl < qgI; ++qgl) qgr["push"](qgu["shape"][qgl]), qgQ *= qgu["shape"][qgl];
  for (let qgH = qgI; qgH < qgL; qgH++) qgr["push"](qgu["shape"][qgH]), qgd *= qgu["shape"][qgH];
  for (let qgA = qgI; qgA < qgb; qgA++) qgr["push"](qgj["shape"][qgA]);
  for (let qgh = qgL + 1; qgh < qgR; qgh++) qgr["push"](qgu["shape"][qgh]), qgv *= qgu["shape"][qgh];
  return { "batchSize": qgQ, "sliceSize": qgv, "outerSize": qgd, "dimSize": qgo, "outputShape": qgr };
}
var uL = Object["freeze"]({ "__proto__": null, "collectGatherOpShapeInfo": uj, "computeOutShape": uu, "segOpComputeOptimalWindowSize": uG });
function uo(qgu) {
  try {
    return qgu["map"]((qgj) => EW(qgj));
  } catch (qgj) {
    throw new Error("Failed to decode encoded string bytes into utf-8, error: " + qgj);
  }
}
function ur(qgu) {
  return qgu["map"]((qgj) => Et(qgj));
}
var uQ = Object["freeze"]({ "__proto__": null, "ERF_A1": GU, "ERF_A2": Nq, "ERF_A3": Nn, "ERF_A4": NM, "ERF_A5": NF, "ERF_P": GP, "PARALLELIZE_THRESHOLD": Gj, get "RowPartitionType"() {
  return GZ;
}, "SELU_SCALE": GY, "SELU_SCALEALPHA": GJ, "applyActivation": zV, "assertAndGetBroadcastShape": OR, "assertAxesAreInnerMostDims": aF, "assertParamsConsistent": GW, "assignToTypedArray": NX, "axesAreInnerMostDims": mP, "calculateShapes": OY, "checkEinsumDimSizes": NB, "checkPadOnDimRoundingMode": DM, "combineLocations": mU, "combineRaggedTensorToTensorShapes": Ge, "complexWithEvenIndex": ND, "complexWithOddIndex": NZ, "computeConv2DInfo": ij, "computeConv3DInfo": iL, "computeDefaultPad": iQ, "computeDilation2DInfo": iX, "computeOptimalWindowSize": GL, "computeOutAndReduceShapes": aq, "computeOutShape": GD, "computePool2DInfo": iG, "computePool3DInfo": iu, "convertConv2DDataFormat": Ds, "decodeEinsumEquation": NH, "eitherStridesOrDilationsAreOne": iU, "expandShapeToKeepDim": aM, "exponent": Nu, "exponents": NG, "fromStringArrayToUint8": ur, "fromUint8ToStringArray": uo, "getAxesPermutation": at, "getBroadcastDims": Oj, "getComplexWithIndex": Nz, "getEinsumComputePath": NV, "getEinsumPermutation": NK, "getFusedBiasGradient": zB, "getFusedDyActivation": zK, "getImageCenter": GR, "getInnerMostAxes": aD, "getPermuted": GH, "getRaggedRank": GX, "getReductionAxes": OL, "getReshaped": GQ, "getReshapedPermuted": GK, "getRowPartitionTypesHelper": Gz, "getSliceBeginCoords": GB, "getSliceSize": GV, "getSparseFillEmptyRowsIndicesDenseShapeMismatch": NU, "getSparseFillEmptyRowsNegativeIndexErrorMessage": uq, "getSparseFillEmptyRowsOutOfRangeIndexErrorMessage": uM, "getSparseReshapeEmptyTensorZeroOutputDimErrorMessage": uW, "getSparseReshapeInputOutputMismatchErrorMessage": ua, "getSparseReshapeInputOutputMultipleErrorMessage": uD, "getSparseReshapeMultipleNegativeOneOutputDimErrorMessage": uF, "getSparseReshapeNegativeOutputDimErrorMessage": ut, "getSparseSegmentReductionIndicesOutOfRangeErrorMessage": uX, "getSparseSegmentReductionNegativeSegmentIdsErrorMessage": uZ, "getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage": ue, "getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage": uz, "getUndoAxesPermutation": aW, "isIdentityPermutation": NJ, "log": gQ, "mergeRealAndImagArrays": Nt, "prepareAndValidate": OB, "prepareSplitSize": NP, "segment_util": uL, "shouldFuse": zJ, "slice_util": WV, "splitRealAndImagArrays": NW, "stridesOrDilationsArePositive": Dq, "tupleValuesAreOne": iP, "upcastType": ML, "validateDefaultValueShape": GG, "validateInput": OJ, "validateUpdateShape": OV, "warn": gL });
var uH = class {
  constructor() {
    this["messageName"] = "setTimeoutCustom", this["functionRefs"] = [], this["handledMessageCount"] = 0, this["hasEventListener"] = false;
  }
  ["fetch"](qgu, qgj) {
    return fetch(qgu, qgj);
  }
  ["now"]() {
    return performance["now"]();
  }
  ["encode"](qgu, qgj) {
    if (qgj !== "utf-8" && qgj !== "utf8") throw new Error("Browser's encoder only supports utf-8, but got " + qgj);
    return this["textEncoder"] == null && (this["textEncoder"] = new TextEncoder()), this["textEncoder"]["encode"](qgu);
  }
  ["decode"](qgu, qgj) {
    return new TextDecoder(qgj)["decode"](qgu);
  }
  ["setTimeoutCustom"](qgu, qgj) {
    if (typeof window == "undefined" || !qM()["getBool"]("USE_SETTIMEOUTCUSTOM")) {
      setTimeout(qgu, qgj);
      return;
    }
    this["functionRefs"]["push"](qgu), setTimeout(() => {
      window["postMessage"]({ "name": this["messageName"], "index": this["functionRefs"]["length"] - 1 }, "*");
    }, qgj), this["hasEventListener"] || (this["hasEventListener"] = true, window["addEventListener"]("message", (qgL) => {
      if (qgL["source"] === window && qgL["data"]["name"] === this["messageName"]) {
        qgL["stopPropagation"]();
        const qgI = this["functionRefs"][qgL["data"]["index"]];
        qgI(), this["handledMessageCount"]++, this["handledMessageCount"] === this["functionRefs"]["length"] && (this["functionRefs"] = [], this["handledMessageCount"] = 0);
      }
    }, true));
  }
  ["isTypedArray"](qgu) {
    return gU(qgu);
  }
};
if (qM()["get"]("IS_BROWSER")) {
  qM()["setPlatform"]("browser", new uH());
  try {
    kK["registerManager"](tX["URL_SCHEME"], new tL());
  } catch (qxg) {
  }
  try {
    kK["registerManager"](FV["URL_SCHEME"], new FU());
  } catch (qxx) {
  }
}
var uK = { "importFetch": () => require_browser() };
var uB;
var uV = class {
  constructor() {
    this["util"] = require_util(), this["textEncoder"] = new this["util"]["TextEncoder"]();
  }
  ["fetch"](qgu, qgj) {
    return qM()["global"]["fetch"] != null ? qM()["global"]["fetch"](qgu, qgj) : (uB == null && (uB = uK["importFetch"]()), uB(qgu, qgj));
  }
  ["now"]() {
    const qgu = process["hrtime"]();
    return qgu[0] * 1e3 + qgu[1] / 1e6;
  }
  ["encode"](qgu, qgj) {
    if (qgj !== "utf-8" && qgj !== "utf8") throw new Error("Node built-in encoder only supports utf-8, but got " + qgj);
    return this["textEncoder"]["encode"](qgu);
  }
  ["decode"](qgu, qgj) {
    return qgu["length"] === 0 ? "" : new this["util"]["TextDecoder"](qgj)["decode"](qgu);
  }
  ["isTypedArray"](qgu) {
    return this["util"]["types"]["isFloat32Array"](qgu) || this["util"]["types"]["isInt32Array"](qgu) || this["util"]["types"]["isUint8Array"](qgu) || this["util"]["types"]["isUint8ClampedArray"](qgu);
  }
};
qM()["get"]("IS_NODE") && !qM()["get"]("IS_BROWSER") && qM()["setPlatform"]("node", new uV()), fn();
var uJ = { "buffer": DY, "cast": OM, "clone": DX, "print": wu };
MM(uJ);
var uY = Object["defineProperty"];
var uP = Object["getOwnPropertySymbols"];
var uU = Object["prototype"]["hasOwnProperty"];
var j6 = Object["prototype"]["propertyIsEnumerable"];
var jq = (qgu, qgj, qgL) => qgj in qgu ? uY(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var jM = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) uU["call"](qgj, qgL) && jq(qgu, qgL, qgj[qgL]);
  if (uP) {
    for (var qgL of uP(qgj)) j6["call"](qgj, qgL) && jq(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var jF = class {
  constructor(qgu) {
    this["model"] = qgu, this["posesMax"] = 1, this["iouThresh"] = 0.3, this["scoreThresh"] = 0.5, this["model"] = qgu, this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 224, "height": 224 }, this["modelRatio"] = this["modelSize"]["width"] / this["modelSize"]["height"], this["anchorsData"] = this["buildAnchors"](this["modelSize"]), this["anchorsX"] = zz(this["anchorsData"]["map"]((qgj) => qgj["x"])), this["anchorsY"] = zz(this["anchorsData"]["map"]((qgj) => qgj["y"]));
  }
  async ["process"](qgu) {
    let qgj = { "x": 0, "y": 0 };
    const [qgL, qgI] = Sq(() => {
      const qgQ = { "width": qgu["shape"][2], "height": qgu["shape"][1] }, qgd = qgQ["width"] / qgQ["height"];
      let qgv = jM({}, qgQ), qgy = { "x": 0, "y": 0 };
      qgd > this["modelRatio"] ? (qgv["height"] = qgu["shape"][2] / this["modelRatio"], qgy["y"] = Math["floor"]((qgv["height"] - qgu["shape"][1]) * 0.5), qgj["y"] = qgy["y"] / qgv["height"]) : qgd < this["modelRatio"] && (qgv["width"] = qgu["shape"][1] * this["modelRatio"], qgy["x"] = Math["floor"]((qgv["width"] - qgu["shape"][2]) * 0.5), qgj["x"] = qgy["x"] / qgv["width"]);
      const qgl = wz(qgu, [[0, 0], [qgy["y"], qgy["y"]], [qgy["x"], qgy["x"]], [0, 0]], 0), qgH = Gq["resizeBilinear"](qgl, [this["modelSize"]["height"], this["modelSize"]["width"]]), qgA = this["model"]["execute"](qgH, "person"), qgh = zq(DH(qgA, [0, 0, 1], [1, -1, -1])), qgT = zq(DH(qgA, [0, 0, 0], [1, -1, 1])), qgK = DR(mq(qgT, -100, 100));
      return [this["decodeBoxes"](qgh, [this["anchorsX"], this["anchorsY"]], this["modelSize"]), qgK];
    }), qgb = await qgL["data"](), qgR = await qgI["data"]();
    let qgo = [];
    for (let qgQ = 0; qgQ < qgR["length"]; qgQ++) {
      if (qgR[qgQ] < this["scoreThresh"]) continue;
      const qgd = qgb[qgQ * 12 + 2] - qgb[qgQ * 12 + 0], qgv = qgb[qgQ * 12 + 3] - qgb[qgQ * 12 + 1];
      qgd < 0 || qgv < 0 || qgo["push"]({ "box": [[qgb[qgQ * 12 + 0], qgb[qgQ * 12 + 1]], [qgb[qgQ * 12 + 2], qgb[qgQ * 12 + 3]]], "points": [[qgb[qgQ * 12 + 4], qgb[qgQ * 12 + 5]], [qgb[qgQ * 12 + 6], qgb[qgQ * 12 + 7]], [qgb[qgQ * 12 + 8], qgb[qgQ * 12 + 9]], [qgb[qgQ * 12 + 10], qgb[qgQ * 12 + 11]]], "score": qgR[qgQ] });
    }
    if (qgL["dispose"](), qgI["dispose"](), qgo["length"] < 1) return [];
    if (qgo["length"] > 1) {
      const qgy = zX(qgo["map"]((qgT) => [qgT["box"][0][1], qgT["box"][0][0], qgT["box"][1][1], qgT["box"][1][0]])), qgl = zz(qgo["map"]((qgT) => qgT["score"])), qgH = await Gq["nonMaxSuppressionAsync"](qgy, qgl, this["posesMax"], this["iouThresh"], this["scoreThresh"]), qgA = await qgH["data"]();
      qgH["dispose"]();
      const qgh = [];
      for (let qgT = 0; qgT < qgA["length"]; qgT++) qgh["push"](qgo[qgA[qgT]]);
      qgo = qgh;
    }
    if (qgo["length"] < 1) return [];
    const qgr = { "width": 1 - 2 * qgj["x"], "height": 1 - 2 * qgj["y"] };
    return qgo["map"]((qgK) => ({ "box": qgK["box"]["map"]((qgB) => [(qgB[0] - qgj["x"]) / qgr["width"], (qgB[1] - qgj["y"]) / qgr["height"]]), "points": qgK["points"]["map"]((qgB) => [(qgB[0] - qgj["x"]) / qgr["width"], (qgB[1] - qgj["y"]) / qgr["height"]]), "score": qgK["score"] }));
  }
  ["decodeBoxes"](qgu, qgj, qgL) {
    let qgI = zq(DH(qgu, [0, 0], [-1, 1])), qgb = zq(DH(qgu, [0, 1], [-1, 1])), qgR = zq(DH(qgu, [0, 2], [-1, 1])), qgo = zq(DH(qgu, [0, 3], [-1, 1]));
    qgI = WY(iM(qgI, qgL["width"]), qgj[0]), qgb = WY(iM(qgb, qgL["height"]), qgj[1]), qgR = iM(qgR, qgL["width"] * 2), qgo = iM(qgo, qgL["height"] * 2);
    const qgr = DW(ZK(qgI, qgR), [2254, 1]), qgQ = DW(ZK(qgb, qgo), [2254, 1]), qgd = DW(WY(qgI, qgR), [2254, 1]), qgv = DW(WY(qgb, qgo), [2254, 1]);
    let qgy = ms([qgr, qgQ, qgd, qgv], 1);
    for (let qgl = 0; qgl < 4; qgl++) {
      let qgH = zq(DH(qgu, [0, 4 + qgl * 2], [-1, 1])), qgA = zq(DH(qgu, [0, 4 + qgl * 2 + 1], [-1, 1]));
      qgH = DW(WY(iM(qgH, qgL["width"]), qgj[0]), [2254, 1]), qgA = DW(WY(iM(qgA, qgL["height"]), qgj[1]), [2254, 1]), qgy = ms([qgy, qgH, qgA], 1);
    }
    return qgy;
  }
  ["buildAnchors"](qgu) {
    const qgj = [8, 16, 32, 32, 32], qgL = [];
    let qgI = 0;
    for (; qgI < 5; ) {
      let qgb = 0, qgR = qgI;
      for (; qgR < qgj["length"] && qgj[qgR] === qgj[qgI]; ) qgb += 2, qgR++;
      const qgo = qgj[qgI], qgr = Math["ceil"](qgu["height"] / qgo), qgQ = Math["ceil"](qgu["width"] / qgo);
      for (let qgd = 0; qgd < qgr; ++qgd) for (let qgv = 0; qgv < qgQ; ++qgv) for (let qgy = 0; qgy < qgb; ++qgy) qgL["push"]({ "x": (qgv + 0.5) / qgQ, "y": (qgd + 0.5) / qgr });
      qgI = qgR;
    }
    return qgL;
  }
  async ["prepare"]() {
    const { width: qgu, height: qgj } = this["modelSize"], qgL = wF([1, qgj, qgu, 3]), qgI = this["model"]["execute"](qgL, "person");
    await qgI["data"](), qgL["dispose"](), qgI["dispose"]();
  }
  ["dispose"]() {
    this["model"]["dispose"](), this["anchorsX"]["dispose"](), this["anchorsY"]["dispose"]();
  }
};
var jW = class {
  constructor(qgu) {
    if (this["size"] = qgu, St() !== "webgl") return;
    const { width: qgj, height: qgL } = qgu;
    this["backend"] = SD(), this["prog"] = { "variableNames": ["maskT", "prevT"], "outputShape": [qgL, qgj], "userCode": "\n                void main() {\n                    ivec2 c = getOutputCoords();\n                    float mask = getMaskT(c[0], c[1]);\n                    float prev = getPrevT(c[0], c[1]);\n                    float t = mask - 0.5;\n                    float x = t * t;\n                    float alpha = 1.0 - min(\n                        x * (5.74062006 + x * (-2.90180189 + x * (-30.34594285 +\n                        x * (153.83657925 + x * (-387.53530186))))), 1.0);\n                    float smoothed = mask + (prev - mask) * (alpha * 0.9);\n                    setOutput(smoothed);\n                }\n        " };
  }
  ["process"](qgu) {
    var qgj;
    if (!this["backend"] || !this["prog"]) return;
    const qgL = this["backend"]["compileAndRun"](this["prog"], [qgu, this["prev"] || qgu]), qgI = fU()["makeTensorFromTensorInfo"](qgL);
    return (qgj = this["prev"]) == null || qgj["dispose"](), this["prev"] = qgI, qgI;
  }
  ["resize"](qgu) {
    const { width: qgj, height: qgL } = qgu;
    this["size"] = { "width": qgj, "height": qgL }, this["prog"] && (this["prog"]["outputShape"] = [qgL, qgj]);
  }
  ["reset"]() {
    var qgu;
    (qgu = this["prev"]) == null || qgu["dispose"](), delete this["prev"];
  }
  async ["prepare"]() {
    if (!this["backend"] || !this["prog"]) return;
    const { width: qgu, height: qgj } = this["size"], qgL = wF([qgj, qgu]), qgI = wW([qgj, qgu]), qgb = this["backend"]["compileAndRun"](this["prog"], [qgL, qgI]), qgR = fU()["makeTensorFromTensorInfo"](qgb);
    await qgR["data"](), qgL["dispose"](), qgI["dispose"](), qgR["dispose"]();
  }
  ["dispose"]() {
    this["reset"](), delete this["prog"], delete this["backend"];
  }
};
var jD = class {
  constructor(qgu, qgj = false) {
    this["model"] = qgu, this["mask"] = qgj, this["sizeFactor"] = 1.2, this["model"] = qgu, this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 256, "height": 256 }, typeof qgj == "object" && qgj["smooth"] && (this["maskFilter"] = new jW(this["modelSize"]));
  }
  ["process"](qgu, qgj) {
    const [qgL, qgI] = [qgu["shape"][1], qgu["shape"][2]], { modelSize: qgb } = this;
    return qgj["map"]((qgR) => {
      var qgo;
      const qgr = [qgR["center"][0] * qgI, qgR["center"][1] * qgL], qgQ = [qgR["top"][0] * qgI, qgR["top"][1] * qgL], qgd = [qgQ[0] - qgr[0], qgQ[1] - qgr[1]], qgv = Math["sqrt"](qgd[0] * qgd[0] + qgd[1] * qgd[1]) * this["sizeFactor"], qgy = Math["atan2"](qgd[0], -qgd[1]), qgl = [qgr[1] - qgv, qgr[0] - qgv, qgr[1] + qgv, qgr[0] + qgv], qgH = Sq(() => {
        const qx1 = this["rotatedRect"](qgu, qgl, qgy, qgb);
        return WY(it(qx1, 0.5), 0.5);
      }), qgA = ["ld_3d", "world_3d", "output_poseflag", "activation_heatmap"];
      this["mask"] && qgA["push"]("activation_segmentation");
      const [qgh, qgT, qgK, qgB, qgV] = this["model"]["execute"](qgH, qgA), qgJ = qgh["dataSync"](), qgY = qgT["dataSync"](), qgP = qgK["dataSync"]()[0];
      let qgU = [];
      for (let qx1 = 0; qx1 < 39; qx1++) qgU["push"]([qgJ[qx1 * 5 + 0] / qgb["width"], qgJ[qx1 * 5 + 1] / qgb["height"], qgJ[qx1 * 5 + 2] / qgb["width"]]);
      let qx0;
      if (qgV) {
        const qx2 = Gq["rotateWithOffset"](qgV, -qgy), qx3 = zq(qx2), qx4 = ((qgo = this["maskFilter"]) == null ? void 0 : qgo["process"](qx3)) || qx3, qx5 = it(qx4, 255);
        qx0 = new Uint8Array(qx5["dataSync"]()), qgV["dispose"](), qx2["dispose"](), qx3["dispose"](), qx5["dispose"]();
      }
      return qgH["dispose"](), qgh["dispose"](), qgT["dispose"](), qgK["dispose"](), qgU = this["refinePoints"](qgU, qgB), qgB["dispose"](), { "points": qgU, "pointsData": qgJ, "metricData": qgY, "maskData": qx0, "score": qgP, "center": qgr, "top": qgQ, "radius": qgv, "angle": qgy };
    })["map"]((qgR) => {
      const { points: qgo, pointsData: qgr, metricData: qgQ, maskData: qgd, score: qgv, center: qgy, top: qgl, radius: qgH, angle: qgA } = qgR;
      let qgh = qgo["map"]((qgP, qgU) => ({ "pixel": qgP, "metric": [qgQ[qgU * 3 + 0], qgQ[qgU * 3 + 1], qgQ[qgU * 3 + 2]], "norm": [qgQ[qgU * 3 + 0], qgQ[qgU * 3 + 1], qgQ[qgU * 3 + 2]], "score": 1 / (1 + Math["exp"](-qgr[qgU * 5 + 3])), "visibility": 1 / (1 + Math["exp"](-qgr[qgU * 5 + 4])) }));
      qgh["forEach"]((qgP) => {
        qgP["pixel"][0] = (qgP["pixel"][0] - 0.5) * 2 * qgH, qgP["pixel"][1] = (qgP["pixel"][1] - 0.5) * 2 * qgH, qgP["pixel"][2] *= 2 * qgH;
      });
      const qgT = Math["sin"](qgA), qgK = Math["cos"](qgA);
      qgh["forEach"]((qgP) => {
        const qgU = qgP["pixel"][0], qx0 = qgP["pixel"][1];
        qgP["pixel"][0] = (qgU * qgK - qx0 * qgT + qgy[0]) / qgI, qgP["pixel"][1] = (qgU * qgT + qx0 * qgK + qgy[1]) / qgL, qgP["pixel"][2] /= qgI;
        const qx1 = qgP["metric"][0], qx2 = qgP["metric"][1];
        qgP["metric"][0] = qx1 * qgK - qx2 * qgT, qgP["metric"][1] = qx1 * qgT + qx2 * qgK;
      });
      const qgB = qgh["map"]((qgP) => qgP["pixel"][0]), qgV = qgh["map"]((qgP) => qgP["pixel"][1]), qgJ = [[Math["min"](...qgB), Math["min"](...qgV)], [Math["max"](...qgB), Math["max"](...qgV)]], qgY = qgd && { "buffer": qgd, "size": { "width": 256, "height": 256 }, "box": [[(qgy[0] - qgH) / qgI, (qgy[1] - qgH) / qgL], [(qgy[0] + qgH) / qgI, (qgy[1] + qgH) / qgL]] };
      return { "keypoints": qgh, "score": qgv, "mask": qgY, "center": [qgh[33]["pixel"][0], qgh[33]["pixel"][1]], "top": [qgh[34]["pixel"][0], qgh[34]["pixel"][1]], "debug": { "center": qgy, "top": qgl, "box": qgJ, "radius": qgH, "angle": qgA } };
    });
  }
  ["refinePoints"](qgu, qgj) {
    const qgL = zq(qgj, [0]), qgI = qgL["bufferSync"](), [qgb, qgR, qgo] = qgL["shape"];
    return qgu["map"]((qgr, qgQ) => {
      const qgd = qgr, qgv = Math["trunc"](qgd[0] * qgR), qgy = Math["trunc"](qgd[1] * qgb);
      if (qgv < 0 || qgv >= qgR || qgy < 0 || qgy >= qgb) return qgr;
      const qgl = Math["trunc"](6 / 2), qgH = Math["max"](qgv - qgl, 0), qgA = Math["min"](qgv + qgl + 1, qgR), qgh = Math["max"](qgy - qgl, 0), qgT = Math["min"](qgy + qgl + 1, qgb);
      let qgK = 0, qgB = 0, qgV = 0, qgJ = 0;
      for (let qgY = qgh; qgY < qgT; qgY++) for (let qgP = qgH; qgP < qgA; qgP++) {
        const qgU = qgI["get"](qgY, qgP, qgQ);
        qgK += qgU, qgB = Math["max"](qgU, qgB), qgV += qgP * qgU, qgJ += qgY * qgU;
      }
      return qgL["dispose"](), qgB >= 0.5 && qgK > 0 ? [qgV / qgK / qgR, qgJ / qgK / qgb, qgd[2]] : qgr;
    });
  }
  ["rotatedRect"](qgu, qgj, qgL, qgI) {
    const [qgb, qgR] = [qgj[2] - qgj[0], qgj[3] - qgj[1]], [qgo, qgr] = [(qgj[2] + qgj[0]) * 0.5, (qgj[3] + qgj[1]) * 0.5], [qgQ, qgd] = [qgb / qgI["height"], qgR / qgI["width"]], [qgv, qgy] = [Math["cos"](qgL), Math["sin"](qgL)], qgl = [qgv * qgd, -qgy * qgQ, (-qgv * qgR + qgy * qgb) * 0.5 + qgr, qgy * qgd, qgv * qgQ, (-qgy * qgR - qgv * qgb) * 0.5 + qgo, 0, 0];
    return Gq["transform"](qgu, [qgl], "bilinear", "constant", 0, [qgI["height"], qgI["width"]]);
  }
  ["reset"]() {
    var qgu;
    (qgu = this["maskFilter"]) == null || qgu["reset"]();
  }
  async ["prepare"]() {
    var qgu;
    const { width: qgj, height: qgL } = this["modelSize"], qgI = wF([1, qgL, qgj, 3]), qgb = this["model"]["execute"](qgI);
    await Promise["all"](qgb["map"](async (qgR) => {
      await qgR["data"](), qgR["dispose"]();
    })), await ((qgu = this["maskFilter"]) == null ? void 0 : qgu["prepare"]()), qgI["dispose"]();
  }
  async ["dispose"]() {
    var qgu, qgj;
    (qgu = this["model"]) == null || qgu["dispose"](), (qgj = this["maskFilter"]) == null || qgj["dispose"](), delete this["maskFilter"];
  }
};
var jZ = Object["defineProperty"];
var je = Object["getOwnPropertySymbols"];
var jz = Object["prototype"]["hasOwnProperty"];
var jX = Object["prototype"]["propertyIsEnumerable"];
var jG = (qgu, qgj, qgL) => qgj in qgu ? jZ(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var jj = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) jz["call"](qgj, qgL) && jG(qgu, qgL, qgj[qgL]);
  if (je) {
    for (var qgL of je(qgj)) jX["call"](qgj, qgL) && jG(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var jL = class {
  constructor() {
    this["freq"] = 30, this["pixelParams"] = { "minCutOff": 1, "minCutOffD": 1, "beta": 40 }, this["metricParams"] = { "minCutOff": 1, "minCutOffD": 1, "beta": 5 }, this["boxParams"] = { "minCutOff": 1, "minCutOffD": 1, "beta": 5 }, this["scoreCutOff"] = 1, this["visibilityCutOff"] = 1, this["time"] = 0;
  }
  ["filter"](qgu, qgj, qgL = 1) {
    return this["time"] >= qgj ? qgu : (this["time"] !== 0 && (this["freq"] = 1 / (qgj - this["time"])), this["time"] = qgj, !this["raw"] || !this["smooth"] || !this["der"] ? (this["raw"] = this["clonePose"](qgu), this["smooth"] = this["clonePose"](qgu), this["der"] = { "keypoints": qgu["keypoints"]["map"](() => ({ "pixel": [0, 0, 0], "metric": [0, 0, 0], "norm": [0, 0, 0], "score": 0, "visibility": 0 })), "score": 0, "center": [0, 0], "top": [0, 0], "debug": { "box": [[0, 0], [0, 0]], "center": [0, 0], "top": [0, 0], "radius": 0, "angle": 0 } }, this["clonePose"](this["smooth"])) : (this["filterKeypoints"](qgu["keypoints"], this["raw"]["keypoints"], this["der"]["keypoints"], this["smooth"]["keypoints"], qgL), this["filterCoord2D"](qgu["center"], this["raw"]["center"], this["der"]["center"], this["smooth"]["center"], qgL, this["boxParams"]), this["filterCoord2D"](qgu["top"], this["raw"]["top"], this["der"]["top"], this["smooth"]["top"], qgL, this["boxParams"]), this["smooth"]["score"] = qgu["score"], this["smooth"]["mask"] = qgu["mask"] && { "buffer": qgu["mask"]["buffer"], "size": jj({}, qgu["mask"]["size"]), "box": [[...qgu["mask"]["box"][0]], [...qgu["mask"]["box"][1]]] }, this["smooth"]["debug"] = qgu["debug"] && { "center": [...qgu["debug"]["center"]], "top": [...qgu["debug"]["top"]], "box": [[...qgu["debug"]["box"][0]], [...qgu["debug"]["box"][1]]], "radius": qgu["debug"]["radius"], "angle": qgu["debug"]["angle"] }, this["clonePose"](this["smooth"])));
  }
  ["filterKeypoints"](qgu, qgj, qgL, qgI, qgb) {
    const qgR = this["alpha"](this["visibilityCutOff"]), qgo = this["alpha"](this["scoreCutOff"]);
    for (let qgr = 0; qgr < qgu["length"]; qgr++) this["filterCoord3D"](qgu[qgr]["pixel"], qgj[qgr]["pixel"], qgL[qgr]["pixel"], qgI[qgr]["pixel"], qgb, this["pixelParams"]), this["filterCoord3D"](qgu[qgr]["metric"], qgj[qgr]["metric"], qgL[qgr]["metric"], qgI[qgr]["metric"], qgb, this["metricParams"]), this["filterCoord3D"](qgu[qgr]["norm"], qgj[qgr]["norm"], qgL[qgr]["norm"], qgI[qgr]["norm"], qgb, this["metricParams"]), qgI[qgr]["score"] = qgI[qgr]["score"] + qgo * (qgu[qgr]["score"] - qgI[qgr]["score"]), qgI[qgr]["visibility"] = qgI[qgr]["visibility"] + qgR * (qgu[qgr]["visibility"] - qgI[qgr]["visibility"]);
  }
  ["filterCoord3D"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = [(qgu[0] - qgI[0]) * qgb * this["freq"], (qgu[1] - qgI[1]) * qgb * this["freq"], (qgu[2] - qgI[2]) * qgb * this["freq"]], qgr = this["alpha"](qgR["minCutOffD"]);
    qgL[0] = qgL[0] + qgr * (qgo[0] - qgL[0]), qgL[1] = qgL[1] + qgr * (qgo[1] - qgL[1]), qgL[2] = qgL[2] + qgr * (qgo[2] - qgL[2]);
    const qgQ = [this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[0])), this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[1])), this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[2]))];
    qgI[0] = qgI[0] + qgQ[0] * (qgu[0] - qgI[0]), qgI[1] = qgI[1] + qgQ[1] * (qgu[1] - qgI[1]), qgI[2] = qgI[2] + qgQ[2] * (qgu[2] - qgI[2]), qgj[0] = qgu[0], qgj[1] = qgu[1], qgj[2] = qgu[2];
  }
  ["filterCoord2D"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = [(qgu[0] - qgI[0]) * qgb * this["freq"], (qgu[1] - qgI[1]) * qgb * this["freq"]], qgr = this["alpha"](qgR["minCutOffD"]);
    qgL[0] = qgL[0] + qgr * (qgo[0] - qgL[0]), qgL[1] = qgL[1] + qgr * (qgo[1] - qgL[1]);
    const qgQ = [this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[0])), this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[1]))];
    qgI[0] = qgI[0] + qgQ[0] * (qgu[0] - qgI[0]), qgI[1] = qgI[1] + qgQ[1] * (qgu[1] - qgI[1]), qgj[0] = qgu[0], qgj[1] = qgu[1];
  }
  ["reset"]() {
    delete this["raw"], delete this["smooth"], delete this["der"];
  }
  ["alpha"](qgu) {
    return 1 / (1 + this["freq"] / (2 * Math["PI"] * qgu));
  }
  ["clonePose"](qgu) {
    return { "keypoints": qgu["keypoints"]["map"]((qgj) => ({ "pixel": [...qgj["pixel"]], "metric": [...qgj["metric"]], "norm": [...qgj["norm"]], "score": qgj["score"], "visibility": qgj["visibility"] })), "score": qgu["score"], "center": [...qgu["center"]], "top": [...qgu["top"]], "mask": qgu["mask"] && { "buffer": qgu["mask"]["buffer"], "size": jj({}, qgu["mask"]["size"]), "box": [[...qgu["mask"]["box"][0]], [...qgu["mask"]["box"][1]]] }, "debug": qgu["debug"] && { "box": [[...qgu["debug"]["box"][0]], [...qgu["debug"]["box"][1]]], "center": [...qgu["debug"]["center"]], "top": [...qgu["debug"]["top"]], "radius": qgu["debug"]["radius"], "angle": qgu["debug"]["angle"] } };
  }
};
function jo(qgu, qgj) {
  const qgL = [[Math["max"](qgu[0][0], qgj[0][0]), Math["max"](qgu[0][1], qgj[0][1])], [Math["min"](qgu[1][0], qgj[1][0]), Math["min"](qgu[1][1], qgj[1][1])]], qgI = (qgL[1][0] - qgL[0][0]) * (qgL[1][1] - qgL[0][1]);
  return qgI / ((qgu[1][0] - qgu[0][0]) * (qgu[1][1] - qgu[0][1]) + (qgj[1][0] - qgj[0][0]) * (qgj[1][1] - qgj[0][1]) - qgI);
}
var jK = (() => {
  var qgu = typeof document != "undefined" && document["currentScript"] ? document["currentScript"]["src"] : void 0;
  return function(qgj = {}) {
    var qgL = qgj, qgI, qgb;
    qgL["ready"] = new Promise((qM8, qM9) => {
      qgI = qM8, qgb = qM9;
    });
    var qgR = Object["assign"]({}, qgL), qgo = "./this.program", qgr = (qM8, qM9) => {
      throw qM9;
    }, qgQ = true, qgd = false, qgv = "";
    function qgy(qM8) {
      return qgL["locateFile"] ? qgL["locateFile"](qM8, qgv) : qgv + qM8;
    }
    typeof document != "undefined" && document["currentScript"] && (qgv = document["currentScript"]["src"]), qgu && (qgv = qgu), qgv["startsWith"]("blob:") ? qgv = "" : qgv = qgv["substr"](0, qgv["replace"](/[?#].*/, "")["lastIndexOf"]("/") + 1), qgL["print"] || console["log"]["bind"](console);
    var qgl = qgL["printErr"] || console["error"]["bind"](console);
    Object["assign"](qgL, qgR), qgR = null, qgL["arguments"] && qgL["arguments"], qgL["thisProgram"] && (qgo = qgL["thisProgram"]), qgL["quit"] && (qgr = qgL["quit"]);
    var qgH;
    qgL["wasmBinary"] && (qgH = qgL["wasmBinary"]);
    var qgA, qgh = false, qgT, qgK, qgB, qgV, qgJ, qgY, qgP, qgU, qx0;
    function qx1() {
      var qM8 = qgA["buffer"];
      qgL["HEAP8"] = qgK = new Int8Array(qM8), qgL["HEAP16"] = qgV = new Int16Array(qM8), qgL["HEAPU8"] = qgB = new Uint8Array(qM8), qgL["HEAPU16"] = qgJ = new Uint16Array(qM8), qgL["HEAP32"] = qgY = new Int32Array(qM8), qgL["HEAPU32"] = qgP = new Uint32Array(qM8), qgL["HEAPF32"] = qgU = new Float32Array(qM8), qgL["HEAPF64"] = qx0 = new Float64Array(qM8);
    }
    var qx2 = [], qx3 = [], qx4 = [];
    function qx5() {
      if (qgL["preRun"]) {
        for (typeof qgL["preRun"] == "function" && (qgL["preRun"] = [qgL["preRun"]]); qgL["preRun"]["length"]; ) qx8(qgL["preRun"]["shift"]());
      }
      qxm(qx2);
    }
    function qx6() {
      qxm(qx3);
    }
    function qx7() {
      if (qgL["postRun"]) {
        for (typeof qgL["postRun"] == "function" && (qgL["postRun"] = [qgL["postRun"]]); qgL["postRun"]["length"]; ) qxq(qgL["postRun"]["shift"]());
      }
      qxm(qx4);
    }
    function qx8(qM8) {
      qx2["unshift"](qM8);
    }
    function qx9(qM8) {
      qx3["unshift"](qM8);
    }
    function qxq(qM8) {
      qx4["unshift"](qM8);
    }
    var qxn = 0, qxp = null;
    function qxs(qM8) {
      var qM9;
      qxn++, (qM9 = qgL["monitorRunDependencies"]) == null || qM9["call"](qgL, qxn);
    }
    function qxE(qM8) {
      var qM9;
      if (qxn--, (qM9 = qgL["monitorRunDependencies"]) == null || qM9["call"](qgL, qxn), qxn == 0 && qxp) {
        var qMq = qxp;
        qxp = null, qMq();
      }
    }
    function qxM(qM8) {
      var qM9;
      (qM9 = qgL["onAbort"]) == null || qM9["call"](qgL, qM8), qM8 = "Aborted(" + qM8 + ")", qgl(qM8), qgh = true, qgT = 1, qM8 += ". Build with -sASSERTIONS for more info.";
      var qMq = new WebAssembly["RuntimeError"](qM8);
      throw qgb(qMq), qMq;
    }
    var qxf = "data:application/octet-stream;base64,", qxS = (qM8) => qM8["startsWith"](qxf), qxF;
    qxF = "bodyutils.wasm", qxS(qxF) || (qxF = qgy(qxF));
    function qxt(qM8) {
      if (qM8 == qxF && qgH) return new Uint8Array(qgH);
      throw "both async and sync fetching of the wasm failed";
    }
    function qxk(qM8) {
      return !qgH && qgQ && typeof fetch == "function" ? fetch(qM8, { "credentials": "same-origin" })["then"]((qM9) => {
        if (!qM9["ok"]) throw "failed to load wasm binary file at '" + qM8 + "'";
        return qM9["arrayBuffer"]();
      })["catch"](() => qxt(qM8)) : Promise["resolve"]()["then"](() => qxt(qM8));
    }
    function qxO(qM8, qM9, qMq) {
      return qxk(qM8)["then"]((qMn) => WebAssembly["instantiate"](qMn, qM9))["then"](qMq, (qMn) => {
        qgl("failed to asynchronously prepare wasm: " + qMn), qxM(qMn);
      });
    }
    function qxW(qM8, qM9, qMq, qMn) {
      return !qM8 && typeof WebAssembly["instantiateStreaming"] == "function" && !qxS(qM9) && typeof fetch == "function" ? fetch(qM9, { "credentials": "same-origin" })["then"]((qMp) => {
        var qMg = WebAssembly["instantiateStreaming"](qMp, qMq);
        return qMg["then"](qMn, function(qMx) {
          return qgl("wasm streaming compile failed: " + qMx), qgl("falling back to ArrayBuffer instantiation"), qxO(qM9, qMq, qMn);
        });
      }) : qxO(qM9, qMq, qMn);
    }
    function qxi() {
      var qM8 = { "a": qM0 };
      function qM9(qMn, qMp) {
        return qM1 = qMn["exports"], qgA = qM1["E"], qx1(), qsD = qM1["H"], qx9(qM1["F"]), qxE(), qM1;
      }
      qxs();
      function qMq(qMn) {
        qM9(qMn["instance"]);
      }
      if (qgL["instantiateWasm"]) try {
        return qgL["instantiateWasm"](qM8, qM9);
      } catch (qMn) {
        qgl("Module.instantiateWasm callback failed with error: " + qMn), qgb(qMn);
      }
      return qxW(qgH, qxF, qM8, qMq)["catch"](qgb), {};
    }
    function qxD(qM8) {
      this["name"] = "ExitStatus", this["message"] = "Program terminated with exit(" + qM8 + ")", this["status"] = qM8;
    }
    var qxm = (qM8) => {
      for (; qM8["length"] > 0; ) qM8["shift"]()(qgL);
    }, qxa = qgL["noExitRuntime"] || true;
    class qxZ {
      constructor(qM8) {
        this["excPtr"] = qM8, this["ptr"] = qM8 - 24;
      }
      ["set_type"](qM8) {
        qgP[this["ptr"] + 4 >> 2] = qM8;
      }
      ["get_type"]() {
        return qgP[this["ptr"] + 4 >> 2];
      }
      ["set_destructor"](qM8) {
        qgP[this["ptr"] + 8 >> 2] = qM8;
      }
      ["get_destructor"]() {
        return qgP[this["ptr"] + 8 >> 2];
      }
      ["set_caught"](qM8) {
        qM8 = qM8 ? 1 : 0, qgK[this["ptr"] + 12] = qM8;
      }
      ["get_caught"]() {
        return qgK[this["ptr"] + 12] != 0;
      }
      ["set_rethrown"](qM8) {
        qM8 = qM8 ? 1 : 0, qgK[this["ptr"] + 13] = qM8;
      }
      ["get_rethrown"]() {
        return qgK[this["ptr"] + 13] != 0;
      }
      ["init"](qM8, qM9) {
        this["set_adjusted_ptr"](0), this["set_type"](qM8), this["set_destructor"](qM9);
      }
      ["set_adjusted_ptr"](qM8) {
        qgP[this["ptr"] + 16 >> 2] = qM8;
      }
      ["get_adjusted_ptr"]() {
        return qgP[this["ptr"] + 16 >> 2];
      }
      ["get_exception_ptr"]() {
        var qM8 = qM5(this["get_type"]());
        if (qM8) return qgP[this["excPtr"] >> 2];
        var qM9 = this["get_adjusted_ptr"]();
        return qM9 !== 0 ? qM9 : this["excPtr"];
      }
    }
    var qxw = 0, qxe = (qM8, qM9, qMq) => {
      var qMn = new qxZ(qM8);
      throw qMn["init"](qM9, qMq), qxw = qM8, qxw;
    }, qxz = (qM8, qM9, qMq, qMn, qMp) => {
    }, qxc = () => {
      for (var qM8 = new Array(256), qM9 = 0; qM9 < 256; ++qM9) qM8[qM9] = String["fromCharCode"](qM9);
      qxX = qM8;
    }, qxX, qxG = (qM8) => {
      for (var qM9 = "", qMq = qM8; qgB[qMq]; ) qM9 += qxX[qgB[qMq++]];
      return qM9;
    }, qxN = {}, qxu = {}, qxj = {}, qxL, qxI = (qM8) => {
      throw new qxL(qM8);
    }, qxb, qxR = (qM8) => {
      throw new qxb(qM8);
    }, qxo = (qM8, qM9, qMq) => {
      qM8["forEach"](function(qMs) {
        qxj[qMs] = qM9;
      });
      function qMn(qMs) {
        var qME = qMq(qMs);
        qME["length"] !== qM8["length"] && qxR("Mismatched type converter count");
        for (var qMM = 0; qMM < qM8["length"]; ++qMM) qxQ(qM8[qMM], qME[qMM]);
      }
      var qMp = new Array(qM9["length"]), qMg = [], qMx = 0;
      qM9["forEach"]((qMs, qME) => {
        qxu["hasOwnProperty"](qMs) ? qMp[qME] = qxu[qMs] : (qMg["push"](qMs), qxN["hasOwnProperty"](qMs) || (qxN[qMs] = []), qxN[qMs]["push"](() => {
          qMp[qME] = qxu[qMs], ++qMx, qMx === qMg["length"] && qMn(qMp);
        }));
      }), qMg["length"] === 0 && qMn(qMp);
    };
    function qxr(qM8, qM9, qMq = {}) {
      var qMn = qM9["name"];
      if (qM8 || qxI('type "' + qMn + '" must have a positive integer typeid pointer'), qxu["hasOwnProperty"](qM8)) {
        if (qMq["ignoreDuplicateRegistrations"]) return;
        qxI("Cannot register type '" + qMn + "' twice");
      }
      if (qxu[qM8] = qM9, delete qxj[qM8], qxN["hasOwnProperty"](qM8)) {
        var qMp = qxN[qM8];
        delete qxN[qM8], qMp["forEach"]((qMg) => qMg());
      }
    }
    function qxQ(qM8, qM9, qMq = {}) {
      if (!("argPackAdvance" in qM9)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return qxr(qM8, qM9, qMq);
    }
    var qxd = 8, qxv = (qM8, qM9, qMq, qMn) => {
      qM9 = qxG(qM9), qxQ(qM8, { "name": qM9, "fromWireType": function(qMp) {
        return !!qMp;
      }, "toWireType": function(qMp, qMg) {
        return qMg ? qMq : qMn;
      }, "argPackAdvance": qxd, "readValueFromPointer": function(qMp) {
        return this["fromWireType"](qgB[qMp]);
      }, "destructorFunction": null });
    }, qxy = (qM8) => ({ "count": qM8["count"], "deleteScheduled": qM8["deleteScheduled"], "preservePointerOnDelete": qM8["preservePointerOnDelete"], "ptr": qM8["ptr"], "ptrType": qM8["ptrType"], "smartPtr": qM8["smartPtr"], "smartPtrType": qM8["smartPtrType"] }), qxC = (qM8) => {
      function qM9(qMq) {
        return qMq["$$"]["ptrType"]["registeredClass"]["name"];
      }
      qxI(qM9(qM8) + " instance already deleted");
    }, qxl = false, qxH = (qM8) => {
    }, qxA = (qM8) => {
      qM8["smartPtr"] ? qM8["smartPtrType"]["rawDestructor"](qM8["smartPtr"]) : qM8["ptrType"]["registeredClass"]["rawDestructor"](qM8["ptr"]);
    }, qxh = (qM8) => {
      qM8["count"]["value"] -= 1;
      var qM9 = qM8["count"]["value"] === 0;
      qM9 && qxA(qM8);
    }, qxT = (qM8, qM9, qMq) => {
      if (qM9 === qMq) return qM8;
      if (qMq["baseClass"] === void 0) return null;
      var qMn = qxT(qM8, qM9, qMq["baseClass"]);
      return qMn === null ? null : qMq["downcast"](qMn);
    }, qxK = {}, qxB = () => Object["keys"](qs1)["length"], qxV = () => {
      var qM8 = [];
      for (var qM9 in qs1) qs1["hasOwnProperty"](qM9) && qM8["push"](qs1[qM9]);
      return qM8;
    }, qxJ = [], qxY = () => {
      for (; qxJ["length"]; ) {
        var qM8 = qxJ["pop"]();
        qM8["$$"]["deleteScheduled"] = false, qM8["delete"]();
      }
    }, qxP, qxU = (qM8) => {
      qxP = qM8, qxJ["length"] && qxP && qxP(qxY);
    }, qs0 = () => {
      qgL["getInheritedInstanceCount"] = qxB, qgL["getLiveInheritedInstances"] = qxV, qgL["flushPendingDeletes"] = qxY, qgL["setDelayFunction"] = qxU;
    }, qs1 = {}, qs2 = (qM8, qM9) => {
      for (qM9 === void 0 && qxI("ptr should not be undefined"); qM8["baseClass"]; ) qM9 = qM8["upcast"](qM9), qM8 = qM8["baseClass"];
      return qM9;
    }, qs3 = (qM8, qM9) => (qM9 = qs2(qM8, qM9), qs1[qM9]), qs4 = (qM8, qM9) => {
      (!qM9["ptrType"] || !qM9["ptr"]) && qxR("makeClassHandle requires ptr and ptrType");
      var qMq = !!qM9["smartPtrType"], qMn = !!qM9["smartPtr"];
      return qMq !== qMn && qxR("Both smartPtrType and smartPtr must be specified"), qM9["count"] = { "value": 1 }, qs6(Object["create"](qM8, { "$$": { "value": qM9, "writable": true } }));
    };
    function qs5(qM8) {
      var qM9 = this["getPointee"](qM8);
      if (!qM9) return this["destructor"](qM8), null;
      var qMq = qs3(this["registeredClass"], qM9);
      if (qMq !== void 0) {
        if (qMq["$$"]["count"]["value"] === 0) return qMq["$$"]["ptr"] = qM9, qMq["$$"]["smartPtr"] = qM8, qMq["clone"]();
        var qMn = qMq["clone"]();
        return this["destructor"](qM8), qMn;
      }
      function qMp() {
        return this["isSmartPointer"] ? qs4(this["registeredClass"]["instancePrototype"], { "ptrType": this["pointeeType"], "ptr": qM9, "smartPtrType": this, "smartPtr": qM8 }) : qs4(this["registeredClass"]["instancePrototype"], { "ptrType": this, "ptr": qM8 });
      }
      var qMg = this["registeredClass"]["getActualType"](qM9), qMx = qxK[qMg];
      if (!qMx) return qMp["call"](this);
      var qMs;
      this["isConst"] ? qMs = qMx["constPointerType"] : qMs = qMx["pointerType"];
      var qME = qxT(qM9, this["registeredClass"], qMs["registeredClass"]);
      return qME === null ? qMp["call"](this) : this["isSmartPointer"] ? qs4(qMs["registeredClass"]["instancePrototype"], { "ptrType": qMs, "ptr": qME, "smartPtrType": this, "smartPtr": qM8 }) : qs4(qMs["registeredClass"]["instancePrototype"], { "ptrType": qMs, "ptr": qME });
    }
    var qs6 = (qM8) => typeof FinalizationRegistry == "undefined" ? (qs6 = (qM9) => qM9, qM8) : (qxl = new FinalizationRegistry((qM9) => {
      qxh(qM9["$$"]);
    }), qs6 = (qM9) => {
      var qMq = qM9["$$"], qMn = !!qMq["smartPtr"];
      if (qMn) {
        var qMp = { "$$": qMq };
        qxl["register"](qM9, qMp, qM9);
      }
      return qM9;
    }, qxH = (qM9) => qxl["unregister"](qM9), qs6(qM8)), qs7 = () => {
      Object["assign"](qs8["prototype"], { "isAliasOf"(qM8) {
        if (!(this instanceof qs8) || !(qM8 instanceof qs8)) return false;
        var qM9 = this["$$"]["ptrType"]["registeredClass"], qMq = this["$$"]["ptr"];
        qM8["$$"] = qM8["$$"];
        for (var qMn = qM8["$$"]["ptrType"]["registeredClass"], qMp = qM8["$$"]["ptr"]; qM9["baseClass"]; ) qMq = qM9["upcast"](qMq), qM9 = qM9["baseClass"];
        for (; qMn["baseClass"]; ) qMp = qMn["upcast"](qMp), qMn = qMn["baseClass"];
        return qM9 === qMn && qMq === qMp;
      }, "clone"() {
        if (this["$$"]["ptr"] || qxC(this), this["$$"]["preservePointerOnDelete"]) return this["$$"]["count"]["value"] += 1, this;
        var qM8 = qs6(Object["create"](Object["getPrototypeOf"](this), { "$$": { "value": qxy(this["$$"]) } }));
        return qM8["$$"]["count"]["value"] += 1, qM8["$$"]["deleteScheduled"] = false, qM8;
      }, "delete"() {
        this["$$"]["ptr"] || qxC(this), this["$$"]["deleteScheduled"] && !this["$$"]["preservePointerOnDelete"] && qxI("Object already scheduled for deletion"), qxH(this), qxh(this["$$"]), this["$$"]["preservePointerOnDelete"] || (this["$$"]["smartPtr"] = void 0, this["$$"]["ptr"] = void 0);
      }, "isDeleted"() {
        return !this["$$"]["ptr"];
      }, "deleteLater"() {
        return this["$$"]["ptr"] || qxC(this), this["$$"]["deleteScheduled"] && !this["$$"]["preservePointerOnDelete"] && qxI("Object already scheduled for deletion"), qxJ["push"](this), qxJ["length"] === 1 && qxP && qxP(qxY), this["$$"]["deleteScheduled"] = true, this;
      } });
    };
    function qs8() {
    }
    var qs9 = (qM8, qM9) => Object["defineProperty"](qM9, "name", { "value": qM8 }), qsq = (qM8, qM9, qMq) => {
      if (qM8[qM9]["overloadTable"] === void 0) {
        var qMn = qM8[qM9];
        qM8[qM9] = function(...qMp) {
          return qM8[qM9]["overloadTable"]["hasOwnProperty"](qMp["length"]) || qxI("Function '" + qMq + "' called with an invalid number of arguments (" + qMp["length"] + ") - expects one of (" + qM8[qM9]["overloadTable"] + ")!"), qM8[qM9]["overloadTable"][qMp["length"]]["apply"](this, qMp);
        }, qM8[qM9]["overloadTable"] = [], qM8[qM9]["overloadTable"][qMn["argCount"]] = qMn;
      }
    }, qsn = (qM8, qM9, qMq) => {
      qgL["hasOwnProperty"](qM8) ? (qxI("Cannot register public name '" + qM8 + "' twice"), qsq(qgL, qM8, qM8), qgL["hasOwnProperty"](qMq) && qxI("Cannot register multiple overloads of a function with the same number of arguments (" + qMq + ")!"), qgL[qM8]["overloadTable"][qMq] = qM9) : qgL[qM8] = qM9;
    }, qsp = 48, qsg = 57, qsx = (qM8) => {
      if (qM8 === void 0) return "_unknown";
      qM8 = qM8["replace"](/[^a-zA-Z0-9_]/g, "$");
      var qM9 = qM8["charCodeAt"](0);
      return qM9 >= qsp && qM9 <= qsg ? "_" + qM8 : qM8;
    };
    function qss(qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs) {
      this["name"] = qM8, this["constructor"] = qM9, this["instancePrototype"] = qMq, this["rawDestructor"] = qMn, this["baseClass"] = qMp, this["getActualType"] = qMg, this["upcast"] = qMx, this["downcast"] = qMs, this["pureVirtualFunctions"] = [];
    }
    var qsE = (qM8, qM9, qMq) => {
      for (; qM9 !== qMq; ) qM9["upcast"] || qxI("Expected null or instance of " + qMq["name"] + ", got an instance of " + qM9["name"]), qM8 = qM9["upcast"](qM8), qM9 = qM9["baseClass"];
      return qM8;
    };
    function qsM(qM8, qM9) {
      if (qM9 === null) return this["isReference"] && qxI("null is not a valid " + this["name"]), 0;
      qM9["$$"] || qxI('Cannot pass "' + qsh(qM9) + '" as a ' + this["name"]), qM9["$$"]["ptr"] || qxI("Cannot pass deleted object as a pointer of type " + this["name"]);
      var qMq = qM9["$$"]["ptrType"]["registeredClass"], qMn = qsE(qM9["$$"]["ptr"], qMq, this["registeredClass"]);
      return qMn;
    }
    function qsf(qM8, qM9) {
      var qMq;
      if (qM9 === null) return this["isReference"] && qxI("null is not a valid " + this["name"]), this["isSmartPointer"] ? (qMq = this["rawConstructor"](), qM8 !== null && qM8["push"](this["rawDestructor"], qMq), qMq) : 0;
      (!qM9 || !qM9["$$"]) && qxI('Cannot pass "' + qsh(qM9) + '" as a ' + this["name"]), qM9["$$"]["ptr"] || qxI("Cannot pass deleted object as a pointer of type " + this["name"]), !this["isConst"] && qM9["$$"]["ptrType"]["isConst"] && qxI("Cannot convert argument of type " + (qM9["$$"]["smartPtrType"] ? qM9["$$"]["smartPtrType"]["name"] : qM9["$$"]["ptrType"]["name"]) + " to parameter type " + this["name"]);
      var qMn = qM9["$$"]["ptrType"]["registeredClass"];
      if (qMq = qsE(qM9["$$"]["ptr"], qMn, this["registeredClass"]), this["isSmartPointer"]) switch (qM9["$$"]["smartPtr"] === void 0 && qxI("Passing raw pointer to smart pointer is illegal"), this["sharingPolicy"]) {
        case 0:
          qM9["$$"]["smartPtrType"] === this ? qMq = qM9["$$"]["smartPtr"] : qxI("Cannot convert argument of type " + (qM9["$$"]["smartPtrType"] ? qM9["$$"]["smartPtrType"]["name"] : qM9["$$"]["ptrType"]["name"]) + " to parameter type " + this["name"]);
          break;
        case 1:
          qMq = qM9["$$"]["smartPtr"];
          break;
        case 2:
          if (qM9["$$"]["smartPtrType"] === this) qMq = qM9["$$"]["smartPtr"];
          else {
            var qMp = qM9["clone"]();
            qMq = this["rawShare"](qMq, qsl["toHandle"](() => qMp["delete"]())), qM8 !== null && qM8["push"](this["rawDestructor"], qMq);
          }
          break;
        default:
          qxI("Unsupporting sharing policy");
      }
      return qMq;
    }
    function qsS(qM8, qM9) {
      if (qM9 === null) return this["isReference"] && qxI("null is not a valid " + this["name"]), 0;
      qM9["$$"] || qxI('Cannot pass "' + qsh(qM9) + '" as a ' + this["name"]), qM9["$$"]["ptr"] || qxI("Cannot pass deleted object as a pointer of type " + this["name"]), qM9["$$"]["ptrType"]["isConst"] && qxI("Cannot convert argument of type " + qM9["$$"]["ptrType"]["name"] + " to parameter type " + this["name"]);
      var qMq = qM9["$$"]["ptrType"]["registeredClass"], qMn = qsE(qM9["$$"]["ptr"], qMq, this["registeredClass"]);
      return qMn;
    }
    function qsF(qM8) {
      return this["fromWireType"](qgP[qM8 >> 2]);
    }
    var qst = () => {
      Object["assign"](qsk["prototype"], { "getPointee"(qM8) {
        return this["rawGetPointee"] && (qM8 = this["rawGetPointee"](qM8)), qM8;
      }, "destructor"(qM8) {
        var qM9;
        (qM9 = this["rawDestructor"]) == null || qM9["call"](this, qM8);
      }, "argPackAdvance": qxd, "readValueFromPointer": qsF, "fromWireType": qs5 });
    };
    function qsk(qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME, qMM, qMf) {
      this["name"] = qM8, this["registeredClass"] = qM9, this["isReference"] = qMq, this["isConst"] = qMn, this["isSmartPointer"] = qMp, this["pointeeType"] = qMg, this["sharingPolicy"] = qMx, this["rawGetPointee"] = qMs, this["rawConstructor"] = qME, this["rawShare"] = qMM, this["rawDestructor"] = qMf, !qMp && qM9["baseClass"] === void 0 ? qMn ? (this["toWireType"] = qsM, this["destructorFunction"] = null) : (this["toWireType"] = qsS, this["destructorFunction"] = null) : this["toWireType"] = qsf;
    }
    var qsO = (qM8, qM9, qMq) => {
      qgL["hasOwnProperty"](qM8) || qxR("Replacing nonexistent public symbol"), qgL[qM8]["overloadTable"] !== void 0 && qMq !== void 0 ? qgL[qM8]["overloadTable"][qMq] = qM9 : (qgL[qM8] = qM9, qgL[qM8]["argCount"] = qMq);
    }, qsW = (qM8, qM9, qMq) => {
      var qMn = qgL["dynCall_" + qM8];
      return qMn(qM9, ...qMq);
    }, qsi = [], qsD, qsm = (qM8) => {
      var qM9 = qsi[qM8];
      return qM9 || (qM8 >= qsi["length"] && (qsi["length"] = qM8 + 1), qsi[qM8] = qM9 = qsD["get"](qM8)), qM9;
    }, qsa = (qM8, qM9, qMq = []) => {
      if (qM8["includes"]("j")) return qsW(qM8, qM9, qMq);
      var qMn = qsm(qM9)(...qMq);
      return qMn;
    }, qsZ = (qM8, qM9) => (...qMq) => qsa(qM8, qM9, qMq), qsw = (qM8, qM9) => {
      qM8 = qxG(qM8);
      function qMq() {
        return qM8["includes"]("j") ? qsZ(qM8, qM9) : qsm(qM9);
      }
      var qMn = qMq();
      return typeof qMn != "function" && qxI("unknown function pointer with signature " + qM8 + ": " + qM9), qMn;
    }, qse = (qM8, qM9) => {
      var qMq = qs9(qM9, function(qMn) {
        this["name"] = qM9, this["message"] = qMn;
        var qMp = new Error(qMn)["stack"];
        qMp !== void 0 && (this["stack"] = this["toString"]() + "\n" + qMp["replace"](/^Error(:[^\n]*)?\n/, ""));
      });
      return qMq["prototype"] = Object["create"](qM8["prototype"]), qMq["prototype"]["constructor"] = qMq, qMq["prototype"]["toString"] = function() {
        return this["message"] === void 0 ? this["name"] : this["name"] + ": " + this["message"];
      }, qMq;
    }, qsz, qsc = (qM8) => {
      var qM9 = qM4(qM8), qMq = qxG(qM9);
      return qM3(qM9), qMq;
    }, qsX = (qM8, qM9) => {
      var qMq = [], qMn = {};
      function qMp(qMg) {
        if (!qMn[qMg] && !qxu[qMg]) {
          if (qxj[qMg]) {
            qxj[qMg]["forEach"](qMp);
            return;
          }
          qMq["push"](qMg), qMn[qMg] = true;
        }
      }
      throw qM9["forEach"](qMp), new qsz(qM8 + ": " + qMq["map"](qsc)["join"]([", "]));
    }, qsG = (qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME, qMM, qMf, qMS, qMF) => {
      qMf = qxG(qMf), qMg = qsw(qMp, qMg), qMs && (qMs = qsw(qMx, qMs)), qMM && (qMM = qsw(qME, qMM)), qMF = qsw(qMS, qMF);
      var qMt = qsx(qMf);
      qsn(qMt, function() {
        qsX("Cannot construct " + qMf + " due to unbound types", [qMn]);
      }), qxo([qM8, qM9, qMq], qMn ? [qMn] : [], (qMk) => {
        var qMO;
        qMk = qMk[0];
        var qMW, qMi;
        qMn ? (qMW = qMk["registeredClass"], qMi = qMW["instancePrototype"]) : qMi = qs8["prototype"];
        var qMD = qs9(qMf, function(...qMz) {
          if (Object["getPrototypeOf"](this) !== qMm) throw new qxL("Use 'new' to construct " + qMf);
          if (qMa["constructor_body"] === void 0) throw new qxL(qMf + " has no accessible constructor");
          var qMc = qMa["constructor_body"][qMz["length"]];
          if (qMc === void 0) throw new qxL("Tried to invoke ctor of " + qMf + " with invalid number of parameters (" + qMz["length"] + ") - expected (" + Object["keys"](qMa["constructor_body"])["toString"]() + ") parameters instead!");
          return qMc["apply"](this, qMz);
        }), qMm = Object["create"](qMi, { "constructor": { "value": qMD } });
        qMD["prototype"] = qMm;
        var qMa = new qss(qMf, qMD, qMm, qMF, qMW, qMg, qMs, qMM);
        qMa["baseClass"] && ((qMO = qMa["baseClass"])["__derivedClasses"] != null || (qMO["__derivedClasses"] = []), qMa["baseClass"]["__derivedClasses"]["push"](qMa));
        var qMZ = new qsk(qMf, qMa, true, false, false), qMw = new qsk(qMf + "*", qMa, false, false, false), qMe = new qsk(qMf + " const*", qMa, false, true, false);
        return qxK[qM8] = { "pointerType": qMw, "constPointerType": qMe }, qsO(qMt, qMD), [qMZ, qMw, qMe];
      });
    }, qsN = (qM8, qM9) => {
      for (var qMq = [], qMn = 0; qMn < qM8; qMn++) qMq["push"](qgP[qM9 + qMn * 4 >> 2]);
      return qMq;
    }, qsu = (qM8) => {
      for (; qM8["length"]; ) {
        var qM9 = qM8["pop"](), qMq = qM8["pop"]();
        qMq(qM9);
      }
    };
    function qsj(qM8) {
      for (var qM9 = 1; qM9 < qM8["length"]; ++qM9) if (qM8[qM9] !== null && qM8[qM9]["destructorFunction"] === void 0) return true;
      return false;
    }
    function qsL(qM8, qM9, qMq, qMn, qMp, qMg) {
      var qMx = qM9["length"];
      qMx < 2 && qxI("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var qMs = qM9[1] !== null && qMq !== null, qME = qsj(qM9), qMM = qM9[0]["name"] !== "void", qMf = qMx - 2, qMS = new Array(qMf), qMF = [], qMt = [], qMk = function(...qMO) {
        qMO["length"] !== qMf && qxI("function " + qM8 + " called with " + qMO["length"] + " arguments, expected " + qMf), qMt["length"] = 0;
        var qMW;
        qMF["length"] = qMs ? 2 : 1, qMF[0] = qMp, qMs && (qMW = qM9[1]["toWireType"](qMt, this), qMF[1] = qMW);
        for (var qMi = 0; qMi < qMf; ++qMi) qMS[qMi] = qM9[qMi + 2]["toWireType"](qMt, qMO[qMi]), qMF["push"](qMS[qMi]);
        var qMD = qMn(...qMF);
        function qMm(qMa) {
          if (qME) qsu(qMt);
          else for (var qMZ = qMs ? 1 : 2; qMZ < qM9["length"]; qMZ++) {
            var qMw = qMZ === 1 ? qMW : qMS[qMZ - 2];
            qM9[qMZ]["destructorFunction"] !== null && qM9[qMZ]["destructorFunction"](qMw);
          }
          if (qMM) return qM9[0]["fromWireType"](qMa);
        }
        return qMm(qMD);
      };
      return qs9(qM8, qMk);
    }
    var qsI = (qM8, qM9, qMq, qMn, qMp, qMg) => {
      var qMx = qsN(qM9, qMq);
      qMp = qsw(qMn, qMp), qxo([], [qM8], (qMs) => {
        qMs = qMs[0];
        var qME = "constructor " + qMs["name"];
        if (qMs["registeredClass"]["constructor_body"] === void 0 && (qMs["registeredClass"]["constructor_body"] = []), qMs["registeredClass"]["constructor_body"][qM9 - 1] !== void 0) throw new qxL("Cannot register multiple constructors with identical number of parameters (" + (qM9 - 1) + ") for class '" + qMs["name"] + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return qMs["registeredClass"]["constructor_body"][qM9 - 1] = () => {
          qsX("Cannot construct " + qMs["name"] + " due to unbound types", qMx);
        }, qxo([], qMx, (qMM) => (qMM["splice"](1, 0, null), qMs["registeredClass"]["constructor_body"][qM9 - 1] = qsL(qME, qMM, null, qMp, qMg), [])), [];
      });
    }, qsb = (qM8) => {
      qM8 = qM8["trim"]();
      const qM9 = qM8["indexOf"]("(");
      return qM9 !== -1 ? qM8["substr"](0, qM9) : qM8;
    }, qsR = (qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME) => {
      var qMM = qsN(qMq, qMn);
      qM9 = qxG(qM9), qM9 = qsb(qM9), qMg = qsw(qMp, qMg), qxo([], [qM8], (qMf) => {
        qMf = qMf[0];
        var qMS = qMf["name"] + "." + qM9;
        qM9["startsWith"]("@@") && (qM9 = Symbol[qM9["substring"](2)]), qMs && qMf["registeredClass"]["pureVirtualFunctions"]["push"](qM9);
        function qMF() {
          qsX("Cannot call " + qMS + " due to unbound types", qMM);
        }
        var qMt = qMf["registeredClass"]["instancePrototype"], qMk = qMt[qM9];
        return qMk === void 0 || qMk["overloadTable"] === void 0 && qMk["className"] !== qMf["name"] && qMk["argCount"] === qMq - 2 ? (qMF["argCount"] = qMq - 2, qMF["className"] = qMf["name"], qMt[qM9] = qMF) : (qsq(qMt, qM9, qMS), qMt[qM9]["overloadTable"][qMq - 2] = qMF), qxo([], qMM, (qMO) => {
          var qMW = qsL(qMS, qMO, qMf, qMg, qMx);
          return qMt[qM9]["overloadTable"] === void 0 ? (qMW["argCount"] = qMq - 2, qMt[qM9] = qMW) : qMt[qM9]["overloadTable"][qMq - 2] = qMW, [];
        }), [];
      });
    }, qso = (qM8, qM9, qMq) => (qM8 instanceof Object || qxI(qMq + ' with invalid "this": ' + qM8), qM8 instanceof qM9["registeredClass"]["constructor"] || qxI(qMq + ' incompatible with "this" of type ' + qM8["constructor"]["name"]), qM8["$$"]["ptr"] || qxI("cannot call emscripten binding method " + qMq + " on deleted object"), qsE(qM8["$$"]["ptr"], qM8["$$"]["ptrType"]["registeredClass"], qM9["registeredClass"])), qsr = (qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME, qMM) => {
      qM9 = qxG(qM9), qMp = qsw(qMn, qMp), qxo([], [qM8], (qMf) => {
        qMf = qMf[0];
        var qMS = qMf["name"] + "." + qM9, qMF = { "get"() {
          qsX("Cannot access " + qMS + " due to unbound types", [qMq, qMx]);
        }, "enumerable": true, "configurable": true };
        return qME ? qMF["set"] = () => qsX("Cannot access " + qMS + " due to unbound types", [qMq, qMx]) : qMF["set"] = (qMt) => qxI(qMS + " is a read-only property"), Object["defineProperty"](qMf["registeredClass"]["instancePrototype"], qM9, qMF), qxo([], qME ? [qMq, qMx] : [qMq], (qMt) => {
          var qMk = qMt[0], qMO = { "get"() {
            var qMi = qso(this, qMf, qMS + " getter");
            return qMk["fromWireType"](qMp(qMg, qMi));
          }, "enumerable": true };
          if (qME) {
            qME = qsw(qMs, qME);
            var qMW = qMt[1];
            qMO["set"] = function(qMi) {
              var qMD = qso(this, qMf, qMS + " setter"), qMm = [];
              qME(qMM, qMD, qMW["toWireType"](qMm, qMi)), qsu(qMm);
            };
          }
          return Object["defineProperty"](qMf["registeredClass"]["instancePrototype"], qM9, qMO), [];
        }), [];
      });
    }, qsQ = [], qsd = [], qsv = (qM8) => {
      qM8 > 9 && --qsd[qM8 + 1] === 0 && (qsd[qM8] = void 0, qsQ["push"](qM8));
    }, qsy = () => qsd["length"] / 2 - 5 - qsQ["length"], qsC = () => {
      qsd["push"](0, 1, void 0, 1, null, 1, true, 1, false, 1), qgL["count_emval_handles"] = qsy;
    }, qsl = { "toValue": (qM8) => (qM8 || qxI("Cannot use deleted val. handle = " + qM8), qsd[qM8]), "toHandle": (qM8) => {
      switch (qM8) {
        case void 0:
          return 2;
        case null:
          return 4;
        case true:
          return 6;
        case false:
          return 8;
        default: {
          const qM9 = qsQ["pop"]() || qsd["length"];
          return qsd[qM9] = qM8, qsd[qM9 + 1] = 1, qM9;
        }
      }
    } }, qsH = { "name": "emscripten::val", "fromWireType": (qM8) => {
      var qM9 = qsl["toValue"](qM8);
      return qsv(qM8), qM9;
    }, "toWireType": (qM8, qM9) => qsl["toHandle"](qM9), "argPackAdvance": qxd, "readValueFromPointer": qsF, "destructorFunction": null }, qsA = (qM8) => qxQ(qM8, qsH), qsh = (qM8) => {
      if (qM8 === null) return "null";
      var qM9 = typeof qM8;
      return qM9 === "object" || qM9 === "array" || qM9 === "function" ? qM8["toString"]() : "" + qM8;
    }, qsT = (qM8, qM9) => {
      switch (qM9) {
        case 4:
          return function(qMq) {
            return this["fromWireType"](qgU[qMq >> 2]);
          };
        case 8:
          return function(qMq) {
            return this["fromWireType"](qx0[qMq >> 3]);
          };
        default:
          throw new TypeError("invalid float width (" + qM9 + "): " + qM8);
      }
    }, qsK = (qM8, qM9, qMq) => {
      qM9 = qxG(qM9), qxQ(qM8, { "name": qM9, "fromWireType": (qMn) => qMn, "toWireType": (qMn, qMp) => qMp, "argPackAdvance": qxd, "readValueFromPointer": qsT(qM9, qMq), "destructorFunction": null });
    }, qsB = (qM8, qM9, qMq) => {
      switch (qM9) {
        case 1:
          return qMq ? (qMn) => qgK[qMn] : (qMn) => qgB[qMn];
        case 2:
          return qMq ? (qMn) => qgV[qMn >> 1] : (qMn) => qgJ[qMn >> 1];
        case 4:
          return qMq ? (qMn) => qgY[qMn >> 2] : (qMn) => qgP[qMn >> 2];
        default:
          throw new TypeError("invalid integer width (" + qM9 + "): " + qM8);
      }
    }, qsV = (qM8, qM9, qMq, qMn, qMp) => {
      qM9 = qxG(qM9);
      var qMg = (qMf) => qMf;
      if (qMn === 0) {
        var qMx = 32 - 8 * qMq;
        qMg = (qMf) => qMf << qMx >>> qMx;
      }
      var qMs = qM9["includes"]("unsigned"), qME = (qMf, qMS) => {
      }, qMM;
      qMs ? qMM = function(qMf, qMS) {
        return qME(qMS, this["name"]), qMS >>> 0;
      } : qMM = function(qMf, qMS) {
        return qME(qMS, this["name"]), qMS;
      }, qxQ(qM8, { "name": qM9, "fromWireType": qMg, "toWireType": qMM, "argPackAdvance": qxd, "readValueFromPointer": qsB(qM9, qMq, qMn !== 0), "destructorFunction": null });
    }, qsJ = (qM8, qM9, qMq) => {
      var qMn = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], qMp = qMn[qM9];
      function qMg(qMx) {
        var qMs = qgP[qMx >> 2], qME = qgP[qMx + 4 >> 2];
        return new qMp(qgK["buffer"], qME, qMs);
      }
      qMq = qxG(qMq), qxQ(qM8, { "name": qMq, "fromWireType": qMg, "argPackAdvance": qxd, "readValueFromPointer": qMg }, { "ignoreDuplicateRegistrations": true });
    }, qsY = (qM8, qM9, qMq, qMn) => {
      if (!(qMn > 0)) return 0;
      for (var qMp = qMq, qMg = qMq + qMn - 1, qMx = 0; qMx < qM8["length"]; ++qMx) {
        var qMs = qM8["charCodeAt"](qMx);
        if (qMs >= 55296 && qMs <= 57343) {
          var qME = qM8["charCodeAt"](++qMx);
          qMs = 65536 + ((qMs & 1023) << 10) | qME & 1023;
        }
        if (qMs <= 127) {
          if (qMq >= qMg) break;
          qM9[qMq++] = qMs;
        } else {
          if (qMs <= 2047) {
            if (qMq + 1 >= qMg) break;
            qM9[qMq++] = 192 | qMs >> 6, qM9[qMq++] = 128 | qMs & 63;
          } else {
            if (qMs <= 65535) {
              if (qMq + 2 >= qMg) break;
              qM9[qMq++] = 224 | qMs >> 12, qM9[qMq++] = 128 | qMs >> 6 & 63, qM9[qMq++] = 128 | qMs & 63;
            } else {
              if (qMq + 3 >= qMg) break;
              qM9[qMq++] = 240 | qMs >> 18, qM9[qMq++] = 128 | qMs >> 12 & 63, qM9[qMq++] = 128 | qMs >> 6 & 63, qM9[qMq++] = 128 | qMs & 63;
            }
          }
        }
      }
      return qM9[qMq] = 0, qMq - qMp;
    }, qsP = (qM8, qM9, qMq) => qsY(qM8, qgB, qM9, qMq), qsU = (qM8) => {
      for (var qM9 = 0, qMq = 0; qMq < qM8["length"]; ++qMq) {
        var qMn = qM8["charCodeAt"](qMq);
        qMn <= 127 ? qM9++ : qMn <= 2047 ? qM9 += 2 : qMn >= 55296 && qMn <= 57343 ? (qM9 += 4, ++qMq) : qM9 += 3;
      }
      return qM9;
    }, qE0 = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0, qE1 = (qM8, qM9, qMq) => {
      for (var qMn = qM9 + qMq, qMp = qM9; qM8[qMp] && !(qMp >= qMn); ) ++qMp;
      if (qMp - qM9 > 16 && qM8["buffer"] && qE0) return qE0["decode"](qM8["subarray"](qM9, qMp));
      for (var qMg = ""; qM9 < qMp; ) {
        var qMx = qM8[qM9++];
        if (!(qMx & 128)) {
          qMg += String["fromCharCode"](qMx);
          continue;
        }
        var qMs = qM8[qM9++] & 63;
        if ((qMx & 224) == 192) {
          qMg += String["fromCharCode"]((qMx & 31) << 6 | qMs);
          continue;
        }
        var qME = qM8[qM9++] & 63;
        if ((qMx & 240) == 224 ? qMx = (qMx & 15) << 12 | qMs << 6 | qME : qMx = (qMx & 7) << 18 | qMs << 12 | qME << 6 | qM8[qM9++] & 63, qMx < 65536) qMg += String["fromCharCode"](qMx);
        else {
          var qMM = qMx - 65536;
          qMg += String["fromCharCode"](55296 | qMM >> 10, 56320 | qMM & 1023);
        }
      }
      return qMg;
    }, qE2 = (qM8, qM9) => qM8 ? qE1(qgB, qM8, qM9) : "", qE3 = (qM8, qM9) => {
      qM9 = qxG(qM9);
      var qMq = qM9 === "std::string";
      qxQ(qM8, { "name": qM9, "fromWireType"(qMn) {
        var qMp = qgP[qMn >> 2], qMg = qMn + 4, qMx;
        if (qMq) for (var qMs = qMg, qME = 0; qME <= qMp; ++qME) {
          var qMM = qMg + qME;
          if (qME == qMp || qgB[qMM] == 0) {
            var qMf = qMM - qMs, qMS = qE2(qMs, qMf);
            qMx === void 0 ? qMx = qMS : (qMx += "\0", qMx += qMS), qMs = qMM + 1;
          }
        }
        else {
          for (var qMF = new Array(qMp), qME = 0; qME < qMp; ++qME) qMF[qME] = String["fromCharCode"](qgB[qMg + qME]);
          qMx = qMF["join"]("");
        }
        return qM3(qMn), qMx;
      }, "toWireType"(qMn, qMp) {
        qMp instanceof ArrayBuffer && (qMp = new Uint8Array(qMp));
        var qMg, qMx = typeof qMp == "string";
        qMx || qMp instanceof Uint8Array || qMp instanceof Uint8ClampedArray || qMp instanceof Int8Array || qxI("Cannot pass non-string to std::string"), qMq && qMx ? qMg = qsU(qMp) : qMg = qMp["length"];
        var qMs = qM2(4 + qMg + 1), qME = qMs + 4;
        if (qgP[qMs >> 2] = qMg, qMq && qMx) qsP(qMp, qME, qMg + 1);
        else {
          if (qMx) for (var qMM = 0; qMM < qMg; ++qMM) {
            var qMf = qMp["charCodeAt"](qMM);
            qMf > 255 && (qM3(qME), qxI("String has UTF-16 code units that do not fit in 8 bits")), qgB[qME + qMM] = qMf;
          }
          else {
            for (var qMM = 0; qMM < qMg; ++qMM) qgB[qME + qMM] = qMp[qMM];
          }
        }
        return qMn !== null && qMn["push"](qM3, qMs), qMs;
      }, "argPackAdvance": qxd, "readValueFromPointer": qsF, "destructorFunction"(qMn) {
        qM3(qMn);
      } });
    }, qE4 = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0, qE5 = (qM8, qM9) => {
      for (var qMq = qM8, qMn = qMq >> 1, qMp = qMn + qM9 / 2; !(qMn >= qMp) && qgJ[qMn]; ) ++qMn;
      if (qMq = qMn << 1, qMq - qM8 > 32 && qE4) return qE4["decode"](qgB["subarray"](qM8, qMq));
      for (var qMg = "", qMx = 0; !(qMx >= qM9 / 2); ++qMx) {
        var qMs = qgV[qM8 + qMx * 2 >> 1];
        if (qMs == 0) break;
        qMg += String["fromCharCode"](qMs);
      }
      return qMg;
    }, qE6 = (qM8, qM9, qMq) => {
      if (qMq != null || (qMq = 2147483647), qMq < 2) return 0;
      qMq -= 2;
      for (var qMn = qM9, qMp = qMq < qM8["length"] * 2 ? qMq / 2 : qM8["length"], qMg = 0; qMg < qMp; ++qMg) {
        var qMx = qM8["charCodeAt"](qMg);
        qgV[qM9 >> 1] = qMx, qM9 += 2;
      }
      return qgV[qM9 >> 1] = 0, qM9 - qMn;
    }, qE7 = (qM8) => qM8["length"] * 2, qE8 = (qM8, qM9) => {
      for (var qMq = 0, qMn = ""; !(qMq >= qM9 / 4); ) {
        var qMp = qgY[qM8 + qMq * 4 >> 2];
        if (qMp == 0) break;
        if (++qMq, qMp >= 65536) {
          var qMg = qMp - 65536;
          qMn += String["fromCharCode"](55296 | qMg >> 10, 56320 | qMg & 1023);
        } else qMn += String["fromCharCode"](qMp);
      }
      return qMn;
    }, qE9 = (qM8, qM9, qMq) => {
      if (qMq != null || (qMq = 2147483647), qMq < 4) return 0;
      for (var qMn = qM9, qMp = qMn + qMq - 4, qMg = 0; qMg < qM8["length"]; ++qMg) {
        var qMx = qM8["charCodeAt"](qMg);
        if (qMx >= 55296 && qMx <= 57343) {
          var qMs = qM8["charCodeAt"](++qMg);
          qMx = 65536 + ((qMx & 1023) << 10) | qMs & 1023;
        }
        if (qgY[qM9 >> 2] = qMx, qM9 += 4, qM9 + 4 > qMp) break;
      }
      return qgY[qM9 >> 2] = 0, qM9 - qMn;
    }, qEq = (qM8) => {
      for (var qM9 = 0, qMq = 0; qMq < qM8["length"]; ++qMq) {
        var qMn = qM8["charCodeAt"](qMq);
        qMn >= 55296 && qMn <= 57343 && ++qMq, qM9 += 4;
      }
      return qM9;
    }, qEn = (qM8, qM9, qMq) => {
      qMq = qxG(qMq);
      var qMn, qMp, qMg, qMx;
      qM9 === 2 ? (qMn = qE5, qMp = qE6, qMx = qE7, qMg = (qMs) => qgJ[qMs >> 1]) : qM9 === 4 && (qMn = qE8, qMp = qE9, qMx = qEq, qMg = (qMs) => qgP[qMs >> 2]), qxQ(qM8, { "name": qMq, "fromWireType": (qMs) => {
        for (var qME = qgP[qMs >> 2], qMM, qMf = qMs + 4, qMS = 0; qMS <= qME; ++qMS) {
          var qMF = qMs + 4 + qMS * qM9;
          if (qMS == qME || qMg(qMF) == 0) {
            var qMt = qMF - qMf, qMk = qMn(qMf, qMt);
            qMM === void 0 ? qMM = qMk : (qMM += "\0", qMM += qMk), qMf = qMF + qM9;
          }
        }
        return qM3(qMs), qMM;
      }, "toWireType": (qMs, qME) => {
        typeof qME != "string" && qxI("Cannot pass non-string to C++ string type " + qMq);
        var qMM = qMx(qME), qMf = qM2(4 + qMM + qM9);
        return qgP[qMf >> 2] = qMM / qM9, qMp(qME, qMf + 4, qMM + qM9), qMs !== null && qMs["push"](qM3, qMf), qMf;
      }, "argPackAdvance": qxd, "readValueFromPointer": qsF, "destructorFunction"(qMs) {
        qM3(qMs);
      } });
    }, qEp = (qM8, qM9) => {
      qM9 = qxG(qM9), qxQ(qM8, { "isVoid": true, "name": qM9, "argPackAdvance": 0, "fromWireType": () => {
      }, "toWireType": (qMq, qMn) => {
      } });
    };
    function qEg(qM8) {
      if (qEz["xhrs"]["has"](qM8)) {
        var qM9 = qEz["xhrs"]["get"](qM8);
        qEz["xhrs"]["free"](qM8), qM9["readyState"] > 0 && qM9["readyState"] < 4 && qM9["abort"]();
      }
    }
    var qEx = (qM8, qM9) => {
      var qMq = qxu[qM8];
      return qMq === void 0 && qxI(qM9 + " has unknown type " + qsc(qM8)), qMq;
    }, qEs = (qM8, qM9, qMq) => {
      var qMn = [], qMp = qM8["toWireType"](qMn, qMq);
      return qMn["length"] && (qgP[qM9 >> 2] = qsl["toHandle"](qMn)), qMp;
    }, qEE = (qM8, qM9, qMq) => (qM8 = qsl["toValue"](qM8), qM9 = qEx(qM9, "emval::as"), qEs(qM9, qMq, qM8)), qEM = {}, qEf = (qM8) => {
      var qM9 = qEM[qM8];
      return qM9 === void 0 ? qxG(qM8) : qM9;
    }, qES = () => {
      if (typeof globalThis == "object") return globalThis;
      function qM8(qM9) {
        qM9["$$$embind_global$$$"] = qM9;
        var qMq = typeof $$$embind_global$$$ == "object" && qM9["$$$embind_global$$$"] == qM9;
        return qMq || delete qM9["$$$embind_global$$$"], qMq;
      }
      if (typeof $$$embind_global$$$ == "object" || (typeof global == "object" && qM8(global) ? $$$embind_global$$$ = global : typeof self == "object" && qM8(self) && ($$$embind_global$$$ = self), typeof $$$embind_global$$$ == "object")) return $$$embind_global$$$;
      throw Error("unable to get global object.");
    }, qEF = (qM8) => qM8 === 0 ? qsl["toHandle"](qES()) : (qM8 = qEf(qM8), qsl["toHandle"](qES()[qM8])), qEt = (qM8, qM9) => (qM8 = qsl["toValue"](qM8), qM9 = qsl["toValue"](qM9), qsl["toHandle"](qM8[qM9])), qEk = (qM8) => qsl["toHandle"](qEf(qM8)), qEO = (qM8) => {
      var qM9 = qsl["toValue"](qM8);
      qsu(qM9), qsv(qM8);
    }, qEW = (qM8, qM9) => {
      qM8 = qEx(qM8, "_emval_take_value");
      var qMq = qM8["readValueFromPointer"](qM9);
      return qsl["toHandle"](qMq);
    }, qEi = () => {
      qxM("");
    }, qED = () => !qgd, qEm = (qM8, qM9, qMq) => qgB["copyWithin"](qM8, qM9, qM9 + qMq), qEa = () => 2147483648, qEZ = (qM8) => {
      var qM9 = qgA["buffer"], qMq = (qM8 - qM9["byteLength"] + 65535) / 65536;
      try {
        return qgA["grow"](qMq), qx1(), 1;
      } catch (qMn) {
      }
    }, qEw = (qM8) => {
      var qM9 = qgB["length"];
      qM8 >>>= 0;
      var qMq = qEa();
      if (qM8 > qMq) return false;
      for (var qMn = (qME, qMM) => qME + (qMM - qME % qMM) % qMM, qMp = 1; qMp <= 4; qMp *= 2) {
        var qMg = qM9 * (1 + 0.2 / qMp);
        qMg = Math["min"](qMg, qM8 + 100663296);
        var qMx = Math["min"](qMq, qMn(Math["max"](qM8, qMg), 65536)), qMs = qEZ(qMx);
        if (qMs) return true;
      }
      return false;
    };
    class qEe {
      constructor() {
        this["allocated"] = [void 0], this["freelist"] = [];
      }
      ["get"](qM8) {
        return this["allocated"][qM8];
      }
      ["has"](qM8) {
        return this["allocated"][qM8] !== void 0;
      }
      ["allocate"](qM8) {
        var qM9 = this["freelist"]["pop"]() || this["allocated"]["length"];
        return this["allocated"][qM9] = qM8, qM9;
      }
      ["free"](qM8) {
        this["allocated"][qM8] = void 0, this["freelist"]["push"](qM8);
      }
    }
    var qEz = { "openDatabase"(qM8, qM9, qMq, qMn) {
      try {
        var qMp = indexedDB["open"](qM8, qM9);
      } catch (qMg) {
        return qMn(qMg);
      }
      qMp["onupgradeneeded"] = (qMx) => {
        var qMs = qMx["target"]["result"];
        qMs["objectStoreNames"]["contains"]("FILES") && qMs["deleteObjectStore"]("FILES"), qMs["createObjectStore"]("FILES");
      }, qMp["onsuccess"] = (qMx) => qMq(qMx["target"]["result"]), qMp["onerror"] = qMn;
    }, "init"() {
      qEz["xhrs"] = new qEe();
      var qM8 = (qMq) => {
        qEz["dbInstance"] = qMq, qxE();
      }, qM9 = () => {
        qEz["dbInstance"] = false, qxE();
      };
      qxs(), qEz["openDatabase"]("emscripten_filesystem", 1, qM8, qM9);
    } };
    function qEc(qM8, qM9, qMq, qMn, qMp) {
      var qMg = qgP[qM8 + 8 >> 2];
      if (!qMg) {
        qMq(qM8, 0, "no url specified!");
        return;
      }
      var qMx = qE2(qMg), qMs = qM8 + 112, qME = qE2(qMs + 0);
      qME || (qME = "GET");
      var qMM = qgP[qMs + 56 >> 2], qMf = qgP[qMs + 68 >> 2], qMS = qgP[qMs + 72 >> 2], qMF = qgP[qMs + 76 >> 2], qMt = qgP[qMs + 80 >> 2], qMk = qgP[qMs + 84 >> 2], qMO = qgP[qMs + 88 >> 2], qMW = qgP[qMs + 52 >> 2], qMi = !!(qMW & 1), qMD = !!(qMW & 2), qMm = !!(qMW & 64), qMa = qMf ? qE2(qMf) : void 0, qMZ = qMS ? qE2(qMS) : void 0, qMw = new XMLHttpRequest();
      if (qMw["withCredentials"] = !!qgB[qMs + 60], qMw["open"](qME, qMx, !qMm, qMa, qMZ), qMm || (qMw["timeout"] = qMM), qMw["url_"] = qMx, qMw["responseType"] = "arraybuffer", qMt) {
        var qMe = qE2(qMt);
        qMw["overrideMimeType"](qMe);
      }
      if (qMF) for (; ; ) {
        var qMz = qgP[qMF >> 2];
        if (!qMz) break;
        var qMc = qgP[qMF + 4 >> 2];
        if (!qMc) break;
        qMF += 8;
        var qMX = qE2(qMz), qMG = qE2(qMc);
        qMw["setRequestHeader"](qMX, qMG);
      }
      var qMN = qEz["xhrs"]["allocate"](qMw);
      qgP[qM8 >> 2] = qMN;
      var qMu = qMk && qMO ? qgB["slice"](qMk, qMk + qMO) : null;
      function qMj() {
        var qML = 0, qMI = 0;
        qMw["response"] && qMi && qgP[qM8 + 12 >> 2] === 0 && (qMI = qMw["response"]["byteLength"]), qMI > 0 && (qML = qM2(qMI), qgB["set"](new Uint8Array(qMw["response"]), qML)), qgP[qM8 + 12 >> 2] = qML, qER(qM8 + 16, qMI), qER(qM8 + 24, 0);
        var qMb = qMw["response"] ? qMw["response"]["byteLength"] : 0;
        qMb && qER(qM8 + 32, qMb), qgV[qM8 + 40 >> 1] = qMw["readyState"], qgV[qM8 + 42 >> 1] = qMw["status"], qMw["statusText"] && qsP(qMw["statusText"], qM8 + 44, 64);
      }
      qMw["onload"] = (qML) => {
        qEz["xhrs"]["has"](qMN) && (qMj(), qMw["status"] >= 200 && qMw["status"] < 300 ? qM9 == null || qM9(qM8, qMw, qML) : qMq == null || qMq(qM8, qMw, qML));
      }, qMw["onerror"] = (qML) => {
        qEz["xhrs"]["has"](qMN) && (qMj(), qMq == null || qMq(qM8, qMw, qML));
      }, qMw["ontimeout"] = (qML) => {
        qEz["xhrs"]["has"](qMN) && (qMq == null || qMq(qM8, qMw, qML));
      }, qMw["onprogress"] = (qML) => {
        if (qEz["xhrs"]["has"](qMN)) {
          var qMI = qMi && qMD && qMw["response"] ? qMw["response"]["byteLength"] : 0, qMb = 0;
          qMI > 0 && qMi && qMD && (qMb = qM2(qMI), qgB["set"](new Uint8Array(qMw["response"]), qMb)), qgP[qM8 + 12 >> 2] = qMb, qER(qM8 + 16, qMI), qER(qM8 + 24, qML["loaded"] - qMI), qER(qM8 + 32, qML["total"]), qgV[qM8 + 40 >> 1] = qMw["readyState"], qMw["readyState"] >= 3 && qMw["status"] === 0 && qML["loaded"] > 0 && (qMw["status"] = 200), qgV[qM8 + 42 >> 1] = qMw["status"], qMw["statusText"] && qsP(qMw["statusText"], qM8 + 44, 64), qMn == null || qMn(qM8, qMw, qML), qMb && qM3(qMb);
        }
      }, qMw["onreadystatechange"] = (qML) => {
        qEz["xhrs"]["has"](qMN) && (qgV[qM8 + 40 >> 1] = qMw["readyState"], qMw["readyState"] >= 2 && (qgV[qM8 + 42 >> 1] = qMw["status"]), qMp == null || qMp(qM8, qMw, qML));
      };
      try {
        qMw["send"](qMu);
      } catch (qML) {
        qMq == null || qMq(qM8, qMw, qML);
      }
    }
    var qEX = (qM8) => {
      if (qM8 instanceof qxD || qM8 == "unwind") return qgT;
      qgr(1, qM8);
    }, qEG = 0, qEN = () => qxa || qEG > 0, qEu = (qM8) => {
      var qM9;
      qgT = qM8, qEN() || ((qM9 = qgL["onExit"]) == null || qM9["call"](qgL, qM8), qgh = true), qgr(qM8, new qxD(qM8));
    }, qEj = (qM8, qM9) => {
      qgT = qM8, qEu(qM8);
    }, qEL = qEj, qEI = () => {
      if (!qEN()) try {
        qEL(qgT);
      } catch (qM8) {
        qEX(qM8);
      }
    }, qEb = (qM8) => {
      if (!qgh) try {
        qM8(), qEI();
      } catch (qM9) {
        qEX(qM9);
      }
    }, qER = (qM8, qM9) => {
      qgP[qM8 >> 2] = qM9;
      var qMq = qgP[qM8 >> 2];
      qgP[qM8 + 4 >> 2] = (qM9 - qMq) / 4294967296;
    };
    function qEo(qM8, qM9, qMq, qMn, qMp) {
      if (!qM8) {
        qMp(qM9, 0, "IndexedDB not available!");
        return;
      }
      var qMg = qM9 + 112, qMx = qgP[qMg + 64 >> 2];
      qMx || (qMx = qgP[qM9 + 8 >> 2]);
      var qMs = qE2(qMx);
      try {
        var qME = qM8["transaction"](["FILES"], "readwrite"), qMM = qME["objectStore"]("FILES"), qMf = qMM["put"](qMq, qMs);
        qMf["onsuccess"] = (qMS) => {
          qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 200, qsP("OK", qM9 + 44, 64), qMn(qM9, 0, qMs);
        }, qMf["onerror"] = (qMS) => {
          qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 413, qsP("Payload Too Large", qM9 + 44, 64), qMp(qM9, 0, qMS);
        };
      } catch (qMS) {
        qMp(qM9, 0, qMS);
      }
    }
    function qEr(qM8, qM9, qMq, qMn) {
      if (!qM8) {
        qMn(qM9, 0, "IndexedDB not available!");
        return;
      }
      var qMp = qM9 + 112, qMg = qgP[qMp + 64 >> 2];
      qMg || (qMg = qgP[qM9 + 8 >> 2]);
      var qMx = qE2(qMg);
      try {
        var qMs = qM8["transaction"](["FILES"], "readonly"), qME = qMs["objectStore"]("FILES"), qMM = qME["get"](qMx);
        qMM["onsuccess"] = (qMf) => {
          if (qMf["target"]["result"]) {
            var qMS = qMf["target"]["result"], qMF = qMS["byteLength"] || qMS["length"], qMt = qM2(qMF);
            qgB["set"](new Uint8Array(qMS), qMt), qgP[qM9 + 12 >> 2] = qMt, qER(qM9 + 16, qMF), qER(qM9 + 24, 0), qER(qM9 + 32, qMF), qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 200, qsP("OK", qM9 + 44, 64), qMq(qM9, 0, qMS);
          } else qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 404, qsP("Not Found", qM9 + 44, 64), qMn(qM9, 0, "no data");
        }, qMM["onerror"] = (qMf) => {
          qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 404, qsP("Not Found", qM9 + 44, 64), qMn(qM9, 0, qMf);
        };
      } catch (qMf) {
        qMn(qM9, 0, qMf);
      }
    }
    function qEQ(qM8, qM9, qMq, qMn) {
      if (!qM8) {
        qMn(qM9, 0, "IndexedDB not available!");
        return;
      }
      var qMp = qM9 + 112, qMg = qgP[qMp + 64 >> 2];
      qMg || (qMg = qgP[qM9 + 8 >> 2]);
      var qMx = qE2(qMg);
      try {
        var qMs = qM8["transaction"](["FILES"], "readwrite"), qME = qMs["objectStore"]("FILES"), qMM = qME["delete"](qMx);
        qMM["onsuccess"] = (qMf) => {
          var qMS = qMf["target"]["result"];
          qgP[qM9 + 12 >> 2] = 0, qER(qM9 + 16, 0), qER(qM9 + 24, 0), qER(qM9 + 32, 0), qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 200, qsP("OK", qM9 + 44, 64), qMq(qM9, 0, qMS);
        }, qMM["onerror"] = (qMf) => {
          qgV[qM9 + 40 >> 1] = 4, qgV[qM9 + 42 >> 1] = 404, qsP("Not Found", qM9 + 44, 64), qMn(qM9, 0, qMf);
        };
      } catch (qMf) {
        qMn(qM9, 0, qMf);
      }
    }
    function qEd(qM8, qM9, qMq, qMn, qMp) {
      var qMg = qM8 + 112, qMx = qgP[qMg + 36 >> 2], qMs = qgP[qMg + 40 >> 2], qME = qgP[qMg + 44 >> 2], qMM = qgP[qMg + 48 >> 2], qMf = qgP[qMg + 52 >> 2], qMS = !!(qMf & 64);
      function qMF(qMX) {
        qMS ? qMX() : qEb(qMX);
      }
      var qMt = (qMX, qMG, qMN) => {
        qMF(() => {
          qMx ? qsm(qMx)(qMX) : qM9 == null || qM9(qMX);
        });
      }, qMk = (qMX, qMG, qMN) => {
        qMF(() => {
          qME ? qsm(qME)(qMX) : qMn == null || qMn(qMX);
        });
      }, qMO = (qMX, qMG, qMN) => {
        qMF(() => {
          qMs ? qsm(qMs)(qMX) : qMq == null || qMq(qMX);
        });
      }, qMW = (qMX, qMG, qMN) => {
        qMF(() => {
          qMM ? qsm(qMM)(qMX) : qMp == null || qMp(qMX);
        });
      }, qMi = (qMX, qMG, qMN) => {
        qEc(qMX, qMt, qMO, qMk, qMW);
      }, qMD = (qMX, qMG, qMN) => {
        var qMu = (qML, qMI, qMb) => {
          qMF(() => {
            qMx ? qsm(qMx)(qML) : qM9 == null || qM9(qML);
          });
        }, qMj = (qML, qMI, qMb) => {
          qMF(() => {
            qMx ? qsm(qMx)(qML) : qM9 == null || qM9(qML);
          });
        };
        qEo(qEz["dbInstance"], qMX, qMG["response"], qMu, qMj);
      }, qMm = (qMX, qMG, qMN) => {
        qEc(qMX, qMD, qMO, qMk, qMW);
      }, qMa = qE2(qMg + 0), qMZ = !!(qMf & 16), qMw = !!(qMf & 4), qMe = !!(qMf & 32);
      if (qMa === "EM_IDB_STORE") {
        var qMz = qgP[qMg + 84 >> 2], qMc = qgP[qMg + 88 >> 2];
        qEo(qEz["dbInstance"], qM8, qgB["slice"](qMz, qMz + qMc), qMt, qMO);
      } else {
        if (qMa === "EM_IDB_DELETE") qEQ(qEz["dbInstance"], qM8, qMt, qMO);
        else {
          if (!qMZ) qEr(qEz["dbInstance"], qM8, qMt, qMe ? qMO : qMw ? qMm : qMi);
          else {
            if (!qMe) qEc(qM8, qMw ? qMD : qMt, qMO, qMk, qMW);
            else return 0;
          }
        }
      }
      return qM8;
    }
    var qEv = {}, qEy = () => qgo || "./this.program", qEC = () => {
      if (!qEC["strings"]) {
        var qM8 = (typeof navigator == "object" && navigator["languages"] && navigator["languages"][0] || "C")["replace"]("-", "_") + ".UTF-8", qM9 = { "USER": "web_user", "LOGNAME": "web_user", "PATH": "/", "PWD": "/", "HOME": "/home/web_user", "LANG": qM8, "_": qEy() };
        for (var qMq in qEv) qEv[qMq] === void 0 ? delete qM9[qMq] : qM9[qMq] = qEv[qMq];
        var qMn = [];
        for (var qMq in qM9) qMn["push"](qMq + "=" + qM9[qMq]);
        qEC["strings"] = qMn;
      }
      return qEC["strings"];
    }, qEl = (qM8, qM9) => {
      for (var qMq = 0; qMq < qM8["length"]; ++qMq) qgK[qM9++] = qM8["charCodeAt"](qMq);
      qgK[qM9] = 0;
    }, qEH = (qM8, qM9) => {
      var qMq = 0;
      return qEC()["forEach"]((qMn, qMp) => {
        var qMg = qM9 + qMq;
        qgP[qM8 + qMp * 4 >> 2] = qMg, qEl(qMn, qMg), qMq += qMn["length"] + 1;
      }), 0;
    }, qEA = (qM8, qM9) => {
      var qMq = qEC();
      qgP[qM8 >> 2] = qMq["length"];
      var qMn = 0;
      return qMq["forEach"]((qMp) => qMn += qMp["length"] + 1), qgP[qM9 >> 2] = qMn, 0;
    }, qEh = (qM8) => qM8 % 4 === 0 && (qM8 % 100 !== 0 || qM8 % 400 === 0), qET = (qM8, qM9) => {
      for (var qMq = 0, qMn = 0; qMn <= qM9; qMq += qM8[qMn++]) ;
      return qMq;
    }, qEK = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], qEB = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], qEV = (qM8, qM9) => {
      for (var qMq = new Date(qM8["getTime"]()); qM9 > 0; ) {
        var qMn = qEh(qMq["getFullYear"]()), qMp = qMq["getMonth"](), qMg = (qMn ? qEK : qEB)[qMp];
        if (qM9 > qMg - qMq["getDate"]()) qM9 -= qMg - qMq["getDate"]() + 1, qMq["setDate"](1), qMp < 11 ? qMq["setMonth"](qMp + 1) : (qMq["setMonth"](0), qMq["setFullYear"](qMq["getFullYear"]() + 1));
        else return qMq["setDate"](qMq["getDate"]() + qM9), qMq;
      }
      return qMq;
    };
    function qEJ(qM8, qM9, qMq) {
      var qMn = qsU(qM8) + 1, qMp = new Array(qMn);
      return qsY(qM8, qMp, 0, qMp["length"]), qMp;
    }
    var qEY = (qM8, qM9) => {
      qgK["set"](qM8, qM9);
    }, qEP = (qM8, qM9, qMq, qMn) => {
      var qMp = qgP[qMn + 40 >> 2], qMg = { "tm_sec": qgY[qMn >> 2], "tm_min": qgY[qMn + 4 >> 2], "tm_hour": qgY[qMn + 8 >> 2], "tm_mday": qgY[qMn + 12 >> 2], "tm_mon": qgY[qMn + 16 >> 2], "tm_year": qgY[qMn + 20 >> 2], "tm_wday": qgY[qMn + 24 >> 2], "tm_yday": qgY[qMn + 28 >> 2], "tm_isdst": qgY[qMn + 32 >> 2], "tm_gmtoff": qgY[qMn + 36 >> 2], "tm_zone": qMp ? qE2(qMp) : "" }, qMx = qE2(qMq), qMs = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var qME in qMs) qMx = qMx["replace"](new RegExp(qME, "g"), qMs[qME]);
      var qMM = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], qMf = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function qMS(qMD, qMm, qMa) {
        for (var qMZ = typeof qMD == "number" ? qMD["toString"]() : qMD || ""; qMZ["length"] < qMm; ) qMZ = qMa[0] + qMZ;
        return qMZ;
      }
      function qMF(qMD, qMm) {
        return qMS(qMD, qMm, "0");
      }
      function qMt(qMD, qMm) {
        function qMa(qMw) {
          return qMw < 0 ? -1 : qMw > 0 ? 1 : 0;
        }
        var qMZ;
        return (qMZ = qMa(qMD["getFullYear"]() - qMm["getFullYear"]())) === 0 && (qMZ = qMa(qMD["getMonth"]() - qMm["getMonth"]())) === 0 && (qMZ = qMa(qMD["getDate"]() - qMm["getDate"]())), qMZ;
      }
      function qMk(qMD) {
        switch (qMD["getDay"]()) {
          case 0:
            return new Date(qMD["getFullYear"]() - 1, 11, 29);
          case 1:
            return qMD;
          case 2:
            return new Date(qMD["getFullYear"](), 0, 3);
          case 3:
            return new Date(qMD["getFullYear"](), 0, 2);
          case 4:
            return new Date(qMD["getFullYear"](), 0, 1);
          case 5:
            return new Date(qMD["getFullYear"]() - 1, 11, 31);
          case 6:
            return new Date(qMD["getFullYear"]() - 1, 11, 30);
        }
      }
      function qMO(qMD) {
        var qMm = qEV(new Date(qMD["tm_year"] + 1900, 0, 1), qMD["tm_yday"]), qMa = new Date(qMm["getFullYear"](), 0, 4), qMZ = new Date(qMm["getFullYear"]() + 1, 0, 4), qMw = qMk(qMa), qMe = qMk(qMZ);
        return qMt(qMw, qMm) <= 0 ? qMt(qMe, qMm) <= 0 ? qMm["getFullYear"]() + 1 : qMm["getFullYear"]() : qMm["getFullYear"]() - 1;
      }
      var qMW = { "%a": (qMD) => qMM[qMD["tm_wday"]]["substring"](0, 3), "%A": (qMD) => qMM[qMD["tm_wday"]], "%b": (qMD) => qMf[qMD["tm_mon"]]["substring"](0, 3), "%B": (qMD) => qMf[qMD["tm_mon"]], "%C": (qMD) => {
        var qMm = qMD["tm_year"] + 1900;
        return qMF(qMm / 100 | 0, 2);
      }, "%d": (qMD) => qMF(qMD["tm_mday"], 2), "%e": (qMD) => qMS(qMD["tm_mday"], 2, " "), "%g": (qMD) => qMO(qMD)["toString"]()["substring"](2), "%G": qMO, "%H": (qMD) => qMF(qMD["tm_hour"], 2), "%I": (qMD) => {
        var qMm = qMD["tm_hour"];
        return qMm == 0 ? qMm = 12 : qMm > 12 && (qMm -= 12), qMF(qMm, 2);
      }, "%j": (qMD) => qMF(qMD["tm_mday"] + qET(qEh(qMD["tm_year"] + 1900) ? qEK : qEB, qMD["tm_mon"] - 1), 3), "%m": (qMD) => qMF(qMD["tm_mon"] + 1, 2), "%M": (qMD) => qMF(qMD["tm_min"], 2), "%n": () => "\n", "%p": (qMD) => qMD["tm_hour"] >= 0 && qMD["tm_hour"] < 12 ? "AM" : "PM", "%S": (qMD) => qMF(qMD["tm_sec"], 2), "%t": () => "	", "%u": (qMD) => qMD["tm_wday"] || 7, "%U": (qMD) => {
        var qMm = qMD["tm_yday"] + 7 - qMD["tm_wday"];
        return qMF(Math["floor"](qMm / 7), 2);
      }, "%V": (qMD) => {
        var qMm = Math["floor"]((qMD["tm_yday"] + 7 - (qMD["tm_wday"] + 6) % 7) / 7);
        if ((qMD["tm_wday"] + 371 - qMD["tm_yday"] - 2) % 7 <= 2 && qMm++, qMm) {
          if (qMm == 53) {
            var qMa = (qMD["tm_wday"] + 371 - qMD["tm_yday"]) % 7;
            qMa != 4 && (qMa != 3 || !qEh(qMD["tm_year"])) && (qMm = 1);
          }
        } else {
          qMm = 52;
          var qMZ = (qMD["tm_wday"] + 7 - qMD["tm_yday"] - 1) % 7;
          (qMZ == 4 || qMZ == 5 && qEh(qMD["tm_year"] % 400 - 1)) && qMm++;
        }
        return qMF(qMm, 2);
      }, "%w": (qMD) => qMD["tm_wday"], "%W": (qMD) => {
        var qMm = qMD["tm_yday"] + 7 - (qMD["tm_wday"] + 6) % 7;
        return qMF(Math["floor"](qMm / 7), 2);
      }, "%y": (qMD) => (qMD["tm_year"] + 1900)["toString"]()["substring"](2), "%Y": (qMD) => qMD["tm_year"] + 1900, "%z": (qMD) => {
        var qMm = qMD["tm_gmtoff"], qMa = qMm >= 0;
        return qMm = Math["abs"](qMm) / 60, qMm = qMm / 60 * 100 + qMm % 60, (qMa ? "+" : "-") + ("0000" + qMm)["slice"](-4);
      }, "%Z": (qMD) => qMD["tm_zone"], "%%": () => "%" };
      qMx = qMx["replace"](/%%/g, "\0\0");
      for (var qME in qMW) qMx["includes"](qME) && (qMx = qMx["replace"](new RegExp(qME, "g"), qMW[qME](qMg)));
      qMx = qMx["replace"](/\0\0/g, "%");
      var qMi = qEJ(qMx);
      return qMi["length"] > qM9 ? 0 : (qEY(qMi, qM8), qMi["length"] - 1);
    }, qEU = (qM8, qM9, qMq, qMn, qMp) => qEP(qM8, qM9, qMq, qMn);
    qxc(), qxL = qgL["BindingError"] = class extends Error {
      constructor(qM8) {
        super(qM8), this["name"] = "BindingError";
      }
    }, qxb = qgL["InternalError"] = class extends Error {
      constructor(qM8) {
        super(qM8), this["name"] = "InternalError";
      }
    }, qs7(), qs0(), qst(), qsz = qgL["UnboundTypeError"] = qse(Error, "UnboundTypeError"), qsC(), qEz["init"]();
    var qM0 = { "a": qxe, "s": qxz, "z": qxv, "l": qsG, "f": qsI, "d": qsR, "o": qsr, "y": qsA, "r": qsK, "e": qsV, "b": qsJ, "q": qE3, "m": qEn, "A": qEp, "B": qEg, "g": qEE, "c": qsv, "n": qEF, "h": qEt, "j": qEk, "i": qEO, "k": qEW, "p": qEi, "D": qED, "x": qEm, "w": qEw, "C": qEd, "u": qEH, "v": qEA, "t": qEU }, qM1 = qxi(), qM2 = (qM8) => (qM2 = qM1["G"])(qM8), qM3 = (qM8) => (qM3 = qM1["I"])(qM8), qM4 = (qM8) => (qM4 = qM1["J"])(qM8), qM5 = (qM8) => (qM5 = qM1["K"])(qM8);
    qgL["dynCall_viijii"] = (qM8, qM9, qMq, qMn, qMp, qMg, qMx) => (qgL["dynCall_viijii"] = qM1["L"])(qM8, qM9, qMq, qMn, qMp, qMg, qMx), qgL["dynCall_iiiiij"] = (qM8, qM9, qMq, qMn, qMp, qMg, qMx) => (qgL["dynCall_iiiiij"] = qM1["M"])(qM8, qM9, qMq, qMn, qMp, qMg, qMx), qgL["dynCall_iiiiijj"] = (qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME) => (qgL["dynCall_iiiiijj"] = qM1["N"])(qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME), qgL["dynCall_iiiiiijj"] = (qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME, qMM) => (qgL["dynCall_iiiiiijj"] = qM1["O"])(qM8, qM9, qMq, qMn, qMp, qMg, qMx, qMs, qME, qMM);
    var qM6;
    qxp = function qM8() {
      qM6 || qM7(), qM6 || (qxp = qM8);
    };
    function qM7() {
      if (qxn > 0 || (qx5(), qxn > 0)) return;
      function qM9() {
        qM6 || (qM6 = true, qgL["calledRun"] = true, !qgh && (qx6(), qgI(qgL), qgL["onRuntimeInitialized"] && qgL["onRuntimeInitialized"](), qx7()));
      }
      qgL["setStatus"] ? (qgL["setStatus"]("Running..."), setTimeout(function() {
        setTimeout(function() {
          qgL["setStatus"]("");
        }, 1), qM9();
      }, 1)) : qM9();
    }
    if (qgL["preInit"]) {
      for (typeof qgL["preInit"] == "function" && (qgL["preInit"] = [qgL["preInit"]]); qgL["preInit"]["length"] > 0; ) qgL["preInit"]["pop"]()();
    }
    return qM7(), qgj["ready"];
  };
})();
async function jB(qgu, qgj = "./", qgL = false) {
  const qgI = await jK({ "locateFile": (qgb) => qgj + qgb });
  return qgI["Loader"]["prototype"]["promisify"] = function(qgb, ...qgR) {
    return qgb["call"](this, ...qgR), new Promise((qgo) => {
      const qgr = setInterval(() => {
        if (this["ready"]) return clearInterval(qgr), qgo(this["status"]);
      }, 5);
    });
  }, qgI["Loader"]["prototype"]["load"] = function(qgb) {
    return this["promisify"](this["loadAsync"], qgb, qgL);
  }, qgI["Loader"]["prototype"]["remove"] = function(qgb) {
    return this["promisify"](this["removeAsync"], qgb);
  }, qgI["DictLoader"]["prototype"]["loadDict"] = function(qgb) {
    return this["promisify"](this["loadDictAsync"], qgu, qgb);
  }, qgI;
}
var jV = (() => {
  var qgu = typeof document != "undefined" && document["currentScript"] ? document["currentScript"]["src"] : void 0;
  return function(qgj = {}) {
    var qgL = qgj, qgI, qgb;
    qgL["ready"] = new Promise((qED, qEm) => {
      qgI = qED, qgb = qEm;
    });
    var qgR = Object["assign"]({}, qgL), qgo = true, qgr = "";
    function qgQ(qED) {
      return qgL["locateFile"] ? qgL["locateFile"](qED, qgr) : qgr + qED;
    }
    typeof document != "undefined" && document["currentScript"] && (qgr = document["currentScript"]["src"]), qgu && (qgr = qgu), qgr["startsWith"]("blob:") ? qgr = "" : qgr = qgr["substr"](0, qgr["replace"](/[?#].*/, "")["lastIndexOf"]("/") + 1), qgL["print"] || console["log"]["bind"](console);
    var qgd = qgL["printErr"] || console["error"]["bind"](console);
    Object["assign"](qgL, qgR), qgR = null, qgL["arguments"] && qgL["arguments"], qgL["thisProgram"] && qgL["thisProgram"], qgL["quit"] && qgL["quit"];
    var qgv;
    qgL["wasmBinary"] && (qgv = qgL["wasmBinary"]);
    var qgy, qgl = false, qgH, qgA, qgh, qgT, qgK, qgB, qgV, qgJ;
    function qgY() {
      var qED = qgy["buffer"];
      qgL["HEAP8"] = qgH = new Int8Array(qED), qgL["HEAP16"] = qgh = new Int16Array(qED), qgL["HEAPU8"] = qgA = new Uint8Array(qED), qgL["HEAPU16"] = qgT = new Uint16Array(qED), qgL["HEAP32"] = qgK = new Int32Array(qED), qgL["HEAPU32"] = qgB = new Uint32Array(qED), qgL["HEAPF32"] = qgV = new Float32Array(qED), qgL["HEAPF64"] = qgJ = new Float64Array(qED);
    }
    var qgP = [], qgU = [], qx0 = [];
    function qx1() {
      if (qgL["preRun"]) {
        for (typeof qgL["preRun"] == "function" && (qgL["preRun"] = [qgL["preRun"]]); qgL["preRun"]["length"]; ) qx4(qgL["preRun"]["shift"]());
      }
      qxk(qgP);
    }
    function qx2() {
      qxk(qgU);
    }
    function qx3() {
      if (qgL["postRun"]) {
        for (typeof qgL["postRun"] == "function" && (qgL["postRun"] = [qgL["postRun"]]); qgL["postRun"]["length"]; ) qx6(qgL["postRun"]["shift"]());
      }
      qxk(qx0);
    }
    function qx4(qED) {
      qgP["unshift"](qED);
    }
    function qx5(qED) {
      qgU["unshift"](qED);
    }
    function qx6(qED) {
      qx0["unshift"](qED);
    }
    var qx7 = 0, qx8 = null;
    function qx9(qED) {
      var qEm;
      qx7++, (qEm = qgL["monitorRunDependencies"]) == null || qEm["call"](qgL, qx7);
    }
    function qxq(qED) {
      var qEm;
      if (qx7--, (qEm = qgL["monitorRunDependencies"]) == null || qEm["call"](qgL, qx7), qx7 == 0 && qx8) {
        var qEa = qx8;
        qx8 = null, qEa();
      }
    }
    function qxn(qED) {
      var qEm;
      (qEm = qgL["onAbort"]) == null || qEm["call"](qgL, qED), qED = "Aborted(" + qED + ")", qgd(qED), qgl = true, qED += ". Build with -sASSERTIONS for more info.";
      var qEa = new WebAssembly["RuntimeError"](qED);
      throw qgb(qEa), qEa;
    }
    var qxp = "data:application/octet-stream;base64,", qxs = (qED) => qED["startsWith"](qxp), qxE;
    qxE = "poseutils.wasm", qxs(qxE) || (qxE = qgQ(qxE));
    function qxM(qED) {
      if (qED == qxE && qgv) return new Uint8Array(qgv);
      throw "both async and sync fetching of the wasm failed";
    }
    function qxf(qED) {
      return !qgv && qgo && typeof fetch == "function" ? fetch(qED, { "credentials": "same-origin" })["then"]((qEm) => {
        if (!qEm["ok"]) throw "failed to load wasm binary file at '" + qED + "'";
        return qEm["arrayBuffer"]();
      })["catch"](() => qxM(qED)) : Promise["resolve"]()["then"](() => qxM(qED));
    }
    function qxS(qED, qEm, qEa) {
      return qxf(qED)["then"]((qEZ) => WebAssembly["instantiate"](qEZ, qEm))["then"](qEa, (qEZ) => {
        qgd("failed to asynchronously prepare wasm: " + qEZ), qxn(qEZ);
      });
    }
    function qxF(qED, qEm, qEa, qEZ) {
      return !qED && typeof WebAssembly["instantiateStreaming"] == "function" && !qxs(qEm) && typeof fetch == "function" ? fetch(qEm, { "credentials": "same-origin" })["then"]((qEw) => {
        var qEe = WebAssembly["instantiateStreaming"](qEw, qEa);
        return qEe["then"](qEZ, function(qEz) {
          return qgd("wasm streaming compile failed: " + qEz), qgd("falling back to ArrayBuffer instantiation"), qxS(qEm, qEa, qEZ);
        });
      }) : qxS(qEm, qEa, qEZ);
    }
    function qxt() {
      var qED = { "a": qEf };
      function qEm(qEZ, qEw) {
        return qES = qEZ["exports"], qgy = qES["v"], qgY(), qsO = qES["z"], qx5(qES["w"]), qxq(), qES;
      }
      qx9();
      function qEa(qEZ) {
        qEm(qEZ["instance"]);
      }
      if (qgL["instantiateWasm"]) try {
        return qgL["instantiateWasm"](qED, qEm);
      } catch (qEZ) {
        qgd("Module.instantiateWasm callback failed with error: " + qEZ), qgb(qEZ);
      }
      return qxF(qgv, qxE, qED, qEa)["catch"](qgb), {};
    }
    var qxk = (qED) => {
      for (; qED["length"] > 0; ) qED["shift"]()(qgL);
    };
    qgL["noExitRuntime"];
    class qxO {
      constructor(qED) {
        this["excPtr"] = qED, this["ptr"] = qED - 24;
      }
      ["set_type"](qED) {
        qgB[this["ptr"] + 4 >> 2] = qED;
      }
      ["get_type"]() {
        return qgB[this["ptr"] + 4 >> 2];
      }
      ["set_destructor"](qED) {
        qgB[this["ptr"] + 8 >> 2] = qED;
      }
      ["get_destructor"]() {
        return qgB[this["ptr"] + 8 >> 2];
      }
      ["set_caught"](qED) {
        qED = qED ? 1 : 0, qgH[this["ptr"] + 12] = qED;
      }
      ["get_caught"]() {
        return qgH[this["ptr"] + 12] != 0;
      }
      ["set_rethrown"](qED) {
        qED = qED ? 1 : 0, qgH[this["ptr"] + 13] = qED;
      }
      ["get_rethrown"]() {
        return qgH[this["ptr"] + 13] != 0;
      }
      ["init"](qED, qEm) {
        this["set_adjusted_ptr"](0), this["set_type"](qED), this["set_destructor"](qEm);
      }
      ["set_adjusted_ptr"](qED) {
        qgB[this["ptr"] + 16 >> 2] = qED;
      }
      ["get_adjusted_ptr"]() {
        return qgB[this["ptr"] + 16 >> 2];
      }
      ["get_exception_ptr"]() {
        var qED = qEO(this["get_type"]());
        if (qED) return qgB[this["excPtr"] >> 2];
        var qEm = this["get_adjusted_ptr"]();
        return qEm !== 0 ? qEm : this["excPtr"];
      }
    }
    var qxW = 0, qxi = (qED, qEm, qEa) => {
      var qEZ = new qxO(qED);
      throw qEZ["init"](qEm, qEa), qxW = qED, qxW;
    }, qxD = {}, qxm = (qED) => {
      for (; qED["length"]; ) {
        var qEm = qED["pop"](), qEa = qED["pop"]();
        qEa(qEm);
      }
    };
    function qxa(qED) {
      return this["fromWireType"](qgB[qED >> 2]);
    }
    var qxZ = {}, qxw = {}, qxe = {}, qxz, qxc = (qED) => {
      throw new qxz(qED);
    }, qxX = (qED, qEm, qEa) => {
      qED["forEach"](function(qEc) {
        qxe[qEc] = qEm;
      });
      function qEZ(qEc) {
        var qEX = qEa(qEc);
        qEX["length"] !== qED["length"] && qxc("Mismatched type converter count");
        for (var qEG = 0; qEG < qED["length"]; ++qEG) qxo(qED[qEG], qEX[qEG]);
      }
      var qEw = new Array(qEm["length"]), qEe = [], qEz = 0;
      qEm["forEach"]((qEc, qEX) => {
        qxw["hasOwnProperty"](qEc) ? qEw[qEX] = qxw[qEc] : (qEe["push"](qEc), qxZ["hasOwnProperty"](qEc) || (qxZ[qEc] = []), qxZ[qEc]["push"](() => {
          qEw[qEX] = qxw[qEc], ++qEz, qEz === qEe["length"] && qEZ(qEw);
        }));
      }), qEe["length"] === 0 && qEZ(qEw);
    }, qxG = (qED) => {
      var qEm = qxD[qED];
      delete qxD[qED];
      var qEa = qEm["rawConstructor"], qEZ = qEm["rawDestructor"], qEw = qEm["fields"], qEe = qEw["map"]((qEz) => qEz["getterReturnType"])["concat"](qEw["map"]((qEz) => qEz["setterArgumentType"]));
      qxX([qED], qEe, (qEz) => {
        var qEc = {};
        return qEw["forEach"]((qEX, qEG) => {
          var qEN = qEX["fieldName"], qEu = qEz[qEG], qEj = qEX["getter"], qEL = qEX["getterContext"], qEI = qEz[qEG + qEw["length"]], qEb = qEX["setter"], qER = qEX["setterContext"];
          qEc[qEN] = { "read": (qEo) => qEu["fromWireType"](qEj(qEL, qEo)), "write": (qEo, qEr) => {
            var qEQ = [];
            qEb(qER, qEo, qEI["toWireType"](qEQ, qEr)), qxm(qEQ);
          } };
        }), [{ "name": qEm["name"], "fromWireType": (qEX) => {
          var qEG = {};
          for (var qEN in qEc) qEG[qEN] = qEc[qEN]["read"](qEX);
          return qEZ(qEX), qEG;
        }, "toWireType": (qEX, qEG) => {
          for (var qEN in qEc) if (!(qEN in qEG)) throw new TypeError('Missing field: "' + qEN + '"');
          var qEu = qEa();
          for (qEN in qEc) qEc[qEN]["write"](qEu, qEG[qEN]);
          return qEX !== null && qEX["push"](qEZ, qEu), qEu;
        }, "argPackAdvance": qxr, "readValueFromPointer": qxa, "destructorFunction": qEZ }];
      });
    }, qxN = (qED, qEm, qEa, qEZ, qEw) => {
    }, qxu = () => {
      for (var qED = new Array(256), qEm = 0; qEm < 256; ++qEm) qED[qEm] = String["fromCharCode"](qEm);
      qxj = qED;
    }, qxj, qxL = (qED) => {
      for (var qEm = "", qEa = qED; qgA[qEa]; ) qEm += qxj[qgA[qEa++]];
      return qEm;
    }, qxI, qxb = (qED) => {
      throw new qxI(qED);
    };
    function qxR(qED, qEm, qEa = {}) {
      var qEZ = qEm["name"];
      if (qED || qxb('type "' + qEZ + '" must have a positive integer typeid pointer'), qxw["hasOwnProperty"](qED)) {
        if (qEa["ignoreDuplicateRegistrations"]) return;
        qxb("Cannot register type '" + qEZ + "' twice");
      }
      if (qxw[qED] = qEm, delete qxe[qED], qxZ["hasOwnProperty"](qED)) {
        var qEw = qxZ[qED];
        delete qxZ[qED], qEw["forEach"]((qEe) => qEe());
      }
    }
    function qxo(qED, qEm, qEa = {}) {
      if (!("argPackAdvance" in qEm)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return qxR(qED, qEm, qEa);
    }
    var qxr = 8, qxQ = (qED, qEm, qEa, qEZ) => {
      qEm = qxL(qEm), qxo(qED, { "name": qEm, "fromWireType": function(qEw) {
        return !!qEw;
      }, "toWireType": function(qEw, qEe) {
        return qEe ? qEa : qEZ;
      }, "argPackAdvance": qxr, "readValueFromPointer": function(qEw) {
        return this["fromWireType"](qgA[qEw]);
      }, "destructorFunction": null });
    }, qxd = (qED) => ({ "count": qED["count"], "deleteScheduled": qED["deleteScheduled"], "preservePointerOnDelete": qED["preservePointerOnDelete"], "ptr": qED["ptr"], "ptrType": qED["ptrType"], "smartPtr": qED["smartPtr"], "smartPtrType": qED["smartPtrType"] }), qxv = (qED) => {
      function qEm(qEa) {
        return qEa["$$"]["ptrType"]["registeredClass"]["name"];
      }
      qxb(qEm(qED) + " instance already deleted");
    }, qxy = false, qxC = (qED) => {
    }, qxl = (qED) => {
      qED["smartPtr"] ? qED["smartPtrType"]["rawDestructor"](qED["smartPtr"]) : qED["ptrType"]["registeredClass"]["rawDestructor"](qED["ptr"]);
    }, qxH = (qED) => {
      qED["count"]["value"] -= 1;
      var qEm = qED["count"]["value"] === 0;
      qEm && qxl(qED);
    }, qxA = (qED, qEm, qEa) => {
      if (qEm === qEa) return qED;
      if (qEa["baseClass"] === void 0) return null;
      var qEZ = qxA(qED, qEm, qEa["baseClass"]);
      return qEZ === null ? null : qEa["downcast"](qEZ);
    }, qxh = {}, qxT = () => Object["keys"](qxU)["length"], qxK = () => {
      var qED = [];
      for (var qEm in qxU) qxU["hasOwnProperty"](qEm) && qED["push"](qxU[qEm]);
      return qED;
    }, qxB = [], qxV = () => {
      for (; qxB["length"]; ) {
        var qED = qxB["pop"]();
        qED["$$"]["deleteScheduled"] = false, qED["delete"]();
      }
    }, qxJ, qxY = (qED) => {
      qxJ = qED, qxB["length"] && qxJ && qxJ(qxV);
    }, qxP = () => {
      qgL["getInheritedInstanceCount"] = qxT, qgL["getLiveInheritedInstances"] = qxK, qgL["flushPendingDeletes"] = qxV, qgL["setDelayFunction"] = qxY;
    }, qxU = {}, qs0 = (qED, qEm) => {
      for (qEm === void 0 && qxb("ptr should not be undefined"); qED["baseClass"]; ) qEm = qED["upcast"](qEm), qED = qED["baseClass"];
      return qEm;
    }, qs1 = (qED, qEm) => (qEm = qs0(qED, qEm), qxU[qEm]), qs2 = (qED, qEm) => {
      (!qEm["ptrType"] || !qEm["ptr"]) && qxc("makeClassHandle requires ptr and ptrType");
      var qEa = !!qEm["smartPtrType"], qEZ = !!qEm["smartPtr"];
      return qEa !== qEZ && qxc("Both smartPtrType and smartPtr must be specified"), qEm["count"] = { "value": 1 }, qs4(Object["create"](qED, { "$$": { "value": qEm, "writable": true } }));
    };
    function qs3(qED) {
      var qEm = this["getPointee"](qED);
      if (!qEm) return this["destructor"](qED), null;
      var qEa = qs1(this["registeredClass"], qEm);
      if (qEa !== void 0) {
        if (qEa["$$"]["count"]["value"] === 0) return qEa["$$"]["ptr"] = qEm, qEa["$$"]["smartPtr"] = qED, qEa["clone"]();
        var qEZ = qEa["clone"]();
        return this["destructor"](qED), qEZ;
      }
      function qEw() {
        return this["isSmartPointer"] ? qs2(this["registeredClass"]["instancePrototype"], { "ptrType": this["pointeeType"], "ptr": qEm, "smartPtrType": this, "smartPtr": qED }) : qs2(this["registeredClass"]["instancePrototype"], { "ptrType": this, "ptr": qED });
      }
      var qEe = this["registeredClass"]["getActualType"](qEm), qEz = qxh[qEe];
      if (!qEz) return qEw["call"](this);
      var qEc;
      this["isConst"] ? qEc = qEz["constPointerType"] : qEc = qEz["pointerType"];
      var qEX = qxA(qEm, this["registeredClass"], qEc["registeredClass"]);
      return qEX === null ? qEw["call"](this) : this["isSmartPointer"] ? qs2(qEc["registeredClass"]["instancePrototype"], { "ptrType": qEc, "ptr": qEX, "smartPtrType": this, "smartPtr": qED }) : qs2(qEc["registeredClass"]["instancePrototype"], { "ptrType": qEc, "ptr": qEX });
    }
    var qs4 = (qED) => typeof FinalizationRegistry == "undefined" ? (qs4 = (qEm) => qEm, qED) : (qxy = new FinalizationRegistry((qEm) => {
      qxH(qEm["$$"]);
    }), qs4 = (qEm) => {
      var qEa = qEm["$$"], qEZ = !!qEa["smartPtr"];
      if (qEZ) {
        var qEw = { "$$": qEa };
        qxy["register"](qEm, qEw, qEm);
      }
      return qEm;
    }, qxC = (qEm) => qxy["unregister"](qEm), qs4(qED)), qs5 = () => {
      Object["assign"](qs6["prototype"], { "isAliasOf"(qED) {
        if (!(this instanceof qs6) || !(qED instanceof qs6)) return false;
        var qEm = this["$$"]["ptrType"]["registeredClass"], qEa = this["$$"]["ptr"];
        qED["$$"] = qED["$$"];
        for (var qEZ = qED["$$"]["ptrType"]["registeredClass"], qEw = qED["$$"]["ptr"]; qEm["baseClass"]; ) qEa = qEm["upcast"](qEa), qEm = qEm["baseClass"];
        for (; qEZ["baseClass"]; ) qEw = qEZ["upcast"](qEw), qEZ = qEZ["baseClass"];
        return qEm === qEZ && qEa === qEw;
      }, "clone"() {
        if (this["$$"]["ptr"] || qxv(this), this["$$"]["preservePointerOnDelete"]) return this["$$"]["count"]["value"] += 1, this;
        var qED = qs4(Object["create"](Object["getPrototypeOf"](this), { "$$": { "value": qxd(this["$$"]) } }));
        return qED["$$"]["count"]["value"] += 1, qED["$$"]["deleteScheduled"] = false, qED;
      }, "delete"() {
        this["$$"]["ptr"] || qxv(this), this["$$"]["deleteScheduled"] && !this["$$"]["preservePointerOnDelete"] && qxb("Object already scheduled for deletion"), qxC(this), qxH(this["$$"]), this["$$"]["preservePointerOnDelete"] || (this["$$"]["smartPtr"] = void 0, this["$$"]["ptr"] = void 0);
      }, "isDeleted"() {
        return !this["$$"]["ptr"];
      }, "deleteLater"() {
        return this["$$"]["ptr"] || qxv(this), this["$$"]["deleteScheduled"] && !this["$$"]["preservePointerOnDelete"] && qxb("Object already scheduled for deletion"), qxB["push"](this), qxB["length"] === 1 && qxJ && qxJ(qxV), this["$$"]["deleteScheduled"] = true, this;
      } });
    };
    function qs6() {
    }
    var qs7 = (qED, qEm) => Object["defineProperty"](qEm, "name", { "value": qED }), qs8 = (qED, qEm, qEa) => {
      if (qED[qEm]["overloadTable"] === void 0) {
        var qEZ = qED[qEm];
        qED[qEm] = function(...qEw) {
          return qED[qEm]["overloadTable"]["hasOwnProperty"](qEw["length"]) || qxb("Function '" + qEa + "' called with an invalid number of arguments (" + qEw["length"] + ") - expects one of (" + qED[qEm]["overloadTable"] + ")!"), qED[qEm]["overloadTable"][qEw["length"]]["apply"](this, qEw);
        }, qED[qEm]["overloadTable"] = [], qED[qEm]["overloadTable"][qEZ["argCount"]] = qEZ;
      }
    }, qs9 = (qED, qEm, qEa) => {
      qgL["hasOwnProperty"](qED) ? (qxb("Cannot register public name '" + qED + "' twice"), qs8(qgL, qED, qED), qgL["hasOwnProperty"](qEa) && qxb("Cannot register multiple overloads of a function with the same number of arguments (" + qEa + ")!"), qgL[qED]["overloadTable"][qEa] = qEm) : qgL[qED] = qEm;
    }, qsq = 48, qsn = 57, qsp = (qED) => {
      if (qED === void 0) return "_unknown";
      qED = qED["replace"](/[^a-zA-Z0-9_]/g, "$");
      var qEm = qED["charCodeAt"](0);
      return qEm >= qsq && qEm <= qsn ? "_" + qED : qED;
    };
    function qsg(qED, qEm, qEa, qEZ, qEw, qEe, qEz, qEc) {
      this["name"] = qED, this["constructor"] = qEm, this["instancePrototype"] = qEa, this["rawDestructor"] = qEZ, this["baseClass"] = qEw, this["getActualType"] = qEe, this["upcast"] = qEz, this["downcast"] = qEc, this["pureVirtualFunctions"] = [];
    }
    var qsx = (qED, qEm, qEa) => {
      for (; qEm !== qEa; ) qEm["upcast"] || qxb("Expected null or instance of " + qEa["name"] + ", got an instance of " + qEm["name"]), qED = qEm["upcast"](qED), qEm = qEm["baseClass"];
      return qED;
    };
    function qss(qED, qEm) {
      if (qEm === null) return this["isReference"] && qxb("null is not a valid " + this["name"]), 0;
      qEm["$$"] || qxb('Cannot pass "' + qsC(qEm) + '" as a ' + this["name"]), qEm["$$"]["ptr"] || qxb("Cannot pass deleted object as a pointer of type " + this["name"]);
      var qEa = qEm["$$"]["ptrType"]["registeredClass"], qEZ = qsx(qEm["$$"]["ptr"], qEa, this["registeredClass"]);
      return qEZ;
    }
    function qsE(qED, qEm) {
      var qEa;
      if (qEm === null) return this["isReference"] && qxb("null is not a valid " + this["name"]), this["isSmartPointer"] ? (qEa = this["rawConstructor"](), qED !== null && qED["push"](this["rawDestructor"], qEa), qEa) : 0;
      (!qEm || !qEm["$$"]) && qxb('Cannot pass "' + qsC(qEm) + '" as a ' + this["name"]), qEm["$$"]["ptr"] || qxb("Cannot pass deleted object as a pointer of type " + this["name"]), !this["isConst"] && qEm["$$"]["ptrType"]["isConst"] && qxb("Cannot convert argument of type " + (qEm["$$"]["smartPtrType"] ? qEm["$$"]["smartPtrType"]["name"] : qEm["$$"]["ptrType"]["name"]) + " to parameter type " + this["name"]);
      var qEZ = qEm["$$"]["ptrType"]["registeredClass"];
      if (qEa = qsx(qEm["$$"]["ptr"], qEZ, this["registeredClass"]), this["isSmartPointer"]) switch (qEm["$$"]["smartPtr"] === void 0 && qxb("Passing raw pointer to smart pointer is illegal"), this["sharingPolicy"]) {
        case 0:
          qEm["$$"]["smartPtrType"] === this ? qEa = qEm["$$"]["smartPtr"] : qxb("Cannot convert argument of type " + (qEm["$$"]["smartPtrType"] ? qEm["$$"]["smartPtrType"]["name"] : qEm["$$"]["ptrType"]["name"]) + " to parameter type " + this["name"]);
          break;
        case 1:
          qEa = qEm["$$"]["smartPtr"];
          break;
        case 2:
          if (qEm["$$"]["smartPtrType"] === this) qEa = qEm["$$"]["smartPtr"];
          else {
            var qEw = qEm["clone"]();
            qEa = this["rawShare"](qEa, qsd["toHandle"](() => qEw["delete"]())), qED !== null && qED["push"](this["rawDestructor"], qEa);
          }
          break;
        default:
          qxb("Unsupporting sharing policy");
      }
      return qEa;
    }
    function qsM(qED, qEm) {
      if (qEm === null) return this["isReference"] && qxb("null is not a valid " + this["name"]), 0;
      qEm["$$"] || qxb('Cannot pass "' + qsC(qEm) + '" as a ' + this["name"]), qEm["$$"]["ptr"] || qxb("Cannot pass deleted object as a pointer of type " + this["name"]), qEm["$$"]["ptrType"]["isConst"] && qxb("Cannot convert argument of type " + qEm["$$"]["ptrType"]["name"] + " to parameter type " + this["name"]);
      var qEa = qEm["$$"]["ptrType"]["registeredClass"], qEZ = qsx(qEm["$$"]["ptr"], qEa, this["registeredClass"]);
      return qEZ;
    }
    var qsf = () => {
      Object["assign"](qsS["prototype"], { "getPointee"(qED) {
        return this["rawGetPointee"] && (qED = this["rawGetPointee"](qED)), qED;
      }, "destructor"(qED) {
        var qEm;
        (qEm = this["rawDestructor"]) == null || qEm["call"](this, qED);
      }, "argPackAdvance": qxr, "readValueFromPointer": qxa, "fromWireType": qs3 });
    };
    function qsS(qED, qEm, qEa, qEZ, qEw, qEe, qEz, qEc, qEX, qEG, qEN) {
      this["name"] = qED, this["registeredClass"] = qEm, this["isReference"] = qEa, this["isConst"] = qEZ, this["isSmartPointer"] = qEw, this["pointeeType"] = qEe, this["sharingPolicy"] = qEz, this["rawGetPointee"] = qEc, this["rawConstructor"] = qEX, this["rawShare"] = qEG, this["rawDestructor"] = qEN, !qEw && qEm["baseClass"] === void 0 ? qEZ ? (this["toWireType"] = qss, this["destructorFunction"] = null) : (this["toWireType"] = qsM, this["destructorFunction"] = null) : this["toWireType"] = qsE;
    }
    var qsF = (qED, qEm, qEa) => {
      qgL["hasOwnProperty"](qED) || qxc("Replacing nonexistent public symbol"), qgL[qED]["overloadTable"] !== void 0 && qEa !== void 0 ? qgL[qED]["overloadTable"][qEa] = qEm : (qgL[qED] = qEm, qgL[qED]["argCount"] = qEa);
    }, qst = (qED, qEm, qEa) => {
      var qEZ = qgL["dynCall_" + qED];
      return qEZ(qEm, ...qEa);
    }, qsk = [], qsO, qsW = (qED) => {
      var qEm = qsk[qED];
      return qEm || (qED >= qsk["length"] && (qsk["length"] = qED + 1), qsk[qED] = qEm = qsO["get"](qED)), qEm;
    }, qsi = (qED, qEm, qEa = []) => {
      if (qED["includes"]("j")) return qst(qED, qEm, qEa);
      var qEZ = qsW(qEm)(...qEa);
      return qEZ;
    }, qsD = (qED, qEm) => (...qEa) => qsi(qED, qEm, qEa), qsm = (qED, qEm) => {
      qED = qxL(qED);
      function qEa() {
        return qED["includes"]("j") ? qsD(qED, qEm) : qsW(qEm);
      }
      var qEZ = qEa();
      return typeof qEZ != "function" && qxb("unknown function pointer with signature " + qED + ": " + qEm), qEZ;
    }, qsa = (qED, qEm) => {
      var qEa = qs7(qEm, function(qEZ) {
        this["name"] = qEm, this["message"] = qEZ;
        var qEw = new Error(qEZ)["stack"];
        qEw !== void 0 && (this["stack"] = this["toString"]() + "\n" + qEw["replace"](/^Error(:[^\n]*)?\n/, ""));
      });
      return qEa["prototype"] = Object["create"](qED["prototype"]), qEa["prototype"]["constructor"] = qEa, qEa["prototype"]["toString"] = function() {
        return this["message"] === void 0 ? this["name"] : this["name"] + ": " + this["message"];
      }, qEa;
    }, qsZ, qsw = (qED) => {
      var qEm = qEk(qED), qEa = qxL(qEm);
      return qEF(qEm), qEa;
    }, qse = (qED, qEm) => {
      var qEa = [], qEZ = {};
      function qEw(qEe) {
        if (!qEZ[qEe] && !qxw[qEe]) {
          if (qxe[qEe]) {
            qxe[qEe]["forEach"](qEw);
            return;
          }
          qEa["push"](qEe), qEZ[qEe] = true;
        }
      }
      throw qEm["forEach"](qEw), new qsZ(qED + ": " + qEa["map"](qsw)["join"]([", "]));
    }, qsz = (qED, qEm, qEa, qEZ, qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj) => {
      qEN = qxL(qEN), qEe = qsm(qEw, qEe), qEc && (qEc = qsm(qEz, qEc)), qEG && (qEG = qsm(qEX, qEG)), qEj = qsm(qEu, qEj);
      var qEL = qsp(qEN);
      qs9(qEL, function() {
        qse("Cannot construct " + qEN + " due to unbound types", [qEZ]);
      }), qxX([qED, qEm, qEa], qEZ ? [qEZ] : [], (qEI) => {
        var qEb;
        qEI = qEI[0];
        var qER, qEo;
        qEZ ? (qER = qEI["registeredClass"], qEo = qER["instancePrototype"]) : qEo = qs6["prototype"];
        var qEr = qs7(qEN, function(...qEl) {
          if (Object["getPrototypeOf"](this) !== qEQ) throw new qxI("Use 'new' to construct " + qEN);
          if (qEd["constructor_body"] === void 0) throw new qxI(qEN + " has no accessible constructor");
          var qEH = qEd["constructor_body"][qEl["length"]];
          if (qEH === void 0) throw new qxI("Tried to invoke ctor of " + qEN + " with invalid number of parameters (" + qEl["length"] + ") - expected (" + Object["keys"](qEd["constructor_body"])["toString"]() + ") parameters instead!");
          return qEH["apply"](this, qEl);
        }), qEQ = Object["create"](qEo, { "constructor": { "value": qEr } });
        qEr["prototype"] = qEQ;
        var qEd = new qsg(qEN, qEr, qEQ, qEj, qER, qEe, qEc, qEG);
        qEd["baseClass"] && ((qEb = qEd["baseClass"])["__derivedClasses"] != null || (qEb["__derivedClasses"] = []), qEd["baseClass"]["__derivedClasses"]["push"](qEd));
        var qEv = new qsS(qEN, qEd, true, false, false), qEy = new qsS(qEN + "*", qEd, false, false, false), qEC = new qsS(qEN + " const*", qEd, false, true, false);
        return qxh[qED] = { "pointerType": qEy, "constPointerType": qEC }, qsF(qEL, qEr), [qEv, qEy, qEC];
      });
    }, qsc = (qED, qEm) => {
      for (var qEa = [], qEZ = 0; qEZ < qED; qEZ++) qEa["push"](qgB[qEm + qEZ * 4 >> 2]);
      return qEa;
    };
    function qsX(qED) {
      for (var qEm = 1; qEm < qED["length"]; ++qEm) if (qED[qEm] !== null && qED[qEm]["destructorFunction"] === void 0) return true;
      return false;
    }
    function qsG(qED, qEm, qEa, qEZ, qEw, qEe) {
      var qEz = qEm["length"];
      qEz < 2 && qxb("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var qEc = qEm[1] !== null && qEa !== null, qEX = qsX(qEm), qEG = qEm[0]["name"] !== "void", qEN = qEz - 2, qEu = new Array(qEN), qEj = [], qEL = [], qEI = function(...qEb) {
        qEb["length"] !== qEN && qxb("function " + qED + " called with " + qEb["length"] + " arguments, expected " + qEN), qEL["length"] = 0;
        var qER;
        qEj["length"] = qEc ? 2 : 1, qEj[0] = qEw, qEc && (qER = qEm[1]["toWireType"](qEL, this), qEj[1] = qER);
        for (var qEo = 0; qEo < qEN; ++qEo) qEu[qEo] = qEm[qEo + 2]["toWireType"](qEL, qEb[qEo]), qEj["push"](qEu[qEo]);
        var qEr = qEZ(...qEj);
        function qEQ(qEd) {
          if (qEX) qxm(qEL);
          else for (var qEv = qEc ? 1 : 2; qEv < qEm["length"]; qEv++) {
            var qEy = qEv === 1 ? qER : qEu[qEv - 2];
            qEm[qEv]["destructorFunction"] !== null && qEm[qEv]["destructorFunction"](qEy);
          }
          if (qEG) return qEm[0]["fromWireType"](qEd);
        }
        return qEQ(qEr);
      };
      return qs7(qED, qEI);
    }
    var qsN = (qED, qEm, qEa, qEZ, qEw, qEe) => {
      var qEz = qsc(qEm, qEa);
      qEw = qsm(qEZ, qEw), qxX([], [qED], (qEc) => {
        qEc = qEc[0];
        var qEX = "constructor " + qEc["name"];
        if (qEc["registeredClass"]["constructor_body"] === void 0 && (qEc["registeredClass"]["constructor_body"] = []), qEc["registeredClass"]["constructor_body"][qEm - 1] !== void 0) throw new qxI("Cannot register multiple constructors with identical number of parameters (" + (qEm - 1) + ") for class '" + qEc["name"] + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return qEc["registeredClass"]["constructor_body"][qEm - 1] = () => {
          qse("Cannot construct " + qEc["name"] + " due to unbound types", qEz);
        }, qxX([], qEz, (qEG) => (qEG["splice"](1, 0, null), qEc["registeredClass"]["constructor_body"][qEm - 1] = qsG(qEX, qEG, null, qEw, qEe), [])), [];
      });
    }, qsu = (qED) => {
      qED = qED["trim"]();
      const qEm = qED["indexOf"]("(");
      return qEm !== -1 ? qED["substr"](0, qEm) : qED;
    }, qsj = (qED, qEm, qEa, qEZ, qEw, qEe, qEz, qEc, qEX) => {
      var qEG = qsc(qEa, qEZ);
      qEm = qxL(qEm), qEm = qsu(qEm), qEe = qsm(qEw, qEe), qxX([], [qED], (qEN) => {
        qEN = qEN[0];
        var qEu = qEN["name"] + "." + qEm;
        qEm["startsWith"]("@@") && (qEm = Symbol[qEm["substring"](2)]), qEc && qEN["registeredClass"]["pureVirtualFunctions"]["push"](qEm);
        function qEj() {
          qse("Cannot call " + qEu + " due to unbound types", qEG);
        }
        var qEL = qEN["registeredClass"]["instancePrototype"], qEI = qEL[qEm];
        return qEI === void 0 || qEI["overloadTable"] === void 0 && qEI["className"] !== qEN["name"] && qEI["argCount"] === qEa - 2 ? (qEj["argCount"] = qEa - 2, qEj["className"] = qEN["name"], qEL[qEm] = qEj) : (qs8(qEL, qEm, qEu), qEL[qEm]["overloadTable"][qEa - 2] = qEj), qxX([], qEG, (qEb) => {
          var qER = qsG(qEu, qEb, qEN, qEe, qEz);
          return qEL[qEm]["overloadTable"] === void 0 ? (qER["argCount"] = qEa - 2, qEL[qEm] = qER) : qEL[qEm]["overloadTable"][qEa - 2] = qER, [];
        }), [];
      });
    }, qsL = (qED, qEm, qEa) => (qED instanceof Object || qxb(qEa + ' with invalid "this": ' + qED), qED instanceof qEm["registeredClass"]["constructor"] || qxb(qEa + ' incompatible with "this" of type ' + qED["constructor"]["name"]), qED["$$"]["ptr"] || qxb("cannot call emscripten binding method " + qEa + " on deleted object"), qsx(qED["$$"]["ptr"], qED["$$"]["ptrType"]["registeredClass"], qEm["registeredClass"])), qsI = (qED, qEm, qEa, qEZ, qEw, qEe, qEz, qEc, qEX, qEG) => {
      qEm = qxL(qEm), qEw = qsm(qEZ, qEw), qxX([], [qED], (qEN) => {
        qEN = qEN[0];
        var qEu = qEN["name"] + "." + qEm, qEj = { "get"() {
          qse("Cannot access " + qEu + " due to unbound types", [qEa, qEz]);
        }, "enumerable": true, "configurable": true };
        return qEX ? qEj["set"] = () => qse("Cannot access " + qEu + " due to unbound types", [qEa, qEz]) : qEj["set"] = (qEL) => qxb(qEu + " is a read-only property"), Object["defineProperty"](qEN["registeredClass"]["instancePrototype"], qEm, qEj), qxX([], qEX ? [qEa, qEz] : [qEa], (qEL) => {
          var qEI = qEL[0], qEb = { "get"() {
            var qEo = qsL(this, qEN, qEu + " getter");
            return qEI["fromWireType"](qEw(qEe, qEo));
          }, "enumerable": true };
          if (qEX) {
            qEX = qsm(qEc, qEX);
            var qER = qEL[1];
            qEb["set"] = function(qEo) {
              var qEr = qsL(this, qEN, qEu + " setter"), qEQ = [];
              qEX(qEG, qEr, qER["toWireType"](qEQ, qEo)), qxm(qEQ);
            };
          }
          return Object["defineProperty"](qEN["registeredClass"]["instancePrototype"], qEm, qEb), [];
        }), [];
      });
    }, qsb = [], qsR = [], qso = (qED) => {
      qED > 9 && --qsR[qED + 1] === 0 && (qsR[qED] = void 0, qsb["push"](qED));
    }, qsr = () => qsR["length"] / 2 - 5 - qsb["length"], qsQ = () => {
      qsR["push"](0, 1, void 0, 1, null, 1, true, 1, false, 1), qgL["count_emval_handles"] = qsr;
    }, qsd = { "toValue": (qED) => (qED || qxb("Cannot use deleted val. handle = " + qED), qsR[qED]), "toHandle": (qED) => {
      switch (qED) {
        case void 0:
          return 2;
        case null:
          return 4;
        case true:
          return 6;
        case false:
          return 8;
        default: {
          const qEm = qsb["pop"]() || qsR["length"];
          return qsR[qEm] = qED, qsR[qEm + 1] = 1, qEm;
        }
      }
    } }, qsv = { "name": "emscripten::val", "fromWireType": (qED) => {
      var qEm = qsd["toValue"](qED);
      return qso(qED), qEm;
    }, "toWireType": (qED, qEm) => qsd["toHandle"](qEm), "argPackAdvance": qxr, "readValueFromPointer": qxa, "destructorFunction": null }, qsy = (qED) => qxo(qED, qsv), qsC = (qED) => {
      if (qED === null) return "null";
      var qEm = typeof qED;
      return qEm === "object" || qEm === "array" || qEm === "function" ? qED["toString"]() : "" + qED;
    }, qsl = (qED, qEm) => {
      switch (qEm) {
        case 4:
          return function(qEa) {
            return this["fromWireType"](qgV[qEa >> 2]);
          };
        case 8:
          return function(qEa) {
            return this["fromWireType"](qgJ[qEa >> 3]);
          };
        default:
          throw new TypeError("invalid float width (" + qEm + "): " + qED);
      }
    }, qsH = (qED, qEm, qEa) => {
      qEm = qxL(qEm), qxo(qED, { "name": qEm, "fromWireType": (qEZ) => qEZ, "toWireType": (qEZ, qEw) => qEw, "argPackAdvance": qxr, "readValueFromPointer": qsl(qEm, qEa), "destructorFunction": null });
    }, qsA = (qED, qEm, qEa) => {
      switch (qEm) {
        case 1:
          return qEa ? (qEZ) => qgH[qEZ] : (qEZ) => qgA[qEZ];
        case 2:
          return qEa ? (qEZ) => qgh[qEZ >> 1] : (qEZ) => qgT[qEZ >> 1];
        case 4:
          return qEa ? (qEZ) => qgK[qEZ >> 2] : (qEZ) => qgB[qEZ >> 2];
        default:
          throw new TypeError("invalid integer width (" + qEm + "): " + qED);
      }
    }, qsh = (qED, qEm, qEa, qEZ, qEw) => {
      qEm = qxL(qEm);
      var qEe = (qEN) => qEN;
      if (qEZ === 0) {
        var qEz = 32 - 8 * qEa;
        qEe = (qEN) => qEN << qEz >>> qEz;
      }
      var qEc = qEm["includes"]("unsigned"), qEX = (qEN, qEu) => {
      }, qEG;
      qEc ? qEG = function(qEN, qEu) {
        return qEX(qEu, this["name"]), qEu >>> 0;
      } : qEG = function(qEN, qEu) {
        return qEX(qEu, this["name"]), qEu;
      }, qxo(qED, { "name": qEm, "fromWireType": qEe, "toWireType": qEG, "argPackAdvance": qxr, "readValueFromPointer": qsA(qEm, qEa, qEZ !== 0), "destructorFunction": null });
    }, qsT = (qED, qEm, qEa) => {
      var qEZ = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], qEw = qEZ[qEm];
      function qEe(qEz) {
        var qEc = qgB[qEz >> 2], qEX = qgB[qEz + 4 >> 2];
        return new qEw(qgH["buffer"], qEX, qEc);
      }
      qEa = qxL(qEa), qxo(qED, { "name": qEa, "fromWireType": qEe, "argPackAdvance": qxr, "readValueFromPointer": qEe }, { "ignoreDuplicateRegistrations": true });
    }, qsK = (qED, qEm, qEa, qEZ) => {
      if (!(qEZ > 0)) return 0;
      for (var qEw = qEa, qEe = qEa + qEZ - 1, qEz = 0; qEz < qED["length"]; ++qEz) {
        var qEc = qED["charCodeAt"](qEz);
        if (qEc >= 55296 && qEc <= 57343) {
          var qEX = qED["charCodeAt"](++qEz);
          qEc = 65536 + ((qEc & 1023) << 10) | qEX & 1023;
        }
        if (qEc <= 127) {
          if (qEa >= qEe) break;
          qEm[qEa++] = qEc;
        } else {
          if (qEc <= 2047) {
            if (qEa + 1 >= qEe) break;
            qEm[qEa++] = 192 | qEc >> 6, qEm[qEa++] = 128 | qEc & 63;
          } else {
            if (qEc <= 65535) {
              if (qEa + 2 >= qEe) break;
              qEm[qEa++] = 224 | qEc >> 12, qEm[qEa++] = 128 | qEc >> 6 & 63, qEm[qEa++] = 128 | qEc & 63;
            } else {
              if (qEa + 3 >= qEe) break;
              qEm[qEa++] = 240 | qEc >> 18, qEm[qEa++] = 128 | qEc >> 12 & 63, qEm[qEa++] = 128 | qEc >> 6 & 63, qEm[qEa++] = 128 | qEc & 63;
            }
          }
        }
      }
      return qEm[qEa] = 0, qEa - qEw;
    }, qsB = (qED, qEm, qEa) => qsK(qED, qgA, qEm, qEa), qsV = (qED) => {
      for (var qEm = 0, qEa = 0; qEa < qED["length"]; ++qEa) {
        var qEZ = qED["charCodeAt"](qEa);
        qEZ <= 127 ? qEm++ : qEZ <= 2047 ? qEm += 2 : qEZ >= 55296 && qEZ <= 57343 ? (qEm += 4, ++qEa) : qEm += 3;
      }
      return qEm;
    }, qsJ = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0, qsY = (qED, qEm, qEa) => {
      for (var qEZ = qEm + qEa, qEw = qEm; qED[qEw] && !(qEw >= qEZ); ) ++qEw;
      if (qEw - qEm > 16 && qED["buffer"] && qsJ) return qsJ["decode"](qED["subarray"](qEm, qEw));
      for (var qEe = ""; qEm < qEw; ) {
        var qEz = qED[qEm++];
        if (!(qEz & 128)) {
          qEe += String["fromCharCode"](qEz);
          continue;
        }
        var qEc = qED[qEm++] & 63;
        if ((qEz & 224) == 192) {
          qEe += String["fromCharCode"]((qEz & 31) << 6 | qEc);
          continue;
        }
        var qEX = qED[qEm++] & 63;
        if ((qEz & 240) == 224 ? qEz = (qEz & 15) << 12 | qEc << 6 | qEX : qEz = (qEz & 7) << 18 | qEc << 12 | qEX << 6 | qED[qEm++] & 63, qEz < 65536) qEe += String["fromCharCode"](qEz);
        else {
          var qEG = qEz - 65536;
          qEe += String["fromCharCode"](55296 | qEG >> 10, 56320 | qEG & 1023);
        }
      }
      return qEe;
    }, qsP = (qED, qEm) => qED ? qsY(qgA, qED, qEm) : "", qsU = (qED, qEm) => {
      qEm = qxL(qEm);
      var qEa = qEm === "std::string";
      qxo(qED, { "name": qEm, "fromWireType"(qEZ) {
        var qEw = qgB[qEZ >> 2], qEe = qEZ + 4, qEz;
        if (qEa) for (var qEc = qEe, qEX = 0; qEX <= qEw; ++qEX) {
          var qEG = qEe + qEX;
          if (qEX == qEw || qgA[qEG] == 0) {
            var qEN = qEG - qEc, qEu = qsP(qEc, qEN);
            qEz === void 0 ? qEz = qEu : (qEz += "\0", qEz += qEu), qEc = qEG + 1;
          }
        }
        else {
          for (var qEj = new Array(qEw), qEX = 0; qEX < qEw; ++qEX) qEj[qEX] = String["fromCharCode"](qgA[qEe + qEX]);
          qEz = qEj["join"]("");
        }
        return qEF(qEZ), qEz;
      }, "toWireType"(qEZ, qEw) {
        qEw instanceof ArrayBuffer && (qEw = new Uint8Array(qEw));
        var qEe, qEz = typeof qEw == "string";
        qEz || qEw instanceof Uint8Array || qEw instanceof Uint8ClampedArray || qEw instanceof Int8Array || qxb("Cannot pass non-string to std::string"), qEa && qEz ? qEe = qsV(qEw) : qEe = qEw["length"];
        var qEc = qEt(4 + qEe + 1), qEX = qEc + 4;
        if (qgB[qEc >> 2] = qEe, qEa && qEz) qsB(qEw, qEX, qEe + 1);
        else {
          if (qEz) for (var qEG = 0; qEG < qEe; ++qEG) {
            var qEN = qEw["charCodeAt"](qEG);
            qEN > 255 && (qEF(qEX), qxb("String has UTF-16 code units that do not fit in 8 bits")), qgA[qEX + qEG] = qEN;
          }
          else {
            for (var qEG = 0; qEG < qEe; ++qEG) qgA[qEX + qEG] = qEw[qEG];
          }
        }
        return qEZ !== null && qEZ["push"](qEF, qEc), qEc;
      }, "argPackAdvance": qxr, "readValueFromPointer": qxa, "destructorFunction"(qEZ) {
        qEF(qEZ);
      } });
    }, qE0 = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0, qE1 = (qED, qEm) => {
      for (var qEa = qED, qEZ = qEa >> 1, qEw = qEZ + qEm / 2; !(qEZ >= qEw) && qgT[qEZ]; ) ++qEZ;
      if (qEa = qEZ << 1, qEa - qED > 32 && qE0) return qE0["decode"](qgA["subarray"](qED, qEa));
      for (var qEe = "", qEz = 0; !(qEz >= qEm / 2); ++qEz) {
        var qEc = qgh[qED + qEz * 2 >> 1];
        if (qEc == 0) break;
        qEe += String["fromCharCode"](qEc);
      }
      return qEe;
    }, qE2 = (qED, qEm, qEa) => {
      if (qEa != null || (qEa = 2147483647), qEa < 2) return 0;
      qEa -= 2;
      for (var qEZ = qEm, qEw = qEa < qED["length"] * 2 ? qEa / 2 : qED["length"], qEe = 0; qEe < qEw; ++qEe) {
        var qEz = qED["charCodeAt"](qEe);
        qgh[qEm >> 1] = qEz, qEm += 2;
      }
      return qgh[qEm >> 1] = 0, qEm - qEZ;
    }, qE3 = (qED) => qED["length"] * 2, qE4 = (qED, qEm) => {
      for (var qEa = 0, qEZ = ""; !(qEa >= qEm / 4); ) {
        var qEw = qgK[qED + qEa * 4 >> 2];
        if (qEw == 0) break;
        if (++qEa, qEw >= 65536) {
          var qEe = qEw - 65536;
          qEZ += String["fromCharCode"](55296 | qEe >> 10, 56320 | qEe & 1023);
        } else qEZ += String["fromCharCode"](qEw);
      }
      return qEZ;
    }, qE5 = (qED, qEm, qEa) => {
      if (qEa != null || (qEa = 2147483647), qEa < 4) return 0;
      for (var qEZ = qEm, qEw = qEZ + qEa - 4, qEe = 0; qEe < qED["length"]; ++qEe) {
        var qEz = qED["charCodeAt"](qEe);
        if (qEz >= 55296 && qEz <= 57343) {
          var qEc = qED["charCodeAt"](++qEe);
          qEz = 65536 + ((qEz & 1023) << 10) | qEc & 1023;
        }
        if (qgK[qEm >> 2] = qEz, qEm += 4, qEm + 4 > qEw) break;
      }
      return qgK[qEm >> 2] = 0, qEm - qEZ;
    }, qE6 = (qED) => {
      for (var qEm = 0, qEa = 0; qEa < qED["length"]; ++qEa) {
        var qEZ = qED["charCodeAt"](qEa);
        qEZ >= 55296 && qEZ <= 57343 && ++qEa, qEm += 4;
      }
      return qEm;
    }, qE7 = (qED, qEm, qEa) => {
      qEa = qxL(qEa);
      var qEZ, qEw, qEe, qEz;
      qEm === 2 ? (qEZ = qE1, qEw = qE2, qEz = qE3, qEe = (qEc) => qgT[qEc >> 1]) : qEm === 4 && (qEZ = qE4, qEw = qE5, qEz = qE6, qEe = (qEc) => qgB[qEc >> 2]), qxo(qED, { "name": qEa, "fromWireType": (qEc) => {
        for (var qEX = qgB[qEc >> 2], qEG, qEN = qEc + 4, qEu = 0; qEu <= qEX; ++qEu) {
          var qEj = qEc + 4 + qEu * qEm;
          if (qEu == qEX || qEe(qEj) == 0) {
            var qEL = qEj - qEN, qEI = qEZ(qEN, qEL);
            qEG === void 0 ? qEG = qEI : (qEG += "\0", qEG += qEI), qEN = qEj + qEm;
          }
        }
        return qEF(qEc), qEG;
      }, "toWireType": (qEc, qEX) => {
        typeof qEX != "string" && qxb("Cannot pass non-string to C++ string type " + qEa);
        var qEG = qEz(qEX), qEN = qEt(4 + qEG + qEm);
        return qgB[qEN >> 2] = qEG / qEm, qEw(qEX, qEN + 4, qEG + qEm), qEc !== null && qEc["push"](qEF, qEN), qEN;
      }, "argPackAdvance": qxr, "readValueFromPointer": qxa, "destructorFunction"(qEc) {
        qEF(qEc);
      } });
    }, qE8 = (qED, qEm, qEa, qEZ, qEw, qEe) => {
      qxD[qED] = { "name": qxL(qEm), "rawConstructor": qsm(qEa, qEZ), "rawDestructor": qsm(qEw, qEe), "fields": [] };
    }, qE9 = (qED, qEm, qEa, qEZ, qEw, qEe, qEz, qEc, qEX, qEG) => {
      qxD[qED]["fields"]["push"]({ "fieldName": qxL(qEm), "getterReturnType": qEa, "getter": qsm(qEZ, qEw), "getterContext": qEe, "setterArgumentType": qEz, "setter": qsm(qEc, qEX), "setterContext": qEG });
    }, qEq = (qED, qEm) => {
      qEm = qxL(qEm), qxo(qED, { "isVoid": true, "name": qEm, "argPackAdvance": 0, "fromWireType": () => {
      }, "toWireType": (qEa, qEZ) => {
      } });
    }, qEn = (qED, qEm) => {
      var qEa = qxw[qED];
      return qEa === void 0 && qxb(qEm + " has unknown type " + qsw(qED)), qEa;
    }, qEp = (qED, qEm) => {
      qED = qEn(qED, "_emval_take_value");
      var qEa = qED["readValueFromPointer"](qEm);
      return qsd["toHandle"](qEa);
    }, qEg = () => {
      qxn("");
    }, qEx = (qED, qEm, qEa) => qgA["copyWithin"](qED, qEm, qEm + qEa), qEs = () => 2147483648, qEE = (qED) => {
      var qEm = qgy["buffer"], qEa = (qED - qEm["byteLength"] + 65535) / 65536;
      try {
        return qgy["grow"](qEa), qgY(), 1;
      } catch (qEZ) {
      }
    }, qEM = (qED) => {
      var qEm = qgA["length"];
      qED >>>= 0;
      var qEa = qEs();
      if (qED > qEa) return false;
      for (var qEZ = (qEX, qEG) => qEX + (qEG - qEX % qEG) % qEG, qEw = 1; qEw <= 4; qEw *= 2) {
        var qEe = qEm * (1 + 0.2 / qEw);
        qEe = Math["min"](qEe, qED + 100663296);
        var qEz = Math["min"](qEa, qEZ(Math["max"](qED, qEe), 65536)), qEc = qEE(qEz);
        if (qEc) return true;
      }
      return false;
    };
    qxz = qgL["InternalError"] = class extends Error {
      constructor(qED) {
        super(qED), this["name"] = "InternalError";
      }
    }, qxu(), qxI = qgL["BindingError"] = class extends Error {
      constructor(qED) {
        super(qED), this["name"] = "BindingError";
      }
    }, qs5(), qxP(), qsf(), qsZ = qgL["UnboundTypeError"] = qsa(Error, "UnboundTypeError"), qsQ();
    var qEf = { "c": qxi, "m": qxG, "p": qxN, "u": qxQ, "i": qsz, "h": qsN, "b": qsj, "e": qsI, "t": qsy, "k": qsH, "d": qsh, "a": qsT, "j": qsU, "g": qE7, "n": qE8, "f": qE9, "l": qEq, "o": qEp, "q": qEg, "s": qEx, "r": qEM }, qES = qxt(), qEF = (qED) => (qEF = qES["x"])(qED), qEt = (qED) => (qEt = qES["y"])(qED), qEk = (qED) => (qEk = qES["A"])(qED), qEO = (qED) => (qEO = qES["B"])(qED), qEW;
    qx8 = function qED() {
      qEW || qEi(), qEW || (qx8 = qED);
    };
    function qEi() {
      if (qx7 > 0 || (qx1(), qx7 > 0)) return;
      function qEm() {
        qEW || (qEW = true, qgL["calledRun"] = true, !qgl && (qx2(), qgI(qgL), qgL["onRuntimeInitialized"] && qgL["onRuntimeInitialized"](), qx3()));
      }
      qgL["setStatus"] ? (qgL["setStatus"]("Running..."), setTimeout(function() {
        setTimeout(function() {
          qgL["setStatus"]("");
        }, 1), qEm();
      }, 1)) : qEm();
    }
    if (qgL["preInit"]) {
      for (typeof qgL["preInit"] == "function" && (qgL["preInit"] = [qgL["preInit"]]); qgL["preInit"]["length"] > 0; ) qgL["preInit"]["pop"]()();
    }
    return qEi(), qgj["ready"];
  };
})();
var jJ = qM();
jJ["registerFlag"]("KEEP_INTERMEDIATE_TENSORS", () => false, (qgu) => {
  qgu && console["warn"]("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.");
});
var jY;
(function(qgu) {
  qgu[qgu["DT_INVALID"] = 0] = "DT_INVALID", qgu[qgu["DT_FLOAT"] = 1] = "DT_FLOAT", qgu[qgu["DT_DOUBLE"] = 2] = "DT_DOUBLE", qgu[qgu["DT_INT32"] = 3] = "DT_INT32", qgu[qgu["DT_UINT8"] = 4] = "DT_UINT8", qgu[qgu["DT_INT16"] = 5] = "DT_INT16", qgu[qgu["DT_INT8"] = 6] = "DT_INT8", qgu[qgu["DT_STRING"] = 7] = "DT_STRING", qgu[qgu["DT_COMPLEX64"] = 8] = "DT_COMPLEX64", qgu[qgu["DT_INT64"] = 9] = "DT_INT64", qgu[qgu["DT_BOOL"] = 10] = "DT_BOOL", qgu[qgu["DT_QINT8"] = 11] = "DT_QINT8", qgu[qgu["DT_QUINT8"] = 12] = "DT_QUINT8", qgu[qgu["DT_QINT32"] = 13] = "DT_QINT32", qgu[qgu["DT_BFLOAT16"] = 14] = "DT_BFLOAT16", qgu[qgu["DT_QINT16"] = 15] = "DT_QINT16", qgu[qgu["DT_QUINT16"] = 16] = "DT_QUINT16", qgu[qgu["DT_UINT16"] = 17] = "DT_UINT16", qgu[qgu["DT_COMPLEX128"] = 18] = "DT_COMPLEX128", qgu[qgu["DT_HALF"] = 19] = "DT_HALF", qgu[qgu["DT_RESOURCE"] = 20] = "DT_RESOURCE", qgu[qgu["DT_VARIANT"] = 21] = "DT_VARIANT", qgu[qgu["DT_UINT32"] = 22] = "DT_UINT32", qgu[qgu["DT_UINT64"] = 23] = "DT_UINT64", qgu[qgu["DT_FLOAT_REF"] = 101] = "DT_FLOAT_REF", qgu[qgu["DT_DOUBLE_REF"] = 102] = "DT_DOUBLE_REF", qgu[qgu["DT_INT32_REF"] = 103] = "DT_INT32_REF", qgu[qgu["DT_UINT8_REF"] = 104] = "DT_UINT8_REF", qgu[qgu["DT_INT16_REF"] = 105] = "DT_INT16_REF", qgu[qgu["DT_INT8_REF"] = 106] = "DT_INT8_REF", qgu[qgu["DT_STRING_REF"] = 107] = "DT_STRING_REF", qgu[qgu["DT_COMPLEX64_REF"] = 108] = "DT_COMPLEX64_REF", qgu[qgu["DT_INT64_REF"] = 109] = "DT_INT64_REF", qgu[qgu["DT_BOOL_REF"] = 110] = "DT_BOOL_REF", qgu[qgu["DT_QINT8_REF"] = 111] = "DT_QINT8_REF", qgu[qgu["DT_QUINT8_REF"] = 112] = "DT_QUINT8_REF", qgu[qgu["DT_QINT32_REF"] = 113] = "DT_QINT32_REF", qgu[qgu["DT_BFLOAT16_REF"] = 114] = "DT_BFLOAT16_REF", qgu[qgu["DT_QINT16_REF"] = 115] = "DT_QINT16_REF", qgu[qgu["DT_QUINT16_REF"] = 116] = "DT_QUINT16_REF", qgu[qgu["DT_UINT16_REF"] = 117] = "DT_UINT16_REF", qgu[qgu["DT_COMPLEX128_REF"] = 118] = "DT_COMPLEX128_REF", qgu[qgu["DT_HALF_REF"] = 119] = "DT_HALF_REF", qgu[qgu["DT_RESOURCE_REF"] = 120] = "DT_RESOURCE_REF", qgu[qgu["DT_VARIANT_REF"] = 121] = "DT_VARIANT_REF", qgu[qgu["DT_UINT32_REF"] = 122] = "DT_UINT32_REF", qgu[qgu["DT_UINT64_REF"] = 123] = "DT_UINT64_REF";
})(jY || (jY = {}));
var jP;
(function(qgu) {
  (function(qgj) {
    qgj[qgj["LEGACY"] = 0] = "LEGACY", qgj[qgj["V1"] = 1] = "V1", qgj[qgj["V2"] = 2] = "V2";
  })(qgu["CheckpointFormatVersion"] || (qgu["CheckpointFormatVersion"] = {}));
})(jP || (jP = {}));
var jU = {};
function Lq(qgu) {
  return jU[qgu];
}
function Ln(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgj["inputParams"][qgu];
  if (qgR && qgR["inputIndexStart"] !== void 0) {
    const qgr = qgR["inputIndexStart"], qgQ = qgR["inputIndexEnd"] === 0 ? void 0 : qgR["inputIndexEnd"] === void 0 ? qgr + 1 : qgR["inputIndexEnd"], qgd = qgr < 0 ? qgj["inputNames"]["length"] + qgr : qgr;
    if (qgR["type"] === "tensor") return Ls(qgj["inputNames"][qgd], qgL, qgI, qgb);
    if (qgR["type"] === "tensors") {
      const qgl = qgj["inputs"]["slice"](qgr, qgQ);
      return qgj["inputNames"]["slice"](qgr, qgQ)["filter"]((qgH, qgA) => {
        var qgh;
        return ((qgh = qgl[qgA]) === null || qgh === void 0 ? void 0 : qgh["op"]) !== "NoOp";
      })["map"]((qgH) => Ls(qgH, qgL, qgI, qgb));
    }
    const qgv = Ls(qgj["inputNames"][qgd], qgL, qgI, qgb), qgy = qgv["dataSync"]();
    return qgR["type"] === "number" ? qgy[0] : l(qgv["shape"], qgy);
  }
  const qgo = qgj["attrParams"][qgu];
  return qgo && qgo["value"];
}
function Ls(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = LD(qgu, qgL);
  if (qgI != null) {
    const qgr = qgI["getHashTableHandleByName"](qgb);
    if (qgr != null) return qgr;
  }
  const qgo = qgL["currentContextIds"]["find"]((qgQ) => !!qgj[LW(qgb, qgQ)]);
  return qgo !== void 0 ? qgj[LW(qgb, qgo)][qgR] : void 0;
}
function LM(qgu, qgj, qgL) {
  return qgj[LW(qgu, qgL["currentContextId"])];
}
function LF(qgu, qgj) {
  const [qgL, qgI, qgb] = LD(qgu, qgj);
  return [LW(qgL, qgj && qgj["currentContextId"]), qgI, qgb];
}
function LW(qgu, qgj) {
  return qgj ? qgu + "-" + qgj : qgu;
}
function LD(qgu, qgj) {
  if (qgu === "") return ["", 0, void 0];
  const qgL = qgj != null && qgj["parseNodeNameCache"] != null;
  if (qgL) {
    const qgR = qgj["parseNodeNameCache"]["get"](qgu);
    if (qgR != null) return qgR;
  }
  const qgI = qgu["split"](":");
  let qgb;
  if (qgI["length"] === 1) qgb = [qgu, 0, void 0];
  else {
    const qgo = qgI[0], qgr = qgI["length"] === 3 ? qgI[1] : void 0, qgQ = Number(qgI[qgI["length"] - 1]);
    qgb = [qgo, qgQ, qgr];
  }
  return qgL && qgj["parseNodeNameCache"]["set"](qgu, qgb), qgb;
}
function LZ(qgu, qgj, qgL) {
  let qgI = Ln("pad", qgu, qgj, qgL);
  if (qgI === "explicit") {
    qgI = Ln("explicitPaddings", qgu, qgj, qgL);
    const qgb = [[0, 0], [0, 0], [0, 0], [0, 0]];
    for (let qgR = 0; qgR < 4; qgR++) qgb[qgR][0] = qgI[qgR * 2], qgb[qgR][1] = qgI[qgR * 2 + 1];
    return qgb;
  }
  return qgI;
}
function Le(qgu) {
  return qgu["kept"] ? qgu : DX(qgu);
}
var Lz = [{ "tfOpName": "Add", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "AddV2", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "AddN", "category": "arithmetic", "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }] }, { "tfOpName": "BiasAdd", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }] }, { "tfOpName": "Sub", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "RealDiv", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Div", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "DivNoNan", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "FloorDiv", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Mul", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Maximum", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Minimum", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Pow", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "SquaredDifference", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Mod", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "FloorMod", "category": "arithmetic", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }];
var LX = Object["freeze"]({ "__proto__": null, "json": Lz });
var LG = [{ "tfOpName": "Abs", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Acos", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Asin", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Atan", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Atan2", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "y", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Ceil", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "ClipByValue", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "clipValueMin", "type": "number" }, { "start": 2, "name": "clipValueMax", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Complex", "category": "basic_math", "inputs": [{ "start": 0, "name": "real", "type": "tensor" }, { "start": 1, "name": "imag", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "ComplexAbs", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Cos", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Cosh", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Elu", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Exp", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Floor", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Log", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Imag", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "Tout", "name": "outputType", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Neg", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Real", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "Tout", "name": "outputType", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Prelu", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "alpha", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Relu", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Relu6", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Selu", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Sigmoid", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Sin", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Sinh", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Sqrt", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Rsqrt", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Square", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Tan", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Tanh", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Sign", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Round", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Expm1", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Log1p", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Reciprocal", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Softplus", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Asinh", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Acosh", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Atanh", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Erf", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LeakyRelu", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "alpha", "name": "alpha", "type": "number", "defaultValue": 0.2 }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "IsNan", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "IsFinite", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "IsInf", "category": "basic_math", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }];
var Lj = Object["freeze"]({ "__proto__": null, "json": LG });
var LL = [{ "tfOpName": "EmptyTensorList", "category": "control", "inputs": [{ "start": 0, "name": "elementShape", "type": "shape" }, { "start": 1, "name": "maxNumElements", "type": "number" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "LoopCond", "category": "control", "inputs": [{ "start": 0, "name": "pred", "type": "tensor" }] }, { "tfOpName": "Switch", "category": "control", "inputs": [{ "start": 0, "name": "data", "type": "tensor" }, { "start": 1, "name": "pred", "type": "tensor" }] }, { "tfOpName": "Merge", "category": "control", "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }] }, { "tfOpName": "Enter", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "frame_name", "name": "frameName", "type": "string" }, { "tfName": "is_constant", "name": "isConstant", "type": "bool" }] }, { "tfOpName": "Exit", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "NextIteration", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "TensorArrayV3", "category": "control", "inputs": [{ "start": 0, "name": "size", "type": "number" }], "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype" }, { "tfName": "element_shape", "name": "elementShape", "type": "shape" }, { "tfName": "dynamic_size", "name": "dynamicSize", "type": "bool" }, { "tfName": "clear_after_read", "name": "clearAfterRead", "type": "bool" }, { "tfName": "identical_element_shapes", "name": "identicalElementShapes", "type": "bool" }, { "tfName": "tensor_array_name", "name": "name", "type": "string" }] }, { "tfOpName": "TensorArrayWriteV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "index", "type": "number" }, { "start": 2, "name": "tensor", "type": "tensor" }, { "start": 3, "name": "flowIn", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "TensorArrayReadV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "index", "type": "number" }, { "start": 2, "name": "flowIn", "type": "number" }], "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "TensorArrayGatherV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "indices", "type": "number[]" }, { "start": 2, "name": "flowIn", "type": "number" }], "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype" }, { "tfName": "element_shape", "name": "elementShape", "type": "shape" }] }, { "tfOpName": "TensorArrayScatterV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "indices", "type": "number[]" }, { "start": 2, "name": "tensor", "type": "tensor" }, { "start": 3, "name": "flowIn", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "TensorArrayConcatV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "flowIn", "type": "number" }], "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype" }, { "tfName": "element_shape_except0", "name": "elementShapeExcept0", "type": "shape", "notSupported": true }] }, { "tfOpName": "TensorArraySplitV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "tensor", "type": "tensor" }, { "start": 2, "name": "lengths", "type": "number[]" }, { "start": 3, "name": "flowIn", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "TensorArraySizeV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }, { "start": 1, "name": "flowIn", "type": "number" }] }, { "tfOpName": "TensorArrayCloseV3", "category": "control", "inputs": [{ "start": 0, "name": "tensorArrayId", "type": "tensor" }] }, { "tfOpName": "StatelessIf", "category": "control", "inputs": [{ "start": 0, "name": "cond", "type": "tensor" }, { "start": 1, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "then_branch", "name": "thenBranch", "type": "func" }, { "tfName": "else_branch", "name": "elseBranch", "type": "func" }] }, { "tfOpName": "If", "category": "control", "inputs": [{ "start": 0, "name": "cond", "type": "tensor" }, { "start": 1, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "then_branch", "name": "thenBranch", "type": "func" }, { "tfName": "else_branch", "name": "elseBranch", "type": "func" }] }, { "tfOpName": "StatelessWhile", "category": "control", "inputs": [{ "start": 0, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "cond", "name": "cond", "type": "func" }, { "tfName": "body", "name": "body", "type": "func" }] }, { "tfOpName": "While", "category": "control", "inputs": [{ "start": 0, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "cond", "name": "cond", "type": "func" }, { "tfName": "body", "name": "body", "type": "func" }] }, { "tfOpName": "TensorListScatter", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }, { "start": 1, "name": "indices", "type": "number[]" }, { "start": 2, "name": "elementShape", "type": "shape" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListScatterV2", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }, { "start": 1, "name": "indices", "type": "number[]" }, { "start": 2, "name": "elementShape", "type": "shape" }, { "start": 3, "name": "numElements", "type": "number" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListGather", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "indices", "type": "number[]" }, { "start": 2, "name": "elementShape", "type": "shape" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListGetItem", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "index", "type": "number" }, { "start": 2, "name": "elementShape", "type": "shape" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListSetItem", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "index", "type": "number" }, { "start": 2, "name": "tensor", "type": "tensor" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListReserve", "category": "control", "inputs": [{ "start": 0, "name": "elementShape", "type": "shape" }, { "start": 1, "name": "numElements", "type": "number" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListFromTensor", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }, { "start": 1, "name": "elementShape", "type": "shape" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListStack", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "elementShape", "type": "shape" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }, { "tfName": "num_elements", "name": "numElements", "type": "dtype" }] }, { "tfOpName": "TensorListSplit", "category": "control", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }, { "start": 1, "name": "elementShape", "type": "shape" }, { "start": 2, "name": "lengths", "type": "number[]" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListConcat", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }], "attrs": [{ "tfName": "element_shape", "name": "elementShape", "type": "shape" }, { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListConcatV2", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }], "attrs": [{ "tfName": "element_shape", "name": "elementShape", "type": "shape" }, { "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListPopBack", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "elementShape", "type": "shape" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListPushBack", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "tensor", "type": "tensor" }], "attrs": [{ "tfName": "element_dtype", "name": "elementDType", "type": "dtype" }] }, { "tfOpName": "TensorListLength", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }] }, { "tfOpName": "TensorListResize", "category": "control", "inputs": [{ "start": 0, "name": "tensorListId", "type": "tensor" }, { "start": 1, "name": "size", "type": "number" }] }];
var LR = Object["freeze"]({ "__proto__": null, "json": LL });
var LQ = [{ "tfOpName": "AvgPool", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }, { "tfName": "ksize", "name": "kernelSize", "type": "number[]" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "MaxPool", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }, { "tfName": "ksize", "name": "kernelSize", "type": "number[]" }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [], "notSupported": true }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "MaxPoolWithArgmax", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "ksize", "name": "kernelSize", "type": "number[]" }, { "tfName": "include_batch_in_index", "name": "includeBatchInIndex", "type": "bool" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "AvgPool3D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }, { "tfName": "ksize", "name": "kernelSize", "type": "number[]" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "MaxPool3D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }, { "tfName": "ksize", "name": "kernelSize", "type": "number[]" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Conv1D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }], "attrs": [{ "tfName": "stride", "name": "stride", "type": "number" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NWC" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "dilation", "name": "dilation", "type": "number", "defaultValue": 1 }] }, { "tfOpName": "Conv2D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "useCudnnOnGpu", "name": "useCudnnOnGpu", "type": "bool" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NHWC" }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [] }, { "tfName": "dilations", "name": "dilations", "type": "number[]" }] }, { "tfOpName": "_FusedConv2D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }, { "start": 2, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "num_args", "name": "numArgs", "type": "number" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [] }, { "tfName": "use_cudnn_on_gpu", "name": "useCudnnOnGpu", "type": "bool", "defaultValue": true }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NHWC" }, { "tfName": "dilations", "name": "dilations", "type": "number[]", "defaultValue": [1, 1, 1, 1] }, { "tfName": "fused_ops", "name": "fusedOps", "type": "string[]", "defaultValue": [] }, { "tfName": "epsilon", "name": "epsilon", "type": "number", "defaultValue": 1e-4 }, { "tfName": "leakyrelu_alpha", "name": "leakyreluAlpha", "type": "number", "defaultValue": 0.2 }] }, { "tfOpName": "Conv2DBackpropInput", "category": "convolution", "inputs": [{ "start": 2, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }, { "start": 0, "name": "outputShape", "type": "number[]" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [] }, { "tfName": "dilations", "name": "dilations", "type": "number[]", "notSupported": true }] }, { "tfOpName": "DepthwiseConv2d", "category": "convolution", "inputs": [{ "start": 0, "name": "input", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NHWC" }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [] }, { "tfName": "dilations", "name": "dilations", "type": "number[]" }] }, { "tfOpName": "DepthwiseConv2dNative", "category": "convolution", "inputs": [{ "start": 0, "name": "input", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NHWC" }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [] }, { "tfName": "dilations", "name": "dilations", "type": "number[]" }] }, { "tfOpName": "FusedDepthwiseConv2dNative", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }, { "start": 2, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "num_args", "name": "numArgs", "type": "number" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NHWC" }, { "tfName": "dilations", "name": "dilations", "type": "number[]", "defaultValue": [1, 1, 1, 1] }, { "tfName": "fused_ops", "name": "fusedOps", "type": "string[]", "defaultValue": [] }, { "tfName": "explicit_paddings", "name": "explicitPaddings", "type": "number[]", "defaultValue": [] }] }, { "tfOpName": "Conv3D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "defaultValue": "NHWC" }, { "tfName": "dilations", "name": "dilations", "type": "number[]" }] }, { "tfOpName": "Dilation2D", "category": "convolution", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "filter", "type": "tensor" }], "attrs": [{ "tfName": "strides", "name": "strides", "type": "number[]" }, { "tfName": "rates", "name": "dilations", "type": "number[]" }, { "tfName": "padding", "name": "pad", "type": "string" }] }];
var LH = Object["freeze"]({ "__proto__": null, "json": LQ });
var LK = [{ "tfOpName": "Fill", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }, { "start": 1, "name": "value", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "LinSpace", "category": "creation", "inputs": [{ "start": 0, "name": "start", "type": "number" }, { "start": 1, "name": "stop", "type": "number" }, { "start": 2, "name": "num", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "OneHot", "category": "creation", "inputs": [{ "start": 0, "name": "indices", "type": "tensor" }, { "start": 1, "name": "depth", "type": "number" }, { "start": 2, "name": "onValue", "type": "number", "defaultValue": 1 }, { "start": 3, "name": "offValue", "type": "number", "defaultValue": 0 }], "attrs": [{ "tfName": "axis", "name": "axis", "type": "number", "notSupported": true }, { "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "Ones", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "OnesLike", "category": "creation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "dtype", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "RandomStandardNormal", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }], "attrs": [{ "tfName": "seed", "name": "seed", "type": "number", "defaultValue": 0 }, { "tfName": "seed2", "name": "seed2", "type": "number", "defaultValue": 0, "notSupported": true }, { "tfName": "dtype", "name": "dtype", "type": "dtype" }, { "tfName": "T", "name": "T", "type": "number", "notSupported": true }] }, { "tfOpName": "RandomUniform", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }], "attrs": [{ "tfName": "minval", "name": "minval", "type": "number", "defaultValue": 0 }, { "tfName": "maxval", "name": "maxval", "type": "number", "defaultValue": 1 }, { "tfName": "dtype", "name": "dtype", "type": "dtype" }, { "tfName": "seed", "name": "seed", "type": "number", "defaultValue": 0 }, { "tfName": "seed2", "name": "seed2", "type": "number", "defaultValue": 0, "notSupported": true }, { "tfName": "T", "name": "T", "type": "number", "notSupported": true }] }, { "tfOpName": "RandomUniformInt", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }], "attrs": [{ "tfName": "minval", "name": "minval", "type": "number" }, { "tfName": "maxval", "name": "maxval", "type": "number" }, { "tfName": "seed", "name": "seed", "type": "number", "defaultValue": 0 }, { "tfName": "seed2", "name": "seed2", "type": "number", "defaultValue": 0, "notSupported": true }] }, { "tfOpName": "Range", "category": "creation", "inputs": [{ "start": 0, "name": "start", "type": "number" }, { "start": 1, "name": "stop", "type": "number" }, { "start": 2, "name": "step", "type": "number", "defaultValue": 0 }], "attrs": [{ "tfName": "Tidx", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "TruncatedNormal", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }], "attrs": [{ "tfName": "means", "name": "mean", "type": "number", "defaultValue": 0 }, { "tfName": "stddev", "name": "stdDev", "type": "number", "defaultValue": 1 }, { "tfName": "seed", "name": "seed", "type": "number" }, { "tfName": "seed2", "name": "seed2", "type": "number", "defaultValue": 0, "notSupported": true }, { "tfName": "dtype", "name": "dtype", "type": "dtype" }, { "tfName": "T", "name": "T", "type": "number", "notSupported": true }] }, { "tfOpName": "Zeros", "category": "creation", "inputs": [{ "start": 0, "name": "shape", "type": "number[]" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "ZerosLike", "category": "creation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "Multinomial", "category": "creation", "inputs": [{ "start": 0, "name": "logits", "type": "tensor" }, { "start": 1, "name": "numSamples", "type": "number" }], "attrs": [{ "tfName": "seed", "name": "seed", "type": "number" }, { "tfName": "seed2", "name": "seed2", "type": "number" }, { "tfName": "T", "name": "dtype", "type": "dtype" }, { "tfName": "output_dtype", "name": "output_dtype", "type": "dtype" }] }];
var LB = Object["freeze"]({ "__proto__": null, "json": LK });
var LV = [{ "tfOpName": "NonMaxSuppressionV2", "category": "dynamic", "inputs": [{ "start": 0, "name": "boxes", "type": "tensor" }, { "start": 1, "name": "scores", "type": "tensor" }, { "start": 2, "name": "maxOutputSize", "type": "number" }, { "start": 3, "name": "iouThreshold", "type": "number" }] }, { "tfOpName": "NonMaxSuppressionV3", "category": "dynamic", "inputs": [{ "start": 0, "name": "boxes", "type": "tensor" }, { "start": 1, "name": "scores", "type": "tensor" }, { "start": 2, "name": "maxOutputSize", "type": "number" }, { "start": 3, "name": "iouThreshold", "type": "number" }, { "start": 4, "name": "scoreThreshold", "type": "number" }] }, { "tfOpName": "NonMaxSuppressionV4", "category": "dynamic", "inputs": [{ "start": 0, "name": "boxes", "type": "tensor" }, { "start": 1, "name": "scores", "type": "tensor" }, { "start": 2, "name": "maxOutputSize", "type": "number" }, { "start": 3, "name": "iouThreshold", "type": "number" }, { "start": 4, "name": "scoreThreshold", "type": "number" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }, { "tfName": "T_threshold", "name": "threshold", "type": "dtype", "notSupported": true }, { "tfName": "pad_to_max_output_size", "name": "padToMaxOutputSize", "type": "bool" }] }, { "tfOpName": "NonMaxSuppressionV5", "category": "dynamic", "inputs": [{ "start": 0, "name": "boxes", "type": "tensor" }, { "start": 1, "name": "scores", "type": "tensor" }, { "start": 2, "name": "maxOutputSize", "type": "number" }, { "start": 3, "name": "iouThreshold", "type": "number" }, { "start": 4, "name": "scoreThreshold", "type": "number" }, { "start": 5, "name": "softNmsSigma", "type": "number" }] }, { "tfOpName": "Where", "category": "dynamic", "inputs": [{ "start": 0, "name": "condition", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "ListDiff", "category": "dynamic", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "y", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }];
var LJ = Object["freeze"]({ "__proto__": null, "json": LV });
var LY = [{ "tfOpName": "LowerBound", "category": "evaluation", "inputs": [{ "start": 0, "name": "sortedSequence", "type": "tensor" }, { "start": 1, "name": "values", "type": "tensor" }] }, { "tfOpName": "TopKV2", "category": "evaluation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "k", "type": "number" }], "attrs": [{ "tfName": "sorted", "name": "sorted", "type": "bool" }] }, { "tfOpName": "UpperBound", "category": "evaluation", "inputs": [{ "start": 0, "name": "sortedSequence", "type": "tensor" }, { "start": 1, "name": "values", "type": "tensor" }] }, { "tfOpName": "Unique", "category": "evaluation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "UniqueV2", "category": "evaluation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number" }] }];
var LP = Object["freeze"]({ "__proto__": null, "json": LY });
var LU = [{ "tfOpName": "PlaceholderWithDefault", "category": "graph", "inputs": [{ "start": 0, "name": "default", "type": "tensor" }], "attrs": [{ "tfName": "shape", "name": "shape", "type": "shape" }, { "tfName": "dtype", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "Placeholder", "category": "graph", "attrs": [{ "tfName": "shape", "name": "shape", "type": "shape" }, { "tfName": "dtype", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "Const", "category": "graph" }, { "tfOpName": "Identity", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "IdentityN", "category": "graph", "inputs": [{ "start": 0, "end": 0, "name": "x", "type": "tensors" }] }, { "tfOpName": "Snapshot", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "Rank", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "Size", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "Shape", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "ShapeN", "category": "graph", "inputs": [{ "start": 0, "end": 0, "name": "x", "type": "tensors" }] }, { "tfOpName": "Print", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "data", "type": "tensors" }], "attrs": [{ "tfName": "message", "name": "message", "type": "string" }, { "tfName": "first_n", "name": "firstN", "type": "number", "notSupported": true }, { "tfName": "summarize", "name": "summarize", "type": "number", "defaultValue": 3 }] }, { "tfOpName": "NoOp", "category": "graph", "inputs": [] }, { "tfOpName": "StopGradient", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "FakeQuantWithMinMaxVars", "category": "graph", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "min", "name": "min", "type": "number" }, { "tfName": "max", "name": "max", "type": "number" }] }];
var Iq = Object["freeze"]({ "__proto__": null, "json": LU });
var IM = [{ "tfOpName": "HashTable", "category": "hash_table", "inputs": [], "attrs": [{ "tfName": "shared_name", "name": "sharedName", "type": "string" }, { "tfName": "use_node_name_sharing", "name": "useNodeNameSharing", "type": "bool" }, { "tfName": "key_dtype", "name": "keyDType", "type": "dtype" }, { "tfName": "value_dtype", "name": "valueDType", "type": "dtype" }] }, { "tfOpName": "HashTableV2", "category": "hash_table", "inputs": [], "attrs": [{ "tfName": "shared_name", "name": "sharedName", "type": "string" }, { "tfName": "use_node_name_sharing", "name": "useNodeNameSharing", "type": "bool" }, { "tfName": "key_dtype", "name": "keyDType", "type": "dtype" }, { "tfName": "value_dtype", "name": "valueDType", "type": "dtype" }] }, { "tfOpName": "LookupTableImport", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }, { "start": 1, "name": "keys", "type": "tensor" }, { "start": 2, "name": "values", "type": "tensor" }], "attrs": [{ "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true }, { "tfName": "Tout", "name": "tOut", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LookupTableImportV2", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }, { "start": 1, "name": "keys", "type": "tensor" }, { "start": 2, "name": "values", "type": "tensor" }], "attrs": [{ "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true }, { "tfName": "Tout", "name": "tOut", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LookupTableFind", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }, { "start": 1, "name": "keys", "type": "tensor" }, { "start": 2, "name": "defaultValue", "type": "tensor" }], "attrs": [{ "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true }, { "tfName": "Tout", "name": "tOut", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LookupTableFindV2", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }, { "start": 1, "name": "keys", "type": "tensor" }, { "start": 2, "name": "defaultValue", "type": "tensor" }], "attrs": [{ "tfName": "Tin", "name": "tIn", "type": "dtype", "notSupported": true }, { "tfName": "Tout", "name": "tOut", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LookupTableSize", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }] }, { "tfOpName": "LookupTableSizeV2", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }] }, { "tfOpName": "InitializeTable", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }, { "start": 1, "name": "keys", "type": "tensor" }, { "start": 2, "name": "values", "type": "tensor" }] }, { "tfOpName": "InitializeTableV2", "category": "hash_table", "inputs": [{ "start": 0, "name": "tableHandle", "type": "tensor" }, { "start": 1, "name": "keys", "type": "tensor" }, { "start": 2, "name": "values", "type": "tensor" }] }];
var IF = Object["freeze"]({ "__proto__": null, "json": IM });
var IW = [{ "tfOpName": "ResizeBilinear", "category": "image", "inputs": [{ "start": 0, "name": "images", "type": "tensor" }, { "start": 1, "name": "size", "type": "number[]" }], "attrs": [{ "tfName": "align_corners", "name": "alignCorners", "type": "bool" }, { "tfName": "half_pixel_centers", "name": "halfPixelCenters", "type": "bool" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "ResizeNearestNeighbor", "category": "image", "inputs": [{ "start": 0, "name": "images", "type": "tensor" }, { "start": 1, "name": "size", "type": "number[]" }], "attrs": [{ "tfName": "align_corners", "name": "alignCorners", "type": "bool" }, { "tfName": "half_pixel_centers", "name": "halfPixelCenters", "type": "bool" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "CropAndResize", "category": "image", "inputs": [{ "start": 0, "name": "image", "type": "tensor" }, { "start": 1, "name": "boxes", "type": "tensor" }, { "start": 2, "name": "boxInd", "type": "tensor" }, { "start": 3, "name": "cropSize", "type": "number[]" }], "attrs": [{ "tfName": "method", "name": "method", "type": "string" }, { "tfName": "extrapolation_value", "name": "extrapolationValue", "type": "number" }] }, { "tfOpName": "ImageProjectiveTransformV3", "category": "image", "inputs": [{ "start": 0, "name": "images", "type": "tensor" }, { "start": 1, "name": "transforms", "type": "tensor" }, { "start": 2, "name": "outputShape", "type": "number[]" }, { "start": 3, "name": "fillValue", "type": "number" }], "attrs": [{ "tfName": "interpolation", "name": "interpolation", "type": "string" }, { "tfName": "fill_mode", "name": "fillMode", "type": "string" }] }];
var ID = Object["freeze"]({ "__proto__": null, "json": IW });
var IZ = [{ "tfOpName": "Equal", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "NotEqual", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Greater", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "GreaterEqual", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Less", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LessEqual", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LogicalAnd", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LogicalNot", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "LogicalOr", "category": "logical", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Select", "category": "logical", "inputs": [{ "start": 0, "name": "condition", "type": "tensor" }, { "start": 1, "name": "a", "type": "tensor" }, { "start": 2, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "SelectV2", "category": "logical", "inputs": [{ "start": 0, "name": "condition", "type": "tensor" }, { "start": 1, "name": "a", "type": "tensor" }, { "start": 2, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "BitwiseAnd", "category": "logical", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "y", "type": "tensor" }] }];
var Iz = Object["freeze"]({ "__proto__": null, "json": IZ });
var IX = [{ "tfOpName": "_FusedMatMul", "category": "matrices", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }, { "start": 2, "end": 0, "name": "args", "type": "tensors" }], "attrs": [{ "tfName": "num_args", "name": "numArgs", "type": "number" }, { "tfName": "fused_ops", "name": "fusedOps", "type": "string[]", "defaultValue": [] }, { "tfName": "epsilon", "name": "epsilon", "type": "number", "defaultValue": 1e-4 }, { "tfName": "transpose_a", "name": "transposeA", "type": "bool", "defaultValue": false }, { "tfName": "transpose_b", "name": "transposeB", "type": "bool", "defaultValue": false }, { "tfName": "leakyrelu_alpha", "name": "leakyreluAlpha", "type": "number", "defaultValue": 0.2 }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "MatMul", "category": "matrices", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "transpose_a", "name": "transposeA", "type": "bool", "defaultValue": false }, { "tfName": "transpose_b", "name": "transposeB", "type": "bool", "defaultValue": false }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "BatchMatMul", "category": "matrices", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "adj_x", "name": "transposeA", "type": "bool", "defaultValue": false }, { "tfName": "adj_y", "name": "transposeB", "type": "bool", "defaultValue": false }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "BatchMatMulV2", "category": "matrices", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "b", "type": "tensor" }], "attrs": [{ "tfName": "adj_x", "name": "transposeA", "type": "bool", "defaultValue": false }, { "tfName": "adj_y", "name": "transposeB", "type": "bool", "defaultValue": false }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Transpose", "category": "matrices", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "perm", "type": "number[]" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Einsum", "category": "matrices", "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }], "attrs": [{ "tfName": "equation", "name": "equation", "type": "string" }, { "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }, { "tfName": "T", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "MatrixBandPart", "category": "matrices", "inputs": [{ "start": 0, "name": "a", "type": "tensor" }, { "start": 1, "name": "numLower", "type": "tensor" }, { "start": 1, "name": "numUpper", "type": "tensor" }] }];
var IG = Object["freeze"]({ "__proto__": null, "json": IX });
var Iu = [{ "tfOpName": "EuclideanNorm", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool", "defaultValue": false }] }, { "tfOpName": "FusedBatchNorm", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "scale", "type": "tensor" }, { "start": 2, "name": "offset", "type": "tensor" }, { "start": 3, "name": "mean", "type": "tensor" }, { "start": 4, "name": "variance", "type": "tensor" }], "attrs": [{ "tfName": "epsilon", "name": "epsilon", "type": "number", "defaultValue": 1e-3 }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }] }, { "tfOpName": "FusedBatchNormV2", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "scale", "type": "tensor" }, { "start": 2, "name": "offset", "type": "tensor" }, { "start": 3, "name": "mean", "type": "tensor" }, { "start": 4, "name": "variance", "type": "tensor" }], "attrs": [{ "tfName": "epsilon", "name": "epsilon", "type": "number", "defaultValue": 1e-3 }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }] }, { "tfOpName": "FusedBatchNormV3", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "scale", "type": "tensor" }, { "start": 2, "name": "offset", "type": "tensor" }, { "start": 3, "name": "mean", "type": "tensor" }, { "start": 4, "name": "variance", "type": "tensor" }], "attrs": [{ "tfName": "epsilon", "name": "epsilon", "type": "number", "defaultValue": 1e-3 }, { "tfName": "data_format", "name": "dataFormat", "type": "string", "notSupported": true }] }, { "tfOpName": "LRN", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "depth_radius", "name": "radius", "type": "number", "defaultValue": 5 }, { "tfName": "bias", "name": "bias", "type": "number", "defaultValue": 1 }, { "tfName": "alpha", "name": "alpha", "type": "number", "defaultValue": 1 }, { "tfName": "beta", "name": "beta", "type": "number", "defaultValue": 0.5 }] }, { "tfOpName": "Softmax", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "LogSoftmax", "category": "normalization", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }];
var Ij = Object["freeze"]({ "__proto__": null, "json": Iu });
var IL = [{ "tfOpName": "Bincount", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "size", "type": "number" }, { "start": 2, "name": "weights", "type": "tensor" }] }, { "tfOpName": "DenseBincount", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "size", "type": "number" }, { "start": 2, "name": "weights", "type": "tensor" }], "attrs": [{ "tfName": "binary_output", "name": "binaryOutput", "type": "bool" }] }, { "tfOpName": "Max", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }] }, { "tfOpName": "Mean", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }] }, { "tfOpName": "Min", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }] }, { "tfOpName": "Sum", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }] }, { "tfOpName": "All", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }] }, { "tfOpName": "Any", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }] }, { "tfOpName": "ArgMax", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number" }] }, { "tfOpName": "ArgMin", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number" }] }, { "tfOpName": "Prod", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }], "attrs": [{ "tfName": "keep_dims", "name": "keepDims", "type": "bool" }, { "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "Cumprod", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number" }], "attrs": [{ "tfName": "exclusive", "name": "exclusive", "type": "bool" }, { "tfName": "reverse", "name": "reverse", "type": "bool" }] }, { "tfOpName": "Cumsum", "category": "reduction", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number" }], "attrs": [{ "tfName": "exclusive", "name": "exclusive", "type": "bool" }, { "tfName": "reverse", "name": "reverse", "type": "bool" }] }];
var IR = Object["freeze"]({ "__proto__": null, "json": IL });
var IQ = [{ "tfOpName": "ConcatV2", "category": "slice_join", "inputs": [{ "start": 0, "end": -1, "name": "tensors", "type": "tensors" }, { "start": -1, "name": "axis", "type": "number" }], "attrs": [{ "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }] }, { "tfOpName": "Concat", "category": "slice_join", "inputs": [{ "start": 1, "end": 0, "name": "tensors", "type": "tensors" }, { "start": 0, "name": "axis", "type": "number" }], "attrs": [{ "tfName": "N", "name": "n", "type": "number", "defaultValue": 2 }] }, { "tfOpName": "GatherV2", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "indices", "type": "tensor" }, { "start": 2, "name": "axis", "type": "number", "defaultValue": 0 }], "attrs": [{ "tfName": "batch_dims", "name": "batchDims", "type": "number", "defaultValue": 0 }] }, { "tfOpName": "Gather", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "indices", "type": "tensor" }], "attrs": [{ "tfName": "validate_indices", "name": "validateIndices", "type": "bool", "notSupported": true }] }, { "tfOpName": "Reverse", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "dims", "type": "bool[]" }] }, { "tfOpName": "ReverseV2", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number[]" }] }, { "tfOpName": "Slice", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "begin", "type": "number[]" }, { "start": 2, "name": "size", "type": "number[]" }] }, { "tfOpName": "StridedSlice", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "begin", "type": "number[]" }, { "start": 2, "name": "end", "type": "number[]" }, { "start": 3, "name": "strides", "type": "number[]" }], "attrs": [{ "tfName": "begin_mask", "name": "beginMask", "type": "number", "defaultValue": 0 }, { "tfName": "end_mask", "name": "endMask", "type": "number", "defaultValue": 0 }, { "tfName": "new_axis_mask", "name": "newAxisMask", "type": "number", "defaultValue": 0 }, { "tfName": "ellipsis_mask", "name": "ellipsisMask", "type": "number", "defaultValue": 0 }, { "tfName": "shrink_axis_mask", "name": "shrinkAxisMask", "type": "number", "defaultValue": 0 }] }, { "tfOpName": "Pack", "category": "slice_join", "inputs": [{ "start": 0, "end": 0, "name": "tensors", "type": "tensors" }], "attrs": [{ "tfName": "axis", "name": "axis", "type": "number", "defaultValue": 0 }] }, { "tfOpName": "Unpack", "category": "slice_join", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }], "attrs": [{ "tfName": "axis", "name": "axis", "type": "number", "defaultValue": 0 }, { "tfName": "num", "name": "num", "type": "number", "defaultValue": 0, "notSupported": true }] }, { "tfOpName": "Tile", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "reps", "type": "number[]" }] }, { "tfOpName": "Split", "category": "slice_join", "inputs": [{ "start": 0, "name": "axis", "type": "number", "defaultValue": 0 }, { "start": 1, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "num_split", "name": "numOrSizeSplits", "type": "number", "defaultValue": 1 }] }, { "tfOpName": "SplitV", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "numOrSizeSplits", "type": "number[]" }, { "start": 2, "name": "axis", "type": "number", "defaultValue": 0 }] }, { "tfOpName": "ScatterNd", "category": "slice_join", "inputs": [{ "start": 0, "name": "indices", "type": "tensor" }, { "start": 1, "name": "values", "type": "tensor" }, { "start": 2, "name": "shape", "type": "number[]" }] }, { "tfOpName": "GatherNd", "category": "slice_join", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "indices", "type": "tensor" }] }, { "tfOpName": "SparseToDense", "category": "slice_join", "inputs": [{ "start": 0, "name": "sparseIndices", "type": "tensor" }, { "start": 1, "name": "outputShape", "type": "number[]" }, { "start": 2, "name": "sparseValues", "type": "tensor" }, { "start": 3, "name": "defaultValue", "type": "tensor" }], "attrs": [{ "tfName": "validate_indices", "name": "validateIndices", "type": "bool", "defaultValue": false, "notSupported": true }] }, { "tfOpName": "TensorScatterUpdate", "category": "slice_join", "inputs": [{ "start": 0, "name": "tensor", "type": "tensor" }, { "start": 1, "name": "indices", "type": "tensor" }, { "start": 2, "name": "values", "type": "tensor" }] }];
var IH = Object["freeze"]({ "__proto__": null, "json": IQ });
var IK = [{ "tfOpName": "SparseFillEmptyRows", "category": "sparse", "inputs": [{ "start": 0, "name": "indices", "type": "tensor" }, { "start": 1, "name": "values", "type": "tensor" }, { "start": 2, "name": "denseShape", "type": "tensor" }, { "start": 3, "name": "defaultValue", "type": "tensor" }] }, { "tfOpName": "SparseReshape", "category": "sparse", "inputs": [{ "start": 0, "name": "inputIndices", "type": "tensor" }, { "start": 1, "name": "inputShape", "type": "tensor" }, { "start": 2, "name": "newShape", "type": "tensor" }], "attrs": [{ "tfName": "T", "name": "dtype", "type": "dtype", "notSupported": true }] }, { "tfOpName": "SparseSegmentMean", "category": "sparse", "inputs": [{ "start": 0, "name": "data", "type": "tensor" }, { "start": 1, "name": "indices", "type": "tensor" }, { "start": 2, "name": "segmentIds", "type": "tensor" }] }, { "tfOpName": "SparseSegmentSum", "category": "sparse", "inputs": [{ "start": 0, "name": "data", "type": "tensor" }, { "start": 1, "name": "indices", "type": "tensor" }, { "start": 2, "name": "segmentIds", "type": "tensor" }] }];
var IB = Object["freeze"]({ "__proto__": null, "json": IK });
var IV = [{ "tfOpName": "FFT", "category": "spectral", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "IFFT", "category": "spectral", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }] }, { "tfOpName": "RFFT", "category": "spectral", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "fft_length", "type": "number", "notSupported": true }] }, { "tfOpName": "IRFFT", "category": "spectral", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "fft_length", "type": "number", "notSupported": true }] }];
var IJ = Object["freeze"]({ "__proto__": null, "json": IV });
var IY = [{ "tfOpName": "StaticRegexReplace", "category": "string", "inputs": [{ "start": 0, "name": "input", "type": "tensor" }], "attrs": [{ "tfName": "pattern", "name": "pattern", "type": "string" }, { "tfName": "rewrite", "name": "rewrite", "type": "string" }, { "tfName": "replace_global", "name": "replaceGlobal", "type": "bool" }] }, { "tfOpName": "StringNGrams", "category": "string", "inputs": [{ "start": 0, "name": "data", "type": "tensor" }, { "start": 1, "name": "dataSplits", "type": "tensor" }], "attrs": [{ "tfName": "separator", "name": "separator", "type": "string" }, { "tfName": "ngram_widths", "name": "nGramWidths", "type": "number[]" }, { "tfName": "left_pad", "name": "leftPad", "type": "string" }, { "tfName": "right_pad", "name": "rightPad", "type": "string" }, { "tfName": "pad_width", "name": "padWidth", "type": "number" }, { "tfName": "preserve_short_sequences", "name": "preserveShortSequences", "type": "bool" }], "outputs": ["ngrams", "ngrams_splits"] }, { "tfOpName": "StringSplit", "category": "string", "inputs": [{ "start": 0, "name": "input", "type": "tensor" }, { "start": 1, "name": "delimiter", "type": "tensor" }], "attrs": [{ "tfName": "skip_empty", "name": "skipEmpty", "type": "bool" }], "outputs": ["indices", "values", "shape"] }, { "tfOpName": "StringToHashBucketFast", "category": "string", "inputs": [{ "start": 0, "name": "input", "type": "tensor" }], "attrs": [{ "tfName": "num_buckets", "name": "numBuckets", "type": "number" }] }];
var IP = Object["freeze"]({ "__proto__": null, "json": IY });
var IU = [{ "tfOpName": "Cast", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "SrcT", "name": "sdtype", "type": "dtype", "notSupported": true }, { "tfName": "DstT", "name": "dtype", "type": "dtype" }] }, { "tfOpName": "ExpandDims", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "axis", "type": "number" }] }, { "tfOpName": "MirrorPad", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "padding", "type": "number[]" }], "attrs": [{ "tfName": "mode", "name": "mode", "type": "string" }] }, { "tfOpName": "Pad", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "padding", "type": "number[]" }], "attrs": [{ "tfName": "constant_value", "name": "constantValue", "type": "number", "defaultValue": 0 }] }, { "tfOpName": "PadV2", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "padding", "type": "number[]" }, { "start": 2, "name": "constantValue", "type": "number", "defaultValue": 0 }] }, { "tfOpName": "Reshape", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "shape", "type": "number[]" }] }, { "tfOpName": "EnsureShape", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "shape", "type": "number[]" }] }, { "tfOpName": "Squeeze", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "axis", "tfDeprecatedName": "squeeze_dims", "name": "axis", "type": "number[]" }] }, { "tfOpName": "SpaceToBatchND", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "blockShape", "type": "number[]" }, { "start": 2, "name": "paddings", "type": "number[]" }] }, { "tfOpName": "BatchToSpaceND", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "blockShape", "type": "number[]" }, { "start": 2, "name": "crops", "type": "number[]" }] }, { "tfOpName": "DepthToSpace", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }], "attrs": [{ "tfName": "block_size", "name": "blockSize", "type": "number" }, { "tfName": "data_format", "name": "dataFormat", "type": "string" }] }, { "tfOpName": "BroadcastTo", "category": "transformation", "inputs": [{ "start": 0, "name": "x", "type": "tensor" }, { "start": 1, "name": "shape", "type": "number[]" }], "attrs": [] }, { "tfOpName": "BroadcastArgs", "category": "transformation", "inputs": [{ "start": 0, "name": "s0", "type": "tensor" }, { "start": 1, "name": "s1", "type": "tensor" }], "attrs": [] }];
var bq = Object["freeze"]({ "__proto__": null, "json": IU });
var bM = class {
  static get ["Instance"]() {
    return this["_instance"] || (this["_instance"] = new this());
  }
  constructor() {
    const qgu = [LX, Lj, LR, LH, LB, LJ, LP, Iq, IF, ID, Iz, IG, Ij, IR, IH, IB, IJ, IP, bq], qgj = []["concat"](...qgu["map"]((qgL) => qgL["json"]));
    this["opMappers"] = qgj["reduce"]((qgL, qgI) => (qgL[qgI["tfOpName"]] = qgI, qgL), {});
  }
  ["transformGraph"](qgu, qgj = {}) {
    const qgL = qgu["node"], qgI = [], qgb = [], qgR = [], qgo = qgL["reduce"]((qgA, qgh) => (qgA[qgh["name"]] = this["mapNode"](qgh), qgh["op"]["startsWith"]("Placeholder") ? qgI["push"](qgA[qgh["name"]]) : qgh["op"] === "Const" ? qgb["push"](qgA[qgh["name"]]) : (qgh["input"] == null || qgh["input"]["length"] === 0) && qgR["push"](qgA[qgh["name"]]), qgA), {});
    let qgr = [];
    const qgQ = [];
    let qgd = {}, qgv = {};
    qgj != null && (qgd = this["mapSignatureEntries"](qgj["inputs"]), qgv = this["mapSignatureEntries"](qgj["outputs"]));
    const qgy = Object["keys"](qgo);
    qgy["forEach"]((qgA) => {
      const qgh = qgo[qgA];
      qgh["inputNames"]["forEach"]((qgT, qgK) => {
        const [qgB, , qgV] = LF(qgT), qgJ = qgo[qgB];
        if (qgJ["outputs"] != null) {
          const qgY = qgJ["outputs"]["indexOf"](qgV);
          if (qgY !== -1) {
            const qgP = qgB + ":" + qgY;
            qgh["inputNames"][qgK] = qgP;
          }
        }
        qgh["inputs"]["push"](qgJ), qgJ["children"]["push"](qgh);
      });
    }), Object["keys"](qgv)["length"] === 0 ? qgy["forEach"]((qgA) => {
      const qgh = qgo[qgA];
      qgh["children"]["length"] === 0 && qgQ["push"](qgh);
    }) : Object["keys"](qgv)["forEach"]((qgA) => {
      const [qgh] = LF(qgA), qgT = qgo[qgh];
      qgT != null && (qgT["signatureKey"] = qgv[qgA], qgQ["push"](qgT));
    }), Object["keys"](qgd)["length"] > 0 ? Object["keys"](qgd)["forEach"]((qgA) => {
      const [qgh] = LF(qgA), qgT = qgo[qgh];
      qgT && (qgT["signatureKey"] = qgd[qgA], qgr["push"](qgT));
    }) : qgr = qgI;
    let qgl = {};
    qgu["library"] != null && qgu["library"]["function"] != null && (qgl = qgu["library"]["function"]["reduce"]((qgA, qgh) => (qgA[qgh["signature"]["name"]] = this["mapFunction"](qgh), qgA), {}));
    const qgH = { "nodes": qgo, "inputs": qgr, "outputs": qgQ, "weights": qgb, "placeholders": qgI, "signature": qgj, "functions": qgl };
    return qgR["length"] > 0 && (qgH["initNodes"] = qgR), qgH;
  }
  ["mapSignatureEntries"](qgu) {
    return Object["keys"](qgu || {})["reduce"]((qgj, qgL) => (qgj[qgu[qgL]["name"]] = qgL, qgj), {});
  }
  ["mapNode"](qgu) {
    const qgj = Lq(qgu["op"]) || this["opMappers"][qgu["op"]] || {};
    qgu["attr"] == null && (qgu["attr"] = {});
    const qgL = { "name": qgu["name"], "op": qgu["op"], "category": qgj["category"], "inputNames": (qgu["input"] || [])["map"]((qgI) => qgI["startsWith"]("^") ? qgI["slice"](1) : qgI), "inputs": [], "children": [], "inputParams": {}, "attrParams": {}, "rawAttrs": qgu["attr"], "outputs": qgj["outputs"] };
    return qgj["inputs"] != null && (qgL["inputParams"] = qgj["inputs"]["reduce"]((qgI, qgb) => (qgI[qgb["name"]] = { "type": qgb["type"], "inputIndexStart": qgb["start"], "inputIndexEnd": qgb["end"] }, qgI), {})), qgj["attrs"] != null && (qgL["attrParams"] = qgj["attrs"]["reduce"]((qgI, qgb) => {
      const qgR = qgb["type"];
      let qgo;
      switch (qgb["type"]) {
        case "string":
          qgo = bW(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bW(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "string[]":
          qgo = bQ(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bQ(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "number":
          qgo = bZ(qgu["attr"], qgb["tfName"], qgb["defaultValue"] || 0), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bZ(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "number[]":
          qgo = bL(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bL(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "bool":
          qgo = bD(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bD(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "bool[]":
          qgo = bK(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bK(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "shape":
          qgo = bj(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bj(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "shape[]":
          qgo = bH(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bH(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "dtype":
          qgo = bX(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bX(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "dtype[]":
          qgo = bG(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bG(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "func":
          qgo = bz(qgu["attr"], qgb["tfName"], qgb["defaultValue"]), qgo === void 0 && qgb["tfDeprecatedName"] && (qgo = bz(qgu["attr"], qgb["tfDeprecatedName"], qgb["defaultValue"]));
          break;
        case "tensor":
        case "tensors":
          break;
        default:
          throw new Error("Unsupported param type: " + qgb["type"] + " for op: " + qgu["op"]);
      }
      return qgI[qgb["name"]] = { "value": qgo, "type": qgR }, qgI;
    }, {})), qgL;
  }
  ["mapFunction"](qgu) {
    const qgj = qgu["nodeDef"], qgL = [], qgI = [];
    let qgb = {};
    qgj != null && (qgb = qgj["reduce"]((qgd, qgv) => (qgd[qgv["name"]] = this["mapNode"](qgv), qgv["op"] === "Const" && qgI["push"](qgd[qgv["name"]]), qgd), {}));
    const qgR = [], qgo = [];
    qgu["signature"]["inputArg"]["forEach"]((qgd) => {
      const [qgv] = LF(qgd["name"]), qgy = { "name": qgv, "op": "Placeholder", "inputs": [], "inputNames": [], "category": "graph", "inputParams": {}, "attrParams": { "dtype": { "value": be(qgd["type"]), "type": "dtype" } }, "children": [] };
      qgy["signatureKey"] = qgd["name"], qgR["push"](qgy), qgb[qgv] = qgy;
    }), Object["keys"](qgb)["forEach"]((qgd) => {
      const qgv = qgb[qgd];
      qgv["inputNames"]["forEach"]((qgy, qgl) => {
        const [qgH, , qgA] = LF(qgy), qgh = qgb[qgH];
        if (qgh["outputs"] != null) {
          const qgT = qgh["outputs"]["indexOf"](qgA);
          if (qgT !== -1) {
            const qgK = qgH + ":" + qgT;
            qgv["inputNames"][qgl] = qgK;
          }
        }
        qgv["inputs"]["push"](qgh), qgh["children"]["push"](qgv);
      });
    });
    const qgr = qgu["ret"];
    qgu["signature"]["outputArg"]["forEach"]((qgd) => {
      const [qgv, qgy] = LF(qgr[qgd["name"]]), qgl = qgb[qgv];
      qgl != null && (qgl["defaultOutput"] = qgy, qgo["push"](qgl));
    });
    const qgQ = this["mapArgsToSignature"](qgu);
    return { "nodes": qgb, "inputs": qgR, "outputs": qgo, "weights": qgI, "placeholders": qgL, "signature": qgQ };
  }
  ["mapArgsToSignature"](qgu) {
    return { "methodName": qgu["signature"]["name"], "inputs": qgu["signature"]["inputArg"]["reduce"]((qgj, qgL) => (qgj[qgL["name"]] = this["mapArgToTensorInfo"](qgL), qgj), {}), "outputs": qgu["signature"]["outputArg"]["reduce"]((qgj, qgL) => (qgj[qgL["name"]] = this["mapArgToTensorInfo"](qgL, qgu["ret"]), qgj), {}) };
  }
  ["mapArgToTensorInfo"](qgu, qgj) {
    let qgL = qgu["name"];
    return qgj != null && (qgL = qgj[qgL]), { "name": qgL, "dtype": qgu["type"] };
  }
};
function bF(qgu) {
  const qgj = qM()["global"];
  if (typeof qgj["atob"] != "undefined") return qgj["atob"](qgu);
  if (typeof Buffer != "undefined") return new Buffer(qgu, "base64")["toString"]();
  throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()");
}
function bt(qgu, qgj) {
  const qgL = Array["isArray"](qgu) ? String["fromCharCode"]["apply"](null, qgu) : bF(qgu);
  return qgj ? qgL : qgL["toLowerCase"]();
}
function bW(qgu, qgj, qgL, qgI = false) {
  const qgb = qgu[qgj];
  return qgb != null ? bt(qgb["s"], qgI) : qgL;
}
function bD(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI ? qgI["b"] : qgL;
}
function bZ(qgu, qgj, qgL) {
  const qgI = qgu[qgj] || {}, qgb = qgI["i"] != null ? qgI["i"] : qgI["f"] != null ? qgI["f"] : qgL;
  return typeof qgb == "number" ? qgb : parseInt(qgb, 10);
}
function be(qgu) {
  switch (typeof qgu == "string" && (qgu = jY[qgu]), qgu) {
    case jY["DT_FLOAT"]:
    case jY["DT_HALF"]:
      return "float32";
    case jY["DT_INT32"]:
    case jY["DT_INT64"]:
    case jY["DT_INT8"]:
    case jY["DT_UINT8"]:
      return "int32";
    case jY["DT_BOOL"]:
      return "bool";
    case jY["DT_DOUBLE"]:
      return "float32";
    case jY["DT_STRING"]:
      return "string";
    case jY["DT_COMPLEX64"]:
    case jY["DT_COMPLEX128"]:
      return "complex64";
    default:
      return null;
  }
}
function bz(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI && qgI["func"] ? qgI["func"]["name"] : qgL;
}
function bX(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI && qgI["type"] ? be(qgI["type"]) : qgL;
}
function bG(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI && qgI["list"] && qgI["list"]["type"] ? qgI["list"]["type"]["map"]((qgb) => be(qgb)) : qgL;
}
function bu(qgu) {
  if (!qgu["unknownRank"]) return qgu["dim"] != null ? qgu["dim"]["map"]((qgj) => typeof qgj["size"] == "number" ? qgj["size"] : parseInt(qgj["size"], 10)) : [];
}
function bj(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI && qgI["shape"] ? bu(qgI["shape"]) : qgL;
}
function bL(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI ? ((qgI["list"]["f"] && qgI["list"]["f"]["length"] ? qgI["list"]["f"] : qgI["list"]["i"]) || [])["map"]((qgb) => typeof qgb == "number" ? qgb : parseInt(qgb, 10)) : qgL;
}
function bQ(qgu, qgj, qgL, qgI = false) {
  const qgb = qgu[qgj];
  return qgb && qgb["list"] && qgb["list"]["s"] ? qgb["list"]["s"]["map"]((qgR) => bt(qgR, qgI)) : qgL;
}
function bH(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI && qgI["list"] && qgI["list"]["shape"] ? qgI["list"]["shape"]["map"]((qgb) => bu(qgb)) : qgL;
}
function bK(qgu, qgj, qgL) {
  const qgI = qgu[qgj];
  return qgI && qgI["list"] && qgI["list"]["b"] ? qgI["list"]["b"] : qgL;
}
var bB = class {
  constructor(qgu, qgj, qgL) {
    this["node"] = qgu, this["tensorMap"] = qgj, this["context"] = qgL, this["inputs"] = [], this["attrs"] = {}, this["inputs"] = qgu["inputNames"]["map"]((qgI) => this["getInput"](qgI)), qgu["rawAttrs"] != null && (this["attrs"] = Object["keys"](qgu["rawAttrs"])["reduce"]((qgI, qgb) => (qgI[qgb] = this["getAttr"](qgb), qgI), {}));
  }
  ["getInput"](qgu) {
    return Ls(qgu, this["tensorMap"], this["context"]);
  }
  ["getAttr"](qgu, qgj) {
    const qgL = this["node"]["rawAttrs"][qgu];
    if (qgL["tensor"] != null) return Ls(qgu, this["tensorMap"], this["context"]);
    if (qgL["i"] != null || qgL["f"] != null) return bZ(this["node"]["rawAttrs"], qgu, qgj);
    if (qgL["s"] != null) return bW(this["node"]["rawAttrs"], qgu, qgj);
    if (qgL["b"] != null) return bD(this["node"]["rawAttrs"], qgu, qgj);
    if (qgL["shape"] != null) return bj(this["node"]["rawAttrs"], qgu, qgj);
    if (qgL["type"] != null) return bX(this["node"]["rawAttrs"], qgu, qgj);
    if (qgL["list"] != null) {
      if (qgL["list"]["i"] != null || qgL["list"]["f"] != null) return bL(this["node"]["rawAttrs"], qgu, qgj);
      if (qgL["list"]["s"] != null) return bQ(this["node"]["rawAttrs"], qgu, qgj);
      if (qgL["list"]["shape"] != null) return bH(this["node"]["rawAttrs"], qgu, qgj);
      if (qgL["list"]["b"] != null) return bK(this["node"]["rawAttrs"], qgu, qgj);
      if (qgL["list"]["type"] != null) return bG(this["node"]["rawAttrs"], qgu, qgj);
    }
    return qgj;
  }
};
var bV = { "conv2d": zP, "depthwiseConv2d": cD, "matMul": cZ };
var bJ = { "resizeBilinear": XQ };
var bY = Object["freeze"]({ "__proto__": null, "add": WY, "addN": iZ, "atan2": iz, "avgPool": DZ, "cast": OM, "concat": Dj, "conv2d": mF, "conv2dTranspose": mZ, "cos": mz, "depthToSpace": mG, "depthwiseConv2d": mj, "expandDims": ZM, "fill": DP, "floor": Za, "fused": bV, "gather": Ze, "greaterEqual": Zj, "image": bJ, "lessEqual": Zr, "logicalAnd": ZV, "matMul": OW, "max": az, "maxPool": ZY, "maximum": ZU, "mean": wM, "min": aG, "minimum": wZ, "mul": it, "neg": Oz, "pad": wz, "prelu": wG, "range": eX, "relu": ej, "relu6": eo, "reshape": DW, "scalar": aL, "sigmoid": DR, "sin": eB, "squeeze": zq, "stack": zF, "stridedSlice": ze, "sub": ZK, "tensor1d": zz, "tile": ZW, "transpose": Ou, "zerosLike": mK });
var bP = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "BiasAdd":
    case "AddV2":
    case "Add":
      return [qgI["add"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "AddN":
      return [qgI["addN"](Ln("tensors", qgu, qgj, qgL))];
    case "FloorMod":
    case "Mod":
      return [qgI["mod"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Mul":
      return [qgI["mul"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "RealDiv":
    case "Div":
      return [qgI["div"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "DivNoNan":
      return [qgI["divNoNan"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "FloorDiv":
      return [qgI["floorDiv"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Sub":
      return [qgI["sub"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Minimum":
      return [qgI["minimum"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Maximum":
      return [qgI["maximum"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Pow":
      return [qgI["pow"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "SquaredDifference":
      return [qgI["squaredDifference"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var bU = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Abs":
    case "ComplexAbs":
      return [qgI["abs"](Ln("x", qgu, qgj, qgL))];
    case "Acos":
      return [qgI["acos"](Ln("x", qgu, qgj, qgL))];
    case "Acosh":
      return [qgI["acosh"](Ln("x", qgu, qgj, qgL))];
    case "Asin":
      return [qgI["asin"](Ln("x", qgu, qgj, qgL))];
    case "Asinh":
      return [qgI["asinh"](Ln("x", qgu, qgj, qgL))];
    case "Atan":
      return [qgI["atan"](Ln("x", qgu, qgj, qgL))];
    case "Atan2":
      return [qgI["atan2"](Ln("x", qgu, qgj, qgL), Ln("y", qgu, qgj, qgL))];
    case "Atanh":
      return [qgI["atanh"](Ln("x", qgu, qgj, qgL))];
    case "Ceil":
      return [qgI["ceil"](Ln("x", qgu, qgj, qgL))];
    case "Complex":
      return [qgI["complex"](Ln("real", qgu, qgj, qgL), Ln("imag", qgu, qgj, qgL))];
    case "Cos":
      return [qgI["cos"](Ln("x", qgu, qgj, qgL))];
    case "Cosh":
      return [qgI["cosh"](Ln("x", qgu, qgj, qgL))];
    case "Elu":
      return [qgI["elu"](Ln("x", qgu, qgj, qgL))];
    case "Erf":
      return [qgI["erf"](Ln("x", qgu, qgj, qgL))];
    case "Exp":
      return [qgI["exp"](Ln("x", qgu, qgj, qgL))];
    case "Expm1":
      return [qgI["expm1"](Ln("x", qgu, qgj, qgL))];
    case "Floor":
      return [qgI["floor"](Ln("x", qgu, qgj, qgL))];
    case "Log":
      return [qgI["log"](Ln("x", qgu, qgj, qgL))];
    case "Log1p":
      return [qgI["log1p"](Ln("x", qgu, qgj, qgL))];
    case "Imag":
      return [qgI["imag"](Ln("x", qgu, qgj, qgL))];
    case "Neg":
      return [qgI["neg"](Ln("x", qgu, qgj, qgL))];
    case "Reciprocal":
      return [qgI["reciprocal"](Ln("x", qgu, qgj, qgL))];
    case "Real":
      return [qgI["real"](Ln("x", qgu, qgj, qgL))];
    case "Relu":
      return [qgI["relu"](Ln("x", qgu, qgj, qgL))];
    case "Round":
      return [qgI["round"](Ln("x", qgu, qgj, qgL))];
    case "Selu":
      return [qgI["selu"](Ln("x", qgu, qgj, qgL))];
    case "Sigmoid":
      return [qgI["sigmoid"](Ln("x", qgu, qgj, qgL))];
    case "Sin":
      return [qgI["sin"](Ln("x", qgu, qgj, qgL))];
    case "Sign":
      return [qgI["sign"](Ln("x", qgu, qgj, qgL))];
    case "Sinh":
      return [qgI["sinh"](Ln("x", qgu, qgj, qgL))];
    case "Softplus":
      return [qgI["softplus"](Ln("x", qgu, qgj, qgL))];
    case "Sqrt":
      return [qgI["sqrt"](Ln("x", qgu, qgj, qgL))];
    case "Square":
      return [qgI["square"](Ln("x", qgu, qgj, qgL))];
    case "Tanh":
      return [qgI["tanh"](Ln("x", qgu, qgj, qgL))];
    case "Tan":
      return [qgI["tan"](Ln("x", qgu, qgj, qgL))];
    case "ClipByValue":
      return [qgI["clipByValue"](Ln("x", qgu, qgj, qgL), Ln("clipValueMin", qgu, qgj, qgL), Ln("clipValueMax", qgu, qgj, qgL))];
    case "Relu6":
      return [qgI["relu6"](Ln("x", qgu, qgj, qgL))];
    case "Rsqrt":
      return [qgI["rsqrt"](Ls(qgu["inputNames"][0], qgj, qgL))];
    case "LeakyRelu":
      return [qgI["leakyRelu"](Ln("x", qgu, qgj, qgL), Ln("alpha", qgu, qgj, qgL))];
    case "Prelu":
      return [qgI["prelu"](Ln("x", qgu, qgj, qgL), Ln("alpha", qgu, qgj, qgL))];
    case "IsNan":
      return [qgI["isNaN"](Ls(qgu["inputNames"][0], qgj, qgL))];
    case "IsInf":
      return [qgI["isInf"](Ls(qgu["inputNames"][0], qgj, qgL))];
    case "IsFinite":
      return [qgI["isFinite"](Ls(qgu["inputNames"][0], qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
function Rq(qgu, qgj, qgL = "") {
  if (!(typeof qgu == "number" || typeof qgj == "number")) {
    k(qgu["length"] === qgj["length"], () => qgL + (" Shapes " + qgu + " and " + qgj + " must match"));
    for (let qgI = 0; qgI < qgu["length"]; qgI++) {
      const qgb = qgu[qgI], qgR = qgj[qgI];
      k(qgb < 0 || qgR < 0 || qgb === qgR, () => qgL + (" Shapes " + qgu + " and " + qgj + " must match"));
    }
  }
}
function Rs(qgu) {
  return !(typeof qgu == "number" || qgu["some"]((qgj) => qgj < 0));
}
function RM(qgu, qgj, qgL) {
  let qgI = RF(qgu, qgL);
  const qgb = !Rs(qgI);
  if (qgb && qgj["length"] === 0) throw new Error("Tried to calculate elements of an empty list with non-fully-defined elementShape: " + qgI);
  if (qgb && qgj["forEach"]((qgR) => {
    qgI = RF(qgR["shape"], qgI);
  }), !Rs(qgI)) throw new Error("Non-fully-defined elementShape: " + qgI);
  return qgI;
}
function RF(qgu, qgj) {
  if (typeof qgu == "number") return qgj;
  if (typeof qgj == "number") return qgu;
  if (qgu["length"] !== qgj["length"]) throw new Error("Incompatible ranks during merge: " + qgu + " vs. " + qgj);
  const qgL = [];
  for (let qgI = 0; qgI < qgu["length"]; ++qgI) {
    const qgb = qgu[qgI], qgR = qgj[qgI];
    if (qgb >= 0 && qgR >= 0 && qgb !== qgR) throw new Error("Incompatible shape during merge: " + qgu + " vs. " + qgj);
    qgL[qgI] = qgb >= 0 ? qgb : qgR;
  }
  return qgL;
}
var RW = class {
  constructor(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
    this["name"] = qgu, this["dtype"] = qgj, this["maxSize"] = qgL, this["elementShape"] = qgI, this["identicalElementShapes"] = qgb, this["dynamicSize"] = qgR, this["clearAfterRead"] = qgo, this["tensors"] = [], this["closed_"] = false, this["idTensor"] = aL(0), SM(this["idTensor"]);
  }
  get ["id"]() {
    return this["idTensor"]["id"];
  }
  get ["closed"]() {
    return this["closed_"];
  }
  ["clearAndClose"](qgu) {
    this["tensors"]["forEach"]((qgj) => {
      (qgu == null || !qgu["has"](qgj["tensor"]["id"])) && qgj["tensor"]["dispose"]();
    }), this["tensors"] = [], this["closed_"] = true, this["idTensor"]["dispose"]();
  }
  ["size"]() {
    return this["tensors"]["length"];
  }
  ["read"](qgu) {
    if (this["closed_"]) throw new Error("TensorArray " + this["name"] + " has already been closed.");
    if (qgu < 0 || qgu >= this["size"]()) throw new Error("Tried to read from index " + qgu + ", but array size is: " + this["size"]());
    const qgj = this["tensors"][qgu];
    if (qgj["cleared"]) throw new Error("TensorArray " + this["name"] + ": Could not read index " + qgu + " twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).");
    return this["clearAfterRead"] && (qgj["cleared"] = true), qgj["read"] = true, qgj["tensor"];
  }
  ["readMany"](qgu) {
    return qgu["map"]((qgj) => this["read"](qgj));
  }
  ["write"](qgu, qgj) {
    if (this["closed_"]) throw new Error("TensorArray " + this["name"] + " has already been closed.");
    if (qgu < 0 || !this["dynamicSize"] && qgu >= this["maxSize"]) throw new Error("Tried to write to index " + qgu + ", but array is not resizeable and size is: " + this["maxSize"]);
    const qgL = this["tensors"][qgu] || {};
    if (qgj["dtype"] !== this["dtype"]) throw new Error("TensorArray " + this["name"] + ": Could not write to TensorArray index " + qgu + ",\n          because the value dtype is " + qgj["dtype"] + ", but TensorArray dtype is " + this["dtype"] + ".");
    if (this["size"]() === 0 && (this["elementShape"] == null || this["elementShape"]["length"] === 0) && (this["elementShape"] = qgj["shape"]), Rq(this["elementShape"], qgj["shape"], "TensorArray " + this["name"] + ": Could not write to TensorArray index " + qgu + "."), qgL["read"]) throw new Error("TensorArray " + this["name"] + ": Could not write to TensorArray index " + qgu + ", because it has already been read.");
    if (qgL["written"]) throw new Error("TensorArray " + this["name"] + ": Could not write to TensorArray index " + qgu + ", because it has already been written.");
    qgL["tensor"] = qgj, SM(qgj), qgL["written"] = true, this["tensors"][qgu] = qgL;
  }
  ["writeMany"](qgu, qgj) {
    if (qgu["length"] !== qgj["length"]) throw new Error("TensorArray " + this["name"] + ": could not write multiple tensors,because the index size: " + qgu["length"] + " is not the same as tensors size: " + qgj["length"] + ".");
    qgu["forEach"]((qgL, qgI) => this["write"](qgL, qgj[qgI]));
  }
  ["gather"](qgu, qgj) {
    if (qgj && qgj !== this["dtype"]) throw new Error("TensorArray dtype is " + this["dtype"] + " but gather requested dtype " + qgj);
    if (qgu) qgu = qgu["slice"](0, this["size"]());
    else {
      qgu = [];
      for (let qgI = 0; qgI < this["size"](); qgI++) qgu["push"](qgI);
    }
    if (qgu["length"] === 0) return fB([], [0]["concat"](this["elementShape"]));
    const qgL = this["readMany"](qgu);
    return Rq(this["elementShape"], qgL[0]["shape"], "TensorArray shape mismatch: "), zF(qgL, 0);
  }
  ["concat"](qgu) {
    if (qgu && qgu !== this["dtype"]) throw new Error("TensorArray dtype is " + this["dtype"] + " but concat requested dtype " + qgu);
    if (this["size"]() === 0) return fB([], [0]["concat"](this["elementShape"]));
    const qgj = [];
    for (let qgI = 0; qgI < this["size"](); qgI++) qgj["push"](qgI);
    const qgL = this["readMany"](qgj);
    return Rq(this["elementShape"], qgL[0]["shape"], "TensorArray shape mismatch: tensor array shape (" + this["elementShape"] + ") vs first tensor shape (" + qgL[0]["shape"] + ")"), Dj(qgL, 0);
  }
  ["scatter"](qgu, qgj) {
    if (qgj["dtype"] !== this["dtype"]) throw new Error("TensorArray dtype is " + this["dtype"] + " but tensor has dtype " + qgj["dtype"]);
    if (qgu["length"] !== qgj["shape"][0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + qgu["length"] + " vs. " + qgj["shape"][0]);
    const qgL = Math["max"](...qgu);
    if (!this["dynamicSize"] && qgL >= this["maxSize"]) throw new Error("Max index must be < array size (" + qgL + "  vs. " + this["maxSize"] + ")");
    this["writeMany"](qgu, zL(qgj, 0));
  }
  ["split"](qgu, qgj) {
    if (qgj["dtype"] !== this["dtype"]) throw new Error("TensorArray dtype is " + this["dtype"] + " but tensor has dtype " + qgj["dtype"]);
    let qgL = 0;
    const qgI = qgu["map"]((qgr) => (qgL += qgr, qgL));
    if (qgL !== qgj["shape"][0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + qgL + ", and tensor's shape is: " + qgj["shape"]);
    if (!this["dynamicSize"] && qgu["length"] !== this["maxSize"]) throw new Error("TensorArray's size is not equal to the size of lengths (" + this["maxSize"] + " vs. " + qgu["length"] + "), and the TensorArray is not marked as dynamically resizeable");
    const qgb = qgL === 0 ? 0 : qgj["size"] / qgL, qgR = [];
    Sq(() => {
      qgj = DW(qgj, [1, qgL, qgb]);
      for (let qgr = 0; qgr < qgu["length"]; ++qgr) {
        const qgQ = [0, qgr === 0 ? 0 : qgI[qgr - 1], 0], qgd = [1, qgu[qgr], qgb];
        qgR[qgr] = DW(DH(qgj, qgQ, qgd), this["elementShape"]);
      }
      return qgR;
    });
    const qgo = [];
    for (let qgr = 0; qgr < qgu["length"]; qgr++) qgo[qgr] = qgr;
    this["writeMany"](qgo, qgR);
  }
};
var RD = class _RD {
  get ["id"]() {
    return this["idTensor"]["id"];
  }
  constructor(qgu, qgj, qgL, qgI = -1) {
    this["tensors"] = qgu, this["elementShape"] = qgj, this["elementDtype"] = qgL, qgu != null && qgu["forEach"]((qgb) => {
      if (qgL !== qgb["dtype"]) throw new Error("Invalid data types; op elements " + qgL + ", but list elements " + qgb["dtype"]);
      Rq(qgj, qgb["shape"], "TensorList shape mismatch: "), SM(qgb);
    }), this["idTensor"] = aL(0), this["maxNumElements"] = qgI, SM(this["idTensor"]);
  }
  ["copy"]() {
    return new _RD([...this["tensors"]], this["elementShape"], this["elementDtype"]);
  }
  ["clearAndClose"](qgu) {
    this["tensors"]["forEach"]((qgj) => {
      (qgu == null || !qgu["has"](qgj["id"])) && qgj["dispose"]();
    }), this["tensors"]["length"] = 0, this["idTensor"]["dispose"]();
  }
  ["size"]() {
    return this["tensors"]["length"];
  }
  ["stack"](qgu, qgj, qgL = -1) {
    if (qgj !== this["elementDtype"]) throw new Error("Invalid data types; op elements " + qgj + ", but list elements " + this["elementDtype"]);
    if (qgL !== -1 && this["tensors"]["length"] !== qgL) throw new Error("Operation expected a list with " + qgL + " elements but got a list with " + this["tensors"]["length"] + " elements.");
    Rq(qgu, this["elementShape"], "TensorList shape mismatch: ");
    const qgI = RM(this["elementShape"], this["tensors"], qgu);
    return Sq(() => {
      const qgb = this["tensors"]["map"]((qgR) => DW(qgR, qgI));
      return zF(qgb, 0);
    });
  }
  ["popBack"](qgu, qgj) {
    if (qgj !== this["elementDtype"]) throw new Error("Invalid data types; op elements " + qgj + ", but list elements " + this["elementDtype"]);
    if (this["size"]() === 0) throw new Error("Trying to pop from an empty list.");
    const qgL = RM(this["elementShape"], this["tensors"], qgu), qgI = this["tensors"]["pop"]();
    return qgI["kept"] = false, Rq(qgI["shape"], qgu, "TensorList shape mismatch: "), DW(qgI, qgL);
  }
  ["pushBack"](qgu) {
    if (qgu["dtype"] !== this["elementDtype"]) throw new Error("Invalid data types; op elements " + qgu["dtype"] + ", but list elements " + this["elementDtype"]);
    if (Rq(qgu["shape"], this["elementShape"], "TensorList shape mismatch: "), this["maxNumElements"] === this["size"]()) throw new Error("Trying to push element into a full list.");
    SM(qgu), this["tensors"]["push"](qgu);
  }
  ["resize"](qgu) {
    if (qgu < 0) throw new Error("TensorListResize expects size to be non-negative. Got: " + qgu);
    if (this["maxNumElements"] !== -1 && qgu > this["maxNumElements"]) throw new Error("TensorListResize input size " + qgu + " is greater maxNumElement " + this["maxNumElements"] + ".");
    const qgj = new _RD([], this["elementShape"], this["elementDtype"], this["maxNumElements"]);
    qgj["tensors"]["length"] = qgu;
    for (let qgL = 0; qgL < Math["min"](this["tensors"]["length"], qgu); ++qgL) qgj["tensors"][qgL] = this["tensors"][qgL];
    return qgj;
  }
  ["getItem"](qgu, qgj, qgL) {
    if (qgL !== this["elementDtype"]) throw new Error("Invalid data types; op elements " + qgL + ", but list elements " + this["elementDtype"]);
    if (qgu < 0 || qgu > this["tensors"]["length"]) throw new Error("Trying to access element " + qgu + " in a list with " + this["tensors"]["length"] + " elements.");
    if (this["tensors"][qgu] == null) throw new Error("element at index " + qgu + " is null.");
    Rq(this["tensors"][qgu]["shape"], qgj, "TensorList shape mismatch: ");
    const qgI = RM(this["elementShape"], this["tensors"], qgj);
    return DW(this["tensors"][qgu], qgI);
  }
  ["setItem"](qgu, qgj) {
    if (qgj["dtype"] !== this["elementDtype"]) throw new Error("Invalid data types; op elements " + qgj["dtype"] + ", but list elements " + this["elementDtype"]);
    if (qgu < 0 || this["maxNumElements"] !== -1 && qgu >= this["maxNumElements"]) throw new Error("Trying to set element " + qgu + " in a list with max " + this["maxNumElements"] + " elements.");
    Rq(this["elementShape"], qgj["shape"], "TensorList shape mismatch: "), SM(qgj), this["tensors"][qgu] != null && (this["tensors"][qgu]["kept"] = false), this["tensors"][qgu] = qgj;
  }
  ["gather"](qgu, qgj, qgL) {
    if (qgj !== this["elementDtype"]) throw new Error("Invalid data types; op elements " + qgj + ", but list elements " + this["elementDtype"]);
    Rq(this["elementShape"], qgL, "TensorList shape mismatch: "), qgu = qgu["slice"](0, this["size"]());
    const qgI = RM(this["elementShape"], this["tensors"], qgL);
    return qgu["length"] === 0 ? fB([], [0]["concat"](qgI)) : Sq(() => {
      const qgb = qgu["map"]((qgR) => DW(this["tensors"][qgR], qgI));
      return zF(qgb, 0);
    });
  }
  ["concat"](qgu, qgj) {
    if (qgu && qgu !== this["elementDtype"]) throw new Error("TensorList dtype is " + this["elementDtype"] + " but concat requested dtype " + qgu);
    Rq(this["elementShape"], qgj, "TensorList shape mismatch: ");
    const qgL = RM(this["elementShape"], this["tensors"], qgj);
    return this["size"]() === 0 ? fB([], [0]["concat"](qgL)) : Sq(() => {
      const qgI = this["tensors"]["map"]((qgb) => DW(qgb, qgL));
      return Dj(qgI, 0);
    });
  }
};
function RZ(qgu, qgj, qgL) {
  const qgI = qgu["dtype"];
  if (qgu["shape"]["length"] < 1) throw new Error("Tensor must be at least a vector, but saw shape: " + qgu["shape"]);
  if (qgu["dtype"] !== qgL) throw new Error("Invalid data types; op elements " + qgu["dtype"] + ", but list elements " + qgL);
  const qgb = qgu["shape"]["slice"](1);
  Rq(qgb, qgj, "TensorList shape mismatch: ");
  const qgR = zL(qgu);
  return new RD(qgR, qgj, qgI);
}
function Re(qgu, qgj, qgL, qgI) {
  return new RD([], qgu, qgj, qgI);
}
function Rz(qgu, qgj, qgL, qgI) {
  if (qgj["length"] !== qgu["shape"][0]) throw new Error("Expected len(indices) == tensor.shape[0], but saw: " + qgj["length"] + " vs. " + qgu["shape"][0]);
  const qgb = Math["max"](...qgj);
  if (qgI != null && qgI !== -1 && qgb >= qgI) throw new Error("Max index must be < array size (" + qgb + "  vs. " + qgI + ")");
  const qgR = new RD([], qgL, qgu["dtype"], qgI), qgo = zL(qgu, 0);
  return qgj["forEach"]((qgr, qgQ) => {
    qgR["setItem"](qgr, qgo[qgQ]);
  }), qgR;
}
function RX(qgu, qgj, qgL) {
  let qgI = 0;
  const qgb = qgj["map"]((qgv) => (qgI += qgv, qgI));
  if (qgI !== qgu["shape"][0]) throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        " + qgI + ", and tensor's shape is: " + qgu["shape"]);
  const qgR = qgu["shape"]["slice"](1), qgo = RF(qgR, qgL), qgr = qgI === 0 ? 0 : qgu["size"] / qgI, qgQ = Sq(() => {
    const qgv = [];
    qgu = DW(qgu, [1, qgI, qgr]);
    for (let qgy = 0; qgy < qgj["length"]; ++qgy) {
      const qgl = [0, qgy === 0 ? 0 : qgb[qgy - 1], 0], qgH = [1, qgj[qgy], qgr];
      qgv[qgy] = DW(DH(qgu, qgl, qgH), qgo);
    }
    return qgu["dispose"](), qgv;
  }), qgd = new RD([], qgL, qgu["dtype"], qgj["length"]);
  for (let qgv = 0; qgv < qgQ["length"]; qgv++) qgd["setItem"](qgv, qgQ[qgv]);
  return qgd;
}
var RG = async (qgu, qgj, qgL) => {
  switch (qgu["op"]) {
    case "If":
    case "StatelessIf": {
      const qgI = Ln("thenBranch", qgu, qgj, qgL), qgb = Ln("elseBranch", qgu, qgj, qgL), qgR = Ln("cond", qgu, qgj, qgL), qgo = Ln("args", qgu, qgj, qgL);
      return (await qgR["data"]())[0] ? qgL["functionMap"][qgI]["executeFunctionAsync"](qgo, qgL["tensorArrayMap"], qgL["tensorListMap"]) : qgL["functionMap"][qgb]["executeFunctionAsync"](qgo, qgL["tensorArrayMap"], qgL["tensorListMap"]);
    }
    case "While":
    case "StatelessWhile": {
      const qgr = Ln("body", qgu, qgj, qgL), qgQ = Ln("cond", qgu, qgj, qgL), qgd = Ln("args", qgu, qgj, qgL), qgv = await qgL["functionMap"][qgQ]["executeFunctionAsync"](qgd, qgL["tensorArrayMap"], qgL["tensorListMap"]), qgy = qgd["map"]((qgA) => qgA["id"]);
      let qgl = await qgv[0]["data"]();
      qgv["forEach"]((qgA) => {
        !qgA["kept"] && qgy["indexOf"](qgA["id"]) === -1 && qgA["dispose"]();
      });
      let qgH = qgd;
      for (; qgl[0]; ) {
        const qgA = qgH;
        qgH = await qgL["functionMap"][qgr]["executeFunctionAsync"](qgH, qgL["tensorArrayMap"], qgL["tensorListMap"]);
        const qgh = qgH["map"]((qgK) => qgK["id"]);
        qgA["forEach"]((qgK) => {
          !qgK["kept"] && qgy["indexOf"](qgK["id"]) === -1 && qgh["indexOf"](qgK["id"]) === -1 && qgK["dispose"]();
        });
        const qgT = await qgL["functionMap"][qgQ]["executeFunctionAsync"](qgH, qgL["tensorArrayMap"], qgL["tensorListMap"]);
        qgl = await qgT[0]["data"](), qgT["forEach"]((qgK) => {
          !qgK["kept"] && qgy["indexOf"](qgK["id"]) === -1 && qgh["indexOf"](qgK["id"]) === -1 && qgK["dispose"]();
        });
      }
      return qgH;
    }
    case "LoopCond": {
      const qgK = Ln("pred", qgu, qgj, qgL);
      return [Le(qgK)];
    }
    case "Switch": {
      const qgB = Ln("pred", qgu, qgj, qgL);
      let qgV = Ln("data", qgu, qgj, qgL);
      return qgV["kept"] || (qgV = Le(qgV)), (await qgB["data"]())[0] ? [void 0, qgV] : [qgV, void 0];
    }
    case "Merge": {
      const qgJ = qgu["inputNames"]["find"]((qgY) => Ls(qgY, qgj, qgL) !== void 0);
      if (qgJ) {
        const qgY = Ls(qgJ, qgj, qgL);
        return [Le(qgY)];
      }
      return;
    }
    case "Enter": {
      const qgP = Ln("frameName", qgu, qgj, qgL), qgU = Ln("tensor", qgu, qgj, qgL);
      return qgL["enterFrame"](qgP), [Le(qgU)];
    }
    case "Exit": {
      const qx0 = Ln("tensor", qgu, qgj, qgL);
      return qgL["exitFrame"](), [Le(qx0)];
    }
    case "NextIteration": {
      const qx1 = Ln("tensor", qgu, qgj, qgL);
      return qgL["nextIteration"](), [Le(qx1)];
    }
    case "TensorArrayV3": {
      const qx2 = Ln("size", qgu, qgj, qgL), qx3 = Ln("dtype", qgu, qgj, qgL), qx4 = Ln("elementShape", qgu, qgj, qgL), qx5 = Ln("dynamicSize", qgu, qgj, qgL), qx6 = Ln("clearAfterRead", qgu, qgj, qgL), qx7 = Ln("identicalElementShapes", qgu, qgj, qgL), qx8 = Ln("name", qgu, qgj, qgL), qx9 = new RW(qx8, qx3, qx2, qx4, qx7, qx5, qx6);
      return qgL["addTensorArray"](qx9), [qx9["idTensor"], aL(1)];
    }
    case "TensorArrayWriteV3": {
      const qxq = Ln("tensorArrayId", qgu, qgj, qgL), qxn = Ln("index", qgu, qgj, qgL), qxp = Ln("tensor", qgu, qgj, qgL), qxs = qgL["getTensorArray"](qxq["id"]);
      return qxs["write"](qxn, qxp), [qxs["idTensor"]];
    }
    case "TensorArrayReadV3": {
      const qxE = Ln("tensorArrayId", qgu, qgj, qgL), qxM = Ln("index", qgu, qgj, qgL);
      return [qgL["getTensorArray"](qxE["id"])["read"](qxM)];
    }
    case "TensorArrayGatherV3": {
      const qxf = Ln("tensorArrayId", qgu, qgj, qgL), qxS = Ln("indices", qgu, qgj, qgL), qxF = Ln("dtype", qgu, qgj, qgL);
      return [qgL["getTensorArray"](qxf["id"])["gather"](qxS, qxF)];
    }
    case "TensorArrayScatterV3": {
      const qxt = Ln("tensorArrayId", qgu, qgj, qgL), qxk = Ln("indices", qgu, qgj, qgL), qxO = Ln("tensor", qgu, qgj, qgL), qxW = qgL["getTensorArray"](qxt["id"]);
      return qxW["scatter"](qxk, qxO), [qxW["idTensor"]];
    }
    case "TensorArrayConcatV3": {
      const qxi = Ln("tensorArrayId", qgu, qgj, qgL), qxD = qgL["getTensorArray"](qxi["id"]), qxm = Ln("dtype", qgu, qgj, qgL);
      return [qxD["concat"](qxm)];
    }
    case "TensorArraySplitV3": {
      const qxa = Ln("tensorArrayId", qgu, qgj, qgL), qxZ = Ln("tensor", qgu, qgj, qgL), qxw = Ln("lengths", qgu, qgj, qgL), qxe = qgL["getTensorArray"](qxa["id"]);
      return qxe["split"](qxw, qxZ), [qxe["idTensor"]];
    }
    case "TensorArraySizeV3": {
      const qxz = Ln("tensorArrayId", qgu, qgj, qgL), qxc = qgL["getTensorArray"](qxz["id"]);
      return [aL(qxc["size"](), "int32")];
    }
    case "TensorArrayCloseV3": {
      const qxX = Ln("tensorArrayId", qgu, qgj, qgL), qxG = qgL["getTensorArray"](qxX["id"]);
      return qxG["clearAndClose"](), [qxG["idTensor"]];
    }
    case "TensorListSetItem": {
      const qxN = Ln("tensorListId", qgu, qgj, qgL), qxu = Ln("index", qgu, qgj, qgL), qxj = Ln("tensor", qgu, qgj, qgL), qxL = qgL["getTensorList"](qxN["id"]);
      return qxL["setItem"](qxu, qxj), [qxL["idTensor"]];
    }
    case "TensorListGetItem": {
      const qxI = Ln("tensorListId", qgu, qgj, qgL), qxb = Ln("index", qgu, qgj, qgL), qxR = Ln("elementShape", qgu, qgj, qgL), qxo = Ln("elementDType", qgu, qgj, qgL);
      return [qgL["getTensorList"](qxI["id"])["getItem"](qxb, qxR, qxo)];
    }
    case "TensorListScatterV2":
    case "TensorListScatter": {
      const qxr = Ln("indices", qgu, qgj, qgL), qxQ = Ln("tensor", qgu, qgj, qgL), qxd = Ln("elementShape", qgu, qgj, qgL), qxv = Ln("numElements", qgu, qgj, qgL), qxy = Rz(qxQ, qxr, qxd, qxv);
      return qgL["addTensorList"](qxy), [qxy["idTensor"]];
    }
    case "TensorListReserve":
    case "EmptyTensorList": {
      const qxC = Ln("elementShape", qgu, qgj, qgL), qxl = Ln("elementDType", qgu, qgj, qgL);
      let qxH;
      qgu["op"] === "TensorListReserve" ? qxH = "numElements" : qxH = "maxNumElements";
      const qxA = Ln(qxH, qgu, qgj, qgL), qxh = qgu["op"] === "TensorListReserve" ? -1 : qxA, qxT = Re(qxC, qxl, qxA, qxh);
      return qgL["addTensorList"](qxT), [qxT["idTensor"]];
    }
    case "TensorListGather": {
      const qxK = Ln("tensorListId", qgu, qgj, qgL), qxB = Ln("indices", qgu, qgj, qgL), qxV = Ln("elementShape", qgu, qgj, qgL), qxJ = Ln("elementDType", qgu, qgj, qgL);
      return [qgL["getTensorList"](qxK["id"])["gather"](qxB, qxJ, qxV)];
    }
    case "TensorListStack": {
      const qxY = Ln("tensorListId", qgu, qgj, qgL), qxP = Ln("elementShape", qgu, qgj, qgL), qxU = Ln("elementDType", qgu, qgj, qgL), qs0 = Ln("numElements", qgu, qgj, qgL);
      return [qgL["getTensorList"](qxY["id"])["stack"](qxP, qxU, qs0)];
    }
    case "TensorListFromTensor": {
      const qs1 = Ln("tensor", qgu, qgj, qgL), qs2 = Ln("elementShape", qgu, qgj, qgL), qs3 = Ln("elementDType", qgu, qgj, qgL), qs4 = RZ(qs1, qs2, qs3);
      return qgL["addTensorList"](qs4), [qs4["idTensor"]];
    }
    case "TensorListConcat":
    case "TensorListConcatV2": {
      const qs5 = Ln("tensorListId", qgu, qgj, qgL), qs6 = qgL["getTensorList"](qs5["id"]), qs7 = Ln("dtype", qgu, qgj, qgL), qs8 = Ln("elementShape", qgu, qgj, qgL);
      return [qs6["concat"](qs7, qs8)];
    }
    case "TensorListPushBack": {
      const qs9 = Ln("tensorListId", qgu, qgj, qgL), qsq = Ln("tensor", qgu, qgj, qgL), qsn = qgL["getTensorList"](qs9["id"]);
      return qsn["pushBack"](qsq), [qsn["idTensor"]];
    }
    case "TensorListPopBack": {
      const qsp = Ln("tensorListId", qgu, qgj, qgL), qsg = Ln("elementShape", qgu, qgj, qgL), qsx = Ln("elementDType", qgu, qgj, qgL);
      return [qgL["getTensorList"](qsp["id"])["popBack"](qsg, qsx)];
    }
    case "TensorListSplit": {
      const qss = Ln("tensor", qgu, qgj, qgL), qsE = Ln("elementShape", qgu, qgj, qgL), qsM = Ln("lengths", qgu, qgj, qgL), qsf = RX(qss, qsM, qsE);
      return qgL["addTensorList"](qsf), [qsf["idTensor"]];
    }
    case "TensorListLength": {
      const qsS = Ln("tensorListId", qgu, qgj, qgL), qsF = qgL["getTensorList"](qsS["id"]);
      return [aL(qsF["size"](), "int32")];
    }
    case "TensorListResize": {
      const qst = Ln("tensorListId", qgu, qgj, qgL), qsk = Ln("size", qgu, qgj, qgL), qsO = qgL["getTensorList"](qst["id"])["resize"](qsk);
      return qgL["addTensorList"](qsO), [qsO["idTensor"]];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
function Ru(qgu, qgj, qgL) {
  const [qgI, qgb] = Ln("fusedOps", qgu, qgj, qgL), qgR = qgI === "biasadd", qgo = !qgR, qgr = qgb === "prelu", qgQ = qgI === "fusedbatchnorm", qgd = Ln("numArgs", qgu, qgj, qgL);
  if (qgR) {
    if (qgr && qgd !== 2) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
    if (!qgr && qgR && qgd !== 1) throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.");
  }
  if (qgQ) throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");
  const qgv = Ln("strides", qgu, qgj, qgL), qgy = LZ(qgu, qgj, qgL), qgl = Ln("dataFormat", qgu, qgj, qgL)["toUpperCase"](), qgH = Ln("dilations", qgu, qgj, qgL);
  let [qgA, qgh] = Ln("args", qgu, qgj, qgL);
  qgo && (qgh = qgA, qgA = void 0);
  const qgT = Ln("leakyreluAlpha", qgu, qgj, qgL);
  return { "stride": qgv, "pad": qgy, "dataFormat": qgl, "dilations": qgH, "biasArg": qgA, "preluArg": qgh, "activationFunc": qgb, "leakyreluAlpha": qgT };
}
var Rj = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Conv1D": {
      const qgb = Ln("stride", qgu, qgj, qgL), qgR = Ln("pad", qgu, qgj, qgL), qgo = Ln("dataFormat", qgu, qgj, qgL)["toUpperCase"](), qgr = Ln("dilation", qgu, qgj, qgL);
      return [qgI["conv1d"](Ln("x", qgu, qgj, qgL), Ln("filter", qgu, qgj, qgL), qgb, qgR, qgo, qgr)];
    }
    case "Conv2D": {
      const qgQ = Ln("strides", qgu, qgj, qgL), qgd = LZ(qgu, qgj, qgL), qgv = Ln("dataFormat", qgu, qgj, qgL)["toUpperCase"](), qgy = Ln("dilations", qgu, qgj, qgL);
      return [qgI["conv2d"](Ln("x", qgu, qgj, qgL), Ln("filter", qgu, qgj, qgL), [qgQ[1], qgQ[2]], qgd, qgv, [qgy[1], qgy[2]])];
    }
    case "_FusedConv2D": {
      const { stride: qgl, pad: qgH, dataFormat: qgA, dilations: qgh, biasArg: qgT, preluArg: qgK, activationFunc: qgB, leakyreluAlpha: qgV } = Ru(qgu, qgj, qgL), qgJ = qgu["name"]["endsWith"]("batch_normalization_88/FusedBatchNormV3") || qgu["name"]["endsWith"]("batch_normalization_90/FusedBatchNormV3") ? qM()["get"]("WEBGL_USE_SHAPES_UNIFORMS") : void 0;
      qgJ && qM()["set"]("WEBGL_USE_SHAPES_UNIFORMS", false);
      const qgY = [qgI["fused"]["conv2d"]({ "x": Ln("x", qgu, qgj, qgL), "filter": Ln("filter", qgu, qgj, qgL), "strides": [qgl[1], qgl[2]], "pad": qgH, "dataFormat": qgA, "dilations": [qgh[1], qgh[2]], "bias": qgT, "activation": qgB, "preluActivationWeights": qgK, "leakyreluAlpha": qgV })];
      return qgJ && qM()["set"]("WEBGL_USE_SHAPES_UNIFORMS", true), qgY;
    }
    case "FusedDepthwiseConv2dNative": {
      const { stride: qgP, pad: qgU, dataFormat: qx0, dilations: qx1, biasArg: qx2, preluArg: qx3, activationFunc: qx4, leakyreluAlpha: qx5 } = Ru(qgu, qgj, qgL);
      return [qgI["fused"]["depthwiseConv2d"]({ "x": Ln("x", qgu, qgj, qgL), "filter": Ln("filter", qgu, qgj, qgL), "strides": [qgP[1], qgP[2]], "pad": qgU, "dataFormat": qx0, "dilations": [qx1[1], qx1[2]], "bias": qx2, "activation": qx4, "preluActivationWeights": qx3, "leakyreluAlpha": qx5 })];
    }
    case "Conv2DBackpropInput":
    case "Conv2dTranspose": {
      const qx6 = Ln("outputShape", qgu, qgj, qgL), qx7 = Ln("strides", qgu, qgj, qgL), qx8 = LZ(qgu, qgj, qgL);
      return [qgI["conv2dTranspose"](Ln("x", qgu, qgj, qgL), Ln("filter", qgu, qgj, qgL), qx6, [qx7[1], qx7[2]], qx8)];
    }
    case "DepthwiseConv2dNative":
    case "DepthwiseConv2d": {
      const qx9 = Ln("strides", qgu, qgj, qgL), qxq = LZ(qgu, qgj, qgL), qxn = Ln("dilations", qgu, qgj, qgL), qxp = Ln("dataFormat", qgu, qgj, qgL)["toUpperCase"]();
      return [qgI["depthwiseConv2d"](Ln("input", qgu, qgj, qgL), Ln("filter", qgu, qgj, qgL), [qx9[1], qx9[2]], qxq, qxp, [qxn[1], qxn[2]])];
    }
    case "Conv3D": {
      const qxs = Ln("strides", qgu, qgj, qgL), qxE = Ln("pad", qgu, qgj, qgL), qxM = Ln("dataFormat", qgu, qgj, qgL)["toUpperCase"](), qxf = Ln("dilations", qgu, qgj, qgL);
      return [qgI["conv3d"](Ln("x", qgu, qgj, qgL), Ln("filter", qgu, qgj, qgL), [qxs[1], qxs[2], qxs[3]], qxE, qxM, [qxf[1], qxf[2], qxf[3]])];
    }
    case "AvgPool": {
      const qxS = Ln("strides", qgu, qgj, qgL), qxF = Ln("pad", qgu, qgj, qgL), qxt = Ln("kernelSize", qgu, qgj, qgL);
      return [qgI["avgPool"](Ln("x", qgu, qgj, qgL), [qxt[1], qxt[2]], [qxS[1], qxS[2]], qxF)];
    }
    case "MaxPool": {
      const qxk = Ln("strides", qgu, qgj, qgL), qxO = Ln("pad", qgu, qgj, qgL), qxW = Ln("kernelSize", qgu, qgj, qgL);
      return [qgI["maxPool"](Ln("x", qgu, qgj, qgL), [qxW[1], qxW[2]], [qxk[1], qxk[2]], qxO)];
    }
    case "MaxPoolWithArgmax": {
      const qxi = Ln("strides", qgu, qgj, qgL), qxD = Ln("pad", qgu, qgj, qgL), qxm = Ln("kernelSize", qgu, qgj, qgL), qxa = Ln("includeBatchInIndex", qgu, qgj, qgL), { result: qxZ, indexes: qxw } = qgI["maxPoolWithArgmax"](Ln("x", qgu, qgj, qgL), [qxm[1], qxm[2]], [qxi[1], qxi[2]], qxD, qxa);
      return [qxZ, qxw];
    }
    case "AvgPool3D": {
      const qxe = Ln("strides", qgu, qgj, qgL), qxz = Ln("pad", qgu, qgj, qgL), qxc = Ln("kernelSize", qgu, qgj, qgL);
      return [qgI["avgPool3d"](Ln("x", qgu, qgj, qgL), [qxc[1], qxc[2], qxc[3]], [qxe[1], qxe[2], qxe[3]], qxz)];
    }
    case "MaxPool3D": {
      const qxX = Ln("strides", qgu, qgj, qgL), qxG = Ln("pad", qgu, qgj, qgL), qxN = Ln("kernelSize", qgu, qgj, qgL);
      return [qgI["maxPool3d"](Ln("x", qgu, qgj, qgL), [qxN[1], qxN[2], qxN[3]], [qxX[1], qxX[2], qxX[3]], qxG)];
    }
    case "Dilation2D": {
      const qxu = Ln("strides", qgu, qgj, qgL), qxj = Ln("pad", qgu, qgj, qgL), qxL = Ln("dilations", qgu, qgj, qgL), qxI = qxu[1], qxb = qxu[2], qxR = qxL[1], qxo = qxL[2];
      return [qgI["dilation2d"](Ln("x", qgu, qgj, qgL), Ln("filter", qgu, qgj, qgL), [qxI, qxb], qxj, [qxR, qxo], "NHWC")];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RL = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Fill": {
      const qgb = Ln("shape", qgu, qgj, qgL), qgR = Ln("dtype", qgu, qgj, qgL), qgo = Ln("value", qgu, qgj, qgL);
      return [qgI["fill"](qgb, qgo, qgR)];
    }
    case "LinSpace": {
      const qgr = Ln("start", qgu, qgj, qgL), qgQ = Ln("stop", qgu, qgj, qgL), qgd = Ln("num", qgu, qgj, qgL);
      return [qgI["linspace"](qgr, qgQ, qgd)];
    }
    case "Multinomial": {
      const qgv = Ln("logits", qgu, qgj, qgL), qgy = Ln("numSamples", qgu, qgj, qgL), qgl = Ln("seed", qgu, qgj, qgL);
      return [qgI["multinomial"](qgv, qgy, qgl)];
    }
    case "OneHot": {
      const qgH = Ln("indices", qgu, qgj, qgL), qgA = Ln("depth", qgu, qgj, qgL), qgh = Ln("onValue", qgu, qgj, qgL), qgT = Ln("offValue", qgu, qgj, qgL), qgK = Ln("dtype", qgu, qgj, qgL);
      return [qgI["oneHot"](qgH, qgA, qgh, qgT, qgK)];
    }
    case "Ones":
      return [qgI["ones"](Ln("shape", qgu, qgj, qgL), Ln("dtype", qgu, qgj, qgL))];
    case "OnesLike":
      return [qgI["onesLike"](Ln("x", qgu, qgj, qgL))];
    case "RandomStandardNormal":
      return [qgI["randomStandardNormal"](Ln("shape", qgu, qgj, qgL), Ln("dtype", qgu, qgj, qgL), Ln("seed", qgu, qgj, qgL))];
    case "RandomUniform":
      return [qgI["randomUniform"](Ln("shape", qgu, qgj, qgL), Ln("minval", qgu, qgj, qgL), Ln("maxval", qgu, qgj, qgL), Ln("dtype", qgu, qgj, qgL))];
    case "RandomUniformInt":
      return [qgI["randomUniformInt"](Ln("shape", qgu, qgj, qgL), Ln("minval", qgu, qgj, qgL), Ln("maxval", qgu, qgj, qgL), Ln("seed", qgu, qgj, qgL))];
    case "Range": {
      const qgB = Ln("start", qgu, qgj, qgL), qgV = Ln("stop", qgu, qgj, qgL), qgJ = Ln("step", qgu, qgj, qgL);
      return [qgI["range"](qgB, qgV, qgJ, Ln("dtype", qgu, qgj, qgL))];
    }
    case "TruncatedNormal": {
      const qgY = Ln("shape", qgu, qgj, qgL), qgP = Ln("mean", qgu, qgj, qgL), qgU = Ln("stdDev", qgu, qgj, qgL), qx0 = Ln("seed", qgu, qgj, qgL);
      return [qgI["truncatedNormal"](qgY, qgP, qgU, Ln("dtype", qgu, qgj, qgL), qx0)];
    }
    case "Zeros":
      return [qgI["zeros"](Ln("shape", qgu, qgj, qgL), Ln("dtype", qgu, qgj, qgL))];
    case "ZerosLike":
      return [qgI["zerosLike"](Ln("x", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
function RR(qgu, qgj, qgL) {
  const qgI = Ln("boxes", qgu, qgj, qgL), qgb = Ln("scores", qgu, qgj, qgL), qgR = Ln("maxOutputSize", qgu, qgj, qgL), qgo = Ln("iouThreshold", qgu, qgj, qgL), qgr = Ln("scoreThreshold", qgu, qgj, qgL), qgQ = Ln("softNmsSigma", qgu, qgj, qgL);
  return { "boxes": qgI, "scores": qgb, "maxOutputSize": qgR, "iouThreshold": qgo, "scoreThreshold": qgr, "softNmsSigma": qgQ };
}
var Rr = async (qgu, qgj, qgL, qgI, qgb = bY) => {
  switch (qgu["op"]) {
    case "NonMaxSuppressionV5": {
      const { boxes: qgR, scores: qgo, maxOutputSize: qgr, iouThreshold: qgQ, scoreThreshold: qgd, softNmsSigma: qgv } = RR(qgu, qgj, qgL), qgy = await qgb["image"]["nonMaxSuppressionWithScoreAsync"](qgR, qgo, qgr, qgQ, qgd, qgv);
      return [qgy["selectedIndices"], qgy["selectedScores"]];
    }
    case "NonMaxSuppressionV4": {
      const { boxes: qgl, scores: qgH, maxOutputSize: qgA, iouThreshold: qgh, scoreThreshold: qgT } = RR(qgu, qgj, qgL), qgK = Ln("padToMaxOutputSize", qgu, qgj, qgL), qgB = await qgb["image"]["nonMaxSuppressionPaddedAsync"](qgl, qgH, qgA, qgh, qgT, qgK);
      return [qgB["selectedIndices"], qgB["validOutputs"]];
    }
    case "NonMaxSuppressionV3":
    case "NonMaxSuppressionV2": {
      const { boxes: qgV, scores: qgJ, maxOutputSize: qgY, iouThreshold: qgP, scoreThreshold: qgU } = RR(qgu, qgj, qgL);
      return [await qgb["image"]["nonMaxSuppressionAsync"](qgV, qgJ, qgY, qgP, qgU)];
    }
    case "Where": {
      const qx0 = qgb["cast"](Ln("condition", qgu, qgj, qgL), "bool"), qx1 = [await qgb["whereAsync"](qx0)];
      return qx0["dispose"](), qx1;
    }
    case "ListDiff":
      return qgb["setdiff1dAsync"](Ln("x", qgu, qgj, qgL), Ln("y", qgu, qgj, qgL));
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RQ = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "LowerBound": {
      const qgb = Ln("sortedSequence", qgu, qgj, qgL), qgR = Ln("values", qgu, qgj, qgL);
      return [qgI["lowerBound"](qgb, qgR)];
    }
    case "TopKV2": {
      const qgo = Ln("x", qgu, qgj, qgL), qgr = Ln("k", qgu, qgj, qgL), qgQ = Ln("sorted", qgu, qgj, qgL), qgd = qgI["topk"](qgo, qgr, qgQ);
      return [qgd["values"], qgd["indices"]];
    }
    case "UpperBound": {
      const qgv = Ln("sortedSequence", qgu, qgj, qgL), qgy = Ln("values", qgu, qgj, qgL);
      return [qgI["upperBound"](qgv, qgy)];
    }
    case "Unique": {
      const qgl = Ln("x", qgu, qgj, qgL), qgH = qgI["unique"](qgl);
      return [qgH["values"], qgH["indices"]];
    }
    case "UniqueV2": {
      const qgA = Ln("x", qgu, qgj, qgL), qgh = Ln("axis", qgu, qgj, qgL), qgT = qgI["unique"](qgA, qgh);
      return [qgT["values"], qgT["indices"]];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RH = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Const":
      return qgj[qgu["name"]];
    case "PlaceholderWithDefault":
      const qgb = Ln("default", qgu, qgj, qgL);
      return [Ls(qgu["name"], qgj, qgL) || qgb];
    case "Placeholder":
      return [Ls(qgu["name"], qgj, qgL)];
    case "Identity":
    case "StopGradient":
    case "FakeQuantWithMinMaxVars": {
      const qgv = Ln("x", qgu, qgj, qgL);
      return [Le(qgv)];
    }
    case "IdentityN":
      return Ln("x", qgu, qgj, qgL)["map"]((qgy) => Le(qgy));
    case "Snapshot":
      const qgR = Ln("x", qgu, qgj, qgL);
      return [Le(qgR)];
    case "Shape":
      return [qgI["tensor1d"](Ln("x", qgu, qgj, qgL)["shape"], "int32")];
    case "ShapeN":
      return Ln("x", qgu, qgj, qgL)["map"]((qgy) => qgI["tensor1d"](qgy["shape"]));
    case "Size":
      return [qgI["scalar"](Ln("x", qgu, qgj, qgL)["size"], "int32")];
    case "Rank":
      return [qgI["scalar"](Ln("x", qgu, qgj, qgL)["rank"], "int32")];
    case "NoOp":
      return [qgI["scalar"](1)];
    case "Print":
      const qgo = Ln("x", qgu, qgj, qgL), qgr = Ln("data", qgu, qgj, qgL), qgQ = Ln("message", qgu, qgj, qgL), qgd = Ln("summarize", qgu, qgj, qgL);
      console["warn"]("The graph has a tf.print() operation,usually used for debugging, which slows down performance."), console["log"](qgQ);
      for (let qgy = 0; qgy < qgr["length"]; qgy++) console["log"](Array["prototype"]["slice"]["call"](qgr[qgy]["dataSync"]())["slice"](0, qgd));
      return [qgo];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RK = class {
  get ["id"]() {
    return this["handle"]["id"];
  }
  constructor(qgu, qgj) {
    this["keyDType"] = qgu, this["valueDType"] = qgj, this["handle"] = aL(0), this["tensorMap"] = /* @__PURE__ */ new Map(), SM(this["handle"]);
  }
  ["clearAndClose"]() {
    this["tensorMap"]["forEach"]((qgu) => qgu["dispose"]()), this["tensorMap"]["clear"](), this["handle"]["dispose"]();
  }
  ["size"]() {
    return this["tensorMap"]["size"];
  }
  ["tensorSize"]() {
    return aL(this["size"](), "int32");
  }
  async ["import"](qgu, qgj) {
    this["checkKeyAndValueTensor"](qgu, qgj);
    const qgL = await qgu["data"]();
    return this["tensorMap"]["forEach"]((qgI) => qgI["dispose"]()), this["tensorMap"]["clear"](), Sq(() => {
      const qgI = zL(qgj), qgb = qgL["length"], qgR = qgI["length"];
      k(qgb === qgR, () => "The number of elements doesn't match, keys has " + qgb + " elements, the values has " + qgR + " elements.");
      for (let qgo = 0; qgo < qgb; qgo++) {
        const qgr = qgL[qgo], qgQ = qgI[qgo];
        SM(qgQ), this["tensorMap"]["set"](qgr, qgQ);
      }
      return this["handle"];
    });
  }
  async ["find"](qgu, qgj) {
    this["checkKeyAndValueTensor"](qgu, qgj);
    const qgL = await qgu["data"]();
    return Sq(() => {
      const qgI = [];
      for (let qgb = 0; qgb < qgL["length"]; qgb++) {
        const qgR = qgL[qgb], qgo = this["findWithDefault"](qgR, qgj);
        qgI["push"](qgo);
      }
      return zF(qgI);
    });
  }
  ["findWithDefault"](qgu, qgj) {
    const qgL = this["tensorMap"]["get"](qgu);
    return qgL != null ? qgL : qgj;
  }
  ["checkKeyAndValueTensor"](qgu, qgj) {
    if (qgu["dtype"] !== this["keyDType"]) throw new Error("Expect key dtype " + this["keyDType"] + ", but got " + qgu["dtype"]);
    if (qgj["dtype"] !== this["valueDType"]) throw new Error("Expect value dtype " + this["valueDType"] + ", but got " + qgj["dtype"]);
  }
};
var RB = async (qgu, qgj, qgL, qgI) => {
  switch (qgu["op"]) {
    case "HashTable":
    case "HashTableV2": {
      const qgb = qgI["getHashTableHandleByName"](qgu["name"]);
      if (qgb != null) return [qgb];
      {
        const qgR = Ln("keyDType", qgu, qgj, qgL), qgo = Ln("valueDType", qgu, qgj, qgL), qgr = new RK(qgR, qgo);
        return qgI["addHashTable"](qgu["name"], qgr), [qgr["handle"]];
      }
    }
    case "InitializeTable":
    case "InitializeTableV2":
    case "LookupTableImport":
    case "LookupTableImportV2": {
      const qgQ = Ln("tableHandle", qgu, qgj, qgL, qgI), qgd = Ln("keys", qgu, qgj, qgL), qgv = Ln("values", qgu, qgj, qgL);
      return [await qgI["getHashTableById"](qgQ["id"])["import"](qgd, qgv)];
    }
    case "LookupTableFind":
    case "LookupTableFindV2": {
      const qgy = Ln("tableHandle", qgu, qgj, qgL, qgI), qgl = Ln("keys", qgu, qgj, qgL), qgH = Ln("defaultValue", qgu, qgj, qgL);
      return [await qgI["getHashTableById"](qgy["id"])["find"](qgl, qgH)];
    }
    case "LookupTableSize":
    case "LookupTableSizeV2": {
      const qgA = Ln("tableHandle", qgu, qgj, qgL, qgI);
      return [qgI["getHashTableById"](qgA["id"])["tensorSize"]()];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RV = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "ResizeBilinear": {
      const qgb = Ln("images", qgu, qgj, qgL), qgR = Ln("size", qgu, qgj, qgL), qgo = Ln("alignCorners", qgu, qgj, qgL), qgr = Ln("halfPixelCenters", qgu, qgj, qgL);
      return [qgI["image"]["resizeBilinear"](qgb, [qgR[0], qgR[1]], qgo, qgr)];
    }
    case "ResizeNearestNeighbor": {
      const qgQ = Ln("images", qgu, qgj, qgL), qgd = Ln("size", qgu, qgj, qgL), qgv = Ln("alignCorners", qgu, qgj, qgL), qgy = Ln("halfPixelCenters", qgu, qgj, qgL);
      return [qgI["image"]["resizeNearestNeighbor"](qgQ, [qgd[0], qgd[1]], qgv, qgy)];
    }
    case "CropAndResize": {
      const qgl = Ln("image", qgu, qgj, qgL), qgH = Ln("boxes", qgu, qgj, qgL), qgA = Ln("boxInd", qgu, qgj, qgL), qgh = Ln("cropSize", qgu, qgj, qgL), qgT = Ln("method", qgu, qgj, qgL), qgK = Ln("extrapolationValue", qgu, qgj, qgL);
      return [qgI["image"]["cropAndResize"](qgl, qgH, qgA, qgh, qgT, qgK)];
    }
    case "ImageProjectiveTransformV3": {
      const qgB = Ln("images", qgu, qgj, qgL), qgV = Ln("transforms", qgu, qgj, qgL), qgJ = Ln("outputShape", qgu, qgj, qgL), qgY = Ln("fillValue", qgu, qgj, qgL), qgP = Ln("interpolation", qgu, qgj, qgL), qgU = Ln("fillMode", qgu, qgj, qgL);
      return [qgI["image"]["transform"](qgB, qgV, qgP["toLowerCase"](), qgU["toLowerCase"](), qgY, qgJ)];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RJ = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Equal":
      return [qgI["equal"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "NotEqual":
      return [qgI["notEqual"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Greater":
      return [qgI["greater"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "GreaterEqual":
      return [qgI["greaterEqual"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Less":
      return [qgI["less"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "LessEqual":
      return [qgI["lessEqual"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "LogicalAnd":
      return [qgI["logicalAnd"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "LogicalNot":
      return [qgI["logicalNot"](Ln("a", qgu, qgj, qgL))];
    case "LogicalOr":
      return [qgI["logicalOr"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "Select":
    case "SelectV2":
      return [qgI["where"](Ln("condition", qgu, qgj, qgL), Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    case "BitwiseAnd":
      return [qgI["bitwiseAnd"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RY = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "BatchMatMul":
    case "BatchMatMulV2":
    case "MatMul":
      return [qgI["matMul"](Ln("a", qgu, qgj, qgL), Ln("b", qgu, qgj, qgL), Ln("transposeA", qgu, qgj, qgL), Ln("transposeB", qgu, qgj, qgL))];
    case "Einsum":
      return [qgI["einsum"](Ln("equation", qgu, qgj, qgL), ...Ln("tensors", qgu, qgj, qgL))];
    case "Transpose":
      return [qgI["transpose"](Ln("x", qgu, qgj, qgL), Ln("perm", qgu, qgj, qgL))];
    case "_FusedMatMul":
      const [qgb, qgR] = Ln("fusedOps", qgu, qgj, qgL), qgo = qgb === "biasadd", qgr = qgR === "prelu", qgQ = Ln("numArgs", qgu, qgj, qgL), qgd = Ln("leakyreluAlpha", qgu, qgj, qgL);
      if (qgo) {
        if (qgr && qgQ !== 2) throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");
        if (!qgr && qgQ !== 1) throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.");
      }
      const [qgv, qgy] = Ln("args", qgu, qgj, qgL);
      return [qgI["fused"]["matMul"]({ "a": Ln("a", qgu, qgj, qgL), "b": Ln("b", qgu, qgj, qgL), "transposeA": Ln("transposeA", qgu, qgj, qgL), "transposeB": Ln("transposeB", qgu, qgj, qgL), "bias": qgv, "activation": qgR, "preluActivationWeights": qgy, "leakyreluAlpha": qgd })];
    case "MatrixBandPart":
      return [qgI["linalg"]["bandPart"](Ln("a", qgu, qgj, qgL), Ln("numLower", qgu, qgj, qgL), Ln("numUpper", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RP = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "EuclideanNorm":
      return [qgI["euclideanNorm"](Ln("x", qgu, qgj, qgL), Ln("axis", qgu, qgj, qgL), Ln("keepDims", qgu, qgj, qgL))];
    case "FusedBatchNorm":
    case "FusedBatchNormV2":
      return [qgI["batchNorm"](Ln("x", qgu, qgj, qgL), Ln("mean", qgu, qgj, qgL), Ln("variance", qgu, qgj, qgL), Ln("offset", qgu, qgj, qgL), Ln("scale", qgu, qgj, qgL), Ln("epsilon", qgu, qgj, qgL))];
    case "FusedBatchNormV3":
      return [qgI["batchNorm"](Ln("x", qgu, qgj, qgL), Ln("mean", qgu, qgj, qgL), Ln("variance", qgu, qgj, qgL), Ln("offset", qgu, qgj, qgL), Ln("scale", qgu, qgj, qgL), Ln("epsilon", qgu, qgj, qgL))];
    case "LRN":
      return [qgI["localResponseNormalization"](Ln("x", qgu, qgj, qgL), Ln("radius", qgu, qgj, qgL), Ln("bias", qgu, qgj, qgL), Ln("alpha", qgu, qgj, qgL), Ln("beta", qgu, qgj, qgL))];
    case "Softmax":
      return [qgI["softmax"](Ln("x", qgu, qgj, qgL))];
    case "LogSoftmax":
      return [qgI["logSoftmax"](Ln("x", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var RU = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "RaggedGather": {
      const { outputNestedSplits: qgb, outputDenseValues: qgR } = qgI["raggedGather"](Ln("paramsNestedSplits", qgu, qgj, qgL), Ln("paramsDenseValues", qgu, qgj, qgL), Ln("indices", qgu, qgj, qgL), Ln("outputRaggedRank", qgu, qgj, qgL));
      return qgb["concat"](qgR);
    }
    case "RaggedRange": {
      const { rtNestedSplits: qgo, rtDenseValues: qgr } = qgI["raggedRange"](Ln("starts", qgu, qgj, qgL), Ln("limits", qgu, qgj, qgL), Ln("splits", qgu, qgj, qgL));
      return [qgo, qgr];
    }
    case "RaggedTensorToTensor":
      return [qgI["raggedTensorToTensor"](Ln("shape", qgu, qgj, qgL), Ln("values", qgu, qgj, qgL), Ln("defaultValue", qgu, qgj, qgL), Ln("rowPartitionTensors", qgu, qgj, qgL), Ln("rowPartitionTypes", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var oq = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Max": {
      const qgr = Ln("axis", qgu, qgj, qgL), qgQ = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["max"](Ln("x", qgu, qgj, qgL), qgr, qgQ)];
    }
    case "Mean": {
      const qgd = Ln("axis", qgu, qgj, qgL), qgv = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["mean"](Ln("x", qgu, qgj, qgL), qgd, qgv)];
    }
    case "Min": {
      const qgy = Ln("axis", qgu, qgj, qgL), qgl = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["min"](Ln("x", qgu, qgj, qgL), qgy, qgl)];
    }
    case "Sum": {
      const qgH = Ln("axis", qgu, qgj, qgL), qgA = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["sum"](Ln("x", qgu, qgj, qgL), qgH, qgA)];
    }
    case "All": {
      const qgh = Ln("axis", qgu, qgj, qgL), qgT = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["all"](Ln("x", qgu, qgj, qgL), qgh, qgT)];
    }
    case "Any": {
      const qgK = Ln("axis", qgu, qgj, qgL), qgB = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["any"](Ln("x", qgu, qgj, qgL), qgK, qgB)];
    }
    case "ArgMax": {
      const qgV = Ln("axis", qgu, qgj, qgL);
      return [qgI["argMax"](Ln("x", qgu, qgj, qgL), qgV)];
    }
    case "ArgMin": {
      const qgJ = Ln("axis", qgu, qgj, qgL);
      return [qgI["argMin"](Ln("x", qgu, qgj, qgL), qgJ)];
    }
    case "Prod": {
      const qgY = Ln("axis", qgu, qgj, qgL), qgP = Ln("keepDims", qgu, qgj, qgL);
      return [qgI["prod"](Ln("x", qgu, qgj, qgL), qgY, qgP)];
    }
    case "Cumprod": {
      const qgU = Ln("axis", qgu, qgj, qgL), qx0 = Ln("exclusive", qgu, qgj, qgL), qx1 = Ln("reverse", qgu, qgj, qgL);
      return [qgI["cumprod"](Ln("x", qgu, qgj, qgL), qgU, qx0, qx1)];
    }
    case "Cumsum": {
      const qx2 = Ln("axis", qgu, qgj, qgL), qx3 = Ln("exclusive", qgu, qgj, qgL), qx4 = Ln("reverse", qgu, qgj, qgL);
      return [qgI["cumsum"](Ln("x", qgu, qgj, qgL), qx2, qx3, qx4)];
    }
    case "Bincount":
      const qgb = Ln("x", qgu, qgj, qgL), qgR = Ln("weights", qgu, qgj, qgL), qgo = Ln("size", qgu, qgj, qgL);
      return [qgI["bincount"](qgb, qgR, qgo)];
    case "DenseBincount": {
      const qx5 = Ln("x", qgu, qgj, qgL), qx6 = Ln("weights", qgu, qgj, qgL), qx7 = Ln("size", qgu, qgj, qgL), qx8 = Ln("binaryOutput", qgu, qgj, qgL);
      return [qgI["denseBincount"](qx5, qx6, qx7, qx8)];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var oM = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "ConcatV2":
    case "Concat": {
      const qgb = Ln("n", qgu, qgj, qgL), qgR = Ln("axis", qgu, qgj, qgL);
      let qgo = Ln("tensors", qgu, qgj, qgL);
      return qgo = qgo["slice"](0, qgb), [qgI["concat"](qgo, qgR)];
    }
    case "Gather": {
      const qgr = Ln("x", qgu, qgj, qgL), qgQ = Ln("indices", qgu, qgj, qgL);
      return [qgI["gather"](qgr, qgI["cast"](qgQ, "int32"), 0)];
    }
    case "GatherV2": {
      const qgd = Ln("axis", qgu, qgj, qgL), qgv = Ln("batchDims", qgu, qgj, qgL), qgy = Ln("x", qgu, qgj, qgL), qgl = Ln("indices", qgu, qgj, qgL);
      return [qgI["gather"](qgy, qgI["cast"](qgl, "int32"), qgd, qgv)];
    }
    case "Reverse": {
      const qgH = Ln("dims", qgu, qgj, qgL), qgA = [];
      for (let qgT = 0; qgT < qgH["length"]; qgT++) qgH[qgT] && qgA["push"](qgT);
      const qgh = Ln("x", qgu, qgj, qgL);
      return [qgI["reverse"](qgh, qgA)];
    }
    case "ReverseV2": {
      const qgK = Ln("axis", qgu, qgj, qgL), qgB = Ln("x", qgu, qgj, qgL);
      return [qgI["reverse"](qgB, qgK)];
    }
    case "Slice": {
      const qgV = Ln("begin", qgu, qgj, qgL), qgJ = Ln("size", qgu, qgj, qgL);
      return [qgI["slice"](Ln("x", qgu, qgj, qgL), qgV, qgJ)];
    }
    case "StridedSlice": {
      const qgY = Ln("begin", qgu, qgj, qgL), qgP = Ln("end", qgu, qgj, qgL), qgU = Ln("strides", qgu, qgj, qgL), qx0 = Ln("beginMask", qgu, qgj, qgL), qx1 = Ln("endMask", qgu, qgj, qgL), qx2 = Ln("ellipsisMask", qgu, qgj, qgL), qx3 = Ln("newAxisMask", qgu, qgj, qgL), qx4 = Ln("shrinkAxisMask", qgu, qgj, qgL), qx5 = Ln("x", qgu, qgj, qgL);
      return [qgI["stridedSlice"](qx5, qgY, qgP, qgU, qx0, qx1, qx2, qx3, qx4)];
    }
    case "Pack":
      return Sq(() => {
        const qx6 = Ln("axis", qgu, qgj, qgL), qx7 = Ln("tensors", qgu, qgj, qgL), qx8 = qx7[0]["shape"], qx9 = qgI["squeeze"](qx7[0])["shape"], qxq = qx7["map"]((qxn) => {
          const qxp = D(qxn["shape"], qx8);
          if (!qxp && !D(qgI["squeeze"](qxn)["shape"], qx9)) throw new Error("the input tensors shape does not match");
          return qxp ? qxn : qgI["reshape"](qxn, qx8);
        });
        return [qgI["stack"](qxq, qx6)];
      });
    case "Unpack": {
      const qx6 = Ln("axis", qgu, qgj, qgL), qx7 = Ln("tensor", qgu, qgj, qgL);
      return qgI["unstack"](qx7, qx6);
    }
    case "Tile": {
      const qx8 = Ln("reps", qgu, qgj, qgL);
      return [qgI["tile"](Ln("x", qgu, qgj, qgL), qx8)];
    }
    case "Split":
    case "SplitV": {
      const qx9 = Ln("axis", qgu, qgj, qgL), qxq = Ln("numOrSizeSplits", qgu, qgj, qgL), qxn = Ln("x", qgu, qgj, qgL);
      return qgI["split"](qxn, qxq, qx9);
    }
    case "ScatterNd": {
      const qxp = Ln("indices", qgu, qgj, qgL), qxs = Ln("values", qgu, qgj, qgL), qxE = Ln("shape", qgu, qgj, qgL);
      return [qgI["scatterND"](qxp, qxs, qxE)];
    }
    case "GatherNd": {
      const qxM = Ln("x", qgu, qgj, qgL), qxf = Ln("indices", qgu, qgj, qgL);
      return [qgI["gatherND"](qxM, qxf)];
    }
    case "SparseToDense": {
      const qxS = Ln("sparseIndices", qgu, qgj, qgL), qxF = Ln("outputShape", qgu, qgj, qgL), qxt = Ln("sparseValues", qgu, qgj, qgL), qxk = Ln("defaultValue", qgu, qgj, qgL);
      return [qgI["sparseToDense"](qxS, qxt, qxF, qxt["dtype"] === qxk["dtype"] ? qxk : qgI["cast"](qxk, qxt["dtype"]))];
    }
    case "TensorScatterUpdate": {
      const qxO = Ln("indices", qgu, qgj, qgL), qxW = Ln("values", qgu, qgj, qgL), qxi = Ln("tensor", qgu, qgj, qgL);
      return [qgI["tensorScatterUpdate"](qxi, qxO, qxW)];
    }
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var oF = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "SparseFillEmptyRows": {
      const { outputIndices: qgb, outputValues: qgR, emptyRowIndicator: qgo, reverseIndexMap: qgr } = qgI["sparse"]["sparseFillEmptyRows"](Ln("indices", qgu, qgj, qgL), Ln("values", qgu, qgj, qgL), Ln("denseShape", qgu, qgj, qgL), Ln("defaultValue", qgu, qgj, qgL));
      return [qgb, qgR, qgo, qgr];
    }
    case "SparseReshape": {
      const { outputIndices: qgQ, outputShape: qgd } = qgI["sparse"]["sparseReshape"](Ln("inputIndices", qgu, qgj, qgL), Ln("inputShape", qgu, qgj, qgL), Ln("newShape", qgu, qgj, qgL));
      return [qgQ, qgd];
    }
    case "SparseSegmentMean":
      return [qgI["sparse"]["sparseSegmentMean"](Ln("data", qgu, qgj, qgL), Ln("indices", qgu, qgj, qgL), Ln("segmentIds", qgu, qgj, qgL))];
    case "SparseSegmentSum":
      return [qgI["sparse"]["sparseSegmentSum"](Ln("data", qgu, qgj, qgL), Ln("indices", qgu, qgj, qgL), Ln("segmentIds", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var oW = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "FFT":
      return [qgI["fft"](Ln("x", qgu, qgj, qgL))];
    case "IFFT":
      return [qgI["ifft"](Ln("x", qgu, qgj, qgL))];
    case "RFFT":
      return [qgI["rfft"](Ln("x", qgu, qgj, qgL))];
    case "IRFFT":
      return [qgI["irfft"](Ln("x", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var oD = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "StaticRegexReplace":
      return [qgI["string"]["staticRegexReplace"](Ln("input", qgu, qgj, qgL), Ln("pattern", qgu, qgj, qgL), Ln("rewrite", qgu, qgj, qgL), Ln("replaceGlobal", qgu, qgj, qgL))];
    case "StringNGrams": {
      const { nGrams: qgb, nGramsSplits: qgR } = qgI["string"]["stringNGrams"](Ln("data", qgu, qgj, qgL), Ln("dataSplits", qgu, qgj, qgL), Ln("separator", qgu, qgj, qgL), Ln("nGramWidths", qgu, qgj, qgL), Ln("leftPad", qgu, qgj, qgL), Ln("rightPad", qgu, qgj, qgL), Ln("padWidth", qgu, qgj, qgL), Ln("preserveShortSequences", qgu, qgj, qgL));
      return [qgb, qgR];
    }
    case "StringSplit": {
      const { indices: qgo, values: qgr, shape: qgQ } = qgI["string"]["stringSplit"](Ln("input", qgu, qgj, qgL), Ln("delimiter", qgu, qgj, qgL), Ln("skipEmpty", qgu, qgj, qgL));
      return [qgo, qgr, qgQ];
    }
    case "StringToHashBucketFast":
      return [qgI["string"]["stringToHashBucketFast"](Ln("input", qgu, qgj, qgL), Ln("numBuckets", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
var oa = (qgu, qgj, qgL, qgI = bY) => {
  switch (qgu["op"]) {
    case "Cast":
      return [qgI["cast"](Ln("x", qgu, qgj, qgL), Ln("dtype", qgu, qgj, qgL))];
    case "ExpandDims": {
      const qgb = Ln("axis", qgu, qgj, qgL);
      return [qgI["expandDims"](Ln("x", qgu, qgj, qgL), qgb)];
    }
    case "Squeeze": {
      const qgR = Ln("axis", qgu, qgj, qgL);
      return [qgI["squeeze"](Ln("x", qgu, qgj, qgL), qgR)];
    }
    case "Reshape":
      return [qgI["reshape"](Ln("x", qgu, qgj, qgL), Ln("shape", qgu, qgj, qgL))];
    case "EnsureShape":
      return [qgI["ensureShape"](Ln("x", qgu, qgj, qgL), Ln("shape", qgu, qgj, qgL))];
    case "MirrorPad":
      return [qgI["mirrorPad"](Ln("x", qgu, qgj, qgL), Ln("padding", qgu, qgj, qgL), Ln("mode", qgu, qgj, qgL))];
    case "PadV2":
    case "Pad":
      return [qgI["pad"](Ln("x", qgu, qgj, qgL), Ln("padding", qgu, qgj, qgL), Ln("constantValue", qgu, qgj, qgL))];
    case "SpaceToBatchND": {
      const qgo = Ln("blockShape", qgu, qgj, qgL), qgr = Ln("paddings", qgu, qgj, qgL);
      return [qgI["spaceToBatchND"](Ln("x", qgu, qgj, qgL), qgo, qgr)];
    }
    case "BatchToSpaceND": {
      const qgQ = Ln("blockShape", qgu, qgj, qgL), qgd = Ln("crops", qgu, qgj, qgL);
      return [qgI["batchToSpaceND"](Ln("x", qgu, qgj, qgL), qgQ, qgd)];
    }
    case "DepthToSpace": {
      const qgv = Ln("blockSize", qgu, qgj, qgL), qgy = Ln("dataFormat", qgu, qgj, qgL)["toUpperCase"]();
      return [qgI["depthToSpace"](Ln("x", qgu, qgj, qgL), qgv, qgy)];
    }
    case "BroadcastTo":
      return [qgI["broadcastTo"](Ln("x", qgu, qgj, qgL), Ln("shape", qgu, qgj, qgL))];
    case "BroadcastArgs":
      return [qgI["broadcastArgs"](Ln("s0", qgu, qgj, qgL), Ln("s1", qgu, qgj, qgL))];
    default:
      throw TypeError("Node type " + qgu["op"] + " is not implemented");
  }
};
function oZ(qgu, qgj, qgL, qgI, qgb = Sq) {
  const qgR = ((qgo, qgr, qgQ) => {
    switch (qgo["category"]) {
      case "arithmetic":
        return qgb(() => bP(qgo, qgr, qgQ));
      case "basic_math":
        return qgb(() => bU(qgo, qgr, qgQ));
      case "control":
        return RG(qgo, qgr, qgQ);
      case "convolution":
        return qgb(() => Rj(qgo, qgr, qgQ));
      case "creation":
        return qgb(() => RL(qgo, qgr, qgQ));
      case "dynamic":
        return Rr(qgo, qgr, qgQ);
      case "evaluation":
        return qgb(() => RQ(qgo, qgr, qgQ));
      case "image":
        return qgb(() => RV(qgo, qgr, qgQ));
      case "graph":
        return qgb(() => RH(qgo, qgr, qgQ));
      case "logical":
        return qgb(() => RJ(qgo, qgr, qgQ));
      case "matrices":
        return qgb(() => RY(qgo, qgr, qgQ));
      case "normalization":
        return qgb(() => RP(qgo, qgr, qgQ));
      case "ragged":
        return qgb(() => RU(qgo, qgr, qgQ));
      case "reduction":
        return qgb(() => oq(qgo, qgr, qgQ));
      case "slice_join":
        return qgb(() => oM(qgo, qgr, qgQ));
      case "sparse":
        return qgb(() => oF(qgo, qgr, qgQ));
      case "spectral":
        return qgb(() => oW(qgo, qgr, qgQ));
      case "string":
        return qgb(() => oD(qgo, qgr, qgQ));
      case "transformation":
        return qgb(() => oa(qgo, qgr, qgQ));
      case "hash_table":
        return RB(qgo, qgr, qgQ, qgI);
      case "custom":
        const qgd = Lq(qgo["op"]);
        if (qgd && qgd["customExecutor"]) return qgd["customExecutor"](new bB(qgo, qgr, qgQ));
        throw TypeError("Custom op " + qgo["op"] + " is not registered.");
      default:
        throw TypeError("Unknown op '" + qgo["op"] + "'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()");
    }
  })(qgu, qgj, qgL);
  return J(qgR) ? qgR["then"]((qgo) => []["concat"](qgo)) : []["concat"](qgR);
}
var oe = class {
  constructor(qgu = {}, qgj = {}, qgL = {}, qgI = {}, qgb) {
    this["weightMap"] = qgu, this["tensorArrayMap"] = qgj, this["tensorListMap"] = qgL, this["functionMap"] = qgI, this["parseNodeNameCache"] = qgb, this["rootContext"] = { "id": 0, "frameName": "", "iterationId": 0 }, this["contexts"] = [this["rootContext"]], this["lastId"] = 0, this["generateCurrentContextIds"]();
  }
  ["newFrame"](qgu, qgj) {
    return { "id": qgu, "frameName": qgj, "iterationId": 0 };
  }
  set ["currentContext"](qgu) {
    this["contexts"] !== qgu && (this["contexts"] = qgu, this["generateCurrentContextIds"]());
  }
  get ["currentContext"]() {
    return this["contexts"];
  }
  get ["currentContextId"]() {
    return this["_currentContextIds"][0];
  }
  get ["currentContextIds"]() {
    return this["_currentContextIds"];
  }
  ["generateCurrentContextIds"]() {
    const qgu = [];
    for (let qgj = 0; qgj < this["contexts"]["length"] - 1; qgj++) {
      const qgL = this["contexts"]["slice"](0, this["contexts"]["length"] - qgj);
      qgu["push"](this["contextIdforContexts"](qgL));
    }
    qgu["push"](""), this["_currentContextIds"] = qgu;
  }
  ["contextIdforContexts"](qgu) {
    return qgu ? qgu["map"]((qgj) => qgj["id"] === 0 && qgj["iterationId"] === 0 ? "" : qgj["frameName"] + "-" + qgj["iterationId"])["join"]("/") : "";
  }
  ["enterFrame"](qgu) {
    this["contexts"] && (this["lastId"]++, this["contexts"] = this["contexts"]["slice"](), this["contexts"]["push"](this["newFrame"](this["lastId"], qgu)), this["_currentContextIds"]["unshift"](this["contextIdforContexts"](this["contexts"])));
  }
  ["exitFrame"]() {
    if (this["contexts"] && this["contexts"]["length"] > 1) this["contexts"] = this["contexts"]["slice"](), this["contexts"]["splice"](-1), this["currentContextIds"]["shift"]();
    else throw new Error("Cannot exit frame, the context is empty");
  }
  ["nextIteration"]() {
    if (this["contexts"] && this["contexts"]["length"] > 0) {
      this["contexts"] = this["contexts"]["slice"](), this["lastId"]++;
      const qgu = Object["assign"]({}, this["contexts"][this["contexts"]["length"] - 1]);
      qgu["iterationId"] += 1, qgu["id"] = this["lastId"], this["contexts"]["splice"](-1, 1, qgu), this["_currentContextIds"]["splice"](0, 1, this["contextIdforContexts"](this["contexts"]));
    } else throw new Error("Cannot increase frame iteration, the context is empty");
  }
  ["getWeight"](qgu) {
    return this["weightMap"][qgu];
  }
  ["addTensorArray"](qgu) {
    this["tensorArrayMap"][qgu["id"]] = qgu;
  }
  ["getTensorArray"](qgu) {
    return this["tensorArrayMap"][qgu];
  }
  ["addTensorList"](qgu) {
    this["tensorListMap"][qgu["id"]] = qgu;
  }
  ["getTensorList"](qgu) {
    return this["tensorListMap"][qgu];
  }
  ["dispose"](qgu) {
    for (const qgj in this["tensorArrayMap"]) this["tensorArrayMap"][qgj]["clearAndClose"](qgu);
    for (const qgL in this["tensorListMap"]) this["tensorListMap"][qgL]["clearAndClose"](qgu);
  }
};
function oz(qgu, qgj, qgL, qgI) {
  const qgb = /* @__PURE__ */ new Set(), qgR = [];
  let qgo = null, qgr = null;
  const qgQ = /* @__PURE__ */ new Set(), qgd = new Set(Object["keys"](qgu)["map"]((qgl) => LD(qgl)[0]));
  qgI = qgI || [];
  const qgv = new Set(qgI["map"]((qgl) => LD(qgl["name"])[0])), qgy = [...qgj];
  for (; qgy["length"] > 0; ) {
    const qgl = qgy["pop"]();
    if ((oH(qgl) || oK(qgl) || oB(qgl)) && qgo == null && (qgo = qgl, qgr = qgo["children"]["map"]((qgH) => qgH["name"])["filter"]((qgH) => qgb["has"](qgH))), qgb["add"](qgl["name"]), qgL[qgl["name"]] == null && !qgd["has"](qgl["name"]) && !qgv["has"](qgl["name"])) {
      if (qgl["inputs"]["length"] === 0) {
        qgR["push"](qgl["name"]);
        continue;
      }
      qgl["inputs"]["forEach"]((qgH) => {
        qgQ["has"](qgH["name"]) || (qgQ["add"](qgH["name"]), qgy["push"](qgH));
      });
    }
  }
  return { "inputs": qgu, "outputs": qgj, "usedNodes": qgb, "missingInputs": qgR, "dynamicNode": qgo, "syncInputs": qgr };
}
function oX(qgu, qgj) {
  const { usedNodes: qgL, inputs: qgI } = qgj, qgb = Object["keys"](qgI)["map"]((qgT) => LD(qgT)[0])["map"]((qgT) => qgu["nodes"][qgT]), qgR = qgu["initNodes"] || [], qgo = (qgT) => qgL["has"](typeof qgT == "string" ? qgT : qgT["name"]);
  function qgr(qgT) {
    return [...new Map(qgT["map"]((qgK) => [qgK["name"], qgK]))["values"]()];
  }
  const qgQ = qgr([...qgb, ...qgu["weights"], ...qgR])["filter"](qgo), qgd = qgr([...qgQ, ...Object["values"](qgu["nodes"])])["filter"](qgo), qgv = new Map(qgd["map"]((qgT) => [qgT["name"], qgT])), qgy = {};
  for (const qgT of qgd) {
    qgy[qgT["name"]] = qgy[qgT["name"]] || 0;
    for (const qgK of qgT["children"]) qgo(qgK) || (qgy[qgK["name"]] = Number["POSITIVE_INFINITY"]), qgy[qgK["name"]] = (qgy[qgK["name"]] || 0) + 1;
  }
  const qgl = Object["entries"](qgy)["filter"](([, qgB]) => qgB === 0)["map"](([qgB]) => qgB), qgH = [...qgl];
  for (; qgl["length"] > 0; ) {
    const qgB = qgl["pop"](), qgV = qgv["get"](qgB);
    for (const qgJ of qgV["children"]["filter"](qgo)) --qgy[qgJ["name"]] === 0 && (qgH["push"](qgJ["name"]), qgl["push"](qgJ["name"]));
  }
  const qgA = qgH["map"]((qgY) => qgv["get"](qgY)), qgh = oG(qgA, qgQ);
  return oj(qgh, qgQ), qgh;
}
function oG(qgu, qgj) {
  const qgL = new Map(qgu["map"]((qgR) => [qgR["name"], qgR])), qgI = qgj["map"]((qgR) => qgR["name"]), qgb = new Set(qgI);
  for (; qgI["length"] > 0; ) {
    const qgR = qgI["pop"](), qgo = qgL["get"](qgR);
    for (const qgr of qgo["children"]) !qgL["has"](qgr["name"]) || qgb["has"](qgr["name"]) || (qgb["add"](qgr["name"]), qgI["push"](qgr["name"]));
  }
  return qgu["filter"]((qgQ) => qgb["has"](qgQ["name"]));
}
var ou = class extends Error {
  constructor(qgu) {
    super("NodesExecutionOrderError: " + qgu);
  }
};
function oj(qgu, qgj) {
  const qgL = new Map(qgu["map"]((qgr, qgQ) => [qgr["name"], qgQ])), qgI = new Set(qgj["map"]((qgr) => qgr["name"])), qgb = (qgr) => qgI["has"](typeof qgr == "string" ? qgr : qgr["name"]), qgR = new Set(qgu["map"]((qgr) => qgr["name"])), qgo = (qgr) => qgR["has"](typeof qgr == "string" ? qgr : qgr["name"]);
  for (const qgr of qgu) {
    for (const qgQ of qgr["children"]["filter"](qgo)) {
      if (!qgL["has"](qgQ["name"])) throw new ou("Child " + qgQ["name"] + " of node " + qgr["name"] + " is unreachable.");
      if (qgL["get"](qgr["name"]) > qgL["get"](qgQ["name"])) throw new ou("Node " + qgr["name"] + " is scheduled to run after its child " + qgQ["name"] + ".");
    }
    if (!qgb(qgr)) for (const qgd of qgr["inputs"]) {
      if (!qgL["has"](qgd["name"])) throw new ou("Input " + qgd["name"] + " of node " + qgr["name"] + " is unreachable.");
      if (qgL["get"](qgd["name"]) > qgL["get"](qgr["name"])) throw new ou("Node " + qgr["name"] + " is scheduled to run before its input " + qgd["name"] + ".");
    }
  }
}
function oL(qgu) {
  const qgj = new Map(qgu["map"]((qgr, qgQ) => [qgr["name"], qgQ])), qgL = Number["MAX_SAFE_INTEGER"], qgI = qgu["map"]((qgr, qgQ) => oH(qgr) ? qgL : qgQ), qgb = (qgr) => {
    const qgQ = qgI[qgj["get"](qgr["name"])];
    return qgQ == null ? -1 : qgQ;
  }, qgR = qgu["map"]((qgr, qgQ) => qgr["children"]["map"](qgb)["reduce"]((qgd, qgv) => Math["max"](qgd, qgv), qgI[qgQ])), qgo = /* @__PURE__ */ new Map();
  for (let qgr = 0; qgr < qgu["length"]; ++qgr) {
    const qgQ = qgR[qgr];
    if (qgQ === qgL) continue;
    const qgd = qgu[qgr], qgv = qgu[qgQ];
    qgo["has"](qgv["name"]) || qgo["set"](qgv["name"], []), qgo["get"](qgv["name"])["push"](qgd);
  }
  return qgo;
}
var oo = /* @__PURE__ */ new Set(["Switch", "Merge", "Enter", "Exit", "NextIteration", "StatelessIf", "StatelessWhile", "if", "While"]);
var or = /* @__PURE__ */ new Set(["NonMaxSuppressionV2", "NonMaxSuppressionV3", "NonMaxSuppressionV5", "Where"]);
var oQ = /* @__PURE__ */ new Set(["HashTable", "HashTableV2", "LookupTableImport", "LookupTableImportV2", "LookupTableFind", "LookupTableFindV2", "LookupTableSize", "LookupTableSizeV2"]);
function oH(qgu) {
  return oo["has"](qgu["op"]);
}
function oK(qgu) {
  return or["has"](qgu["op"]);
}
function oB(qgu) {
  return oQ["has"](qgu["op"]);
}
var oV = class _oV {
  get ["weightIds"]() {
    return this["parent"] ? this["parent"]["weightIds"] : this["_weightIds"];
  }
  get ["functionExecutorMap"]() {
    return this["parent"] ? this["parent"]["functionExecutorMap"] : this["_functionExecutorMap"];
  }
  get ["weightMap"]() {
    return this["parent"] ? this["parent"]["weightMap"] : this["_weightMap"];
  }
  set ["weightMap"](qgu) {
    const qgj = Object["keys"](qgu)["map"]((qgL) => qgu[qgL]["map"]((qgI) => qgI["id"]));
    this["_weightIds"] = []["concat"](...qgj), this["_weightMap"] = qgu;
  }
  set ["resourceManager"](qgu) {
    this["_resourceManager"] = qgu;
  }
  get ["inputs"]() {
    return this["_inputs"]["map"]((qgu) => ({ "name": qgu["name"], "shape": qgu["attrParams"]["shape"] ? qgu["attrParams"]["shape"]["value"] : void 0, "dtype": qgu["attrParams"]["dtype"] ? qgu["attrParams"]["dtype"]["value"] : void 0 }));
  }
  get ["outputs"]() {
    return this["_outputs"]["map"]((qgu) => ({ "name": qgu["name"], "shape": qgu["attrParams"]["shape"] ? qgu["attrParams"]["shape"]["value"] : void 0, "dtype": qgu["attrParams"]["dtype"] ? qgu["attrParams"]["dtype"]["value"] : void 0 }));
  }
  get ["inputNodes"]() {
    return this["_inputs"]["map"]((qgu) => qgu["signatureKey"] || qgu["name"]);
  }
  get ["outputNodes"]() {
    return this["_outputs"]["map"]((qgu) => {
      const qgj = qgu["signatureKey"] || qgu["name"];
      return qgu["defaultOutput"] ? qgj + ":" + qgu["defaultOutput"] : qgj;
    });
  }
  get ["functions"]() {
    return Object["keys"](this["_functions"])["reduce"]((qgu, qgj) => (qgu[qgj] = this["_functions"][qgj]["signature"], qgu), {});
  }
  constructor(qgu, qgj) {
    this["graph"] = qgu, this["parent"] = qgj, this["compiledMap"] = /* @__PURE__ */ new Map(), this["parseNodeNameCache"] = /* @__PURE__ */ new Map(), this["_weightMap"] = {}, this["SEPARATOR"] = ",", this["_functions"] = {}, this["_functionExecutorMap"] = {}, this["keepIntermediateTensors"] = false, this["_outputs"] = qgu["outputs"], this["_inputs"] = qgu["inputs"], this["_initNodes"] = qgu["initNodes"], this["_signature"] = qgu["signature"], this["_functions"] = qgu["functions"], qgu["functions"] != null && Object["keys"](qgu["functions"])["forEach"]((qgL) => {
      this["_functionExecutorMap"][qgL] = new _oV(qgu["functions"][qgL], this);
    });
  }
  ["getCompilationKey"](qgu, qgj) {
    const qgL = qgu["map"]((qgb) => qgb["name"])["sort"](), qgI = qgj["map"]((qgb) => qgb["name"])["sort"]();
    return qgL["join"](this["SEPARATOR"]) + "--" + qgI["join"](this["SEPARATOR"]);
  }
  ["compile"](qgu, qgj) {
    const qgL = oz(qgu, qgj, this["weightMap"], this["_initNodes"]), { missingInputs: qgI, dynamicNode: qgb, syncInputs: qgR } = qgL;
    if (qgb != null) throw new Error("This execution contains the node '" + qgb["name"] + "', which has the dynamic op '" + qgb["op"] + "'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [" + qgR + "]");
    if (qgI["length"] > 0) {
      const qgQ = qgj["map"]((qgv) => qgv["name"]), qgd = Object["keys"](qgu);
      throw new Error("Cannot compute the outputs [" + qgQ + "] from the provided inputs [" + qgd + "]. Missing the following inputs: [" + qgI + "]");
    }
    const qgo = oX(this["graph"], qgL), qgr = oL(qgo);
    return { "orderedNodes": qgo, "nodeLiveUntilMap": qgr };
  }
  ["cloneAndKeepTensor"](qgu) {
    if (qgu == null) return null;
    const qgj = qgu["clone"]();
    return SM(qgj), qgj;
  }
  ["cloneTensorList"](qgu) {
    return qgu ? qgu["map"]((qgj) => this["cloneAndKeepTensor"](qgj)) : null;
  }
  ["cloneTensorMap"](qgu) {
    return Object["fromEntries"](Object["entries"](qgu)["map"](([qgj, qgL]) => [qgj, this["cloneTensorList"](qgL)]));
  }
  ["execute"](qgu, qgj) {
    this["disposeIntermediateTensors"](), qgu = this["mapInputs"](qgu);
    const qgL = Object["keys"](qgu)["sort"]();
    this["checkInputs"](qgu), this["checkInputShapeAndType"](qgu), qgj = this["mapOutputs"](qgj), this["checkOutputs"](qgj);
    const qgI = qgL["map"]((qgy) => this["graph"]["nodes"][LD(qgy)[0]]), qgb = qgj["map"]((qgy) => LD(qgy)[0]), qgR = new Set(qgb);
    let qgo = qgb["map"]((qgy) => this["graph"]["nodes"][qgy]);
    qgo["length"] === 0 && (qgo = this["_outputs"]);
    const qgr = this["getCompilationKey"](qgI, qgo);
    let qgQ = this["compiledMap"]["get"](qgr);
    qgQ == null && (qgQ = this["compile"](qgu, qgo), this["compiledMap"]["set"](qgr, qgQ));
    try {
      this["keepIntermediateTensors"] = qM()["getBool"]("KEEP_INTERMEDIATE_TENSORS");
    } catch (qgy) {
      this["keepIntermediateTensors"] = false, console["warn"](qgy["message"]);
    }
    const qgd = {}, qgv = {};
    return Sq(() => {
      const qgl = new oe(this["weightMap"], qgd, qgv, this["functionExecutorMap"], this["parseNodeNameCache"]), qgH = Object["assign"]({}, this["weightMap"]);
      this["keepIntermediateTensors"] && (this["clonedTensorsMap"] = this["cloneTensorMap"](this["weightMap"])), Object["keys"](qgu)["forEach"]((qgK) => {
        const [qgB, qgV] = LD(qgK, qgl), qgJ = [];
        qgJ[qgV] = qgu[qgK], qgH[qgB] = qgJ, this["keepIntermediateTensors"] && (this["clonedTensorsMap"][qgB] = this["cloneTensorList"](qgJ));
      });
      const qgA = this["getFrozenTensorIds"](qgH), { orderedNodes: qgh, nodeLiveUntilMap: qgT } = qgQ;
      for (const qgK of qgh) {
        if (qgH[qgK["name"]]) continue;
        const qgB = oZ(qgK, qgH, qgl, this["_resourceManager"]);
        if (J(qgB)) throw new Error("The execution of the op '" + qgK["op"] + "' returned a promise. Please use model.executeAsync() instead.");
        qgH[qgK["name"]] = qgB, this["keepIntermediateTensors"] && (this["clonedTensorsMap"][qgK["name"]] = this["cloneTensorList"](qgB)), this["checkTensorForDisposalWithNodeLiveUntilInfo"](qgK, qgH, qgl, qgA, qgR, qgT["get"](qgK["name"]));
      }
      return this["parent"] == null && qgl["dispose"](qgA), qgj["map"]((qgV) => Ls(qgV, qgH, qgl));
    });
  }
  ["getFrozenTensorIds"](qgu) {
    const qgj = []["concat"]["apply"]([], Object["keys"](qgu)["map"]((qgL) => qgu[qgL])["map"]((qgL) => qgL["map"]((qgI) => qgI["id"])));
    return new Set(qgj);
  }
  ["checkTensorForDisposal"](qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
    if (!(oH(qgj) || qgR["has"](qgu))) {
      for (const qgr of qgL[qgu]) qgr != null && (qgo[qgr["id"]] = (qgo[qgr["id"]] || 0) + qgj["children"]["length"]);
      for (const qgQ of qgj["inputs"]) {
        if (oH(qgQ)) continue;
        const qgd = LM(qgQ["name"], qgL, qgI);
        if (qgd != null) for (const qgv of qgd) {
          if (!qgv || qgv["kept"] || qgb["has"](qgv["id"])) continue;
          const qgy = qgo[qgv["id"]];
          qgy === 1 ? (qgv["dispose"](), delete qgo[qgv["id"]]) : qgy != null && qgo[qgv["id"]]--;
        }
      }
    }
  }
  ["checkTensorForDisposalWithNodeLiveUntilInfo"](qgu, qgj, qgL, qgI, qgb, qgR) {
    function qgo(qgr) {
      return oH(qgr) || qgb["has"](qgr["name"]);
    }
    if (!(oH(qgu) || qgR == null)) for (const qgr of qgR) {
      if (qgo(qgr)) continue;
      const qgQ = LM(qgr["name"], qgj, qgL);
      for (const qgd of qgQ) !qgd || qgd["kept"] || qgI["has"](qgd["id"]) || qgd["dispose"]();
    }
  }
  async ["executeAsync"](qgu, qgj) {
    return this["_executeAsync"](qgu, qgj);
  }
  ["disposeIntermediateTensors"]() {
    this["clonedTensorsMap"] && (Object["values"](this["clonedTensorsMap"])["forEach"]((qgu) => {
      for (const qgj of qgu) qgj && !qgj["isDisposed"] && qgj["dispose"]();
    }), this["clonedTensorsMap"] = null);
  }
  ["getIntermediateTensors"]() {
    return this["clonedTensorsMap"];
  }
  async ["_executeAsync"](qgu, qgj, qgL = false, qgI = {}, qgb = {}) {
    this["disposeIntermediateTensors"](), qgL || (qgu = this["mapInputs"](qgu), this["checkInputs"](qgu), this["checkInputShapeAndType"](qgu), qgj = this["mapOutputs"](qgj), this["checkOutputs"](qgj));
    try {
      this["keepIntermediateTensors"] = qM()["getBool"]("KEEP_INTERMEDIATE_TENSORS");
    } catch (qgy) {
      this["keepIntermediateTensors"] = false, console["warn"](qgy["message"]);
    }
    const qgR = new oe(this["weightMap"], qgI, qgb, this["functionExecutorMap"], this["parseNodeNameCache"]);
    this["keepIntermediateTensors"] && (this["clonedTensorsMap"] = this["cloneTensorMap"](this["weightMap"]));
    const qgo = await this["executeWithControlFlow"](qgu, qgR, qgj, qgL), qgr = qgj["map"]((qgl) => Ls(qgl, qgo, qgR)), qgQ = qgr["map"]((qgl) => qgl["id"]), qgd = Object["keys"](qgu)["map"]((qgl) => qgu[qgl]["id"]), qgv = /* @__PURE__ */ new Set([...qgQ, ...qgd, ...this["weightIds"]]);
    return Object["values"](qgo)["forEach"]((qgl) => {
      qgl["forEach"]((qgH) => {
        qgH && !qgH["isDisposed"] && !qgv["has"](qgH["id"]) && qgH["dispose"]();
      });
    }), this["parent"] == null && qgR["dispose"](qgv), qgr;
  }
  async ["executeFunctionAsync"](qgu, qgj, qgL) {
    const qgI = qgu["reduce"]((qgb, qgR, qgo) => (qgb[this["inputs"][qgo]["name"]] = qgR, qgb), {});
    return this["_executeAsync"](qgI, this["outputNodes"], true, qgj, qgL);
  }
  async ["executeWithControlFlow"](qgu, qgj, qgL, qgI) {
    const qgb = Object["keys"](qgu), qgR = qgb["map"]((qgV) => this["graph"]["nodes"][LD(qgV)[0]]), qgo = qgL["map"]((qgV) => LD(qgV)[0]), qgr = new Set(qgo);
    let qgQ = qgo["map"]((qgV) => this["graph"]["nodes"][qgV]);
    qgQ["length"] === 0 && (qgQ = this["_outputs"]);
    const { usedNodes: qgd, missingInputs: qgv, dynamicNode: qgy, syncInputs: qgl } = oz(qgu, qgQ, this["weightMap"], this["_initNodes"]), qgH = [...qgR, ...this["graph"]["weights"], ...this["_initNodes"] || []]["map"]((qgV) => ({ "node": qgV, "contexts": qgj["currentContext"] })), qgA = Object["assign"]({}, this["weightMap"]);
    Object["keys"](qgu)["forEach"]((qgV) => {
      const [qgJ, qgY] = LD(qgV), qgP = [];
      qgP[qgY] = qgu[qgV], qgA[qgJ] = qgP;
    });
    const qgh = {}, qgT = this["getFrozenTensorIds"](qgA), qgK = {};
    for (; qgH["length"] > 0; ) {
      const qgV = this["processStack"](qgR, qgH, qgj, qgA, qgK, qgT, qgr, qgh, qgd);
      await Promise["all"](qgV);
    }
    qgy == null && !qgI && console["warn"]("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");
    const qgB = qgQ["filter"]((qgJ) => !oH(qgJ) && !Ls(qgJ["name"], qgA, qgj))["map"]((qgJ) => qgJ["name"]);
    if (qgB["length"] > 0) {
      let qgJ = "";
      throw qgy != null && (qgJ = "Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [" + qgl + "]"), new Error("Cannot compute the outputs [" + qgB + "] from the provided inputs [" + qgb + "]. Consider providing the following inputs: [" + qgv + "]. " + qgJ);
    }
    return qgA;
  }
  ["processStack"](qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ) {
    const qgd = [];
    for (; qgj["length"] > 0; ) {
      const qgv = qgj["pop"]();
      qgL["currentContext"] = qgv["contexts"];
      let qgy = "";
      if (qgv["node"]["op"] === "Enter" && Ln("isConstant", qgv["node"], qgI, qgL) && ([qgy] = LF(qgv["node"]["name"], qgL)), qgI[qgv["node"]["name"]] == null) {
        const qgl = oZ(qgv["node"], qgI, qgL, this["_resourceManager"]);
        qgy || ([qgy] = LF(qgv["node"]["name"], qgL));
        const qgH = qgL["currentContext"];
        J(qgl) ? qgd["push"](qgl["then"]((qgA) => (qgI[qgy] = qgA, this["keepIntermediateTensors"] && (this["clonedTensorsMap"][qgy] = this["cloneTensorList"](qgA)), qgL["currentContext"] = qgH, this["checkTensorForDisposal"](qgy, qgv["node"], qgI, qgL, qgR, qgo, qgr), this["processChildNodes"](qgv["node"], qgj, qgL, qgI, qgb, qgQ), qgA))) : (qgI[qgy] = qgl, this["keepIntermediateTensors"] && (this["clonedTensorsMap"][qgy] = this["cloneTensorList"](qgl)), this["checkTensorForDisposal"](qgy, qgv["node"], qgI, qgL, qgR, qgo, qgr), this["processChildNodes"](qgv["node"], qgj, qgL, qgI, qgb, qgQ));
      } else this["processChildNodes"](qgv["node"], qgj, qgL, qgI, qgb, qgQ);
    }
    return qgd;
  }
  ["processChildNodes"](qgu, qgj, qgL, qgI, qgb, qgR) {
    qgu["children"]["forEach"]((qgo) => {
      const [qgr] = LF(qgo["name"], qgL);
      qgb[qgr] || !qgR["has"](qgo["name"]) || (qgo["op"] === "Merge" ? qgo["inputNames"]["some"]((qgQ) => !!Ls(qgQ, qgI, qgL)) && (qgb[qgr] = true, qgj["push"]({ "contexts": qgL["currentContext"], "node": qgo })) : qgo["inputNames"]["every"]((qgQ) => !!Ls(qgQ, qgI, qgL)) && (qgb[qgr] = true, qgj["push"]({ "contexts": qgL["currentContext"], "node": qgo })));
    });
  }
  ["dispose"]() {
    Object["keys"](this["weightMap"])["forEach"]((qgu) => this["weightMap"][qgu]["forEach"]((qgj) => qgj["dispose"]()));
  }
  ["checkInputShapeAndType"](qgu) {
    Object["keys"](qgu)["forEach"]((qgj) => {
      const qgL = qgu[qgj], [qgI] = LD(qgj), qgb = this["graph"]["nodes"][qgI];
      if (qgb["attrParams"]["shape"] && qgb["attrParams"]["shape"]["value"]) {
        const qgR = qgb["attrParams"]["shape"]["value"], qgo = qgR["length"] === qgL["shape"]["length"] && qgL["shape"]["every"]((qgr, qgQ) => qgR[qgQ] === -1 || qgR[qgQ] === qgr);
        k(qgo, () => "The shape of dict['" + qgb["name"] + "'] provided in model.execute(dict) must be [" + qgR + "], but was [" + qgL["shape"] + "]");
      }
      qgb["attrParams"]["dtype"] && qgb["attrParams"]["dtype"]["value"] && k(qgL["dtype"] === qgb["attrParams"]["dtype"]["value"], () => "The dtype of dict['" + qgb["name"] + "'] provided in model.execute(dict) must be " + qgb["attrParams"]["dtype"]["value"] + ", but was " + qgL["dtype"]);
    });
  }
  ["mapInputs"](qgu) {
    var qgj, qgL;
    const qgI = {};
    for (const qgb in qgu) {
      const qgR = (qgL = (qgj = this["_signature"]) === null || qgj === void 0 ? void 0 : qgj["inputs"]) === null || qgL === void 0 ? void 0 : qgL[qgb];
      qgR != null ? qgI[qgR["name"]] = qgu[qgb] : qgI[qgb] = qgu[qgb];
    }
    return qgI;
  }
  ["checkInputs"](qgu) {
    const qgj = Object["keys"](qgu)["filter"]((qgL) => {
      const [qgI] = LD(qgL);
      return this["graph"]["nodes"][qgI] == null;
    });
    if (qgj["length"] > 0) throw new Error("The dict provided in model.execute(dict) has keys: [" + qgj + "] that are not part of graph");
  }
  ["mapOutputs"](qgu) {
    return qgu["map"]((qgj) => {
      var qgL, qgI;
      const qgb = (qgI = (qgL = this["_signature"]) === null || qgL === void 0 ? void 0 : qgL["outputs"]) === null || qgI === void 0 ? void 0 : qgI[qgj];
      return qgb != null ? qgb["name"] : qgj;
    }, {});
  }
  ["checkOutputs"](qgu) {
    qgu["forEach"]((qgj) => {
      const [qgL] = LD(qgj);
      if (!this["graph"]["nodes"][qgL]) throw new Error("The output '" + qgj + "' is not found in the graph");
    });
  }
};
var oJ = class {
  constructor(qgu = {}, qgj = {}) {
    this["hashTableNameToHandle"] = qgu, this["hashTableMap"] = qgj;
  }
  ["addHashTable"](qgu, qgj) {
    this["hashTableNameToHandle"][qgu] = qgj["handle"], this["hashTableMap"][qgj["id"]] = qgj;
  }
  ["getHashTableHandleByName"](qgu) {
    return this["hashTableNameToHandle"][qgu];
  }
  ["getHashTableById"](qgu) {
    return this["hashTableMap"][qgu];
  }
  ["dispose"]() {
    for (const qgu in this["hashTableMap"]) this["hashTableMap"][qgu]["clearAndClose"](), delete this["hashTableMap"][qgu];
    for (const qgj in this["hashTableNameToHandle"]) this["hashTableNameToHandle"][qgj]["dispose"](), delete this["hashTableNameToHandle"][qgj];
  }
};
var oY = "?tfjs-format=file";
var oP = "model.json";
var oU = class {
  get ["modelVersion"]() {
    return this["version"];
  }
  get ["inputNodes"]() {
    return this["executor"]["inputNodes"];
  }
  get ["outputNodes"]() {
    return this["executor"]["outputNodes"];
  }
  get ["inputs"]() {
    return this["executor"]["inputs"];
  }
  get ["outputs"]() {
    return this["executor"]["outputs"];
  }
  get ["weights"]() {
    return this["executor"]["weightMap"];
  }
  get ["metadata"]() {
    return this["artifacts"]["userDefinedMetadata"];
  }
  get ["modelSignature"]() {
    return this["signature"];
  }
  get ["modelStructuredOutputKeys"]() {
    return this["structuredOutputKeys"];
  }
  constructor(qgu, qgj = {}, qgL = Oq) {
    this["modelUrl"] = qgu, this["loadOptions"] = qgj, this["version"] = "n/a", this["io"] = qgL, qgj == null && (this["loadOptions"] = {}), this["resourceManager"] = new oJ();
  }
  ["findIOHandler"]() {
    const qgu = this["modelUrl"];
    if (qgu["load"] != null) this["handler"] = qgu;
    else {
      if (this["loadOptions"]["requestInit"] != null) this["handler"] = this["io"]["browserHTTPRequest"](qgu, this["loadOptions"]);
      else {
        const qgj = this["io"]["getLoadHandlers"](qgu, this["loadOptions"]);
        if (qgj["length"] === 0) qgj["push"](this["io"]["browserHTTPRequest"](qgu, this["loadOptions"]));
        else {
          if (qgj["length"] > 1) throw new Error("Found more than one (" + qgj["length"] + ") load handlers for URL '" + [qgu] + "'");
        }
        this["handler"] = qgj[0];
      }
    }
  }
  ["load"]() {
    if (this["findIOHandler"](), this["handler"]["load"] == null) throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");
    const qgu = this["handler"]["load"]();
    return J(qgu) ? qgu["then"]((qgj) => qgj["getWeightStream"] == null ? this["loadSync"](qgj) : this["loadStreaming"](qgj)) : this["loadSync"](qgu);
  }
  ["loadSync"](qgu) {
    const qgj = this["io"]["decodeWeights"](qgu["weightData"], qgu["weightSpecs"]);
    return this["loadWithWeightMap"](qgu, qgj);
  }
  async ["loadStreaming"](qgu) {
    if (qgu["getWeightStream"] == null) throw new Error("Model artifacts missing streamWeights function");
    const qgj = await SQ(qgu["getWeightStream"](), qgu["weightSpecs"]);
    return this["loadWithWeightMap"](qgu, qgj);
  }
  ["loadWithWeightMap"](qgu, qgj) {
    this["artifacts"] = qgu;
    const qgL = this["artifacts"]["modelTopology"];
    let qgI = this["artifacts"]["signature"];
    if (this["artifacts"]["userDefinedMetadata"] != null) {
      const qgb = this["artifacts"]["userDefinedMetadata"];
      qgb["signature"] != null && (qgI = qgb["signature"]), qgb["structuredOutputKeys"] != null && (this["structuredOutputKeys"] = qgb["structuredOutputKeys"]);
    }
    if (this["signature"] = qgI, this["version"] = qgL["versions"]["producer"] + "." + qgL["versions"]["minConsumer"], this["executor"] = new oV(bM["Instance"]["transformGraph"](qgL, this["signature"])), this["executor"]["weightMap"] = this["convertTensorMapToTensorsMap"](qgj), this["executor"]["resourceManager"] = this["resourceManager"], qgu["modelInitializer"] != null && qgu["modelInitializer"]["node"] != null) {
      const qgR = bM["Instance"]["transformGraph"](qgu["modelInitializer"]);
      this["initializer"] = new oV(qgR), this["initializer"]["weightMap"] = this["executor"]["weightMap"], this["initializer"]["resourceManager"] = this["resourceManager"], this["initializerSignature"] = qgu["initializerSignature"];
    }
    return true;
  }
  async ["save"](qgu, qgj) {
    if (typeof qgu == "string") {
      const qgL = this["io"]["getSaveHandlers"](qgu);
      if (qgL["length"] === 0) throw new Error("Cannot find any save handlers for URL '" + qgu + "'");
      if (qgL["length"] > 1) throw new Error("Found more than one (" + qgL["length"] + ") save handlers for URL '" + qgu + "'");
      qgu = qgL[0];
    }
    if (qgu["save"] == null) throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");
    return qgu["save"](this["artifacts"]);
  }
  ["addStructuredOutputNames"](qgu) {
    if (this["structuredOutputKeys"]) {
      const qgj = qgu instanceof MF ? [qgu] : qgu, qgL = {};
      return qgj["forEach"]((qgI, qgb) => qgL[this["structuredOutputKeys"][qgb]] = qgI), qgL;
    }
    return qgu;
  }
  ["predict"](qgu, qgj) {
    const qgL = this["execute"](qgu, this["outputNodes"]);
    return this["addStructuredOutputNames"](qgL);
  }
  async ["predictAsync"](qgu, qgj) {
    const qgL = await this["executeAsync"](qgu, this["outputNodes"]);
    return this["addStructuredOutputNames"](qgL);
  }
  ["normalizeInputs"](qgu) {
    var qgj;
    if (!(qgu instanceof MF) && !Array["isArray"](qgu)) {
      const qgb = (qgj = this["signature"]) === null || qgj === void 0 ? void 0 : qgj["inputs"];
      if (qgb != null) for (const qgR in qgb) {
        const qgo = qgb[qgR];
        qgo["resourceId"] != null && (qgu[qgR] = this["resourceIdToCapturedInput"][qgo["resourceId"]]);
      }
      return qgu;
    }
    qgu = Array["isArray"](qgu) ? qgu : [qgu];
    const qgL = Object["keys"](this["resourceIdToCapturedInput"])["length"];
    if (qgu["length"] + qgL !== this["inputNodes"]["length"]) throw new Error("Input tensor count mismatch, the graph model has " + (this["inputNodes"]["length"] - qgL) + " non-resource placeholders, while there are " + qgu["length"] + " input tensors provided.");
    let qgI = 0;
    return this["inputNodes"]["reduce"]((qgr, qgQ) => {
      var qgd, qgv, qgy;
      const qgl = (qgy = (qgv = (qgd = this["signature"]) === null || qgd === void 0 ? void 0 : qgd["inputs"]) === null || qgv === void 0 ? void 0 : qgv[qgQ]) === null || qgy === void 0 ? void 0 : qgy["resourceId"];
      return qgl != null ? qgr[qgQ] = this["resourceIdToCapturedInput"][qgl] : qgr[qgQ] = qgu[qgI++], qgr;
    }, {});
  }
  ["normalizeOutputs"](qgu) {
    return qgu = qgu || this["outputNodes"], Array["isArray"](qgu) ? qgu : [qgu];
  }
  ["executeInitializerGraph"]() {
    return this["initializer"] == null ? [] : this["initializerSignature"] == null ? this["initializer"]["execute"]({}, []) : this["initializer"]["execute"]({}, Object["keys"](this["initializerSignature"]["outputs"]));
  }
  async ["executeInitializerGraphAsync"]() {
    return this["initializer"] == null ? [] : this["initializerSignature"] == null ? this["initializer"]["executeAsync"]({}, []) : this["initializer"]["executeAsync"]({}, Object["keys"](this["initializerSignature"]["outputs"]));
  }
  ["setResourceIdToCapturedInput"](qgu) {
    if (this["resourceIdToCapturedInput"] = {}, this["initializerSignature"]) {
      const qgj = this["initializerSignature"]["outputs"], qgL = Object["keys"](qgj);
      for (let qgI = 0; qgI < qgL["length"]; qgI++) {
        const qgb = qgL[qgI], qgR = qgj[qgb];
        this["resourceIdToCapturedInput"][qgR["resourceId"]] = qgu[qgI];
      }
    }
  }
  ["execute"](qgu, qgj) {
    this["resourceIdToCapturedInput"] == null && this["setResourceIdToCapturedInput"](this["executeInitializerGraph"]()), qgu = this["normalizeInputs"](qgu), qgj = this["normalizeOutputs"](qgj);
    const qgL = this["executor"]["execute"](qgu, qgj);
    return qgL["length"] > 1 ? qgL : qgL[0];
  }
  async ["executeAsync"](qgu, qgj) {
    this["resourceIdToCapturedInput"] == null && this["setResourceIdToCapturedInput"](await this["executeInitializerGraphAsync"]()), qgu = this["normalizeInputs"](qgu), qgj = this["normalizeOutputs"](qgj);
    const qgL = await this["executor"]["executeAsync"](qgu, qgj);
    return qgL["length"] > 1 ? qgL : qgL[0];
  }
  ["getIntermediateTensors"]() {
    return this["executor"]["getIntermediateTensors"]();
  }
  ["disposeIntermediateTensors"]() {
    this["executor"]["disposeIntermediateTensors"]();
  }
  ["convertTensorMapToTensorsMap"](qgu) {
    return Object["keys"](qgu)["reduce"]((qgj, qgL) => (qgj[qgL] = [qgu[qgL]], qgj), {});
  }
  ["dispose"]() {
    this["executor"]["dispose"](), this["initializer"] && (this["initializer"]["dispose"](), this["resourceIdToCapturedInput"] && Sn(this["resourceIdToCapturedInput"])), this["resourceManager"]["dispose"]();
  }
};
async function rq(qgu, qgj = {}, qgL = Oq) {
  if (qgu == null) throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");
  qgj == null && (qgj = {}), qgj["fromTFHub"] && typeof qgu == "string" && (qgu = rn(qgu));
  const qgI = new oU(qgu, qgj, qgL);
  return await qgI["load"](), qgI;
}
function rn(qgu) {
  return qgu["endsWith"]("/") || (qgu = qgu + "/"), "" + qgu + oP + oY;
}
var rs = {};
var rM = { "alpha": false, "antialias": false, "premultipliedAlpha": false, "preserveDrawingBuffer": false, "depth": false, "stencil": false, "failIfMajorPerformanceCaveat": true };
function rF(qgu, qgj) {
  rs[qgu] = qgj;
}
function rW(qgu, qgj) {
  if (!(qgu in rs) || qgj != null) {
    const qgI = rZ(qgu, qgj);
    if (qgI !== null) rs[qgu] = qgI;
    else return console["log"]("Could not get context for WebGL version", qgu), null;
  }
  const qgL = rs[qgu];
  return qgL == null || qgL["isContextLost"]() ? (delete rs[qgu], rW(qgu)) : (qgL["disable"](qgL["DEPTH_TEST"]), qgL["disable"](qgL["STENCIL_TEST"]), qgL["disable"](qgL["BLEND"]), qgL["disable"](qgL["DITHER"]), qgL["disable"](qgL["POLYGON_OFFSET_FILL"]), qgL["disable"](qgL["SAMPLE_COVERAGE"]), qgL["enable"](qgL["SCISSOR_TEST"]), qgL["enable"](qgL["CULL_FACE"]), qgL["cullFace"](qgL["BACK"]), rs[qgu]);
}
function rD(qgu) {
  if (!qM()["getBool"]("IS_SAFARI") && typeof OffscreenCanvas != "undefined" && qgu === 2) return new OffscreenCanvas(300, 150);
  if (typeof document != "undefined") return document["createElement"]("canvas");
  throw new Error("Cannot create a canvas in this context");
}
function rZ(qgu, qgj) {
  if (qgu !== 1 && qgu !== 2) throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");
  const qgL = qgj == null ? rD(qgu) : qgj;
  return qgL["addEventListener"]("webglcontextlost", (qgI) => {
    qgI["preventDefault"](), delete rs[qgu];
  }, false), qM()["getBool"]("SOFTWARE_WEBGL_ENABLED") && (rM["failIfMajorPerformanceCaveat"] = false), qgu === 1 ? qgL["getContext"]("webgl", rM) || qgL["getContext"]("experimental-webgl", rM) : qgL["getContext"]("webgl2", rM);
}
var rz;
(function(qgu) {
  qgu[qgu["DENSE"] = 0] = "DENSE", qgu[qgu["SHARED_BATCH"] = 1] = "SHARED_BATCH";
})(rz || (rz = {}));
var rX;
(function(qgu) {
  qgu[qgu["RENDER"] = 0] = "RENDER", qgu[qgu["UPLOAD"] = 1] = "UPLOAD", qgu[qgu["PIXELS"] = 2] = "PIXELS", qgu[qgu["DOWNLOAD"] = 3] = "DOWNLOAD";
})(rX || (rX = {}));
var rG;
(function(qgu) {
  qgu[qgu["UNPACKED_FLOAT16"] = 0] = "UNPACKED_FLOAT16", qgu[qgu["UNPACKED_FLOAT32"] = 1] = "UNPACKED_FLOAT32", qgu[qgu["PACKED_4X1_UNSIGNED_BYTE"] = 2] = "PACKED_4X1_UNSIGNED_BYTE", qgu[qgu["PACKED_2X2_FLOAT32"] = 3] = "PACKED_2X2_FLOAT32", qgu[qgu["PACKED_2X2_FLOAT16"] = 4] = "PACKED_2X2_FLOAT16";
})(rG || (rG = {}));
function ru(qgu, qgj) {
  return [qgj, qgu];
}
function rj(qgu, qgj) {
  return qgu * qgj;
}
function rL(qgu) {
  const qgj = i2(qgu), qgL = Math["ceil"](qgj / 4);
  return a(qgL);
}
function ro(qgu, qgj) {
  return [Math["max"](1, Math["ceil"](qgj / 2)), Math["max"](1, Math["ceil"](qgu / 2))];
}
function rQ(qgu, qgj) {
  const [qgL, qgI] = ro(qgu, qgj);
  return qgL * qgI * 4;
}
function rH(qgu, qgj) {
  const qgL = qgu;
  let qgI, qgb, qgR, qgo, qgr, qgQ, qgd, qgv, qgy, qgl;
  return qM()["getNumber"]("WEBGL_VERSION") === 2 ? (qgI = qgL["R32F"], qgb = qgL["R16F"], qgR = qgL["RGBA16F"], qgo = qgL["RGBA32F"], qgr = qgL["RED"], qgd = 4, qgv = 1, qgy = qgL["HALF_FLOAT"], qgl = qgL["FLOAT"], qgQ = qgL["RGBA8"]) : (qgI = qgu["RGBA"], qgb = qgu["RGBA"], qgR = qgu["RGBA"], qgo = qgL["RGBA"], qgr = qgu["RGBA"], qgd = 4, qgv = 4, qgy = qgj != null ? qgj["HALF_FLOAT_OES"] : null, qgl = qgu["FLOAT"], qgQ = qgu["RGBA"]), { "internalFormatFloat": qgI, "internalFormatHalfFloat": qgb, "internalFormatPackedHalfFloat": qgR, "internalFormatPackedFloat": qgo, "textureFormatFloat": qgr, "downloadTextureFormat": qgQ, "downloadUnpackNumChannels": qgd, "defaultNumChannels": qgv, "textureTypeHalfFloat": qgy, "textureTypeFloat": qgl };
}
function rK(qgu, qgj) {
  const qgL = qgj();
  return qM()["getBool"]("DEBUG") && rB(qgu), qgL;
}
function rB(qgu) {
  const qgj = qgu["getError"]();
  if (qgj !== qgu["NO_ERROR"]) throw new Error("WebGL Error: " + rP(qgu, qgj));
}
var rV = 596e-10;
var rJ = 65504;
function rY(qgu) {
  return !!(qM()["getBool"]("WEBGL_RENDER_FLOAT32_ENABLED") || qgu === 0 || rV < Math["abs"](qgu) && Math["abs"](qgu) < rJ);
}
function rP(qgu, qgj) {
  switch (qgj) {
    case qgu["NO_ERROR"]:
      return "NO_ERROR";
    case qgu["INVALID_ENUM"]:
      return "INVALID_ENUM";
    case qgu["INVALID_VALUE"]:
      return "INVALID_VALUE";
    case qgu["INVALID_OPERATION"]:
      return "INVALID_OPERATION";
    case qgu["INVALID_FRAMEBUFFER_OPERATION"]:
      return "INVALID_FRAMEBUFFER_OPERATION";
    case qgu["OUT_OF_MEMORY"]:
      return "OUT_OF_MEMORY";
    case qgu["CONTEXT_LOST_WEBGL"]:
      return "CONTEXT_LOST_WEBGL";
    default:
      return "Unknown error code " + qgj;
  }
}
function rU(qgu, qgj) {
  return QY(qgu, () => qgu["getExtension"](qgj), 'Extension "' + qgj + '" not supported on this browser.');
}
function Qq(qgu, qgj) {
  const qgL = QY(qgu, () => qgu["createShader"](qgu["VERTEX_SHADER"]), "Unable to create vertex WebGLShader.");
  if (rK(qgu, () => qgu["shaderSource"](qgL, qgj)), rK(qgu, () => qgu["compileShader"](qgL)), qgu["getShaderParameter"](qgL, qgu["COMPILE_STATUS"]) === false) throw console["log"](qgu["getShaderInfoLog"](qgL)), new Error("Failed to compile vertex shader.");
  return qgL;
}
function QM(qgu, qgj) {
  const qgL = QY(qgu, () => qgu["createShader"](qgu["FRAGMENT_SHADER"]), "Unable to create fragment WebGLShader.");
  if (rK(qgu, () => qgu["shaderSource"](qgL, qgj)), rK(qgu, () => qgu["compileShader"](qgL)), qM()["get"]("ENGINE_COMPILE_ONLY")) return qgL;
  if (qgu["getShaderParameter"](qgL, qgu["COMPILE_STATUS"]) === false) throw QW(qgj, qgu["getShaderInfoLog"](qgL)), new Error("Failed to compile fragment shader.");
  return qgL;
}
var QF = /ERROR: [0-9]+:([0-9]+):/g;
function QW(qgu, qgj) {
  const qgL = QF["exec"](qgj);
  if (qgL == null) {
    console["log"]("Couldn't parse line number in error: " + qgj), console["log"](qgu);
    return;
  }
  const qgI = +qgL[1], qgb = qgu["split"]("\n"), qgR = qgb["length"]["toString"]()["length"] + 2, qgo = qgb["map"]((qgy, qgl) => Z((qgl + 1)["toString"](), qgR) + qgy);
  let qgr = 0;
  for (let qgy = 0; qgy < qgo["length"]; qgy++) qgr = Math["max"](qgo[qgy]["length"], qgr);
  const qgQ = qgo["slice"](0, qgI - 1), qgd = qgo["slice"](qgI - 1, qgI), qgv = qgo["slice"](qgI);
  console["log"](qgQ["join"]("\n")), console["log"](qgj["split"]("\n")[0]), console["log"]("%c " + Z(qgd[0], qgr), "border:1px solid red; background-color:#e3d2d2; color:#a61717"), console["log"](qgv["join"]("\n"));
}
function QD(qgu) {
  return QY(qgu, () => qgu["createProgram"](), "Unable to create WebGLProgram.");
}
function Qa(qgu, qgj) {
  if (rK(qgu, () => qgu["linkProgram"](qgj)), !qM()["get"]("ENGINE_COMPILE_ONLY") && qgu["getProgramParameter"](qgj, qgu["LINK_STATUS"]) === false) throw console["log"](qgu["getProgramInfoLog"](qgj)), new Error("Failed to link vertex and fragment shaders.");
}
function QZ(qgu, qgj) {
  if (rK(qgu, () => qgu["validateProgram"](qgj)), qgu["getProgramParameter"](qgj, qgu["VALIDATE_STATUS"]) === false) throw console["log"](qgu["getProgramInfoLog"](qgj)), new Error("Shader program validation failed.");
}
function Qz(qgu, qgj) {
  const qgL = QY(qgu, () => qgu["createBuffer"](), "Unable to create WebGLBuffer");
  return rK(qgu, () => qgu["bindBuffer"](qgu["ARRAY_BUFFER"], qgL)), rK(qgu, () => qgu["bufferData"](qgu["ARRAY_BUFFER"], qgj, qgu["STATIC_DRAW"])), qgL;
}
function QX(qgu, qgj) {
  const qgL = QY(qgu, () => qgu["createBuffer"](), "Unable to create WebGLBuffer");
  return rK(qgu, () => qgu["bindBuffer"](qgu["ELEMENT_ARRAY_BUFFER"], qgL)), rK(qgu, () => qgu["bufferData"](qgu["ELEMENT_ARRAY_BUFFER"], qgj, qgu["STATIC_DRAW"])), qgL;
}
function QG(qgu) {
  return QY(qgu, () => qgu["createTexture"](), "Unable to create WebGLTexture.");
}
function Qj(qgu, qgj) {
  const qgL = qM()["getNumber"]("WEBGL_MAX_TEXTURE_SIZE");
  if (qgu <= 0 || qgj <= 0) {
    const qgI = "[" + qgu + "x" + qgj + "]";
    throw new Error("Requested texture size " + qgI + " is invalid.");
  }
  if (qgu > qgL || qgj > qgL) {
    const qgb = "[" + qgu + "x" + qgj + "]", qgR = "[" + qgL + "x" + qgL + "]";
    throw new Error("Requested texture size " + qgb + " greater than WebGL maximum on this browser / GPU " + qgR + ".");
  }
}
function QL(qgu) {
  return QY(qgu, () => qgu["createFramebuffer"](), "Unable to create WebGLFramebuffer.");
}
function QR(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
  const qgr = qgu["getAttribLocation"](qgj, qgL);
  return qgr === -1 ? false : (rK(qgu, () => qgu["bindBuffer"](qgu["ARRAY_BUFFER"], qgI)), rK(qgu, () => qgu["vertexAttribPointer"](qgr, qgb, qgu["FLOAT"], false, qgR, qgo)), rK(qgu, () => qgu["enableVertexAttribArray"](qgr)), true);
}
function Qo(qgu, qgj, qgL) {
  QP(qgu, qgL), rK(qgu, () => qgu["activeTexture"](qgu["TEXTURE0"] + qgL)), rK(qgu, () => qgu["bindTexture"](qgu["TEXTURE_2D"], qgj));
}
function QQ(qgu, qgj, qgL) {
  return QY(qgu, () => qgu["getUniformLocation"](qgj, qgL), 'uniform "' + qgL + '" not present in program.');
}
function QH(qgu, qgj, qgL) {
  return qgu["getUniformLocation"](qgj, qgL);
}
function Qh(qgu, qgj, qgL, qgI) {
  rK(qgu, () => Qo(qgu, qgj, qgI)), rK(qgu, () => qgu["uniform1i"](qgL, qgI));
}
function QK(qgu, qgj, qgL) {
  rK(qgu, () => qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], qgL)), rK(qgu, () => qgu["framebufferTexture2D"](qgu["FRAMEBUFFER"], qgu["COLOR_ATTACHMENT0"], qgu["TEXTURE_2D"], qgj, 0));
}
function QB(qgu, qgj) {
  rK(qgu, () => qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], qgj)), rK(qgu, () => qgu["framebufferTexture2D"](qgu["FRAMEBUFFER"], qgu["COLOR_ATTACHMENT0"], qgu["TEXTURE_2D"], null, 0));
}
function QV(qgu) {
  const qgj = qgu["checkFramebufferStatus"](qgu["FRAMEBUFFER"]);
  if (qgj !== qgu["FRAMEBUFFER_COMPLETE"]) throw new Error("Error binding framebuffer: " + QJ(qgu, qgj));
}
function QJ(qgu, qgj) {
  switch (qgj) {
    case qgu["FRAMEBUFFER_INCOMPLETE_ATTACHMENT"]:
      return "FRAMEBUFFER_INCOMPLETE_ATTACHMENT";
    case qgu["FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT"]:
      return "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";
    case qgu["FRAMEBUFFER_INCOMPLETE_DIMENSIONS"]:
      return "FRAMEBUFFER_INCOMPLETE_DIMENSIONS";
    case qgu["FRAMEBUFFER_UNSUPPORTED"]:
      return "FRAMEBUFFER_UNSUPPORTED";
    default:
      return "unknown error " + qgj;
  }
}
function QY(qgu, qgj, qgL) {
  const qgI = rK(qgu, () => qgj());
  if (qgI == null) throw new Error(qgL);
  return qgI;
}
function QP(qgu, qgj) {
  const qgL = qgu["MAX_COMBINED_TEXTURE_IMAGE_UNITS"] - 1, qgI = qgj + qgu["TEXTURE0"];
  if (qgI < qgu["TEXTURE0"] || qgI > qgL) {
    const qgb = "[gl.TEXTURE0, gl.TEXTURE" + qgL + "]";
    throw new Error("textureUnit must be in " + qgb + ".");
  }
}
function QU(qgu, qgj = 2) {
  return i2(qgu["slice"](0, qgu["length"] - qgj));
}
function d1(qgu) {
  if (qgu["length"] === 0) throw Error("Cannot get rows and columns of an empty shape array.");
  return [qgu["length"] > 1 ? qgu[qgu["length"] - 2] : 1, qgu[qgu["length"] - 1]];
}
function dq(qgu) {
  let qgj = [1, 1, 1];
  return qgu["length"] === 0 || qgu["length"] === 1 && qgu[0] === 1 || (qgj = [QU(qgu), ...d1(qgu)]), qgj;
}
function dM(qgu, qgj = false) {
  let qgL = qM()["getNumber"]("WEBGL_MAX_TEXTURE_SIZE"), qgI = qM()["getNumber"]("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");
  qgI === 1 / 0 && qM()["getBool"]("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE") && (qgI = qgL / 2), qgj && (qgL = qgL * 2, qgI = qgI * 2, qgu = qgu["map"]((qgr, qgQ) => qgQ >= qgu["length"] - 2 ? f(qgu[qgQ]) : qgu[qgQ]), qgu["length"] === 1 && (qgu = [2, qgu[0]])), qgu["length"] !== 2 && (qgu = c(qgu)["newShape"]);
  let qgb = i2(qgu), qgR = null;
  qgu["length"] <= 1 && qgb <= qgL ? qgR = [1, qgb] : qgu["length"] === 2 && qgu[0] <= qgL && qgu[1] <= qgL ? qgR = qgu : qgu["length"] === 3 && qgu[0] * qgu[1] <= qgL && qgu[2] <= qgL ? qgR = [qgu[0] * qgu[1], qgu[2]] : qgu["length"] === 3 && qgu[0] <= qgL && qgu[1] * qgu[2] <= qgL ? qgR = [qgu[0], qgu[1] * qgu[2]] : qgu["length"] === 4 && qgu[0] * qgu[1] * qgu[2] <= qgL && qgu[3] <= qgL ? qgR = [qgu[0] * qgu[1] * qgu[2], qgu[3]] : qgu["length"] === 4 && qgu[0] <= qgL && qgu[1] * qgu[2] * qgu[3] <= qgL && (qgR = [qgu[0], qgu[1] * qgu[2] * qgu[3]]);
  const qgo = qgR != null && Math["max"](...qgR) > qgI && Math["min"](...qgR) <= (qgj ? 2 : 1) && Math["min"](...qgR) > 0;
  if (qgR == null || qgo) {
    if (qgj) {
      const qgr = QU(qgu);
      let qgQ = 2, qgd = 2;
      qgu["length"] && ([qgQ, qgd] = d1(qgu)), qgb = qgr * (qgQ / 2) * (qgd / 2), qgR = a(qgb)["map"]((qgv) => qgv * 2);
    } else qgR = a(qgb);
  }
  return qgR;
}
function dF(qgu) {
  return qgu % 2 === 0;
}
function dt(qgu, qgj) {
  if (qgu = qgu["slice"](-2), qgj = qgj["slice"](-2), D(qgu, qgj) || !qgu["length"] || !qgj["length"] || qgu[0] === 0 || qgu[1] === 0 || qgj[0] === 0 || qgj[1] === 0) return true;
  if (qgu["length"] !== qgj["length"]) {
    const qgL = qgu[qgu["length"] - 1], qgI = qgj[qgj["length"] - 1];
    if (qgL === qgI || dF(qgL) && dF(qgI) && (qgu[0] === 1 || qgj[0] === 1)) return true;
  }
  return qgu[1] === qgj[1] && dF(qgu[0]) && dF(qgj[0]);
}
var dW;
var dD;
function da(qgu) {
  if (dW == null) {
    const qgj = rW(qgu);
    dW = qgj["getParameter"](qgj["MAX_TEXTURE_SIZE"]);
  }
  return dW;
}
function dZ(qgu) {
  if (dD == null) {
    const qgj = rW(qgu);
    dD = qgj["getParameter"](qgj["MAX_TEXTURE_IMAGE_UNITS"]);
  }
  return Math["min"](16, dD);
}
function de(qgu) {
  if (qgu === 0) return 0;
  let qgj;
  const qgL = rW(qgu);
  return dz(qgL, "EXT_disjoint_timer_query_webgl2") && qgu === 2 ? qgj = 2 : dz(qgL, "EXT_disjoint_timer_query") ? qgj = 1 : qgj = 0, qgj;
}
function dz(qgu, qgj) {
  return qgu["getExtension"](qgj) != null;
}
function dX(qgu) {
  try {
    if (rW(qgu) != null) return true;
  } catch (qgj) {
    return console["log"]("Error when getting WebGL context: ", qgj), false;
  }
  return false;
}
function dG(qgu) {
  if (qgu === 0) return false;
  const qgj = rW(qgu);
  if (qgu === 1) {
    if (!dz(qgj, "OES_texture_float")) return false;
  } else {
    if (!dz(qgj, "EXT_color_buffer_float")) return false;
  }
  return dj(qgj);
}
function du(qgu) {
  if (qgu === 0) return false;
  const qgj = rW(qgu);
  if (qgu === 1) {
    if (!dz(qgj, "OES_texture_float") || !dz(qgj, "WEBGL_color_buffer_float")) return false;
  } else {
    if (dz(qgj, "EXT_color_buffer_float")) return dj(qgj);
    const qgL = "EXT_color_buffer_half_float";
    if (dz(qgj, qgL)) {
      const qgI = qgj["getExtension"](qgL);
      return dL(qgj, qgI);
    }
    return false;
  }
  return dj(qgj);
}
function dj(qgu) {
  const qgj = rH(qgu), qgL = qgu["createTexture"]();
  qgu["bindTexture"](qgu["TEXTURE_2D"], qgL), qgu["texImage2D"](qgu["TEXTURE_2D"], 0, qgj["internalFormatFloat"], 1, 1, 0, qgj["textureFormatFloat"], qgj["textureTypeFloat"], null);
  const qgI = qgu["createFramebuffer"]();
  qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], qgI), qgu["framebufferTexture2D"](qgu["FRAMEBUFFER"], qgu["COLOR_ATTACHMENT0"], qgu["TEXTURE_2D"], qgL, 0);
  const qgb = qgu["checkFramebufferStatus"](qgu["FRAMEBUFFER"]) === qgu["FRAMEBUFFER_COMPLETE"];
  return qgu["bindTexture"](qgu["TEXTURE_2D"], null), qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], null), qgu["deleteTexture"](qgL), qgu["deleteFramebuffer"](qgI), qgb;
}
function dL(qgu, qgj) {
  const qgL = rH(qgu, qgj), qgI = qgu["createTexture"]();
  qgu["bindTexture"](qgu["TEXTURE_2D"], qgI), qgu["texImage2D"](qgu["TEXTURE_2D"], 0, qgL["internalFormatHalfFloat"], 1, 1, 0, qgL["textureFormatFloat"], qgL["textureTypeHalfFloat"], null);
  const qgb = qgu["createFramebuffer"]();
  qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], qgb), qgu["framebufferTexture2D"](qgu["FRAMEBUFFER"], qgu["COLOR_ATTACHMENT0"], qgu["TEXTURE_2D"], qgI, 0);
  const qgR = qgu["checkFramebufferStatus"](qgu["FRAMEBUFFER"]) === qgu["FRAMEBUFFER_COMPLETE"];
  return qgu["bindTexture"](qgu["TEXTURE_2D"], null), qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], null), qgu["deleteTexture"](qgI), qgu["deleteFramebuffer"](qgb), qgR;
}
function dQ(qgu) {
  return qgu !== 2 ? false : rW(qgu)["fenceSync"] != null;
}
function dH(qgu, qgj) {
  Array["isArray"](qgu) || (qgu = [qgu]), qgu["forEach"]((qgL) => {
    qgL != null && k(qgL["dtype"] !== "complex64", () => qgj + " does not support complex64 tensors in the WebGL backend.");
  });
}
var dK = qM();
dK["registerFlag"]("HAS_WEBGL", () => dK["getNumber"]("WEBGL_VERSION") > 0), dK["registerFlag"]("WEBGL_VERSION", () => dX(2) ? 2 : dX(1) ? 1 : 0), dK["registerFlag"]("WEBGL_CHECK_NUMERICAL_PROBLEMS", () => false), dK["registerFlag"]("WEBGL_BUFFER_SUPPORTED", () => dK["get"]("WEBGL_VERSION") === 2), dK["registerFlag"]("WEBGL_CPU_FORWARD", () => true), dK["registerFlag"]("WEBGL_FORCE_F16_TEXTURES", () => false), dK["registerFlag"]("WEBGL_PACK", () => dK["getBool"]("HAS_WEBGL")), dK["registerFlag"]("WEBGL_PACK_NORMALIZATION", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_CLIP", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_DEPTHWISECONV", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_BINARY_OPERATIONS", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_UNARY_OPERATIONS", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_ARRAY_OPERATIONS", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_IMAGE_OPERATIONS", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_REDUCE", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_LAZILY_UNPACK", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_CONV_IM2COL", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_PACK_CONV2DTRANSPOSE", () => dK["getBool"]("WEBGL_PACK")), dK["registerFlag"]("WEBGL_MAX_TEXTURE_SIZE", () => da(dK["getNumber"]("WEBGL_VERSION"))), dK["registerFlag"]("WEBGL_MAX_TEXTURES_IN_SHADER", () => dZ(dK["getNumber"]("WEBGL_VERSION"))), dK["registerFlag"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION", () => {
  const qgu = dK["getNumber"]("WEBGL_VERSION");
  return qgu === 0 ? 0 : de(qgu);
}), dK["registerFlag"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE", () => dK["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 && !fW()), dK["registerFlag"]("WEBGL_RENDER_FLOAT32_CAPABLE", () => dG(dK["getNumber"]("WEBGL_VERSION"))), dK["registerFlag"]("WEBGL_RENDER_FLOAT32_ENABLED", () => dK["getBool"]("WEBGL_FORCE_F16_TEXTURES") ? false : dK["getBool"]("WEBGL_RENDER_FLOAT32_CAPABLE")), dK["registerFlag"]("WEBGL_DOWNLOAD_FLOAT_ENABLED", () => du(dK["getNumber"]("WEBGL_VERSION"))), dK["registerFlag"]("WEBGL_FENCE_API_ENABLED", () => dQ(dK["getNumber"]("WEBGL_VERSION"))), dK["registerFlag"]("WEBGL_SIZE_UPLOAD_UNIFORM", () => dK["getBool"]("WEBGL_RENDER_FLOAT32_ENABLED") ? 4 : 0), dK["registerFlag"]("WEBGL_DELETE_TEXTURE_THRESHOLD", () => -1, (qgu) => {
  if (typeof qgu != "number") throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got " + qgu + ".");
  if (qgu < 0 && qgu !== -1) throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got " + qgu + ".");
}), dK["registerFlag"]("WEBGL_FLUSH_THRESHOLD", () => fW() ? 1 : -1, (qgu) => {
  if (typeof qgu != "number") throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got " + qgu + ".");
  if (qgu < 0 && qgu !== -1) throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got " + qgu + ".");
}), dK["registerFlag"]("CPU_HANDOFF_SIZE_THRESHOLD", () => 128), dK["registerFlag"]("WEBGL_USE_SHAPES_UNIFORMS", () => false), dK["registerFlag"]("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD", () => 1e5), dK["registerFlag"]("TOPK_K_CPU_HANDOFF_THRESHOLD", () => 128), dK["registerFlag"]("WEBGL_EXP_CONV", () => false), dK["registerFlag"]("SOFTWARE_WEBGL_ENABLED", () => dK["getBool"]("IS_TEST")), dK["registerFlag"]("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE", () => 1 / 0), dK["registerFlag"]("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE", () => false), dK["registerFlag"]("WEBGL2_ISNAN_CUSTOM", () => false), dK["registerFlag"]("ENGINE_COMPILE_ONLY", () => false);
function dB() {
  let qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd;
  return qM()["getNumber"]("WEBGL_VERSION") === 2 ? (qgu = "#version 300 es", qgj = "in", qgL = "out", qgI = "in", qgb = "texture", qgR = "outputColor", qgo = "out vec4 outputColor;", qgr = qM()["getBool"]("WEBGL2_ISNAN_CUSTOM") ? "\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    " : "", qgQ = "", qgd = "\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    ") : (qgu = "", qgj = "attribute", qgL = "varying", qgI = "varying", qgb = "texture2D", qgR = "gl_FragColor", qgo = "", qgr = "\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ", qgQ = "\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ", qgd = "\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "), { "version": qgu, "attribute": qgj, "varyingVs": qgL, "varyingFs": qgI, "texture2D": qgb, "output": qgR, "defineOutput": qgo, "defineSpecialNaN": qgr, "defineSpecialInf": qgQ, "defineRound": qgd };
}
function dV(qgu, qgj, qgL = "index") {
  const qgI = y(qgj);
  return qgI["map"]((qgb, qgR) => {
    const qgo = "int " + qgu[qgR] + " = " + qgL + " / " + qgb, qgr = qgR === qgI["length"] - 1 ? "int " + qgu[qgR + 1] + " = " + qgL + " - " + qgu[qgR] + " * " + qgb : "index -= " + qgu[qgR] + " * " + qgb;
    return qgo + "; " + qgr + ";";
  })["join"]("");
}
function dJ(qgu, qgj, qgL = "index") {
  const qgI = y(qgj);
  return qgI["map"]((qgb, qgR) => {
    const qgo = "int " + qgu[qgR] + " = " + qgL + " / outShapeStrides[" + qgR + "]", qgr = qgR === qgI["length"] - 1 ? "int " + qgu[qgR + 1] + " = " + qgL + " - " + qgu[qgR] + " * outShapeStrides[" + qgR + "]" : "index -= " + qgu[qgR] + " * outShapeStrides[" + qgR + "]";
    return qgo + "; " + qgr + ";";
  })["join"]("");
}
function dY(qgu, qgj) {
  const qgL = qgu["length"], qgI = qgu["map"]((qgR) => qgj + "[" + qgR + "]"), qgb = new Array(qgL - 1);
  qgb[qgL - 2] = qgI[qgL - 1];
  for (let qgR = qgL - 3; qgR >= 0; --qgR) qgb[qgR] = "(" + qgb[qgR + 1] + " * " + qgI[qgR + 1] + ")";
  return qgb;
}
function dP(qgu, qgj, qgL = "index") {
  const qgI = qgu["map"]((qgR, qgo) => qgo), qgb = dY(qgI, qgj);
  return qgb["map"]((qgR, qgo) => {
    const qgr = "int " + qgu[qgo] + " = " + qgL + " / " + qgb[qgo], qgQ = qgo === qgb["length"] - 1 ? "int " + qgu[qgo + 1] + " = " + qgL + " - " + qgu[qgo] + " * " + qgb[qgo] : "index -= " + qgu[qgo] + " * " + qgb[qgo];
    return qgr + "; " + qgQ + ";";
  })["join"]("");
}
function dU(qgu) {
  const qgj = y(qgu)["map"]((qgL) => qgL["toString"]());
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * " + qgj[0] + " + coords.y * " + qgj[1] + " + coords.z;\n  }\n";
}
function vq() {
  return "\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n";
}
var vM = "\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n";
var { getBroadcastDims: vF } = uQ;
function vW(qgu, qgj, qgL) {
  const qgI = [];
  if (qgu["forEach"]((qgl) => {
    const qgH = i2(qgl["shapeInfo"]["logicalShape"]);
    if (qgl["shapeInfo"]["isUniform"] ? qgI["push"]("uniform float " + qgl["name"] + (qgH > 1 ? "[" + qgH + "]" : "") + ";") : (qgI["push"]("uniform sampler2D " + qgl["name"] + ";"), qgI["push"]("uniform int offset" + qgl["name"] + ";")), qgL["enableShapeUniforms"]) {
      const { uniformShape: qgA } = Cq(qgL["packedInputs"], qgl["shapeInfo"]["logicalShape"], qgl["shapeInfo"]["texShape"]);
      switch (qgA["length"]) {
        case 1:
          qgI["push"]("uniform int " + qgl["name"] + "Shape;");
          break;
        case 2:
          qgI["push"]("uniform ivec2 " + qgl["name"] + "Shape;");
          break;
        case 3:
          qgI["push"]("uniform ivec3 " + qgl["name"] + "Shape;");
          break;
        case 4:
          qgI["push"]("uniform ivec4 " + qgl["name"] + "Shape;");
          break;
      }
      qgI["push"]("uniform ivec2 " + qgl["name"] + "TexShape;");
    }
  }), qgL["enableShapeUniforms"]) {
    switch (qgj["logicalShape"]["length"]) {
      case 1:
        qgI["push"]("uniform int outShape;");
        break;
      case 2:
        qgI["push"]("uniform ivec2 outShape;"), qgI["push"]("uniform int outShapeStrides;");
        break;
      case 3:
        qgI["push"]("uniform ivec3 outShape;"), qgI["push"]("uniform ivec2 outShapeStrides;");
        break;
      case 4:
        qgI["push"]("uniform ivec4 outShape;"), qgI["push"]("uniform ivec3 outShapeStrides;");
        break;
    }
    qgI["push"]("uniform ivec2 outTexShape;");
  }
  qgL["customUniforms"] && qgL["customUniforms"]["forEach"]((qgl) => {
    qgI["push"]("uniform " + qgl["type"] + " " + qgl["name"] + (qgl["arrayIndex"] ? "[" + qgl["arrayIndex"] + "]" : "") + ";");
  });
  const qgb = qgI["join"]("\n"), qgR = qgu["map"]((qgl) => vz(qgl, qgj, qgL["packedInputs"], qgL["enableShapeUniforms"]))["join"]("\n"), qgo = qgj["texShape"], qgr = dB(), qgQ = vu(qgr);
  let qgd, qgv, qgy = vQ(qgr);
  return qgj["isPacked"] ? (qgd = vX(qgj["logicalShape"], qgo, qgL["enableShapeUniforms"]), qgv = vL(qgr)) : (qgd = vG(qgj["logicalShape"], qgo, qgL["enableShapeUniforms"]), qgv = vj(qgr)), qgL["packedInputs"] && (qgy += vV), [qgy, qgQ, qgv, qgb, qgd, qgR, qgL["userCode"]]["join"]("\n");
}
function vD(qgu, qgj = false) {
  const qgL = qgu["shapeInfo"]["logicalShape"];
  switch (qgL["length"]) {
    case 0:
      return yz(qgu, qgj);
    case 1:
      return yG(qgu, qgj);
    case 2:
      return yj(qgu, qgj);
    case 3:
      return yQ(qgu, qgj);
    case 4:
      return yK(qgu, qgj);
    case 5:
      return yB(qgu);
    case 6:
      return yV(qgu);
    default:
      throw new Error(qgL["length"] + "-D input sampling is not yet supported");
  }
}
function vZ(qgu, qgj) {
  switch (qgu["shapeInfo"]["logicalShape"]["length"]) {
    case 0:
      return yZ(qgu);
    case 1:
      return yX(qgu, qgj);
    case 2:
      return yu(qgu, qgj);
    case 3:
      return yL(qgu, qgj);
    default:
      return yH(qgu, qgj);
  }
}
function vz(qgu, qgj, qgL = false, qgI) {
  let qgb = "";
  qgL ? qgb += vZ(qgu, qgI) : qgb += vD(qgu, qgI);
  const qgR = qgu["shapeInfo"]["logicalShape"], qgo = qgj["logicalShape"];
  return qgR["length"] <= qgo["length"] && (qgL ? qgb += yY(qgu, qgj) : qgb += yP(qgu, qgj)), qgb;
}
function vX(qgu, qgj, qgL) {
  switch (qgu["length"]) {
    case 0:
      return vJ();
    case 1:
      return vY(qgu, qgj, qgL);
    case 2:
      return yW(qgu, qgj, qgL);
    case 3:
      return vU(qgu, qgj, qgL);
    default:
      return ys(qgu, qgj, qgL);
  }
}
function vG(qgu, qgj, qgL) {
  switch (qgu["length"]) {
    case 0:
      return vJ();
    case 1:
      return vP(qgu, qgj, qgL);
    case 2:
      return yD(qgu, qgj, qgL);
    case 3:
      return yq(qgu, qgj, qgL);
    case 4:
      return yM(qgu, qgj, qgL);
    case 5:
      return yF(qgu, qgj);
    case 6:
      return yt(qgu, qgj);
    default:
      throw new Error(qgu["length"] + "-D output sampling is not yet supported");
  }
}
function vu(qgu) {
  return "\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return " + qgu["texture2D"] + "(textureSampler, uv).r;\n    }\n  ";
}
function vj(qgu) {
  return "\n    void setOutput(float val) {\n      " + qgu["output"] + " = vec4(val, 0, 0, 0);\n    }\n  ";
}
function vL(qgu) {
  return "\n    void setOutput(vec4 val) {\n      " + qgu["output"] + " = val;\n    }\n  ";
}
function vQ(qgu) {
  return qgu["version"] + "\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    " + qgu["varyingFs"] + " vec2 resultUV;\n    " + qgu["defineOutput"] + "\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    " + qgu["defineSpecialNaN"] + "\n    " + qgu["defineSpecialInf"] + "\n    " + qgu["defineRound"] + "\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    " + vH + "\n    " + vK + "\n    " + vB + "\n  ";
}
var vH = "\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var vK = "\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var vB = "\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n";
var vV = "\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";
function vJ() {
  return "\n    int getOutputCoords() {\n      return 0;\n    }\n  ";
}
function vY(qgu, qgj, qgL) {
  const qgI = [Math["ceil"](qgj[0] / 2), Math["ceil"](qgj[1] / 2)];
  return qgI[0] === 1 ? qgL ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * " + qgI[1] + ".0);\n      }\n    " : qgI[1] === 1 ? qgL ? "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    " : "\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * " + qgI[0] + ".0);\n      }\n    " : qgL ? "\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgI[0] + ", " + qgI[1] + "));\n      return 2 * (resTexRC.x * " + qgI[1] + " + resTexRC.y);\n    }\n  ";
}
function vP(qgu, qgj, qgL) {
  return qgj[0] === 1 ? qgL ? "\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.x * " + qgj[1] + ".0);\n      }\n    " : qgj[1] === 1 ? qgL ? "\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    " : "\n      int getOutputCoords() {\n        return int(resultUV.y * " + qgj[0] + ".0);\n      }\n    " : qgL ? "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  " : "\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgj[0] + ", " + qgj[1] + "));\n      return resTexRC.x * " + qgj[1] + " + resTexRC.y;\n    }\n  ";
}
function vU(qgu, qgj, qgL) {
  if (qgL) return "\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
  const qgI = [Math["ceil"](qgj[0] / 2), Math["ceil"](qgj[1] / 2)], qgb = Math["ceil"](qgu[2] / 2), qgR = qgb * Math["ceil"](qgu[1] / 2);
  return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgI[0] + ", " + qgI[1] + "));\n      int index = resTexRC.x * " + qgI[1] + " + resTexRC.y;\n\n      int b = index / " + qgR + ";\n      index -= b * " + qgR + ";\n\n      int r = 2 * (index / " + qgb + ");\n      int c = imod(index, " + qgb + ") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";
}
function yq(qgu, qgj, qgL) {
  if (qgL) return "\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    " + dJ(["r", "c", "d"], qgu) + "\n    return ivec3(r, c, d);\n  }\n";
  const qgI = dV(["r", "c", "d"], qgu);
  return "\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgj[0] + ", " + qgj[1] + "));\n      int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n      " + qgI + "\n      return ivec3(r, c, d);\n    }\n  ";
}
function ys(qgu, qgj, qgL) {
  if (qgL) return "\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";
  const qgI = [Math["ceil"](qgj[0] / 2), Math["ceil"](qgj[1] / 2)], qgb = Math["ceil"](qgu[qgu["length"] - 1] / 2), qgR = qgb * Math["ceil"](qgu[qgu["length"] - 2] / 2);
  let qgo = qgR, qgr = "", qgQ = "b, r, c";
  for (let qgd = 2; qgd < qgu["length"] - 1; qgd++) qgo *= qgu[qgu["length"] - qgd - 1], qgr = "\n      int b" + qgd + " = index / " + qgo + ";\n      index -= b" + qgd + " * " + qgo + ";\n    " + qgr, qgQ = "b" + qgd + ", " + qgQ;
  return "\n    ivec" + qgu["length"] + " getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgI[0] + ", " + qgI[1] + "));\n      int index = resTexRC.x * " + qgI[1] + " + resTexRC.y;\n\n      " + qgr + "\n\n      int b = index / " + qgR + ";\n      index -= b * " + qgR + ";\n\n      int r = 2 * (index / " + qgb + ");\n      int c = imod(index, " + qgb + ") * 2;\n\n      return ivec" + qgu["length"] + "(" + qgQ + ");\n    }\n  ";
}
function yM(qgu, qgj, qgL) {
  if (qgL) return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      " + dJ(["r", "c", "d", "d2"], qgu) + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
  const qgI = dV(["r", "c", "d", "d2"], qgu);
  return "\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + qgj[0] + ", " + qgj[1] + "));\n      int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n      " + qgI + "\n      return ivec4(r, c, d, d2);\n    }\n  ";
}
function yF(qgu, qgj) {
  const qgL = dV(["r", "c", "d", "d2", "d3"], qgu);
  return "\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(" + qgj[0] + ",\n                             " + qgj[1] + "));\n\n      int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n\n      " + qgL + "\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ";
}
function yt(qgu, qgj) {
  const qgL = dV(["r", "c", "d", "d2", "d3", "d4"], qgu);
  return "\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(" + qgj[0] + ", " + qgj[1] + "));\n      int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n\n      " + qgL + "\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ";
}
function yW(qgu, qgj, qgL) {
  const qgI = [Math["ceil"](qgj[0] / 2), Math["ceil"](qgj[1] / 2)];
  if (D(qgu, qgj)) return qgL ? "\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(" + qgI[0] + ", " + qgI[1] + "));\n      }\n    ";
  const qgb = Math["ceil"](qgu[1] / 2);
  return qgL ? "\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgI[0] + ", " + qgI[1] + "));\n\n      int index = resTexRC.x * " + qgI[1] + " + resTexRC.y;\n      int r = 2 * (index / " + qgb + ");\n      int c = imod(index, " + qgb + ") * 2;\n\n      return ivec2(r, c);\n    }\n  ";
}
function yD(qgu, qgj, qgL) {
  return D(qgu, qgj) ? qgL ? "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(" + qgj[0] + ", " + qgj[1] + "));\n      }\n    " : qgu[1] === 1 ? qgL ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + qgj[0] + ", " + qgj[1] + "));\n        int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    " : qgu[0] === 1 ? qgL ? "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : "\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(" + qgj[0] + ", " + qgj[1] + "));\n        int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n        return ivec2(0, index);\n      }\n    " : qgL ? "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  " : "\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(" + qgj[0] + ", " + qgj[1] + "));\n      int index = resTexRC.x * " + qgj[1] + " + resTexRC.y;\n      int r = index / " + qgu[1] + ";\n      int c = index - r * " + qgu[1] + ";\n      return ivec2(r, c);\n    }\n  ";
}
function ya(qgu) {
  return "offset" + qgu;
}
function yZ(qgu) {
  const qgj = qgu["name"], qgL = "get" + qgj["charAt"](0)["toUpperCase"]() + qgj["slice"](1), qgI = dB();
  return "\n    vec4 " + qgL + "() {\n      return " + qgI["texture2D"] + "(" + qgj + ", halfCR);\n    }\n  ";
}
function yz(qgu, qgj) {
  const qgL = qgu["name"], qgI = "get" + qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1);
  if (qgu["shapeInfo"]["isUniform"]) return "float " + qgI + "() {return " + qgL + ";}";
  const [qgb, qgR] = qgu["shapeInfo"]["texShape"];
  if (qgb === 1 && qgR === 1) return "\n      float " + qgI + "() {\n        return sampleTexture(" + qgL + ", halfCR);\n      }\n    ";
  const qgo = ya(qgL);
  if (qgj) return "\n    float " + qgI + "() {\n      vec2 uv = uvFromFlat(" + qgL + "TexShape[0], " + qgL + "TexShape[1], " + qgo + ");\n      return sampleTexture(" + qgL + ", uv);\n    }\n  ";
  const [qgr, qgQ] = qgu["shapeInfo"]["texShape"];
  return "\n    float " + qgI + "() {\n      vec2 uv = uvFromFlat(" + qgr + ", " + qgQ + ", " + qgo + ");\n      return sampleTexture(" + qgL + ", uv);\n    }\n  ";
}
function yX(qgu, qgj) {
  const qgL = qgu["name"], qgI = "get" + qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1), qgb = qgu["shapeInfo"]["texShape"], qgR = dB();
  if (qgj) return "\n    vec4 " + qgI + "(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(" + qgL + "TexShape[0]) / 2.0), ceil(float(" + qgL + "TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return " + qgR["texture2D"] + "(" + qgL + ", uv);\n    }\n  ";
  const qgo = [Math["ceil"](qgb[0] / 2), Math["ceil"](qgb[1] / 2)];
  return "\n    vec4 " + qgI + "(int index) {\n      vec2 uv = packedUVfrom1D(\n        " + qgo[0] + ", " + qgo[1] + ", index);\n      return " + qgR["texture2D"] + "(" + qgL + ", uv);\n    }\n  ";
}
function yG(qgu, qgj) {
  const qgL = qgu["name"], qgI = "get" + qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1);
  if (qgu["shapeInfo"]["isUniform"]) return "\n      float " + qgI + "(int index) {\n        " + yJ(qgu) + "\n      }\n    ";
  const qgb = qgu["shapeInfo"]["texShape"], qgR = qgb[0], qgo = qgb[1];
  if (qgo === 1 && qgR === 1) return "\n      float " + qgI + "(int index) {\n        return sampleTexture(" + qgL + ", halfCR);\n      }\n    ";
  const qgr = ya(qgL);
  return qgo === 1 ? qgj ? "\n      float " + qgI + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + qgr + ") + 0.5) / float(" + qgL + "TexShape[0]));\n        return sampleTexture(" + qgL + ", uv);\n      }\n    " : "\n      float " + qgI + "(int index) {\n        vec2 uv = vec2(0.5, (float(index + " + qgr + ") + 0.5) / " + qgR + ".0);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    " : qgR === 1 ? qgj ? "\n      float " + qgI + "(int index) {\n        vec2 uv = vec2((float(index + " + qgr + ") + 0.5) / float(" + qgL + "TexShape[1]), 0.5);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    " : "\n      float " + qgI + "(int index) {\n        vec2 uv = vec2((float(index + " + qgr + ") + 0.5) / " + qgo + ".0, 0.5);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    " : qgj ? "\n    float " + qgI + "(int index) {\n      vec2 uv = uvFromFlat(" + qgL + "TexShape[0], " + qgL + "TexShape[1], index + " + qgr + ");\n      return sampleTexture(" + qgL + ", uv);\n    }\n  " : "\n    float " + qgI + "(int index) {\n      vec2 uv = uvFromFlat(" + qgR + ", " + qgo + ", index + " + qgr + ");\n      return sampleTexture(" + qgL + ", uv);\n    }\n  ";
}
function yu(qgu, qgj) {
  const qgL = qgu["shapeInfo"]["logicalShape"], qgI = qgu["name"], qgb = "get" + qgI["charAt"](0)["toUpperCase"]() + qgI["slice"](1), qgR = qgu["shapeInfo"]["texShape"], qgo = qgR[0], qgr = qgR[1], qgQ = dB();
  if (qgR != null && D(qgL, qgR)) return qgj ? "\n      vec4 " + qgb + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + qgI + "TexShape[1], " + qgI + "TexShape[0]);\n\n        return " + qgQ["texture2D"] + "(" + qgI + ", uv);\n      }\n    " : "\n      vec4 " + qgb + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + qgr + ".0, " + qgo + ".0);\n\n        return " + qgQ["texture2D"] + "(" + qgI + ", uv);\n      }\n    ";
  if (qgj) return "\n    vec4 " + qgb + "(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(" + qgI + "TexShape[0]) / 2.0), ceil(float(" + qgI + "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(" + qgI + "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return " + qgQ["texture2D"] + "(" + qgI + ", uv);\n    }\n  ";
  const qgd = [Math["ceil"](qgR[0] / 2), Math["ceil"](qgR[1] / 2)], qgv = Math["ceil"](qgL[1] / 2);
  return "\n    vec4 " + qgb + "(int row, int col) {\n      vec2 uv = packedUVfrom2D(" + qgv + ", " + qgd[0] + ", " + qgd[1] + ", row, col);\n      return " + qgQ["texture2D"] + "(" + qgI + ", uv);\n    }\n  ";
}
function yj(qgu, qgj) {
  const qgL = qgu["shapeInfo"]["logicalShape"], qgI = qgu["name"], qgb = "get" + qgI["charAt"](0)["toUpperCase"]() + qgI["slice"](1), qgR = qgu["shapeInfo"]["texShape"];
  if (qgR != null && D(qgL, qgR)) {
    if (qgj) return "\n      float " + qgb + "(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(" + qgI + "TexShape[1], " + qgI + "TexShape[0]);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    ";
    const qgl = qgR[0], qgH = qgR[1];
    return "\n    float " + qgb + "(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(" + qgH + ".0, " + qgl + ".0);\n      return sampleTexture(" + qgI + ", uv);\n    }\n  ";
  }
  const { newShape: qgo, keptDims: qgr } = c(qgL), qgQ = qgo;
  if (qgQ["length"] < qgL["length"]) {
    const qgA = CM(qgu, qgQ), qgh = ["row", "col"];
    return "\n      " + vD(qgA, qgj) + "\n      float " + qgb + "(int row, int col) {\n        return " + qgb + "(" + CF(qgh, qgr) + ");\n      }\n    ";
  }
  if (qgu["shapeInfo"]["isUniform"]) return "\n      float " + qgb + "(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(" + qgL[1] + ", 1)));\n        " + yJ(qgu) + "\n      }\n    ";
  const qgd = qgR[0], qgv = qgR[1], qgy = ya(qgI);
  return qgv === 1 ? qgj ? "\n      float " + qgb + "(int row, int col) {\n        float index = dot(vec3(row, col, " + qgy + "), vec3(" + qgI + "Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(" + qgI + "TexShape[0]));\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n    float " + qgb + "(int row, int col) {\n      float index = dot(vec3(row, col, " + qgy + "), vec3(" + qgL[1] + ", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / " + qgd + ".0);\n      return sampleTexture(" + qgI + ", uv);\n    }\n  " : qgd === 1 ? qgj ? "\n      float " + qgb + "(int row, int col) {\n        float index = dot(vec3(row, col, " + qgy + "), vec3(" + qgI + "Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(" + qgI + "TexShape[1]), 0.5);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n    float " + qgb + "(int row, int col) {\n      float index = dot(vec3(row, col, " + qgy + "), vec3(" + qgL[1] + ", 1, 1));\n      vec2 uv = vec2((index + 0.5) / " + qgv + ".0, 0.5);\n      return sampleTexture(" + qgI + ", uv);\n    }\n  " : qgj ? "\n      float " + qgb + "(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + qgI + "Shape[1] + col + " + qgy + ";\n        vec2 uv = uvFromFlat(" + qgI + "TexShape[0], " + qgI + "TexShape[1], index);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n  float " + qgb + "(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * " + qgL[1] + " + col + " + qgy + ";\n    vec2 uv = uvFromFlat(" + qgd + ", " + qgv + ", index);\n    return sampleTexture(" + qgI + ", uv);\n  }\n";
}
function yL(qgu, qgj) {
  const qgL = qgu["shapeInfo"]["logicalShape"], qgI = qgu["name"], qgb = "get" + qgI["charAt"](0)["toUpperCase"]() + qgI["slice"](1), qgR = qgu["shapeInfo"]["texShape"], qgo = [Math["ceil"](qgR[0] / 2), Math["ceil"](qgR[1] / 2)];
  if (qgL[0] === 1) {
    const qgl = qgL["slice"](1), qgH = [1, 2], qgA = CM(qgu, qgl), qgh = ["b", "row", "col"];
    return "\n        " + vZ(qgA, qgj) + "\n        vec4 " + qgb + "(int b, int row, int col) {\n          return " + qgb + "(" + CF(qgh, qgH) + ");\n        }\n      ";
  }
  const qgr = dB();
  if (qgj) return "\n    vec4 " + qgb + "(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(" + qgI + "TexShape[0]) / 2.0), ceil(float(" + qgI + "TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(" + qgI + "Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(" + qgI + "Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return " + qgr["texture2D"] + "(" + qgI + ", uv);\n    }\n  ";
  const qgQ = qgo[0], qgd = qgo[1], qgv = Math["ceil"](qgL[2] / 2), qgy = qgv * Math["ceil"](qgL[1] / 2);
  return "\n    vec4 " + qgb + "(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        " + qgQ + ", " + qgd + ", " + qgy + ", " + qgv + ", b, row, col);\n      return " + qgr["texture2D"] + "(" + qgI + ", uv);\n    }\n  ";
}
function yQ(qgu, qgj) {
  const qgL = qgu["shapeInfo"]["logicalShape"], qgI = qgu["name"], qgb = "get" + qgI["charAt"](0)["toUpperCase"]() + qgI["slice"](1), qgR = qgL[1] * qgL[2], qgo = qgL[2], { newShape: qgr, keptDims: qgQ } = c(qgL), qgd = qgr;
  if (qgd["length"] < qgL["length"]) {
    const qgh = CM(qgu, qgd), qgT = ["row", "col", "depth"];
    return "\n        " + vD(qgh, qgj) + "\n        float " + qgb + "(int row, int col, int depth) {\n          return " + qgb + "(" + CF(qgT, qgQ) + ");\n        }\n      ";
  }
  if (qgu["shapeInfo"]["isUniform"]) return "\n      float " + qgb + "(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(" + qgR + ", " + qgo + ", 1)));\n        " + yJ(qgu) + "\n      }\n    ";
  const qgv = qgu["shapeInfo"]["texShape"], qgy = qgv[0], qgl = qgv[1], qgH = qgu["shapeInfo"]["flatOffset"];
  if (qgl === qgR && qgH == null) return qgj ? "\n      float " + qgb + "(int row, int col, int depth) {\n        int stride1 = " + qgI + "Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + qgI + "TexShape[1], " + qgI + "TexShape[0]);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n        float " + qgb + "(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(" + qgo + ", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(" + qgl + ".0, " + qgy + ".0);\n          return sampleTexture(" + qgI + ", uv);\n        }\n      ";
  if (qgl === qgo && qgH == null) return qgj ? "\n      float " + qgb + "(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(" + qgI + "Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + qgI + "TexShape[1], " + qgI + "TexShape[0]);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n    float " + qgb + "(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(" + qgL[1] + ", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + qgl + ".0, " + qgy + ".0);\n      return sampleTexture(" + qgI + ", uv);\n    }\n  ";
  const qgA = ya(qgI);
  return qgj ? "\n    float " + qgb + "(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = " + qgI + "Shape[1] * " + qgI + "Shape[2];\n      int stride1 = " + qgI + "Shape[2];\n      int index = row * stride0 + col * stride1 + depth + " + qgA + ";\n      vec2 uv = uvFromFlat(" + qgI + "TexShape[0], " + qgI + "TexShape[1], index);\n      return sampleTexture(" + qgI + ", uv);\n    }\n    " : "\n      float " + qgb + "(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * " + qgR + " + col * " + qgo + " + depth + " + qgA + ";\n        vec2 uv = uvFromFlat(" + qgy + ", " + qgl + ", index);\n        return sampleTexture(" + qgI + ", uv);\n      }\n  ";
}
function yH(qgu, qgj) {
  const qgL = qgu["name"], qgI = "get" + qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1), qgb = dB();
  if (qgj) return "\n    vec4 " + qgI + "(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(" + qgL + "Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(" + qgL + "Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= " + qgL + "Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(" + qgL + "TexShape[0]) / 2.0), ceil(float(" + qgL + "TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return " + qgb["texture2D"] + "(" + qgL + ", uv);\n    }\n  ";
  const qgR = qgu["shapeInfo"]["logicalShape"], qgo = qgR["length"], qgr = qgu["shapeInfo"]["texShape"], qgQ = [Math["ceil"](qgr[0] / 2), Math["ceil"](qgr[1] / 2)], qgd = qgQ[0], qgv = qgQ[1], qgy = Math["ceil"](qgR[qgo - 1] / 2);
  let qgl = qgy * Math["ceil"](qgR[qgo - 2] / 2), qgH = "int b, int row, int col", qgA = "b * " + qgl + " + (row / 2) * " + qgy + " + (col / 2)";
  for (let qgh = 2; qgh < qgo - 1; qgh++) qgH = "int b" + qgh + ", " + qgH, qgl *= qgR[qgo - qgh - 1], qgA = "b" + qgh + " * " + qgl + " + " + qgA;
  return "\n    vec4 " + qgI + "(" + qgH + ") {\n      int index = " + qgA + ";\n      int texR = index / " + qgv + ";\n      int texC = index - texR * " + qgv + ";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + qgv + ", " + qgd + ");\n      return " + qgb["texture2D"] + "(" + qgL + ", uv);\n    }\n  ";
}
function yK(qgu, qgj) {
  const qgL = qgu["shapeInfo"]["logicalShape"], qgI = qgu["name"], qgb = "get" + qgI["charAt"](0)["toUpperCase"]() + qgI["slice"](1), qgR = qgL[3], qgo = qgL[2] * qgR, qgr = qgL[1] * qgo, { newShape: qgQ, keptDims: qgd } = c(qgL);
  if (qgQ["length"] < qgL["length"]) {
    const qgB = CM(qgu, qgQ), qgV = ["row", "col", "depth", "depth2"];
    return "\n      " + vD(qgB, qgj) + "\n      float " + qgb + "(int row, int col, int depth, int depth2) {\n        return " + qgb + "(" + CF(qgV, qgd) + ");\n      }\n    ";
  }
  if (qgu["shapeInfo"]["isUniform"]) return "\n      float " + qgb + "(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(" + qgr + ", " + qgo + ", " + qgR + ", 1)));\n        " + yJ(qgu) + "\n      }\n    ";
  const qgv = qgu["shapeInfo"]["flatOffset"], qgy = qgu["shapeInfo"]["texShape"], qgl = qgy[0], qgH = qgy[1], qgA = "int stride2 = " + qgI + "Shape[3];", qgh = "int stride1 = " + qgI + "Shape[2] * stride2;", qgT = "int stride0 = " + qgI + "Shape[1] * stride1;";
  if (qgH === qgr && qgv == null) return qgj ? "\n      float " + qgb + "(int row, int col, int depth, int depth2) {\n        " + qgA + "\n        " + qgh + "\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + qgI + "TexShape[1], " + qgI + "TexShape[0]);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n      float " + qgb + "(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(" + qgo + ", " + qgR + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + qgH + ".0, " + qgl + ".0);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    ";
  if (qgH === qgR && qgv == null) return qgj ? "\n      float " + qgb + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + qgI + "Shape[1] * " + qgI + "Shape[2], " + qgI + "Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + qgI + "TexShape[1], " + qgI + "TexShape[0]);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    " : "\n      float " + qgb + "(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(" + qgL[1] * qgL[2] + ", " + qgL[2] + ", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + qgH + ".0, " + qgl + ".0);\n        return sampleTexture(" + qgI + ", uv);\n      }\n    ";
  const qgK = ya(qgI);
  return qgj ? "\n    float " + qgb + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      " + qgA + "\n      " + qgh + "\n      " + qgT + "\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(" + qgI + "TexShape[0], " + qgI + "TexShape[1], index + " + qgK + ");\n      return sampleTexture(" + qgI + ", uv);\n    }\n  " : "\n    float " + qgb + "(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + qgr + " + col * " + qgo + " +\n          depth * " + qgR + " + depth2;\n      vec2 uv = uvFromFlat(" + qgl + ", " + qgH + ", index + " + qgK + ");\n      return sampleTexture(" + qgI + ", uv);\n    }\n  ";
}
function yB(qgu) {
  const qgj = qgu["shapeInfo"]["logicalShape"], qgL = qgu["name"], qgI = "get" + qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1), qgb = qgj[4], qgR = qgj[3] * qgb, qgo = qgj[2] * qgR, qgr = qgj[1] * qgo, { newShape: qgQ, keptDims: qgd } = c(qgj);
  if (qgQ["length"] < qgj["length"]) {
    const qgh = CM(qgu, qgQ), qgT = ["row", "col", "depth", "depth2", "depth3"];
    return "\n      " + vD(qgh) + "\n      float " + qgI + "(int row, int col, int depth, int depth2, int depth3) {\n        return " + qgI + "(" + CF(qgT, qgd) + ");\n      }\n    ";
  }
  if (qgu["shapeInfo"]["isUniform"]) return "\n      float " + qgI + "(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + qgr + ", " + qgo + ", " + qgR + ", " + qgb + ")) +\n          depth3;\n        " + yJ(qgu) + "\n      }\n    ";
  const qgv = qgu["shapeInfo"]["flatOffset"], qgy = qgu["shapeInfo"]["texShape"], qgl = qgy[0], qgH = qgy[1];
  if (qgH === qgr && qgv == null) return "\n      float " + qgI + "(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(" + qgo + ", " + qgR + ", " + qgb + ", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + qgH + ".0, " + qgl + ".0);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    ";
  if (qgH === qgb && qgv == null) return "\n      float " + qgI + "(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + qgj[1] * qgj[2] * qgj[3] + ",\n               " + qgj[2] * qgj[3] + ", " + qgj[3] + ", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + qgH + ".0, " + qgl + ".0);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    ";
  const qgA = ya(qgL);
  return "\n    float " + qgI + "(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + qgr + " + col * " + qgo + " + depth * " + qgR + " +\n          depth2 * " + qgb + " + depth3 + " + qgA + ";\n      vec2 uv = uvFromFlat(" + qgl + ", " + qgH + ", index);\n      return sampleTexture(" + qgL + ", uv);\n    }\n  ";
}
function yV(qgu) {
  const qgj = qgu["shapeInfo"]["logicalShape"], qgL = qgu["name"], qgI = "get" + qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1), { newShape: qgb, keptDims: qgR } = c(qgj);
  if (qgb["length"] < qgj["length"]) {
    const qgT = CM(qgu, qgb), qgK = ["row", "col", "depth", "depth2", "depth3", "depth4"];
    return "\n      " + vD(qgT) + "\n      float " + qgI + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return " + qgI + "(" + CF(qgK, qgR) + ");\n      }\n    ";
  }
  const qgo = qgj[5], qgr = qgj[4] * qgo, qgQ = qgj[3] * qgr, qgd = qgj[2] * qgQ, qgv = qgj[1] * qgd;
  if (qgu["shapeInfo"]["isUniform"]) return "\n      float " + qgI + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(" + qgv + ", " + qgd + ", " + qgQ + ", " + qgr + ")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(" + qgo + ", 1)));\n        " + yJ(qgu) + "\n      }\n    ";
  const qgy = qgu["shapeInfo"]["flatOffset"], qgl = qgu["shapeInfo"]["texShape"], qgH = qgl[0], qgA = qgl[1];
  if (qgA === qgv && qgy == null) return "\n      float " + qgI + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(" + qgd + ", " + qgQ + ", " + qgr + ", " + qgo + ")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(" + qgA + ".0, " + qgH + ".0);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    ";
  if (qgA === qgo && qgy == null) return "\n      float " + qgI + "(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(" + qgj[1] * qgj[2] * qgj[3] * qgj[4] + ",\n               " + qgj[2] * qgj[3] * qgj[4] + ",\n               " + qgj[3] * qgj[4] + ",\n               " + qgj[4] + ")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(" + qgA + ".0, " + qgH + ".0);\n        return sampleTexture(" + qgL + ", uv);\n      }\n    ";
  const qgh = ya(qgL);
  return "\n    float " + qgI + "(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * " + qgv + " + col * " + qgd + " + depth * " + qgQ + " +\n          depth2 * " + qgr + " + depth3 * " + qgo + " + depth4 + " + qgh + ";\n      vec2 uv = uvFromFlat(" + qgH + ", " + qgA + ", index);\n      return sampleTexture(" + qgL + ", uv);\n    }\n  ";
}
function yJ(qgu) {
  const qgj = qgu["name"], qgL = i2(qgu["shapeInfo"]["logicalShape"]);
  return qgL < 2 ? "return " + qgj + ";" : "\n    for (int i = 0; i < " + qgL + "; i++) {\n      if (i == index) {\n        return " + qgj + "[i];\n      }\n    }\n  ";
}
function yY(qgu, qgj) {
  const qgL = qgu["name"], qgI = qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1), qgb = "get" + qgI + "AtOutCoords", qgR = qgu["shapeInfo"]["logicalShape"]["length"], qgo = qgj["logicalShape"]["length"], qgr = vF(qgu["shapeInfo"]["logicalShape"], qgj["logicalShape"]), qgQ = yU(qgo), qgd = qgo - qgR;
  let qgv;
  const qgy = ["x", "y", "z", "w", "u", "v"];
  qgR === 0 ? qgv = "" : qgo < 2 && qgr["length"] >= 1 ? qgv = "coords = 0;" : qgv = qgr["map"]((qgT) => "coords." + qgy[qgT + qgd] + " = 0;")["join"]("\n");
  let qgl = "";
  qgo < 2 && qgR > 0 ? qgl = "coords" : qgl = qgu["shapeInfo"]["logicalShape"]["map"]((qgT, qgK) => "coords." + qgy[qgK + qgd])["join"](", ");
  let qgH = "return outputValue;";
  const qgA = i2(qgu["shapeInfo"]["logicalShape"]) === 1, qgh = i2(qgj["logicalShape"]) === 1;
  if (qgR === 1 && !qgA && !qgh) qgH = "\n      return vec4(outputValue.xy, outputValue.xy);\n    ";
  else {
    if (qgA && !qgh) qgo === 1 ? qgH = "\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      " : qgH = "\n        return vec4(outputValue.x);\n      ";
    else {
      if (qgr["length"]) {
        const qgT = qgR - 2, qgK = qgR - 1;
        qgr["indexOf"](qgT) > -1 && qgr["indexOf"](qgK) > -1 ? qgH = "return vec4(outputValue.x);" : qgr["indexOf"](qgT) > -1 ? qgH = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : qgr["indexOf"](qgK) > -1 && (qgH = "return vec4(outputValue.xx, outputValue.zz);");
      }
    }
  }
  return "\n    vec4 " + qgb + "() {\n      " + qgQ + " coords = getOutputCoords();\n      " + qgv + "\n      vec4 outputValue = get" + qgI + "(" + qgl + ");\n      " + qgH + "\n    }\n  ";
}
function yP(qgu, qgj) {
  const qgL = qgu["name"], qgI = qgL["charAt"](0)["toUpperCase"]() + qgL["slice"](1), qgb = "get" + qgI + "AtOutCoords", qgR = qgj["texShape"], qgo = qgu["shapeInfo"]["texShape"], qgr = qgu["shapeInfo"]["logicalShape"]["length"], qgQ = qgj["logicalShape"]["length"];
  if (!qgu["shapeInfo"]["isUniform"] && qgr === qgQ && qgu["shapeInfo"]["flatOffset"] == null && D(qgo, qgR)) return "\n      float " + qgb + "() {\n        return sampleTexture(" + qgL + ", resultUV);\n      }\n    ";
  const qgd = yU(qgQ), qgv = vF(qgu["shapeInfo"]["logicalShape"], qgj["logicalShape"]), qgy = qgQ - qgr;
  let qgl;
  const qgH = ["x", "y", "z", "w", "u", "v"];
  qgr === 0 ? qgl = "" : qgQ < 2 && qgv["length"] >= 1 ? qgl = "coords = 0;" : qgl = qgv["map"]((qgh) => "coords." + qgH[qgh + qgy] + " = 0;")["join"]("\n");
  let qgA = "";
  return qgQ < 2 && qgr > 0 ? qgA = "coords" : qgA = qgu["shapeInfo"]["logicalShape"]["map"]((qgh, qgT) => "coords." + qgH[qgT + qgy])["join"](", "), "\n    float " + qgb + "() {\n      " + qgd + " coords = getOutputCoords();\n      " + qgl + "\n      return get" + qgI + "(" + qgA + ");\n    }\n  ";
}
function yU(qgu) {
  if (qgu <= 1) return "int";
  if (qgu === 2) return "ivec2";
  if (qgu === 3) return "ivec3";
  if (qgu === 4) return "ivec4";
  if (qgu === 5) return "ivec5";
  if (qgu === 6) return "ivec6";
  throw Error("GPU for rank " + qgu + " is not yet supported");
}
function Cq(qgu, qgj, qgL) {
  const { newShape: qgI, keptDims: qgb } = c(qgj), qgR = qgj["length"], qgo = qgu && qgR === 3 && qgj[0] === 1, qgr = qgo ? qgj["slice"](1) : qgI, qgQ = !qgu && qgR > 1 && !D(qgj, qgL) && qgI["length"] < qgR || qgo;
  return { "useSqueezeShape": qgQ, "uniformShape": qgQ ? qgr : qgj, "keptDims": qgb };
}
function CM(qgu, qgj) {
  const qgL = JSON["parse"](JSON["stringify"](qgu));
  return qgL["shapeInfo"]["logicalShape"] = qgj, qgL;
}
function CF(qgu, qgj) {
  return qgj["map"]((qgL) => qgu[qgL])["join"](", ");
}
function CW(qgu, qgj, qgL, qgI) {
  const qgb = qgL["map"]((qgv, qgy) => {
    const qgl = { "logicalShape": qgv["shape"], "texShape": qgv["isUniform"] ? null : qgv["texData"]["texShape"], "isUniform": qgv["isUniform"], "isPacked": qgv["isUniform"] ? false : qgv["texData"]["isPacked"], "flatOffset": null };
    return qgv["texData"] != null && qgv["texData"]["slice"] != null && qgv["texData"]["slice"]["flatOffset"] > 0 && (qgl["flatOffset"] = qgv["texData"]["slice"]["flatOffset"]), { "name": qgj["variableNames"][qgy], "shapeInfo": qgl };
  }), qgR = qgb["map"]((qgv) => qgv["shapeInfo"]), qgo = { "logicalShape": qgI["shape"], "texShape": qgI["texData"]["texShape"], "isUniform": false, "isPacked": qgI["texData"]["isPacked"], "flatOffset": null }, qgr = vW(qgb, qgo, qgj), qgQ = QM(qgu["gl"], qgr), qgd = qgu["createProgram"](qgQ);
  return qM()["get"]("ENGINE_COMPILE_ONLY") ? { "program": qgj, "fragmentShader": qgQ, "source": qgr, "webGLProgram": qgd, "inShapeInfos": qgR, "outShapeInfo": qgo, "variablesLocations": null, "customUniformLocations": null, "infLoc": null, "nanLoc": null, "outShapeLocation": null, "outShapeStridesLocation": null, "outTexShapeLocation": null } : (qgu["buildVao"](qgd), Object["assign"]({ "program": qgj, "fragmentShader": qgQ, "source": qgr, "webGLProgram": qgd, "inShapeInfos": qgR, "outShapeInfo": qgo }, CD(qgu, qgj, qgd)));
}
function CD(qgu, qgj, qgL) {
  const qgI = [], qgb = [];
  let qgR, qgo, qgr, qgQ = null, qgd = null;
  qgd = qgu["getUniformLocation"](qgL, "NAN", false), qM()["getNumber"]("WEBGL_VERSION") === 1 && (qgQ = qgu["getUniformLocation"](qgL, "INFINITY", false));
  const qgv = false;
  for (const qgy of qgj["variableNames"]) {
    const qgl = { "name": qgy, "uniform": qgu["getUniformLocation"](qgL, qgy, qgv), "offset": qgu["getUniformLocation"](qgL, "offset" + qgy, qgv) };
    qgj["enableShapeUniforms"] && (qgl["shape"] = qgu["getUniformLocation"](qgL, qgy + "Shape", qgv), qgl["texShape"] = qgu["getUniformLocation"](qgL, qgy + "TexShape", qgv)), qgI["push"](qgl);
  }
  if (qgj["enableShapeUniforms"] && (qgR = qgu["getUniformLocation"](qgL, "outShape", qgv), qgr = qgu["getUniformLocation"](qgL, "outShapeStrides", qgv), qgo = qgu["getUniformLocation"](qgL, "outTexShape", qgv)), qgj["customUniforms"]) {
    for (const qgH of qgj["customUniforms"]) qgb["push"](qgu["getUniformLocation"](qgL, qgH["name"], qgv));
  }
  return { "variablesLocations": qgI, "customUniformLocations": qgb, "infLoc": qgQ, "nanLoc": qgd, "outShapeLocation": qgR, "outShapeStridesLocation": qgr, "outTexShapeLocation": qgo };
}
function CZ(qgu, qgj) {
  if (qgu["length"] !== qgj["length"]) throw Error("Binary was compiled with " + qgu["length"] + " inputs, but was executed with " + qgj["length"] + " inputs");
  qgu["forEach"]((qgL, qgI) => {
    const qgb = qgL["logicalShape"], qgR = qgj[qgI], qgo = qgR["shape"];
    if (!D(qgb, qgo)) throw Error("Binary was compiled with different shapes than the current args. Shapes " + qgb + " and " + qgo + " must match");
    if (qgL["isUniform"] && qgR["isUniform"]) return;
    const qgr = qgL["texShape"], qgQ = qgR["isUniform"] ? null : qgR["texData"]["texShape"];
    if (!D(qgr, qgQ)) throw Error("Binary was compiled with different texture shapes than the current args. Shape " + qgr + " and " + qgQ + " must match");
  });
}
function Cz(qgu, qgj, qgL, qgI, qgb) {
  qgj["program"]["enableShapeUniforms"] || (CZ(qgj["inShapeInfos"], qgL), CZ([qgj["outShapeInfo"]], [qgI]));
  const qgR = qgI["texData"]["texture"], qgo = qgI["texData"]["texShape"];
  qgI["texData"]["isPacked"] ? qgu["setOutputPackedMatrixTexture"](qgR["texture"], qgo[0], qgo[1]) : qgu["setOutputMatrixTexture"](qgR["texture"], qgo[0], qgo[1]), qgu["setProgram"](qgj["webGLProgram"]), qgu["bindVertexArray"](qgj["webGLProgram"]["vao"]), qM()["getNumber"]("WEBGL_VERSION") === 1 && qgj["infLoc"] !== null && qgu["gl"]["uniform1f"](qgj["infLoc"], 1 / 0), qgj["nanLoc"] !== null && qgu["gl"]["uniform1f"](qgj["nanLoc"], NaN);
  for (let qgQ = 0; qgQ < qgL["length"]; ++qgQ) {
    const qgd = qgL[qgQ], { uniform: qgv, offset: qgy, shape: qgl, texShape: qgH } = qgj["variablesLocations"][qgQ];
    if (qgl) {
      const { uniformShape: qgA } = Cq(qgj["program"]["packedInputs"], qgd["shape"], qgd["texData"]["texShape"]);
      switch (qgA["length"]) {
        case 1:
          qgu["gl"]["uniform1iv"](qgl, new Int32Array(qgA));
          break;
        case 2:
          qgu["gl"]["uniform2iv"](qgl, new Int32Array(qgA));
          break;
        case 3:
          qgu["gl"]["uniform3iv"](qgl, new Int32Array(qgA));
          break;
        case 4:
          qgu["gl"]["uniform4iv"](qgl, new Int32Array(qgA));
          break;
      }
    }
    if (qgH && qgu["gl"]["uniform2i"](qgH, qgd["texData"]["texShape"][0], qgd["texData"]["texShape"][1]), qgv != null) {
      if (qgd["isUniform"]) {
        if (i2(qgd["shape"]) < 2) qgu["gl"]["uniform1f"](qgv, qgd["uniformValues"][0]);
        else {
          let qgh = qgd["uniformValues"];
          qgh instanceof Float32Array || (qgh = new Float32Array(qgh)), qgu["gl"]["uniform1fv"](qgv, qgh);
        }
        continue;
      }
      qgd["texData"]["slice"] != null && qgy != null && qgu["gl"]["uniform1i"](qgy, qgd["texData"]["slice"]["flatOffset"]), qgu["setInputMatrixTexture"](qgd["texData"]["texture"]["texture"], qgv, qgQ);
    }
  }
  const qgr = qgj["outShapeLocation"];
  if (qgr) switch (qgI["shape"]["length"]) {
    case 1:
      qgu["gl"]["uniform1iv"](qgr, new Int32Array(qgI["shape"]));
      break;
    case 2:
      qgu["gl"]["uniform2iv"](qgr, new Int32Array(qgI["shape"]));
      break;
    case 3:
      qgu["gl"]["uniform3iv"](qgr, new Int32Array(qgI["shape"]));
      break;
    case 4:
      qgu["gl"]["uniform4iv"](qgr, new Int32Array(qgI["shape"]));
      break;
  }
  if (qgj["outShapeStridesLocation"]) {
    const qgT = y(qgI["shape"]);
    switch (qgI["shape"]["length"]) {
      case 2:
        qgu["gl"]["uniform1iv"](qgj["outShapeStridesLocation"], new Int32Array(qgT));
        break;
      case 3:
        qgu["gl"]["uniform2iv"](qgj["outShapeStridesLocation"], new Int32Array(qgT));
        break;
      case 4:
        qgu["gl"]["uniform3iv"](qgj["outShapeStridesLocation"], new Int32Array(qgT));
        break;
    }
  }
  if (qgj["outTexShapeLocation"] && qgu["gl"]["uniform2i"](qgj["outTexShapeLocation"], qgI["texData"]["texShape"][0], qgI["texData"]["texShape"][1]), qgj["program"]["customUniforms"] && qgb) for (let qgK = 0; qgK < qgj["program"]["customUniforms"]["length"]; ++qgK) {
    const qgB = qgj["program"]["customUniforms"][qgK], qgV = qgj["customUniformLocations"][qgK], qgJ = qgb[qgK];
    if (qgB["type"] === "float") qgu["gl"]["uniform1fv"](qgV, qgJ);
    else {
      if (qgB["type"] === "vec2") qgu["gl"]["uniform2fv"](qgV, qgJ);
      else {
        if (qgB["type"] === "vec3") qgu["gl"]["uniform3fv"](qgV, qgJ);
        else {
          if (qgB["type"] === "vec4") qgu["gl"]["uniform4fv"](qgV, qgJ);
          else {
            if (qgB["type"] === "int") qgu["gl"]["uniform1iv"](qgV, qgJ);
            else {
              if (qgB["type"] === "ivec2") qgu["gl"]["uniform2iv"](qgV, qgJ);
              else {
                if (qgB["type"] === "ivec3") qgu["gl"]["uniform3iv"](qgV, qgJ);
                else {
                  if (qgB["type"] === "ivec4") qgu["gl"]["uniform4iv"](qgV, qgJ);
                  else throw Error("uniform type " + qgB["type"] + " is not supported yet.");
                }
              }
            }
          }
        }
      }
    }
  }
  qgu["executeProgram"]();
}
function CX(qgu, qgj, qgL) {
  let qgI = "";
  qgj["concat"](qgL)["forEach"]((qgo) => {
    const qgr = qgo["texData"] != null && qgo["texData"]["slice"] != null && qgo["texData"]["slice"]["flatOffset"] > 0;
    if (qgu["enableShapeUniforms"] && !qgo["isUniform"]) {
      const qgQ = qgo["texData"]["texShape"], { useSqueezeShape: qgd, uniformShape: qgv, keptDims: qgy } = Cq(qgu["packedInputs"], qgo["shape"], qgQ);
      let qgl = "", qgH = "", qgA = "";
      if (qgv["length"] === 1 && qgu["packedInputs"]) {
        const qgY = [Math["ceil"](qgQ[0] / 2), Math["ceil"](qgQ[1] / 2)];
        qgl = (qgY[0] > 1) + "_" + (qgY[1] > 1);
      } else {
        if (qgv["length"] === 2 && !qgu["packedInputs"]) qgH = (qgv[0] > 1) + "_" + (qgv[1] > 1);
        else {
          if (qgv["length"] > 2 && !qgu["packedInputs"]) {
            const qgP = y(qgv);
            qgA = (qgP[0] === qgQ[1]) + "_" + (qgP[qgP["length"] - 1] === qgQ[1]);
          }
        }
      }
      const qgh = qgo["shape"]["length"], qgT = qgv["length"] === 2 && D(qgo["shape"], qgQ), qgK = i2(qgo["shape"]) === 1, qgB = Oj(qgo["shape"], qgL["shape"]), qgV = !qgu["packedInputs"] && qgh === qgL["shape"]["length"] && D(qgQ, qgL["texData"]["texShape"]), qgJ = qgu["packedInputs"] || qgv["length"] > 2 ? "" : (qgQ[0] > 1) + "_" + (qgQ[1] > 1);
      qgI += qgh + "_" + qgV + "_" + (qgd ? qgy : "") + "_" + qgv["length"] + "_" + qgK + "_" + qgB + "_" + qgT + "_" + qgl + "_" + qgH + "_" + qgA + "_" + qgJ + "_" + qgr;
    } else {
      const qgU = qgo["isUniform"] ? "uniform" : qgo["texData"]["texShape"];
      qgI += qgo["shape"] + "_" + qgU + "_" + qgr;
    }
  });
  const qgb = qgu["userCode"];
  let qgR = qgu["constructor"]["name"];
  return qgR += "_" + qgI + "_" + qgb + ("" + qM()["getNumber"]("WEBGL_VERSION")), qgR;
}
function CG(qgu) {
  return qM()["getBool"]("WEBGL_USE_SHAPES_UNIFORMS") && qgu <= 4;
}
var Cu = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["packedInputs"] = false, this["packedOutput"] = true, this["outPackingScheme"] = rz["DENSE"], this["customUniforms"] = [{ "name": "texShape", "type": "ivec2" }];
    const qgj = dB();
    this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]), this["userCode"] = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + (this["enableShapeUniforms"] ? dJ(["r", "c", "d"], qgu) : dV(["r", "c", "d"], qgu)) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        " + qgj["output"] + " = result;\n      }\n    ";
  }
};
var Cj = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true, this["outPackingScheme"] = rz["DENSE"], this["customUniforms"] = [{ "name": "texShape", "type": "ivec2" }];
    const qgj = dB();
    this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]), this["userCode"] = "\n      ivec3 outCoordsFromFlatIndex(int index) {\n        " + (this["enableShapeUniforms"] ? dJ(["r", "c", "d"], qgu) : dV(["r", "c", "d"], qgu)) + "\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        " + qgj["output"] + " = result;\n      }\n    ";
  }
};
var CL = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["outTexUsage"] = rX["DOWNLOAD"];
    const qgj = dB();
    this["outputShape"] = qgu, this["userCode"] = "\n      " + vM + "\n\n      void main() {\n        float x = getAAtOutCoords();\n        " + qgj["output"] + " = encode_float(x);\n      }\n    ";
  }
};
var CQ = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = false, this["outTexUsage"] = rX["DOWNLOAD"];
    const qgj = dB();
    this["outputShape"] = qgu, this["userCode"] = "\n      " + vM + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        " + qgj["output"] + " = encode_float(x);\n      }\n    ";
  }
};
var CH = { "R": 0, "G": 1, "B": 2, "A": 3 };
var CK = class {
  constructor(qgu, qgj = false, qgL = "RGBA") {
    this["variableNames"] = ["A"], this["customUniforms"] = [{ "name": "texShape", "type": "ivec2" }];
    const qgI = dB();
    this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    let qgb = "result";
    qgj && (qgb = "floor(result * 255. + 0.5)");
    let qgR = "";
    for (let qgo = 0; qgo < qgL["length"]; qgo++) {
      const qgr = qgL[qgo];
      qgR += "\n          if(offset == " + qgo + ") {\n            result = values[" + CH[qgr] + "];\n          }";
    }
    this["userCode"] = "\n      " + (this["enableShapeUniforms"] ? vq() : dU(qgu)) + "\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, " + qgL["length"] + ");\n\n        flatIndex = idiv(flatIndex, " + qgL["length"] + ", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = " + qgI["texture2D"] + "(A, uv);\n          " + qgR + "\n        }\n        " + qgI["output"] + " = vec4(" + qgb + ", 0., 0., 0.);\n      }\n    ";
  }
};
var CB = class {
  constructor(qgu, qgj = false) {
    this["variableNames"] = ["A"], this["packedInputs"] = false, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "texShape", "type": "ivec2" }];
    const qgL = dB();
    this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    let qgI = "", qgb = "result";
    qgj && (qgb = "floor(result * 255. + 0.5)");
    for (let qgR = 0; qgR <= 1; qgR++) for (let qgo = 0; qgo <= 1; qgo++) {
      const qgr = qgR * 2 + qgo;
      qgI += "\n          localCoords = coords;\n          if(localCoords[2] + " + qgo + " < " + (this["enableShapeUniforms"] ? "outShape[2]" : "" + qgu[2]) + ") {\n          localCoords[2] += " + qgo + ";\n          if (localCoords[1] + " + qgR + " < " + (this["enableShapeUniforms"] ? "outShape[1]" : "" + qgu[1]) + ") {\n            localCoords[1] += " + qgR + ";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = " + qgL["texture2D"] + "(A, uv);\n\n            if (offset == 0) {\n              result[" + qgr + "] = values[0];\n            } else if (offset == 1) {\n              result[" + qgr + "] = values[1];\n            } else if (offset == 2) {\n              result[" + qgr + "] = values[2];\n            } else {\n              result[" + qgr + "] = values[3];\n            }\n          }\n        }\n        ";
    }
    this["userCode"] = "\n        " + (this["enableShapeUniforms"] ? vq() : dU(qgu)) + "\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          " + qgI + "\n\n          " + qgL["output"] + " = " + qgb + ";\n        }\n    ";
  }
};
function CV(qgu) {
  const qgj = dB(), qgL = qgj["version"] + "\n    precision highp float;\n    " + qgj["attribute"] + " vec3 clipSpacePos;\n    " + qgj["attribute"] + " vec2 uv;\n    " + qgj["varyingVs"] + " vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }";
  return Qq(qgu, qgL);
}
function CJ(qgu) {
  const qgj = new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
  return Qz(qgu, qgj);
}
function CY(qgu) {
  const qgj = new Uint16Array([0, 1, 2, 2, 1, 3]);
  return QX(qgu, qgj);
}
function CP(qgu, qgj, qgL, qgI, qgb, qgR) {
  Qj(qgj, qgL);
  const qgo = QG(qgu), qgr = qgu["TEXTURE_2D"];
  return rK(qgu, () => qgu["bindTexture"](qgr, qgo)), rK(qgu, () => qgu["texParameteri"](qgr, qgu["TEXTURE_WRAP_S"], qgu["CLAMP_TO_EDGE"])), rK(qgu, () => qgu["texParameteri"](qgr, qgu["TEXTURE_WRAP_T"], qgu["CLAMP_TO_EDGE"])), rK(qgu, () => qgu["texParameteri"](qgr, qgu["TEXTURE_MIN_FILTER"], qgu["NEAREST"])), rK(qgu, () => qgu["texParameteri"](qgr, qgu["TEXTURE_MAG_FILTER"], qgu["NEAREST"])), qM()["getNumber"]("WEBGL_VERSION") === 1 ? rK(qgu, () => qgu["texImage2D"](qgr, 0, qgI, qgj, qgL, 0, qgb, qgR, null)) : rK(qgu, () => qgu["texStorage2D"](qgr, 1, qgI, qgj, qgL)), rK(qgu, () => qgu["bindTexture"](qgu["TEXTURE_2D"], null)), { "texture": qgo, "texShape": [qgL, qgj] };
}
function CU(qgu) {
  return qgu["internalFormatFloat"];
}
function l1(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = ru(qgj, qgL);
  return CP(qgu, qgb, qgR, CU(qgI), qgI["textureFormatFloat"], qgu["FLOAT"]);
}
function lq(qgu) {
  return qgu["internalFormatHalfFloat"];
}
function ln(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = ru(qgj, qgL);
  return CP(qgu, qgb, qgR, lq(qgI), qgI["textureFormatFloat"], qgI["textureTypeHalfFloat"]);
}
function lM(qgu) {
  return qgu["downloadTextureFormat"];
}
function lF(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = ru(qgj, qgL);
  return CP(qgu, qgb, qgR, lM(qgI), qgu["RGBA"], qgu["UNSIGNED_BYTE"]);
}
function lW(qgu) {
  return qgu["internalFormatPackedFloat"];
}
function lD(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = ro(qgj, qgL);
  return CP(qgu, qgb, qgR, lW(qgI), qgu["RGBA"], qgu["FLOAT"]);
}
function la(qgu) {
  return qgu["internalFormatPackedHalfFloat"];
}
function lZ(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = ro(qgj, qgL);
  return CP(qgu, qgb, qgR, la(qgI), qgu["RGBA"], qgI["textureTypeHalfFloat"]);
}
function lz(qgu, qgj, qgL) {
  return rK(qgu, () => qgu["bindBuffer"](qgu["ARRAY_BUFFER"], qgL)), QR(qgu, qgj, "clipSpacePos", qgL, 3, 20, 0) && QR(qgu, qgj, "uv", qgL, 2, 20, 12);
}
function lX(qgu, qgj, qgL, qgI, qgb, qgR) {
  rK(qgu, () => qgu["bindTexture"](qgu["TEXTURE_2D"], qgj));
  let qgo, qgr, qgQ;
  qgb instanceof Uint8Array ? (qgo = new Uint8Array(qgL * qgI * 4), qgr = qgu["UNSIGNED_BYTE"], qgQ = qgu["RGBA"]) : (qgo = new Float32Array(qgL * qgI * 4), qgr = qgu["FLOAT"], qgQ = qgR["internalFormatPackedFloat"]), qgo["set"](qgb), qM()["getNumber"]("WEBGL_VERSION") === 2 ? rK(qgu, () => qgu["texSubImage2D"](qgu["TEXTURE_2D"], 0, 0, 0, qgL, qgI, qgu["RGBA"], qgr, qgo)) : rK(qgu, () => qgu["texImage2D"](qgu["TEXTURE_2D"], 0, qgQ, qgL, qgI, 0, qgu["RGBA"], qgr, qgo)), rK(qgu, () => qgu["bindTexture"](qgu["TEXTURE_2D"], null));
}
function lG(qgu, qgj, qgL) {
  rK(qgu, () => qgu["bindTexture"](qgu["TEXTURE_2D"], qgj)), qgL["data"] instanceof Uint8Array ? qM()["getNumber"]("WEBGL_VERSION") === 2 ? rK(qgu, () => qgu["texSubImage2D"](qgu["TEXTURE_2D"], 0, 0, 0, qgL["width"], qgL["height"], qgu["RGBA"], qgu["UNSIGNED_BYTE"], qgL["data"])) : rK(qgu, () => qgu["texImage2D"](qgu["TEXTURE_2D"], 0, qgu["RGBA"], qgL["width"], qgL["height"], 0, qgu["RGBA"], qgu["UNSIGNED_BYTE"], qgL["data"])) : qM()["getNumber"]("WEBGL_VERSION") === 2 ? rK(qgu, () => qgu["texSubImage2D"](qgu["TEXTURE_2D"], 0, 0, 0, qgu["RGBA"], qgu["UNSIGNED_BYTE"], qgL)) : rK(qgu, () => qgu["texImage2D"](qgu["TEXTURE_2D"], 0, qgu["RGBA"], qgu["RGBA"], qgu["UNSIGNED_BYTE"], qgL)), rK(qgu, () => qgu["bindTexture"](qgu["TEXTURE_2D"], null));
}
function lu(qgu, qgj, qgL, qgI) {
  const qgb = qgu["createBuffer"]();
  rK(qgu, () => qgu["bindBuffer"](qgu["PIXEL_PACK_BUFFER"], qgb));
  const qgR = 4 * 4 * qgj * qgL;
  return rK(qgu, () => qgu["bufferData"](qgu["PIXEL_PACK_BUFFER"], qgR, qgu["STREAM_READ"])), rK(qgu, () => qgu["readPixels"](0, 0, qgL, qgj, qgu["RGBA"], qgu["FLOAT"], 0)), rK(qgu, () => qgu["bindBuffer"](qgu["PIXEL_PACK_BUFFER"], null)), qgb;
}
function lj(qgu, qgj, qgL) {
  const qgI = qgu, qgb = new Float32Array(qgL);
  return qgI["bindBuffer"](qgI["PIXEL_PACK_BUFFER"], qgj), qgI["getBufferSubData"](qgI["PIXEL_PACK_BUFFER"], 0, qgb), qgI["bindBuffer"](qgI["PIXEL_PACK_BUFFER"], null), qgb;
}
function lL(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = ru(qgj, qgL), qgo = 4, qgr = new Uint8Array(rj(qgj * qgL, qgo));
  return rK(qgu, () => qgu["readPixels"](0, 0, qgb, qgR, qgI["downloadTextureFormat"], qgu["UNSIGNED_BYTE"], qgr)), new Float32Array(qgr["buffer"]);
}
function lo(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr) {
  const qgQ = qgu, qgd = new Float32Array(rQ(qgR, qgo));
  return qgQ["bindBuffer"](qgQ["PIXEL_PACK_BUFFER"], qgj), qgQ["getBufferSubData"](qgQ["PIXEL_PACK_BUFFER"], 0, qgd), qgQ["bindBuffer"](qgQ["PIXEL_PACK_BUFFER"], null), qgd;
}
function lr(qgu, qgj, qgL) {
  const qgI = new Float32Array(qgj * qgL * 4);
  return rK(qgu, () => qgu["readPixels"](0, 0, qgL, qgj, qgu["RGBA"], qgu["FLOAT"], qgI)), qgI;
}
var lQ = class {
  constructor(qgu) {
    this["outputTexture"] = null, this["program"] = null, this["disposed"] = false, this["itemsToPoll"] = [];
    const qgj = qM()["getNumber"]("WEBGL_VERSION");
    if (qgu != null ? (this["gl"] = qgu, rF(qgj, qgu)) : this["gl"] = rW(qgj), qgu = this["gl"], qM()["getNumber"]("WEBGL_VERSION") === 2) {
      const qgb = qgu;
      this["createVertexArray"] = () => rK(qgb, () => qgb["createVertexArray"]()), this["bindVertexArray"] = (qgR) => rK(qgb, () => qgb["bindVertexArray"](qgR)), this["deleteVertexArray"] = (qgR) => rK(qgb, () => qgb["deleteVertexArray"](qgR)), this["getVertexArray"] = () => rK(qgb, () => qgb["getParameter"](qgb["VERTEX_ARRAY_BINDING"]));
    } else {
      if (qgu != null) {
        const qgR = qgu["getExtension"]("OES_vertex_array_object");
        if (qgR == null) throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");
        this["createVertexArray"] = () => rK(qgu, () => qgR["createVertexArrayOES"]()), this["bindVertexArray"] = (qgo) => rK(qgu, () => qgR["bindVertexArrayOES"](qgo)), this["deleteVertexArray"] = (qgo) => rK(qgu, () => qgR["deleteVertexArrayOES"](qgo)), this["getVertexArray"] = () => rK(qgu, () => qgu["getParameter"](qgR["VERTEX_ARRAY_BINDING_OES"]));
      }
    }
    let qgL = "WEBGL_color_buffer_float";
    const qgI = "EXT_color_buffer_half_float";
    if (this["parallelCompilationExtension"] = this["gl"]["getExtension"]("KHR_parallel_shader_compile"), qM()["getNumber"]("WEBGL_VERSION") === 1) {
      const qgo = "OES_texture_float", qgr = "OES_texture_half_float";
      if (this["textureFloatExtension"] = rU(this["gl"], qgo), dz(this["gl"], qgr)) this["textureHalfFloatExtension"] = rU(this["gl"], qgr);
      else {
        if (qM()["get"]("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      }
      if (this["colorBufferFloatExtension"] = this["gl"]["getExtension"](qgL), dz(this["gl"], qgI)) this["colorBufferHalfFloatExtension"] = rU(this["gl"], qgI);
      else {
        if (qM()["get"]("WEBGL_FORCE_F16_TEXTURES")) throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");
      }
    } else {
      if (qgL = "EXT_color_buffer_float", dz(this["gl"], qgL)) this["colorBufferFloatExtension"] = this["gl"]["getExtension"](qgL);
      else {
        if (dz(this["gl"], qgI)) this["colorBufferHalfFloatExtension"] = this["gl"]["getExtension"](qgI);
        else throw new Error("GL context does not support color renderable floats");
      }
    }
    this["vertexBuffer"] = CJ(this["gl"]), this["indexBuffer"] = CY(this["gl"]), this["framebuffer"] = QL(this["gl"]), this["textureConfig"] = rH(this["gl"], this["textureHalfFloatExtension"]);
  }
  get ["debug"]() {
    return qM()["getBool"]("DEBUG");
  }
  ["dispose"]() {
    if (this["disposed"]) return;
    this["program"] != null && console["warn"]("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."), this["outputTexture"] != null && console["warn"]("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");
    const qgu = this["gl"];
    rK(qgu, () => qgu["finish"]()), rK(qgu, () => qgu["bindFramebuffer"](qgu["FRAMEBUFFER"], null)), rK(qgu, () => qgu["deleteFramebuffer"](this["framebuffer"])), rK(qgu, () => qgu["bindBuffer"](qgu["ARRAY_BUFFER"], null)), rK(qgu, () => qgu["bindBuffer"](qgu["ELEMENT_ARRAY_BUFFER"], null)), rK(qgu, () => qgu["deleteBuffer"](this["indexBuffer"])), this["disposed"] = true;
  }
  ["createFloat32MatrixTexture"](qgu, qgj) {
    return this["throwIfDisposed"](), l1(this["gl"], qgu, qgj, this["textureConfig"]);
  }
  ["createFloat16MatrixTexture"](qgu, qgj) {
    return this["throwIfDisposed"](), ln(this["gl"], qgu, qgj, this["textureConfig"]);
  }
  ["createUnsignedBytesMatrixTexture"](qgu, qgj) {
    return this["throwIfDisposed"](), lF(this["gl"], qgu, qgj, this["textureConfig"]);
  }
  ["uploadPixelDataToTexture"](qgu, qgj) {
    this["throwIfDisposed"](), lG(this["gl"], qgu, qgj);
  }
  ["uploadDenseMatrixToTexture"](qgu, qgj, qgL, qgI) {
    this["throwIfDisposed"](), lX(this["gl"], qgu, qgj, qgL, qgI, this["textureConfig"]);
  }
  ["createFloat16PackedMatrixTexture"](qgu, qgj) {
    return this["throwIfDisposed"](), lZ(this["gl"], qgu, qgj, this["textureConfig"]);
  }
  ["createPackedMatrixTexture"](qgu, qgj) {
    return this["throwIfDisposed"](), lD(this["gl"], qgu, qgj, this["textureConfig"]);
  }
  ["deleteMatrixTexture"](qgu) {
    this["throwIfDisposed"](), this["outputTexture"] === qgu && (QB(this["gl"], this["framebuffer"]), this["outputTexture"] = null), rK(this["gl"], () => this["gl"]["deleteTexture"](qgu));
  }
  ["downloadByteEncodedFloatMatrixFromOutputTexture"](qgu, qgj, qgL) {
    return this["downloadMatrixDriver"](qgu, () => lL(this["gl"], qgj, qgL, this["textureConfig"]));
  }
  ["downloadPackedMatrixFromBuffer"](qgu, qgj, qgL, qgI, qgb, qgR) {
    return lo(this["gl"], qgu, qgj, qgL, qgI, qgb, qgR, this["textureConfig"]);
  }
  ["downloadFloat32MatrixFromBuffer"](qgu, qgj) {
    return lj(this["gl"], qgu, qgj);
  }
  ["createBufferFromTexture"](qgu, qgj, qgL) {
    this["bindTextureToFrameBuffer"](qgu);
    const qgI = lu(this["gl"], qgj, qgL, this["textureConfig"]);
    return this["unbindTextureToFrameBuffer"](), qgI;
  }
  ["createAndWaitForFence"]() {
    const qgu = this["createFence"](this["gl"]);
    return this["pollFence"](qgu);
  }
  ["createFence"](qgu) {
    let qgj, qgL;
    if (qM()["getBool"]("WEBGL_FENCE_API_ENABLED")) {
      const qgI = qgu, qgb = qgI["fenceSync"](qgI["SYNC_GPU_COMMANDS_COMPLETE"], 0);
      qgu["flush"](), qgL = () => {
        const qgR = qgI["clientWaitSync"](qgb, 0, 0);
        return qgR === qgI["ALREADY_SIGNALED"] || qgR === qgI["CONDITION_SATISFIED"];
      }, qgj = qgb;
    } else qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") > 0 ? (qgj = this["beginQuery"](), this["endQuery"](), qgL = () => this["isQueryAvailable"](qgj, qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))) : qgL = () => true;
    return { "query": qgj, "isFencePassed": qgL };
  }
  ["downloadMatrixFromPackedTexture"](qgu, qgj, qgL) {
    return this["downloadMatrixDriver"](qgu, () => lr(this["gl"], qgj, qgL));
  }
  ["createProgram"](qgu) {
    this["throwIfDisposed"]();
    const qgj = this["gl"];
    this["vertexShader"] == null && (this["vertexShader"] = CV(qgj));
    const qgL = QD(qgj);
    rK(qgj, () => qgj["attachShader"](qgL, this["vertexShader"])), rK(qgj, () => qgj["attachShader"](qgL, qgu)), Qa(qgj, qgL);
    const qgI = Object["assign"](qgL, { "vao": this["createVertexArray"]() });
    return this["debug"] && QZ(qgj, qgI), qgI;
  }
  ["buildVao"](qgu) {
    this["setProgram"](qgu), this["bindVertexArray"](qgu["vao"]);
    const qgj = this["gl"];
    rK(qgj, () => qgj["bindBuffer"](qgj["ELEMENT_ARRAY_BUFFER"], this["indexBuffer"])), lz(qgj, qgu, this["vertexBuffer"]);
  }
  ["deleteProgram"](qgu) {
    this["throwIfDisposed"](), qgu === this["program"] && (this["program"] = null), qgu != null && (rK(this["gl"], () => this["gl"]["deleteProgram"](qgu)), this["deleteVertexArray"](qgu["vao"]));
  }
  ["setProgram"](qgu) {
    this["throwIfDisposed"](), this["program"] = qgu, this["program"] != null && this["debug"] && QZ(this["gl"], this["program"]), rK(this["gl"], () => this["gl"]["useProgram"](qgu));
  }
  ["getUniformLocation"](qgu, qgj, qgL = true) {
    return this["throwIfDisposed"](), qgL ? QQ(this["gl"], qgu, qgj) : QH(this["gl"], qgu, qgj);
  }
  ["getAttributeLocation"](qgu, qgj) {
    return this["throwIfDisposed"](), rK(this["gl"], () => this["gl"]["getAttribLocation"](qgu, qgj));
  }
  ["getUniformLocationNoThrow"](qgu, qgj) {
    return this["throwIfDisposed"](), this["gl"]["getUniformLocation"](qgu, qgj);
  }
  ["setInputMatrixTexture"](qgu, qgj, qgL) {
    this["throwIfDisposed"](), this["throwIfNoProgram"](), Qh(this["gl"], qgu, qgj, qgL);
  }
  ["setOutputMatrixTexture"](qgu, qgj, qgL) {
    this["setOutputMatrixTextureDriver"](qgu, qgL, qgj);
  }
  ["setOutputPackedMatrixTexture"](qgu, qgj, qgL) {
    this["throwIfDisposed"]();
    const [qgI, qgb] = ro(qgj, qgL);
    this["setOutputMatrixTextureDriver"](qgu, qgI, qgb);
  }
  ["setOutputMatrixWriteRegion"](qgu, qgj, qgL, qgI) {
    this["setOutputMatrixWriteRegionDriver"](qgL, qgu, qgI, qgj);
  }
  ["setOutputPackedMatrixWriteRegion"](qgu, qgj, qgL, qgI) {
    throw new Error("setOutputPackedMatrixWriteRegion not implemented.");
  }
  ["debugValidate"]() {
    this["program"] != null && QZ(this["gl"], this["program"]), QV(this["gl"]);
  }
  ["executeProgram"]() {
    this["throwIfDisposed"](), this["throwIfNoProgram"]();
    const qgu = this["gl"];
    if (this["debug"]) {
      const qgj = this["getVertexArray"]();
      console["assert"](qgj === this["program"]["vao"], "VAO changed between setProgram and executeProgram!"), this["debugValidate"]();
    }
    rK(qgu, () => qgu["drawElements"](qgu["TRIANGLES"], 6, qgu["UNSIGNED_SHORT"], 0));
  }
  ["blockUntilAllProgramsCompleted"]() {
    this["throwIfDisposed"](), rK(this["gl"], () => this["gl"]["finish"]());
  }
  ["getQueryTimerExtension"]() {
    return this["disjointQueryTimerExtension"] == null && (this["disjointQueryTimerExtension"] = rU(this["gl"], qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2 ? "EXT_disjoint_timer_query_webgl2" : "EXT_disjoint_timer_query")), this["disjointQueryTimerExtension"];
  }
  ["getQueryTimerExtensionWebGL2"]() {
    return this["getQueryTimerExtension"]();
  }
  ["getQueryTimerExtensionWebGL1"]() {
    return this["getQueryTimerExtension"]();
  }
  ["beginQuery"]() {
    if (qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const qgL = this["gl"], qgI = this["getQueryTimerExtensionWebGL2"](), qgb = qgL["createQuery"]();
      return qgL["beginQuery"](qgI["TIME_ELAPSED_EXT"], qgb), qgb;
    }
    const qgu = this["getQueryTimerExtensionWebGL1"](), qgj = qgu["createQueryEXT"]();
    return qgu["beginQueryEXT"](qgu["TIME_ELAPSED_EXT"], qgj), qgj;
  }
  ["endQuery"]() {
    if (qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION") === 2) {
      const qgj = this["gl"], qgL = this["getQueryTimerExtensionWebGL2"]();
      qgj["endQuery"](qgL["TIME_ELAPSED_EXT"]);
      return;
    }
    const qgu = this["getQueryTimerExtensionWebGL1"]();
    qgu["endQueryEXT"](qgu["TIME_ELAPSED_EXT"]);
  }
  async ["waitForQueryAndGetTime"](qgu) {
    return await w(() => this["disposed"] || this["isQueryAvailable"](qgu, qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))), this["getQueryTime"](qgu, qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"));
  }
  ["getQueryTime"](qgu, qgj) {
    if (qgj === 0) return null;
    if (qgj === 2) {
      const qgL = this["gl"];
      return qgL["getQueryParameter"](qgu, qgL["QUERY_RESULT"]) / 1e6;
    } else {
      const qgI = this["getQueryTimerExtensionWebGL1"]();
      return qgI["getQueryObjectEXT"](qgu, qgI["QUERY_RESULT_EXT"]) / 1e6;
    }
  }
  ["isQueryAvailable"](qgu, qgj) {
    if (qgj === 0) return true;
    if (qgj === 2) {
      const qgL = this["gl"], qgI = this["getQueryTimerExtensionWebGL2"](), qgb = qgL["getQueryParameter"](qgu, qgL["QUERY_RESULT_AVAILABLE"]);
      return this["disjoint"] == null && (this["disjoint"] = this["gl"]["getParameter"](qgI["GPU_DISJOINT_EXT"])), qgb && !this["disjoint"];
    } else {
      const qgR = this["getQueryTimerExtensionWebGL1"](), qgo = qgR["getQueryObjectEXT"](qgu, qgR["QUERY_RESULT_AVAILABLE_EXT"]);
      return this["disjoint"] == null && (this["disjoint"] = this["gl"]["getParameter"](qgR["GPU_DISJOINT_EXT"])), qgo && !this["disjoint"];
    }
  }
  ["pollFence"](qgu) {
    return new Promise((qgj) => {
      this["addItemToPoll"](() => qgu["isFencePassed"](), () => qgj());
    });
  }
  ["pollItems"]() {
    const qgu = lH(this["itemsToPoll"]["map"]((qgj) => qgj["isDoneFn"]));
    for (let qgj = 0; qgj <= qgu; ++qgj) {
      const { resolveFn: qgL } = this["itemsToPoll"][qgj];
      qgL();
    }
    this["itemsToPoll"] = this["itemsToPoll"]["slice"](qgu + 1);
  }
  ["addItemToPoll"](qgu, qgj) {
    if (this["itemsToPoll"]["push"]({ "isDoneFn": qgu, "resolveFn": qgj }), this["itemsToPoll"]["length"] > 1) return;
    let qgL;
    "setTimeoutCustom" in qM()["platform"] && (qgL = qM()["platform"]["setTimeoutCustom"]["bind"](qM()["platform"])), w(() => (this["pollItems"](), this["itemsToPoll"]["length"] === 0), () => 0, null, qgL);
  }
  ["bindTextureToFrameBuffer"](qgu) {
    this["throwIfDisposed"](), QK(this["gl"], qgu, this["framebuffer"]), this["debug"] && QV(this["gl"]);
  }
  ["unbindTextureToFrameBuffer"]() {
    this["outputTexture"] != null ? (QK(this["gl"], this["outputTexture"], this["framebuffer"]), this["debug"] && QV(this["gl"])) : QB(this["gl"], this["framebuffer"]);
  }
  ["downloadMatrixDriver"](qgu, qgj) {
    this["bindTextureToFrameBuffer"](qgu);
    const qgL = qgj();
    return this["unbindTextureToFrameBuffer"](), qgL;
  }
  ["setOutputMatrixTextureDriver"](qgu, qgj, qgL) {
    this["throwIfDisposed"]();
    const qgI = this["gl"];
    QK(qgI, qgu, this["framebuffer"]), this["debug"] && QV(qgI), this["outputTexture"] = qgu, rK(qgI, () => qgI["viewport"](0, 0, qgj, qgL)), rK(qgI, () => qgI["scissor"](0, 0, qgj, qgL));
  }
  ["setOutputMatrixWriteRegionDriver"](qgu, qgj, qgL, qgI) {
    this["throwIfDisposed"](), rK(this["gl"], () => this["gl"]["scissor"](qgu, qgj, qgL, qgI));
  }
  ["throwIfDisposed"]() {
    if (this["disposed"]) throw new Error("Attempted to use disposed GPGPUContext.");
  }
  ["throwIfNoProgram"]() {
    if (this["program"] == null) throw new Error("No GPU program is currently set.");
  }
};
function lH(qgu) {
  let qgj = 0;
  for (; qgj < qgu["length"] && qgu[qgj](); ++qgj) ;
  return qgj - 1;
}
function lK(qgu, qgj) {
  Array["isArray"](qgu) || (qgu = [qgu]), qgu["forEach"]((qgL) => {
    qgL != null && k(qgL["dtype"] !== "complex64", () => qgj + " does not support complex64 tensors in the CPU backend.");
  });
}
function lB(qgu) {
  const qgj = new Float32Array(qgu["length"]);
  for (let qgL = 0; qgL < qgu["length"]; ++qgL) qgj[qgL] = Math["abs"](qgu[qgL]);
  return qgj;
}
var lV = (qgu) => {
  const { x: qgj } = qgu["inputs"], qgL = qgu["backend"];
  lK(qgj, "abs");
  let qgI = new Float32Array(i2(qgj["shape"]));
  const qgb = qgL["data"]["get"](qgj["dataId"])["values"];
  return qgI = lB(qgb), qgL["makeOutput"](qgI, qgj["shape"], qgj["dtype"]);
};
var lJ = { "kernelName": qX, "backendName": "cpu", "kernelFunc": lV };
function lY(qgu) {
  return (qgj, qgL, qgI, qgb, qgR) => {
    const qgo = OR(qgj, qgL), qgr = qgo["length"], qgQ = y(qgo), qgd = i2(qgo), qgv = X(qgR, qgd), qgy = qgj["length"], qgl = qgL["length"], qgH = y(qgj), qgA = y(qgL), qgh = Oj(qgj, qgo), qgT = Oj(qgL, qgo);
    if (qgh["length"] + qgT["length"] === 0) {
      for (let qgK = 0; qgK < qgv["length"]; ++qgK) qgv[qgK] = qgu(qgI[qgK % qgI["length"]], qgb[qgK % qgb["length"]]);
    } else for (let qgB = 0; qgB < qgv["length"]; ++qgB) {
      const qgV = V(qgB, qgr, qgQ), qgJ = qgV["slice"](-qgy);
      qgh["forEach"]((qx0) => qgJ[qx0] = 0);
      const qgY = B(qgJ, qgy, qgH), qgP = qgV["slice"](-qgl);
      qgT["forEach"]((qx0) => qgP[qx0] = 0);
      const qgU = B(qgP, qgl, qgA);
      qgv[qgB] = qgu(qgI[qgY], qgb[qgU]);
    }
    return [qgv, qgo];
  };
}
function lP(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { real: qgI, imag: qgb } = qgj, qgR = qgL["data"]["get"](qgI["dataId"])["values"], qgo = qgL["data"]["get"](qgb["dataId"])["values"], qgr = qgL["makeTensorInfo"](qgI["shape"], "complex64"), qgQ = qgL["data"]["get"](qgr["dataId"]);
  return qgQ["complexTensorInfos"] = { "real": qgL["makeTensorInfo"](qgI["shape"], "float32", qgR), "imag": qgL["makeTensorInfo"](qgb["shape"], "float32", qgo) }, qgr;
}
function lU(qgu, qgj, qgL = "float32") {
  if (qgL === "complex64") {
    const qgb = lU(qgu, qgj, "float32"), qgR = lU(qgu, qgj, "float32");
    return lP({ "inputs": { "real": qgb, "imag": qgR }, "backend": qgu });
  }
  const qgI = T(i2(qgj), qgL);
  return qgu["makeTensorInfo"](qgj, qgL, qgI);
}
function H6(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  return qgL["incRef"](qgI["dataId"]), { "dataId": qgI["dataId"], "shape": qgI["shape"], "dtype": qgI["dtype"] };
}
var Hq = { "kernelName": no, "backendName": "cpu", "kernelFunc": H6 };
function HM(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { input: qgI } = qgj, qgb = qgL["data"]["get"](qgI["dataId"])["complexTensorInfos"]["real"], qgR = qgL["data"]["get"](qgb["dataId"])["values"];
  return qgL["makeTensorInfo"](qgb["shape"], qgb["dtype"], qgR);
}
function HF(qgu, qgj, qgL, qgI) {
  if (qgI === "int32") {
    const qgb = Int32Array["from"](qgu);
    return [qgj, "int32", qgb];
  }
  if (qgI === "bool") {
    const qgR = EM([0], qgL), [qgo, qgr] = lY((qgQ, qgd) => qgQ !== qgd ? 1 : 0)(qgj, [], qgu, qgR, "bool");
    return [qgr, "bool", qgo];
  }
  throw new Error("Error in Cast: failed to cast " + qgL + " to " + qgI);
}
function HW(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { dtype: qgR } = qgI;
  if (qgR === "complex64") {
    if (qgb["dtype"] === "complex64") return H6({ "inputs": { "x": qgb }, "backend": qgL });
    const qgv = lU(qgL, qgb["shape"], qgb["dtype"]), qgy = HW({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "dtype": "float32" } }), qgl = lP({ "inputs": { "real": qgy, "imag": qgv }, "backend": qgL });
    return qgL["disposeIntermediateTensorInfo"](qgv), qgL["disposeIntermediateTensorInfo"](qgy), qgl;
  }
  if (qgb["dtype"] === "complex64") {
    const qgH = HM({ "inputs": { "input": qgb }, "backend": qgL }), qgA = HW({ "inputs": { "x": qgH }, "backend": qgL, "attrs": { "dtype": qgR } });
    return qgL["disposeIntermediateTensorInfo"](qgH), qgA;
  }
  if (!j(qgb["dtype"], qgR)) {
    const qgh = H6({ "inputs": { "x": qgb }, "backend": qgL });
    return { "dataId": qgh["dataId"], "shape": qgh["shape"], "dtype": qgR };
  }
  const qgo = qgL["data"]["get"](qgb["dataId"])["values"], [qgr, qgQ, qgd] = HF(qgo, qgb["shape"], qgb["dtype"], qgR);
  return qgL["makeTensorInfo"](qgr, qgQ, qgd);
}
var HD = { "kernelName": qH, "backendName": "cpu", "kernelFunc": HW };
function HZ(qgu, qgj, qgL, qgI) {
  return qgL == null ? ({ inputs: qgb, backend: qgR }) => {
    const { a: qgo, b: qgr } = qgb, qgQ = qgR;
    lK([qgo, qgr], qgu);
    const qgd = qgQ["data"]["get"](qgo["dataId"])["values"], qgv = qgQ["data"]["get"](qgr["dataId"])["values"], qgy = qgo["dtype"] === "string" ? uo(qgd) : qgd, qgl = qgo["dtype"] === "string" ? uo(qgv) : qgv, qgH = qgI || qgo["dtype"], [qgA, qgh] = qgj(qgo["shape"], qgr["shape"], qgy, qgl, qgH);
    return qgQ["makeTensorInfo"](qgh, qgH, qgA);
  } : ({ inputs: qgb, backend: qgR }) => {
    const { a: qgo, b: qgr } = qgb, qgQ = qgR;
    if (qgo["dtype"] === "complex64" || qgr["dtype"] === "complex64") {
      const qgd = HW({ "inputs": { "x": qgo }, "backend": qgQ, "attrs": { "dtype": "complex64" } }), qgv = qgQ["data"]["get"](qgd["dataId"]), qgy = qgv["complexTensorInfos"]["real"], qgl = qgv["complexTensorInfos"]["imag"], qgH = qgQ["data"]["get"](qgy["dataId"])["values"], qgA = qgQ["data"]["get"](qgl["dataId"])["values"], qgh = HW({ "inputs": { "x": qgr }, "backend": qgQ, "attrs": { "dtype": "complex64" } }), qgT = qgQ["data"]["get"](qgh["dataId"]), qgK = qgT["complexTensorInfos"]["real"], qgB = qgT["complexTensorInfos"]["imag"], qgV = qgQ["data"]["get"](qgK["dataId"])["values"], qgJ = qgQ["data"]["get"](qgB["dataId"])["values"], [qgY, qgP, qgU] = qgL(qgo["shape"], qgr["shape"], qgH, qgA, qgV, qgJ), qx0 = qgQ["makeTensorInfo"](qgU, "float32", qgY), qx1 = qgQ["makeTensorInfo"](qgU, "float32", qgP), qx2 = lP({ "inputs": { "real": qx0, "imag": qx1 }, "backend": qgQ });
      return qgQ["disposeIntermediateTensorInfo"](qgd), qgQ["disposeIntermediateTensorInfo"](qgh), qgQ["disposeIntermediateTensorInfo"](qx0), qgQ["disposeIntermediateTensorInfo"](qx1), qx2;
    } else {
      const qx3 = qgQ["data"]["get"](qgo["dataId"])["values"], qx4 = qgQ["data"]["get"](qgr["dataId"])["values"], qx5 = qgI || qgo["dtype"], [qx6, qx7] = qgj(qgo["shape"], qgr["shape"], qx3, qx4, qx5);
      return qgQ["makeTensorInfo"](qx7, qx5, qx6);
    }
  };
}
function He(qgu) {
  return (qgj, qgL, qgI, qgb, qgR, qgo) => {
    const qgr = OR(qgj, qgL), qgQ = i2(qgr), qgd = qgr["length"], qgv = y(qgr), qgy = X("float32", qgQ), qgl = X("float32", qgQ), qgH = Oj(qgj, qgr), qgA = Oj(qgL, qgr), qgh = Nt(qgI, qgb), qgT = Nt(qgR, qgo), qgK = qgj["length"], qgB = y(qgj), qgV = qgL["length"], qgJ = y(qgL);
    if (qgH["length"] + qgA["length"] === 0) for (let qgY = 0; qgY < qgy["length"]; qgY++) {
      const qgP = qgY % qgh["length"], qgU = qgY % qgT["length"], qx0 = qgu(qgh[qgP * 2], qgh[qgP * 2 + 1], qgT[qgU * 2], qgT[qgU * 2 + 1]);
      qgy[qgY] = qx0["real"], qgl[qgY] = qx0["imag"];
    }
    else for (let qx1 = 0; qx1 < qgy["length"]; qx1++) {
      const qx2 = V(qx1, qgd, qgv), qx3 = qx2["slice"](-qgK);
      qgH["forEach"]((qx8) => qx3[qx8] = 0);
      const qx4 = B(qx3, qgK, qgB), qx5 = qx2["slice"](-qgV);
      qgA["forEach"]((qx8) => qx5[qx8] = 0);
      const qx6 = B(qx5, qgV, qgJ), qx7 = qgu(qgh[qx4 * 2], qgh[qx4 * 2 + 1], qgT[qx6 * 2], qgT[qx6 * 2 + 1]);
      qgy[qx1] = qx7["real"], qgl[qx1] = qx7["imag"];
    }
    return [qgy, qgl, qgr];
  };
}
var HX = lY((qgu, qgj) => qgu + qgj);
var HG = He((qgu, qgj, qgL, qgI) => ({ "real": qgu + qgL, "imag": qgj + qgI }));
var Hj = HZ(qG, HX, HG);
var HL = { "kernelName": qG, "backendName": "cpu", "kernelFunc": Hj };
function HR(qgu, qgj, qgL, qgI, qgb) {
  const qgR = i2(qgI), qgo = T(qgb, qgL);
  for (let qgr = 0; qgr < qgu["length"]; qgr++) {
    const qgQ = qgu[qgr];
    if (qgQ < 0) throw new Error("Input x must be non-negative!");
    qgQ >= qgb || (qgR > 0 ? qgo[qgQ] += qgj[qgr] : qgo[qgQ] += 1);
  }
  return qgo;
}
function Ho(qgu, qgj, qgL, qgI = false) {
  const qgb = qgu["shape"][0], qgR = qgu["shape"][1], qgo = DY([qgb, qgL], qgj["dtype"]);
  for (let qgr = 0; qgr < qgb; qgr++) for (let qgQ = 0; qgQ < qgR; qgQ++) {
    const qgd = qgu["get"](qgr, qgQ);
    if (qgd < 0) throw new Error("Input x must be non-negative!");
    qgd >= qgL || (qgI ? qgo["set"](1, qgr, qgd) : qgj["size"] > 0 ? qgo["set"](qgo["get"](qgr, qgd) + qgj["get"](qgr, qgQ), qgr, qgd) : qgo["set"](qgo["get"](qgr, qgd) + 1, qgr, qgd));
  }
  return qgo;
}
var HQ = lY((qgu, qgj) => qgu & qgj);
function HH(qgu) {
  return (qgj, qgL, qgI) => {
    const qgb = G(qgL, qgj["length"]);
    for (let qgR = 0; qgR < qgj["length"]; ++qgR) qgb[qgR] = qgu(qgj[qgR], qgI);
    return qgb;
  };
}
function HK(qgu, qgj, qgL) {
  const qgI = HH(qgj);
  return HB(qgu, qgI, qgL);
}
function HB(qgu, qgj, qgL) {
  return ({ inputs: qgI, attrs: qgb, backend: qgR }) => {
    const { x: qgo } = qgI;
    lK(qgo, qgu);
    const qgr = qgR, qgQ = qgr["data"]["get"](qgo["dataId"])["values"];
    let qgd;
    if (qgo["dtype"] === "string") {
      if (!Array["isArray"](qgQ)) throw new Error("String tensor's value was not an instance of Array");
      qgd = uo(qgQ);
    } else qgd = qgQ;
    const qgv = qgL || qgo["dtype"], qgy = qgj(qgd, qgv, qgb);
    return qgr["makeTensorInfo"](qgo["shape"], qgv, qgy);
  };
}
var HV = HH((qgu) => Math["ceil"](qgu));
function HJ(qgu, qgj, qgL, qgI) {
  const qgb = G(qgL, i2(qgj));
  if (qgI && qgL !== "string") {
    let qgR = 0;
    qgu["forEach"]((qgo) => {
      const qgr = i2(qgo["shape"]);
      qgb["set"](qgo["vals"], qgR), qgR += qgr;
    });
  } else {
    let qgo = 0;
    qgu["forEach"]((qgr) => {
      const qgQ = qgL === "string" ? uo(qgr["vals"]) : qgr["vals"];
      let qgd = 0;
      for (let qgv = 0; qgv < qgr["shape"][0]; ++qgv) {
        const qgy = qgv * qgj[1] + qgo;
        for (let qgl = 0; qgl < qgr["shape"][1]; ++qgl) qgb[qgy + qgl] = qgQ[qgd++];
      }
      qgo += qgr["shape"][1];
    });
  }
  return qgb;
}
var HY = lY((qgu, qgj) => qgu === qgj ? 1 : 0);
var HP = HH((qgu) => Math["exp"](qgu));
var HU = HH((qgu) => Math["expm1"](qgu));
var Aq = HH((qgu) => Math["floor"](qgu));
var AM = HB(nX, Aq);
var AF = { "kernelName": nX, "backendName": "cpu", "kernelFunc": AM };
var At = lY((qgu, qgj) => Math["floor"](qgu / qgj));
function AW(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ) {
  const qgd = DY([qgI, qgR], qgL);
  for (let qgv = 0; qgv < qgI; qgv++) {
    const qgy = [];
    let qgl = 0;
    for (let qgH = 0; qgH < qgb; qgH++) {
      const qgA = qgu[qgv * qgb + qgH];
      qgl += qgA * qgo[qgH], qgy["push"](qgA);
    }
    if (qgl < 0 || qgl >= qgQ / qgR) throw new Error("Invalid indices: " + qgy + " does not index into " + qgr);
    for (let qgh = 0; qgh < qgR; qgh++) qgd["values"][qgv * qgR + qgh] = qgj["get"](...qgj["indexToLoc"](qgl * qgR + qgh));
  }
  return qgd;
}
function AD(qgu, qgj, qgL) {
  const qgI = DY(qgL, qgu["dtype"]);
  for (let qgb = 0; qgb < qgI["size"]; ++qgb) {
    const qgR = qgI["indexToLoc"](qgb)["slice"](), qgo = qgR[0], qgr = qgR[2], qgQ = qgj["locToIndex"]([qgo, qgr]);
    qgR[2] = qgj["values"][qgQ];
    const qgd = qgu["locToIndex"](qgR);
    0 <= qgd && qgd < qgu["values"]["length"] && (qgI["values"][qgb] = qgu["values"][qgd]);
  }
  return qgI;
}
var AZ = lY((qgu, qgj) => qgu > qgj ? 1 : 0);
var Ae = lY((qgu, qgj) => qgu >= qgj ? 1 : 0);
var Az = HZ(nL, Ae, null, "bool");
var AX = { "kernelName": nL, "backendName": "cpu", "kernelFunc": Az };
var AG = lY((qgu, qgj) => qgu < qgj ? 1 : 0);
var Au = HZ(nK, AG, null, "bool");
var Aj = { "kernelName": nK, "backendName": "cpu", "kernelFunc": Au };
var AL = lY((qgu, qgj) => qgu <= qgj ? 1 : 0);
var AR = HZ(nB, AL, null, "bool");
var AQ = { "kernelName": nB, "backendName": "cpu", "kernelFunc": AR };
function AH(qgu, qgj, qgL) {
  const qgI = (qgj - qgu) / (qgL - 1), qgb = T(qgL, "float32");
  qgb[0] = qgu;
  for (let qgR = 1; qgR < qgb["length"]; qgR++) qgb[qgR] = qgb[qgR - 1] + qgI;
  return qgb;
}
var AK = HH((qgu) => Math["log"](qgu));
function AB(qgu, qgj, qgL, qgI) {
  const qgb = X(qgI, i2(qgL));
  for (let qgR = 0; qgR < qgb["length"]; ++qgR) {
    const qgo = qgR * qgj;
    let qgr = qgu[qgo];
    for (let qgQ = 0; qgQ < qgj; ++qgQ) {
      const qgd = qgu[qgo + qgQ];
      (Number["isNaN"](qgd) || qgd > qgr) && (qgr = qgd);
    }
    qgb[qgR] = qgr;
  }
  return qgb;
}
var AV = lY((qgu, qgj) => Math["max"](qgu, qgj));
var AJ = HZ(nP, AV);
var AY = { "kernelName": nP, "backendName": "cpu", "kernelFunc": AJ };
var AP = lY((qgu, qgj) => Math["min"](qgu, qgj));
var AU = HZ(pM, AP);
var h1 = { "kernelName": pM, "backendName": "cpu", "kernelFunc": AU };
var hq = lY((qgu, qgj) => qgu * qgj);
var hn = He((qgu, qgj, qgL, qgI) => ({ "real": qgu * qgL - qgj * qgI, "imag": qgu * qgI + qgj * qgL }));
var hM = HZ(pF, hq, hn);
var hF = { "kernelName": pF, "backendName": "cpu", "kernelFunc": hM };
function ht(qgu, qgj, qgL) {
  const qgI = Eq(-1, qgL);
  return hq([], qgj, qgI, qgu, qgL);
}
function hW(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  lK(qgI, "neg");
  const qgb = qgL["data"]["get"](qgI["dataId"])["values"], [qgR, qgo] = ht(qgb, qgI["shape"], qgI["dtype"]);
  return qgL["makeTensorInfo"](qgo, qgI["dtype"], qgR);
}
var hD = { "kernelName": pt, "backendName": "cpu", "kernelFunc": hW };
var ha = lY((qgu, qgj) => qgu !== qgj ? 1 : 0);
function hZ(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgj["length"], qgo = i2(qgj), qgr = y(qgj), qgQ = y(qgb), qgd = X(qgL, i2(qgb));
  for (let qgv = 0; qgv < qgo; ++qgv) {
    const qgy = V(qgv, qgR, qgr), qgl = new Array(qgy["length"]);
    for (let qgA = 0; qgA < qgl["length"]; qgA++) qgl[qgA] = qgy[qgI[qgA]];
    const qgH = B(qgl, qgR, qgQ);
    qgd[qgH] = qgu[qgv];
  }
  return qgd;
}
function he(qgu) {
  const { inputs: qgj, attrs: qgL, backend: qgI } = qgu, { x: qgb } = qgj, { perm: qgR } = qgL;
  lK(qgb, "transpose");
  const qgo = qgb["shape"]["length"], qgr = new Array(qgo);
  for (let qgv = 0; qgv < qgr["length"]; qgv++) qgr[qgv] = qgb["shape"][qgR[qgv]];
  const qgQ = qgI["data"]["get"](qgb["dataId"])["values"], qgd = hZ(qgQ, qgb["shape"], qgb["dtype"], qgR, qgr);
  return { "dataId": qgI["write"](qgd, qgr, qgb["dtype"]), "shape": qgr, "dtype": qgb["dtype"] };
}
var hz = { "kernelName": gD, "backendName": "cpu", "kernelFunc": he };
function hX(qgu, qgj, qgL, qgI) {
  const [qgb, qgR] = aq(qgu, qgI), qgo = ML(qgj, "int32"), qgr = T(i2(qgb), qgo), qgQ = i2(qgR);
  for (let qgd = 0; qgd < qgr["length"]; ++qgd) {
    const qgv = qgd * qgQ;
    let qgy = 1;
    for (let qgl = 0; qgl < qgQ; ++qgl) qgy *= qgL[qgv + qgl];
    qgr[qgd] = qgy;
  }
  return { "outVals": qgr, "outShape": qgb, "outDtype": qgo };
}
function hG(qgu, qgj, qgL) {
  qgu["forEach"]((qgI, qgb) => {
    if (qgI < 0 || qgI >= qgL) {
      const qgR = V(qgb, qgj["length"], y(qgj))["join"](",");
      throw new Error("indices[" + qgR + "] = " + qgI + " is not in [0, " + qgL + ")");
    }
  });
}
function hu(qgu, qgj) {
  for (let qgL = 0; qgL < qgu["length"]; ++qgL) {
    const qgI = qgu[qgL], qgb = qgL === qgu["length"] - 1 ? qgj : qgu[qgL + 1]["length"];
    if (qgI["length"] === 0) throw new Error("Ragged splits may not be empty");
    if (qgI[0] < 0) throw new Error("Ragged splits must be non-negative");
    if (qgI[qgI["length"] - 1] > qgb) throw new Error("Ragged splits must not point past values");
    for (let qgR = 1; qgR < qgI["length"]; ++qgR) if (qgI[qgR - 1] > qgI[qgR]) throw new Error("Ragged splits must be sorted in ascending order");
  }
}
function hj(qgu, qgj, qgL, qgI) {
  const qgb = [];
  let qgR = 0;
  const qgo = qgj["length"] - 1 + qgL["length"], qgr = new Array(qgo)["fill"](null)["map"](() => [0]);
  hu(qgL, qgI);
  let qgQ = 1;
  for (let qgd = 0; qgd < qgj["length"] - 1; ++qgd) {
    qgQ *= qgj[qgd];
    const qgv = qgj[qgd + 1];
    for (let qgy = 1; qgy < qgQ + 1; ++qgy) qgr[qgd]["push"](qgy * qgv);
  }
  for (let qgl = 0; qgl < qgu["length"]; ++qgl) {
    let qgH = qgu[qgl], qgA = qgu[qgl] + 1;
    for (let qgh = 0; qgh < qgL["length"]; ++qgh) {
      const qgT = qgL[qgh], qgK = qgh + qgj["length"] - 1;
      if (qgK >= 0) {
        const qgB = qgr[qgK], qgV = qgB[qgB["length"] - 1] - qgT[qgH];
        for (let qgJ = qgH; qgJ < qgA; ++qgJ) qgr[qgK]["push"](qgT[qgJ + 1] + qgV);
      }
      qgH = qgT[qgH], qgA = qgT[qgA];
    }
    qgA !== qgH && (qgb["push"]([qgH, qgA]), qgR += qgA - qgH);
  }
  return { "outSplits": qgr, "valueSlices": qgb, "numValues": qgR };
}
function hL(qgu) {
  const qgj = [];
  for (let qgL = 0; qgL < qgu["length"]; ++qgL) {
    const qgI = qgu[qgL]["length"], qgb = G("int32", qgI);
    qgj["push"](qgb), qgu[qgL]["forEach"]((qgR, qgo) => qgb[qgo] = qgR);
  }
  return qgj;
}
function ho(qgu, qgj) {
  const qgL = qgu["slice"](0, qgj);
  for (; qgL["length"] < qgj; ) qgL["push"](1);
  for (let qgI = qgj; qgI < qgu["length"]; qgI++) qgL[qgj - 1] *= qgu[qgI];
  return qgL;
}
function hr(qgu, qgj, qgL, qgI, qgb, qgR) {
  const qgo = ho(qgj, 2)[1], qgr = ho(qgR, 2)[1];
  let qgQ = 0;
  for (const qgd of qgL) for (let qgv = qgd[0]; qgv < qgd[1]; ++qgv) {
    for (let qgy = 0; qgy < qgI; ++qgy) qgb[qgQ * qgr + qgy] = qgu[qgv * qgo + qgy];
    ++qgQ;
  }
}
function hQ(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgj["slice"]();
  qgR[0] = qgb;
  const qgo = G(qgL, i2(qgR)), qgr = qgu["length"], qgQ = qgr === 0 ? 0 : qgr / qgj[0];
  return hr(qgu, qgj, qgI, qgQ, qgo, qgR), [qgo, qgR];
}
function hH(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr) {
  if (qgu["length"] === 0) throw new Error("paramsNestedSplits must be non empty");
  if (qgj[0]["length"] === 0) throw new Error("Split tensors must not be scalars");
  const qgQ = qgj[0][0] - 1;
  if (hG(qgR, qgo, qgQ), qgI["length"] === 0) throw new Error("params.rank must be nonzero");
  const qgd = qgI[0], { outSplits: qgv, valueSlices: qgy, numValues: qgl } = hj(qgR, qgo, qgu, qgd), qgH = hL(qgv), qgA = hQ(qgL, qgI, qgb, qgy, qgl);
  return [qgH, qgA[0], qgA[1]];
}
var hK = 2147483647;
function hB(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
  if (qgj["length"] > 1) throw new Error("starts must be a scalar or vector");
  if (qgb["length"] > 1) throw new Error("limits must be a scalar or vector");
  if (qgo["length"] > 1) throw new Error("deltas must be a scalar or vector");
  const qgr = qgj["length"] === 0, qgQ = qgb["length"] === 0, qgd = qgo["length"] === 0, qgv = [];
  qgr || qgv["push"](qgj[0]), qgQ || qgv["push"](qgb[0]), qgd || qgv["push"](qgo[0]);
  for (let qgT = 1; qgT < qgv["length"]; ++qgT) if (qgv[qgT] !== qgv[qgT - 1]) throw new Error("starts, limits, and deltas must have the same shape");
  const qgy = qgv["length"] === 0 ? 1 : qgv[0], qgl = G("int32", qgy + 1);
  qgl[0] = 0;
  for (let qgK = 0; qgK < qgy; ++qgK) {
    const qgB = qgr ? qgu[0] : qgu[qgK], qgV = qgQ ? qgI[0] : qgI[qgK], qgJ = qgd ? qgR[0] : qgR[qgK];
    if (qgJ === 0) throw new Error("Requires delta != 0");
    let qgY;
    if (qgJ > 0 && qgV < qgB || qgJ < 0 && qgV > qgB) qgY = 0;
    else {
      if (qgY = Math["ceil"](Math["abs"]((qgV - qgB) / qgJ)), qgY > hK) throw new Error("Requires ((limit - start) / delta) <= " + hK);
    }
    qgl[qgK + 1] = qgl[qgK] + qgY;
  }
  const qgH = qgl[qgy], qgA = G(qgL, qgH);
  let qgh = 0;
  for (let qgP = 0; qgP < qgy; ++qgP) {
    const qgU = qgl[qgP + 1] - qgl[qgP];
    let qx0 = qgr ? qgu[0] : qgu[qgP];
    const qx1 = qgd ? qgR[0] : qgR[qgP];
    for (let qx2 = 0; qx2 < qgU; ++qx2) qgA[qgh++] = qx0, qx0 += qx1;
  }
  return [qgl, qgA];
}
var hV = GZ;
var hJ = class _hJ {
  constructor(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd) {
    this["shape"] = qgu, this["shapeShape"] = qgj, this["values"] = qgL, this["valuesShape"] = qgI, this["valuesDType"] = qgb, this["defaultValue"] = qgR, this["defaultValueShape"] = qgo, this["rowPartitionValues"] = qgr, this["rowPartitionValuesShapes"] = qgQ, this["rowPartitionTypes"] = Gz(qgd), this["raggedRank"] = GX(this["rowPartitionTypes"]);
  }
  ["getRowPartitionTypeByDimension"](qgu) {
    return this["rowPartitionTypes"][0] === hV["FIRST_DIM_SIZE"] ? this["rowPartitionTypes"][qgu + 1] : this["rowPartitionTypes"][qgu];
  }
  ["getRowPartitionTensor"](qgu) {
    return this["rowPartitionTypes"][0] === hV["FIRST_DIM_SIZE"] ? this["rowPartitionValues"][qgu + 1] : this["rowPartitionValues"][qgu];
  }
  ["getMaxWidth"](qgu) {
    const qgj = this["getRowPartitionTensor"](qgu - 1);
    switch (this["getRowPartitionTypeByDimension"](qgu - 1)) {
      case hV["VALUE_ROWIDS"]:
        return _hJ["getMaxWidthValueRowID"](qgj);
      case hV["ROW_SPLITS"]:
        return _hJ["getMaxWidthRowSplit"](qgj);
      default:
        throw new Error("Cannot handle partition type " + hV[this["getRowPartitionTypeByDimension"](qgu - 1)]);
    }
  }
  static ["getMaxWidthRowSplit"](qgu) {
    const qgj = qgu["length"];
    if (qgj === 0 || qgj === 1) return 0;
    let qgL = 0;
    for (let qgI = 0; qgI < qgj - 1; ++qgI) {
      const qgb = qgu[qgI + 1] - qgu[qgI];
      qgb > qgL && (qgL = qgb);
    }
    return qgL;
  }
  static ["getMaxWidthValueRowID"](qgu) {
    const qgj = qgu["length"];
    if (qgj === 0) return 0;
    let qgL = 0, qgI = qgu[0], qgb = 0;
    for (let qgR = 1; qgR < qgj; ++qgR) {
      const qgo = qgu[qgR];
      qgo !== qgI && (qgI = qgo, qgb = Math["max"](qgR - qgL, qgb), qgL = qgR);
    }
    return Math["max"](qgj - qgL, qgb);
  }
  ["tensorShapeFromTensor"](qgu, qgj, qgL = true) {
    if (qgj["length"] === 0) {
      if (qgu[0] === -1) return [];
      throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.");
    }
    return hP(qgu, qgL);
  }
  ["calculateOutputSize"](qgu) {
    const qgj = this["valuesShape"], qgL = this["defaultValueShape"];
    GG(qgL, qgj);
    const qgI = this["tensorShapeFromTensor"](this["shape"], this["shapeShape"]), qgb = Ge(this["raggedRank"], qgI, qgj);
    qgb[0] < 0 && (qgb[0] = qgu);
    for (let qgR = 1; qgR <= this["raggedRank"]; ++qgR) qgb[qgR] < 0 && (qgb[qgR] = this["getMaxWidth"](qgR));
    return qgb;
  }
  ["calculateFirstParentOutputIndex"](qgu, qgj, qgL) {
    const qgI = Math["min"](qgu, qgL), qgb = [];
    let qgR = 0;
    for (let qgo = 0; qgo < qgI; ++qgo, qgR += qgj) qgb["push"](qgR);
    for (let qgr = qgI; qgr < qgu; ++qgr) qgb["push"](-1);
    return k(qgb["length"] === qgu, () => "Final length of result must be equal to firstDimension."), qgb;
  }
  ["calculateOutputIndexRowSplit"](qgu, qgj, qgL, qgI) {
    const qgb = qgu["length"], qgR = [];
    for (let qgo = 0; qgo < qgb - 1; ++qgo) {
      const qgr = qgu[qgo + 1] - qgu[qgo];
      let qgQ = Math["min"](qgI, qgr), qgd = qgj[qgo];
      qgd === -1 && (qgQ = 0);
      for (let qgv = 0; qgv < qgQ; ++qgv) qgR["push"](qgd), qgd += qgL;
      for (let qgy = 0; qgy < qgr - qgQ; ++qgy) qgR["push"](-1);
    }
    if (qgb > 0 && qgR["length"] !== qgu[qgb - 1]) throw new Error("Invalid row split size.");
    return qgR;
  }
  ["calculateOutputIndexValueRowID"](qgu, qgj, qgL, qgI) {
    const qgb = qgu["length"], qgR = [];
    if (qgb === 0) return [];
    let qgo = 0, qgr = qgu[0];
    if (qgr >= qgj["length"]) throw new Error("Got currentValueRowId=" + qgr + ", which is not less than " + qgj["length"]);
    let qgQ = qgj[qgr];
    qgR["push"](qgQ);
    for (let qgd = 1; qgd < qgb; ++qgd) {
      const qgv = qgu[qgd];
      if (qgv === qgr) qgQ >= 0 && (++qgo, qgo < qgI ? qgQ += qgL : qgQ = -1);
      else {
        if (qgo = 0, qgr = qgv, qgv >= qgj["length"]) throw new Error("Got nextValueRowId=" + qgv + " which is not less than " + qgj["length"]);
        qgQ = qgj[qgv];
      }
      qgR["push"](qgQ);
    }
    if (qgR["length"] !== qgu["length"]) throw new Error("Invalid row ids.");
    return qgR;
  }
  ["calculateOutputIndex"](qgu, qgj, qgL, qgI) {
    const qgb = this["getRowPartitionTensor"](qgu), qgR = this["getRowPartitionTypeByDimension"](qgu);
    switch (qgR) {
      case hV["VALUE_ROWIDS"]:
        return this["calculateOutputIndexValueRowID"](qgb, qgj, qgL, qgI);
      case hV["ROW_SPLITS"]:
        if (qgb["length"] - 1 > qgj["length"]) throw new Error("Row partition size is greater than output size: " + (qgb["length"] - 1) + " > " + qgj["length"]);
        return this["calculateOutputIndexRowSplit"](qgb, qgj, qgL, qgI);
      default:
        throw new Error("Unsupported partition type: " + hV[qgR]);
    }
  }
  ["getFirstDimensionSize"]() {
    const qgu = this["rowPartitionValues"][0];
    if (this["rowPartitionTypes"]["length"] === 0) throw new Error("No row_partition_types given.");
    const qgj = this["rowPartitionTypes"][0];
    switch (qgj) {
      case hV["FIRST_DIM_SIZE"]:
        return qgu[0];
      case hV["VALUE_ROWIDS"]:
        throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");
      case hV["ROW_SPLITS"]:
        return this["rowPartitionValuesShapes"][0][0] - 1;
      default:
        throw new Error("Cannot handle type " + hV[qgj]);
    }
  }
  ["compute"]() {
    if (this["rowPartitionValues"][0]["length"] <= 0) throw new Error("Invalid first partition input. Tensor requires at least one element.");
    const qgu = this["getFirstDimensionSize"](), qgj = this["calculateOutputSize"](qgu), qgL = new Array(this["raggedRank"] + 1);
    qgL[qgL["length"] - 1] = 1;
    for (let qgR = qgL["length"] - 2; qgR >= 0; --qgR) qgL[qgR] = qgL[qgR + 1] * qgj[qgR + 1];
    const qgI = hP(qgj, false), qgb = G(this["valuesDType"], i2(qgI));
    if (qgL[0] * qgj[0] > 0) {
      let qgo = this["calculateFirstParentOutputIndex"](qgu, qgL[0], qgj[0]);
      for (let qgr = 1; qgr <= this["raggedRank"]; ++qgr) qgo = this["calculateOutputIndex"](qgr - 1, qgo, qgL[qgr], qgj[qgr]);
      this["setOutput"](this["raggedRank"], qgo, qgb, qgI);
    }
    return [qgI, qgb];
  }
  ["setOutput"](qgu, qgj, qgL, qgI) {
    if (qgL["length"] === 0) return;
    const qgb = this["values"], qgR = qgL;
    let qgo = qgI["slice"]();
    qgo = qgo["slice"](qgu + 1);
    const qgr = i2(qgo), qgQ = qgj["length"];
    let qgd = this["defaultValue"];
    if (qgd["length"] !== qgr && qgd["length"] !== 1) {
      const qgH = this["defaultValueShape"];
      Sq(() => {
        const qgA = DW(qgd, qgH);
        qgd = DJ(qgA, qgo)["dataSync"]();
      });
    }
    let qgv = 0, qgy = 0, qgl = 0;
    for (let qgA = 0; qgA <= qgQ; ++qgA) {
      let qgh = qgA < qgQ ? qgj[qgA] : -1;
      if (qgh === qgl) {
        ++qgl;
        continue;
      }
      if (qgy < qgl) {
        const qgT = qgb["subarray"](qgv * qgr), qgK = qgR["subarray"](qgy * qgr), qgB = (qgl - qgy) * qgr;
        hY(qgK, qgT, qgB);
      }
      if (qgA >= qgQ) {
        const qgV = qgL["length"];
        qgh = Math["floor"](qgV / qgr);
      }
      if (qgh > qgl) {
        if (this["defaultValue"]["length"] === 1) qgR["subarray"](qgl * qgr, qgh * qgr)["fill"](this["defaultValue"][0]), qgl = qgh;
        else for (; qgh > qgl; ) {
          const qgJ = qgR["slice"](qgl * qgr);
          hY(qgJ, qgd, qgr), ++qgl;
        }
      }
      qgh < 0 ? (qgv = qgA + 1, qgy = qgl) : (qgv = qgA, qgy = qgl, qgl = qgy + 1);
    }
  }
};
function hY(qgu, qgj, qgL) {
  for (let qgI = 0; qgI < qgL; qgI++) qgu[qgI] = qgj[qgI];
}
function hP(qgu, qgj) {
  const qgL = [];
  for (let qgI of qgu) {
    if (qgI < 0) {
      if (!qgj) throw new Error("Dimension " + qgI + " must be >= 0");
      if (qgI < -1) throw new Error("Dimension " + qgI + " must be >= -1");
      qgI = -1;
    }
    qgL["push"](qgI);
  }
  return qgL;
}
function hU(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd) {
  return new hJ(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd)["compute"]();
}
function Tq(qgu, qgj, qgL, qgI) {
  const qgb = qgu === qgj, qgR = qgu < qgj && qgL < 0, qgo = qgj < qgu && qgL > 1;
  if (qgb || qgR || qgo) return T(0, qgI);
  const qgr = Math["abs"](Math["ceil"]((qgj - qgu) / qgL)), qgQ = T(qgr, qgI);
  qgj < qgu && qgL === 1 && (qgL = -1), qgQ[0] = qgu;
  for (let qgd = 1; qgd < qgQ["length"]; qgd++) qgQ[qgd] = qgQ[qgd - 1] + qgL;
  return qgQ;
}
var TM = HH((qgu) => 1 / Math["sqrt"](qgu));
function TF(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd) {
  const qgv = [qgI / qgb, qgb], qgy = qgu["values"], qgl = qgj["values"];
  if (qgI === 0) return DY(qgL, qgj["dtype"]);
  const qgH = qgQ instanceof EU ? qgQ : DY(qgv, qgj["dtype"]);
  typeof qgQ == "string" || typeof qgQ == "number" ? qgH["values"]["fill"](qgQ) : typeof qgQ == "boolean" && qgH["values"]["fill"](+qgQ);
  for (let qgA = 0; qgA < qgR; qgA++) {
    const qgh = [];
    let qgT = 0;
    for (let qgK = 0; qgK < qgo; qgK++) {
      const qgB = qgy[qgA * qgo + qgK];
      qgh["push"](qgB), qgT += qgB * qgr[qgK];
    }
    if (qgT < 0 || qgT >= qgI / qgb) throw new Error("Invalid indices: " + qgh + " does not index into " + qgL);
    for (let qgV = 0; qgV < qgb; qgV++) qgd ? qgH["values"][qgT * qgb + qgV] += qgl[qgA * qgb + qgV] : qgH["values"][qgT * qgb + qgV] = qgj["rank"] === 0 ? qgl[0] : qgl[qgA * qgb + qgV];
  }
  return qgH;
}
var TW = HH((qgu) => 1 / (1 + Math["exp"](-qgu)));
var TD = HK(pY, (qgu) => 1 / (1 + Math["exp"](-qgu)));
var TZ = { "kernelName": pY, "backendName": "cpu", "kernelFunc": TD };
function Te(qgu, qgj, qgL, qgI, qgb) {
  const qgR = WL(qgI, qgj, qgL), qgo = i2(qgL), qgr = y(qgI);
  if (qgR) {
    const qgy = WR(qgj, qgr);
    return qgb === "string" ? qgu["slice"](qgy, qgy + qgo) : qgu["subarray"](qgy, qgy + qgo);
  }
  const qgQ = qgb === "string" ? uo(qgu) : qgu, qgd = DY(qgI, qgb, qgQ), qgv = DY(qgL, qgb);
  for (let qgl = 0; qgl < qgv["size"]; ++qgl) {
    const qgH = qgv["indexToLoc"](qgl), qgA = qgH["map"]((qgh, qgT) => qgh + qgj[qgT]);
    qgv["set"](qgd["get"](...qgA), ...qgH);
  }
  return qgb === "string" ? ur(qgv["values"]) : qgv["values"];
}
function Tz(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { begin: qgR, size: qgo } = qgI;
  lK(qgb, "slice");
  const [qgr, qgQ] = WQ(qgb, qgR, qgo);
  Wq(qgb, qgr, qgQ);
  const qgd = qgL["data"]["get"](qgb["dataId"])["values"], qgv = Te(qgd, qgr, qgQ, qgb["shape"], qgb["dtype"]);
  return qgL["makeTensorInfo"](qgQ, qgb["dtype"], qgv);
}
var TX = { "kernelName": pV, "backendName": "cpu", "kernelFunc": Tz };
function TG(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
  const qgr = qgj[0], qgQ = qgR[0], qgd = new Array(qgQ), qgv = new Array(qgr), qgy = qgj[1];
  if (qgQ === 0) {
    if (qgr !== 0) throw new Error(NU(qgr));
    const qgT = G(qgL, 0), qgK = G(qgb, 0);
    return [qgT, [0, qgy], qgK, qgd, qgv];
  }
  let qgl = true, qgH = 0;
  const qgA = new Array(qgQ)["fill"](0);
  for (let qgB = 0; qgB < qgr; ++qgB) {
    const qgV = qgu[qgB * qgy];
    if (qgV < 0) throw new Error(uq(qgB, qgV));
    if (qgV >= qgQ) throw new Error(uM(qgB, qgV, qgQ));
    ++qgA[qgV], qgl = qgl && qgV >= qgH, qgH = qgV;
  }
  let qgh = true;
  for (let qgJ = 0; qgJ < qgQ; ++qgJ) {
    const qgY = qgA[qgJ] === 0;
    qgd[qgJ] = qgY, qgh = qgh && !qgY, qgA[qgJ] = Math["max"](qgA[qgJ], 1), qgJ > 0 && (qgA[qgJ] += qgA[qgJ - 1]);
  }
  if (qgh && qgl) {
    const qgP = qgu, qgU = qgI;
    for (let qx0 = 0; qx0 < qgr; ++qx0) qgv[qx0] = qx0;
    return [qgP, [qgr, qgy], qgU, qgd, qgv];
  } else {
    const qx1 = qgA[qgQ - 1], qx2 = G(qgL, qx1 * qgy), qx3 = G(qgb, qx1), qx4 = new Array(qgQ)["fill"](0);
    for (let qx5 = 0; qx5 < qgr; ++qx5) {
      const qx6 = qgu[qx5 * qgy], qx7 = qx4[qx6], qx8 = (qx6 === 0 ? 0 : qgA[qx6 - 1]) + qx7;
      qx4[qx6]++;
      for (let qx9 = 0; qx9 < qgy; ++qx9) qx2[qx8 * qgy + qx9] = qgu[qx5 * qgy + qx9];
      qx3[qx8] = qgI[qx5], qgv[qx5] = qx8;
    }
    for (let qxq = 0; qxq < qgQ; ++qxq) if (qx4[qxq] === 0) {
      const qxn = qxq === 0 ? 0 : qgA[qxq - 1];
      qx2[qxn * qgy + 0] = qxq;
      for (let qxp = 1; qxp < qgy; ++qxp) qx2[qxn * qgy + qxp] = 0;
      qx3[qxn] = qgo;
    }
    return [qx2, [qx1, qgy], qx3, qgd, qgv];
  }
}
function Tu(qgu, qgj, qgL, qgI, qgb) {
  const qgR = i2(qgI), qgo = qgj[0], qgr = qgb["length"], qgQ = [];
  let qgd = 1, qgv = -1;
  for (let qgh = 0; qgh < qgr; ++qgh) {
    const qgT = qgb[qgh];
    if (qgT === -1) {
      if (qgv !== -1) throw new Error(uF(qgv, qgh));
      qgv = qgh, qgQ["push"](1);
    } else {
      if (qgT < 0) throw new Error(ut(qgh, qgT));
      qgd *= qgT, qgQ["push"](qgT);
    }
  }
  if (qgv !== -1) {
    if (qgd <= 0) throw new Error(uW());
    const qgK = Math["trunc"](qgR / qgd);
    if (qgd * qgK !== qgR) throw new Error(uD(qgI, qgQ));
    qgQ[qgv] = qgK;
  }
  if (i2(qgQ) !== qgR) throw new Error(ua(qgI, qgQ));
  const qgy = qgI["length"], qgl = [];
  if (qgy > 0) {
    qgl[qgy - 1] = 1;
    for (let qgB = qgy - 2; qgB >= 0; --qgB) qgl[qgB] = qgl[qgB + 1] * qgI[qgB + 1];
  }
  const qgH = [];
  if (qgr > 0) {
    qgH[qgr - 1] = 1;
    for (let qgV = qgr - 2; qgV >= 0; --qgV) qgH[qgV] = qgH[qgV + 1] * qgQ[qgV + 1];
  }
  const qgA = G(qgL, qgo * qgr);
  for (let qgJ = 0; qgJ < qgo; ++qgJ) {
    let qgY = 0;
    for (let qgP = 0; qgP < qgy; ++qgP) qgY += qgu[qgJ * qgy + qgP] * qgl[qgP];
    for (let qgU = 0; qgU < qgr; ++qgU) qgA[qgJ * qgr + qgU] = Math["trunc"](qgY / qgH[qgU]), qgY %= qgH[qgU];
  }
  return [qgA, [qgo, qgr], qgQ];
}
function Tj(qgu, qgj, qgL, qgI, qgb, qgR = false, qgo = 0) {
  const qgr = qgI["length"], qgQ = [qgj[0], qgu["length"] / qgj[0]], qgd = qgQ[1], qgv = qgr > 0 ? qgb[qgr - 1] + 1 : 0;
  if (qgv < 0) throw new Error(uZ());
  const qgy = qgj["slice"]();
  qgy[0] = qgv;
  const qgl = qgy["reduce"]((qgB, qgV) => qgB * qgV, 1), qgH = G(qgL, qgl);
  if (qgr === 0) return qgv > 0 && qgH["fill"](qgo), [qgH, qgy];
  if (qgv <= 0) throw new Error(uZ());
  let qgA = 0, qgh = 1, qgT = 0, qgK = qgb[qgA];
  for (; ; ) {
    let qgB = 0;
    if (qgh < qgr) {
      if (qgB = qgb[qgh], qgK === qgB) {
        ++qgh;
        continue;
      }
      if (qgK >= qgB) throw new Error(ue());
    }
    if (qgK < 0 || qgK >= qgv) throw new Error(uz(qgK, qgv));
    qgK > qgT && qgH["fill"](qgo, qgT * qgd, qgK * qgd);
    for (let qgV = qgA; qgV < qgh; ++qgV) {
      const qgJ = qgI[qgV];
      if (qgJ < 0 || qgJ >= qgQ[0]) throw new Error(uX(qgV, qgI[qgV], qgQ[0]));
      for (let qgY = 0; qgY < qgd; qgY++) qgH[qgK * qgd + qgY] += qgu[qgJ * qgd + qgY];
    }
    if (qgR) {
      for (let qgP = 0; qgP < qgd; qgP++) qgH[qgK * qgd + qgP] /= qgh - qgA;
    }
    if (qgA = qgh, ++qgh, qgT = qgK + 1, qgK = qgB, qgh > qgr) break;
  }
  return qgT < qgv && qgH["fill"](qgo, qgT * qgd, qgv * qgd), [qgH, qgy];
}
var TL = HH((qgu) => Math["sqrt"](qgu));
var TQ = HK(pP, (qgu) => Math["sqrt"](qgu));
var TH = { "kernelName": pP, "backendName": "cpu", "kernelFunc": TQ };
var TK = lY((qgu, qgj) => {
  const qgL = qgu - qgj;
  return qgL * qgL;
});
var TB = HH((qgu, qgj) => {
  const { pattern: qgL, replaceGlobal: qgI, rewrite: qgb } = qgj;
  return qgu["replace"](new RegExp(qgL, qgI ? "g" : ""), qgb);
});
function TV(qgu, qgj, qgL, qgI) {
  const qgb = DY(qgu, qgj["dtype"]);
  for (let qgR = 0; qgR < qgb["size"]; qgR++) {
    const qgo = qgb["indexToLoc"](qgR), qgr = new Array(qgo["length"]);
    for (let qgQ = 0; qgQ < qgr["length"]; qgQ++) qgr[qgQ] = qgo[qgQ] * qgL[qgQ] + qgI[qgQ];
    qgb["set"](qgj["get"](...qgr), ...qgo);
  }
  return qgb;
}
var TJ = class {
  constructor(qgu, qgj, qgL, qgI, qgb, qgR) {
    this["separator"] = Et(qgu), this["nGramWidths"] = qgj, this["leftPad"] = Et(qgL), this["rightPad"] = Et(qgI), this["padWidth"] = qgb, this["preserveShort"] = qgR;
  }
  ["getPadWidth"](qgu) {
    return Math["min"](this["padWidth"] < 0 ? qgu - 1 : this["padWidth"], qgu - 1);
  }
  ["getNumNGrams"](qgu, qgj) {
    const qgL = this["getPadWidth"](qgj);
    return Math["max"](0, qgu + 2 * qgL - qgj + 1);
  }
  ["createNGrams"](qgu, qgj, qgL, qgI, qgb, qgR) {
    for (let qgo = 0; qgo < qgb; ++qgo) {
      const qgr = this["getPadWidth"](qgR), qgQ = Math["max"](0, qgr - qgo), qgd = Math["max"](0, qgr - (qgb - (qgo + 1))), qgv = qgR - (qgQ + qgd), qgy = qgj + (qgQ > 0 ? 0 : qgo - qgr);
      let qgl = 0;
      qgl += qgQ * this["leftPad"]["length"];
      for (let qgK = 0; qgK < qgv; ++qgK) qgl += qgu[qgy + qgK]["length"];
      qgl += qgd * this["rightPad"]["length"];
      const qgH = qgQ + qgd + qgv - 1;
      qgl += qgH * this["separator"]["length"], qgL[qgI + qgo] = new Uint8Array(qgl);
      const qgA = qgL[qgI + qgo];
      let qgh = 0;
      const qgT = (qgB) => qgB["forEach"]((qgV) => qgA[qgh++] = qgV);
      for (let qgB = 0; qgB < qgQ; ++qgB) qgT(this["leftPad"]), qgT(this["separator"]);
      for (let qgV = 0; qgV < qgv - 1; ++qgV) qgT(qgu[qgy + qgV]), qgT(this["separator"]);
      if (qgv > 0) {
        qgT(qgu[qgy + qgv - 1]);
        for (let qgJ = 0; qgJ < qgd; ++qgJ) qgT(this["separator"]), qgT(this["rightPad"]);
      } else {
        for (let qgY = 0; qgY < qgd - 1; ++qgY) qgT(this["rightPad"]), qgT(this["separator"]);
        qgT(this["rightPad"]);
      }
    }
  }
  ["compute"](qgu, qgj) {
    const qgL = qgu["length"], qgI = qgj["length"];
    if (qgI > 0) {
      let qgr = qgj[0];
      if (qgr !== 0) throw new Error("First split value must be 0, got " + qgr);
      for (let qgQ = 1; qgQ < qgI; ++qgQ) {
        let qgd = qgj[qgQ] >= qgr;
        if (qgd = qgd && qgj[qgQ] <= qgL, !qgd) throw new Error("Invalid split value " + qgj[qgQ] + ", must be in [" + qgr + ", " + qgL + "]");
        qgr = qgj[qgQ];
      }
      if (qgr !== qgL) throw new Error("Last split value must be data size. Expected " + qgL + ", got " + qgr);
    }
    const qgb = qgI - 1, qgR = G("int32", qgI);
    if (qgL === 0 || qgI === 0) {
      const qgv = new Array(qgL);
      for (let qgy = 0; qgy <= qgb; ++qgy) qgR[qgy] = 0;
      return [qgv, qgR];
    }
    qgR[0] = 0;
    for (let qgl = 1; qgl <= qgb; ++qgl) {
      const qgH = qgj[qgl] - qgj[qgl - 1];
      let qgA = 0;
      this["nGramWidths"]["forEach"]((qgh) => {
        qgA += this["getNumNGrams"](qgH, qgh);
      }), this["preserveShort"] && qgH > 0 && qgA === 0 && (qgA = 1), qgR[qgl] = qgR[qgl - 1] + qgA;
    }
    const qgo = new Array(qgR[qgb]);
    for (let qgh = 0; qgh < qgb; ++qgh) {
      const qgT = qgj[qgh];
      let qgK = qgR[qgh];
      if (this["nGramWidths"]["forEach"]((qgB) => {
        const qgV = qgj[qgh + 1] - qgj[qgh], qgJ = this["getNumNGrams"](qgV, qgB);
        this["createNGrams"](qgu, qgT, qgo, qgK, qgJ, qgB), qgK += qgJ;
      }), this["preserveShort"] && qgK === qgR[qgh]) {
        const qgB = qgj[qgh + 1] - qgj[qgh];
        if (qgB === 0) continue;
        const qgV = qgB + 2 * this["padWidth"];
        this["createNGrams"](qgu, qgT, qgo, qgK, 1, qgV);
      }
    }
    return [qgo, qgR];
  }
};
function TY(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr) {
  return new TJ(qgL, qgI, qgb, qgR, qgo, qgr)["compute"](qgu, qgj);
}
function TP(qgu, qgj, qgL, qgI) {
  if (!qgu["length"]) return;
  if (qgj["length"] === 0) {
    for (let qgR = 0; qgR < qgu["length"]; ++qgR) qgI["push"](qgu["subarray"](qgR, qgR + 1));
    return;
  }
  if (qgj["length"] === 1) {
    const qgo = qgj[0];
    let qgr = qgu["indexOf"](qgo);
    for (; qgr !== -1; ) {
      const qgQ = qgu["subarray"](0, qgr);
      (!qgL || qgQ["length"] !== 0) && qgI["push"](qgQ), qgu = qgu["subarray"](qgr + 1), qgr = qgu["indexOf"](qgo);
    }
    (!qgL || qgu["length"] !== 0) && qgI["push"](qgu);
    return;
  }
  let qgb = 0;
  for (let qgd = 0; qgd < qgu["length"] + 1; qgd++) if (qgd === qgu["length"] || qgj["indexOf"](qgu[qgd]) !== -1) {
    const qgv = qgu["subarray"](qgb, qgd);
    (!qgL || qgv["length"] !== 0) && qgI["push"](qgv), qgb = qgd + 1;
  }
}
function TU(qgu, qgj, qgL) {
  const qgI = qgu["length"], qgb = [];
  let qgR = 0, qgo = 0;
  const qgr = new Array(qgI);
  for (let qgl = 0; qgl < qgI; ++qgl) {
    const qgH = qgb["length"];
    TP(qgu[qgl], qgj, qgL, qgb);
    const qgA = qgb["length"] - qgH;
    qgr[qgl] = qgA, qgR += qgA, qgo = Math["max"](qgo, qgA);
  }
  const qgQ = G("int32", qgR * 2), qgd = new Array(qgR), qgv = [qgI, qgo];
  let qgy = 0;
  for (let qgh = 0; qgh < qgI; ++qgh) for (let qgT = 0; qgT < qgr[qgh]; ++qgT) qgQ[qgy * 2] = qgh, qgQ[qgy * 2 + 1] = qgT, qgd[qgy] = qgb[qgy], ++qgy;
  return [qgQ, qgd, qgv];
}
function K6(qgu, qgj) {
  const qgL = G("int32", qgu["length"]);
  for (let qgI = 0; qgI < qgu["length"]; ++qgI) qgL[qgI] = sU(qgu[qgI])["modulo"](qgj)["getLowBitsUnsigned"]();
  return qgL;
}
var Kq = lY((qgu, qgj) => qgu - qgj);
var Kn = He((qgu, qgj, qgL, qgI) => ({ "real": qgu - qgL, "imag": qgj - qgI }));
var KM = HZ(gM, Kq, Kn);
var KF = { "kernelName": gM, "backendName": "cpu", "kernelFunc": KM };
function Kt(qgu, qgj) {
  const qgL = new Array(qgu["rank"]);
  for (let qgb = 0; qgb < qgL["length"]; qgb++) qgL[qgb] = qgu["shape"][qgb] * qgj[qgb];
  const qgI = DY(qgL, qgu["dtype"]);
  for (let qgR = 0; qgR < qgI["values"]["length"]; ++qgR) {
    const qgo = qgI["indexToLoc"](qgR), qgr = new Array(qgu["rank"]);
    for (let qgd = 0; qgd < qgr["length"]; qgd++) qgr[qgd] = qgo[qgd] % qgu["shape"][qgd];
    const qgQ = qgu["locToIndex"](qgr);
    qgI["values"][qgR] = qgu["values"][qgQ];
  }
  return qgI;
}
var KW = (qgu, qgj) => {
  const qgL = qgj["value"] - qgu["value"];
  return qgL === 0 ? qgu["index"] - qgj["index"] : qgL;
};
function KD(qgu, qgj, qgL = 0, qgI = qgu["length"] - 1) {
  for (; qgI > qgL; ) {
    if (qgI - qgL > 600) {
      const qgr = qgI - qgL + 1, qgQ = qgj - qgL + 1, qgd = Math["log"](qgr), qgv = 0.5 * Math["exp"](2 * qgd / 3), qgy = 0.5 * Math["sqrt"](qgd * qgv * (qgr - qgv) / qgr) * Math["sign"](qgQ - qgr / 2), qgl = Math["max"](qgL, Math["floor"](qgj - qgQ * qgv / qgr + qgy)), qgH = Math["min"](qgI, Math["floor"](qgj + (qgr - qgQ) * qgv / qgr + qgy));
      KD(qgu, qgj, qgl, qgH);
    }
    const qgb = qgu[qgj];
    let qgR = qgL, qgo = qgI;
    for (S(qgu, qgL, qgj), KW(qgu[qgI], qgb) > 0 && S(qgu, qgL, qgI); qgR < qgo; ) {
      for (S(qgu, qgR, qgo), qgR++, qgo--; KW(qgu[qgR], qgb) < 0; ) qgR = qgR + 1;
      for (; KW(qgu[qgo], qgb) > 0; ) qgo = qgo - 1;
    }
    KW(qgu[qgL], qgb) === 0 ? S(qgu, qgL, qgo) : (qgo = qgo + 1, S(qgu, qgo, qgI)), qgo <= qgj && (qgL = qgo + 1), qgj <= qgo && (qgI = qgo - 1);
  }
}
function Ka(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgj[qgj["length"] - 1], [qgo, qgr] = [qgu["length"] / qgR, qgR], qgQ = X(qgL, qgo * qgI), qgd = X("int32", qgo * qgI);
  for (let qgy = 0; qgy < qgo; qgy++) {
    const qgl = qgy * qgr, qgH = qgu["subarray"](qgl, qgl + qgr);
    let qgA = new Array(qgH["length"]);
    qgH["forEach"]((qgB, qgV) => qgA[qgV] = { "value": qgB, "index": qgV }), qgI < qgA["length"] && (KD(qgA, qgI), qgA = qgA["slice"](0, qgI)), qgb && qgA["sort"](KW);
    const qgh = qgy * qgI, qgT = qgQ["subarray"](qgh, qgh + qgI), qgK = qgd["subarray"](qgh, qgh + qgI);
    for (let qgB = 0; qgB < qgI; qgB++) qgT[qgB] = qgA[qgB]["value"], qgK[qgB] = qgA[qgB]["index"];
  }
  const qgv = qgj["slice"]();
  return qgv[qgv["length"] - 1] = qgI, [DY(qgv, qgL, qgQ), DY(qgv, "int32", qgd)];
}
function KZ(qgu, qgj, qgL, qgI) {
  const qgb = z(qgj, qgL)[0], qgR = [1, qgL[0], 1];
  for (let qgA = 0; qgA < qgb; qgA++) qgR[0] *= qgL[qgA];
  qgR[1] = qgL[qgb];
  for (let qgh = qgb + 1; qgh < qgL["length"]; qgh++) qgR[2] *= qgL[qgh];
  const qgo = /* @__PURE__ */ new Map(), qgr = new Int32Array(qgL[qgb]), qgQ = new EU(qgR, qgI, qgu), qgd = [], qgv = qgR[0] === 1 && qgR[2] === 1;
  for (let qgT = 0; qgT < qgL[qgb]; qgT++) {
    let qgK;
    if (qgv) qgK = qgu[qgT]["toString"]();
    else {
      const qgV = [];
      for (let qgJ = 0; qgJ < qgR[0]; qgJ++) for (let qgY = 0; qgY < qgR[2]; qgY++) qgV["push"](qgQ["get"](qgJ, qgT, qgY));
      qgK = qgV["join"](",");
    }
    const qgB = qgo["get"](qgK);
    if (qgB != null) qgr[qgT] = qgB;
    else {
      const qgP = qgo["size"];
      qgo["set"](qgK, qgP), qgr[qgT] = qgP, qgd["push"](qgT);
    }
  }
  const qgy = qgR["slice"]();
  qgy[1] = qgo["size"];
  const qgl = new EU(qgy, qgI);
  qgd["forEach"]((qgU, qx0) => {
    for (let qx1 = 0; qx1 < qgR[0]; qx1++) for (let qx2 = 0; qx2 < qgR[2]; qx2++) qgl["set"](qgQ["get"](qx1, qgU, qx2), qx1, qx0, qx2);
  });
  const qgH = qgL["slice"]();
  return qgH[qgb] = qgy[1], { "outputValues": qgl["values"], "outputShape": qgH, "indices": qgr };
}
var Ke = Object["freeze"]({ "__proto__": null, "addImpl": HX, "bincountImpl": HR, "bincountReduceImpl": Ho, "bitwiseAndImpl": HQ, "castImpl": HF, "ceilImpl": HV, "concatImpl": HJ, "equalImpl": HY, "expImpl": HP, "expm1Impl": HU, "floorDivImpl": At, "floorImpl": Aq, "gatherNdImpl": AW, "gatherV2Impl": AD, "greaterEqualImpl": Ae, "greaterImpl": AZ, "lessEqualImpl": AL, "lessImpl": AG, "linSpaceImpl": AH, "logImpl": AK, "maxImpl": AB, "maximumImpl": AV, "minimumImpl": AP, "multiplyImpl": hq, "negImpl": ht, "notEqualImpl": ha, "prodImpl": hX, "raggedGatherImpl": hH, "raggedRangeImpl": hB, "raggedTensorToTensorImpl": hU, "rangeImpl": Tq, "rsqrtImpl": TM, "scatterImpl": TF, "sigmoidImpl": TW, "simpleAbsImpl": lB, "sliceImpl": Te, "sparseFillEmptyRowsImpl": TG, "sparseReshapeImpl": Tu, "sparseSegmentReductionImpl": Tj, "sqrtImpl": TL, "squaredDifferenceImpl": TK, "staticRegexReplaceImpl": TB, "stridedSliceImpl": TV, "stringNGramsImpl": TY, "stringSplitImpl": TU, "stringToHashBucketFastImpl": K6, "subImpl": Kq, "tileImpl": Kt, "topKImpl": Ka, "transposeImpl": hZ, "uniqueImpl": KZ });
var { addImpl: Kz, bincountImpl: KX, bincountReduceImpl: KG, bitwiseAndImpl: Kj, castImpl: KL, ceilImpl: KR, concatImpl: Ko, equalImpl: KQ, expImpl: KH, expm1Impl: KK, floorImpl: KB, gatherNdImpl: KV, gatherV2Impl: KJ, greaterImpl: KY, greaterEqualImpl: KP, lessImpl: KU, lessEqualImpl: Bq, linSpaceImpl: Bn, logImpl: Bs, maxImpl: BM, maximumImpl: BF, minimumImpl: Bt, multiplyImpl: BW, negImpl: BD, notEqualImpl: BZ, prodImpl: Bz, raggedGatherImpl: BX, raggedRangeImpl: BG, raggedTensorToTensorImpl: Bj, rangeImpl: BL, rsqrtImpl: BR, scatterImpl: BQ, sigmoidImpl: BH, simpleAbsImpl: BK, sliceImpl: BB, sparseFillEmptyRowsImpl: BV, sparseReshapeImpl: BJ, sparseSegmentReductionImpl: BY, sqrtImpl: BP, staticRegexReplaceImpl: BU, stridedSliceImpl: Vq, stringNGramsImpl: Vn, stringSplitImpl: Vs, stringToHashBucketFastImpl: VM, subImpl: VF, tileImpl: VW, topKImpl: VD, transposeImpl: VZ, uniqueImpl: Ve } = Ke;
function Vz(qgu, qgj) {
  return ["x", "y", "z", "w", "u", "v"]["slice"](0, qgj)["map"]((qgL) => qgu + "." + qgL);
}
function VX(qgu, qgj) {
  return qgj === 1 ? [qgu] : Vz(qgu, qgj);
}
function VG(qgu, qgj) {
  if (qgu === 1) return "rc";
  let qgL = "";
  for (let qgI = 0; qgI < qgu; qgI++) qgL += qgj[qgI], qgI < qgu - 1 && (qgL += ",");
  return qgL;
}
var Vj = class {
  constructor(qgu) {
    if (this["variableNames"] = ["A"], this["packedInputs"] = false, this["packedOutput"] = true, this["outputShape"] = qgu, this["rank"] = qgu["length"], this["enableShapeUniforms"] = CG(this["outputShape"]["length"]), this["rank"] === 0) this["userCode"] = "\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";
    else {
      const qgj = VX("rc", this["rank"]), qgL = yU(this["rank"]), qgI = this["getOutOfBoundsCondition"](qgj), qgb = this["getSetup"](qgj), qgR = this["getOutput"](qgj);
      this["userCode"] = "\n        void main() {\n          " + qgL + " rc = getOutputCoords();\n\n          if(" + qgI + ") {\n            setOutput(vec4(0));\n          } else {\n            " + qgb + "\n\n            setOutput(vec4(" + qgR + "));\n          }\n        }\n      ";
    }
  }
  ["getSourceCoordsArr"](qgu) {
    const qgj = [];
    for (let qgL = 0; qgL <= 1; qgL++) for (let qgI = 0; qgI <= 1; qgI++) {
      let qgb = (qgL === 0 ? "r" : "rp1") + ", " + (qgI === 0 ? "c" : "cp1");
      for (let qgR = 2; qgR < this["rank"]; qgR++) qgb = qgu[qgu["length"] - 1 - qgR] + "," + qgb;
      qgj["push"](qgb);
    }
    return qgj;
  }
  ["getOutOfBoundsCondition"](qgu) {
    if (this["rank"] === 1) return "rc > " + (this["enableShapeUniforms"] ? "outShape" : this["outputShape"][0]);
    let qgj = "";
    for (let qgL = this["rank"] - 2; qgL < this["rank"]; qgL++) qgj += qgu[qgL] + " >= " + (this["enableShapeUniforms"] ? "outShape[" + qgL + "]" : this["outputShape"][qgL]), qgL < this["rank"] - 1 && (qgj += "||");
    return qgj;
  }
  ["getSetup"](qgu) {
    if (this["rank"] === 1) return "";
    const qgj = qgu["slice"](-2), qgL = this["enableShapeUniforms"] ? "outShape[" + this["rank"] + " - 1]" : this["outputShape"][this["rank"] - 1], qgI = this["enableShapeUniforms"] ? "outShape[" + this["rank"] + " - 2]" : this["outputShape"][this["rank"] - 2];
    return "\n      int r = " + qgj[0] + ";\n      int c = " + qgj[1] + ";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= " + qgL + ";\n      bool rEdge = rp1 >= " + qgI + ";\n    ";
  }
  ["getOutput"](qgu) {
    const qgj = this["getSourceCoordsArr"](qgu);
    return this["rank"] === 1 ? "getA(rc), (rc + 1 >= " + (this["enableShapeUniforms"] ? "outShape" : this["outputShape"][0]) + " ? 0. : getA(rc + 1)), 0, 0" : "getA(" + qgj[0] + "),\n            cEdge ? 0. : getA(" + qgj[1] + "),\n            rEdge ? 0. : getA(" + qgj[2] + "),\n            rEdge || cEdge ? 0. : getA(" + qgj[3] + ")";
  }
};
var VL = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "inputShape", "type": "ivec3" }], this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    let qgL = "";
    for (let qgI = 0; qgI < 4; qgI++) {
      let qgb = "thisRC = rc;";
      qgI % 2 === 1 && (qgb += "thisRC.z += 1;"), qgI > 1 && (qgb += "thisRC.y += 1;"), qgL += "\n        " + qgb + "\n        " + (qgI > 0 ? "if(thisRC.y < rows && thisRC.z < cols){" : "") + "\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[" + qgI + "] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        " + (qgI > 0 ? "}" : "") + "\n      ";
    }
    this["userCode"] = "\n      " + VR(qgj, this["enableShapeUniforms"]) + "\n      " + (this["enableShapeUniforms"] ? vq() : dU(qgu)) + "\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = " + (this["enableShapeUniforms"] ? "outShape[1]" : qgu[1]) + ";\n        int cols = " + (this["enableShapeUniforms"] ? "outShape[2]" : qgu[2]) + ";\n\n        " + qgL + "\n\n        setOutput(result);\n      }\n    ";
  }
};
function VR(qgu, qgj) {
  return "\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      " + (qgj ? dP(["r", "c", "d"], "inputShape") : dV(["r", "c", "d"], qgu)) + "\n      return ivec3(r, c, d);\n    }\n  ";
}
var VQ = class {
  constructor(qgu) {
    this["gpgpu"] = qgu, this["numUsedTextures"] = 0, this["numFreeTextures"] = 0, this["_numBytesAllocated"] = 0, this["_numBytesFree"] = 0, this["freeTextures"] = {}, this["usedTextures"] = {}, this["logEnabled"] = false;
  }
  ["acquireTexture"](qgu, qgj, qgL) {
    const qgI = VJ(qgj, qgL), qgb = VY(qgu, qgI, qgL);
    qgb in this["freeTextures"] || (this["freeTextures"][qgb] = []), qgb in this["usedTextures"] || (this["usedTextures"][qgb] = []);
    const qgR = VK(qgu, qgI, this["gpgpu"]["gl"], this["gpgpu"]["textureConfig"], qgL);
    if (this["freeTextures"][qgb]["length"] > 0) {
      this["numFreeTextures"]--, this["numUsedTextures"]++, this["_numBytesFree"] -= qgR, this["log"]();
      const qgr = this["freeTextures"][qgb]["pop"]();
      return this["usedTextures"][qgb]["push"](qgr), qgr;
    }
    let qgo;
    return qgI === rG["PACKED_2X2_FLOAT32"] ? qgo = this["gpgpu"]["createPackedMatrixTexture"](qgu[0], qgu[1]) : qgI === rG["PACKED_2X2_FLOAT16"] ? qgo = this["gpgpu"]["createFloat16PackedMatrixTexture"](qgu[0], qgu[1]) : qgI === rG["UNPACKED_FLOAT32"] ? qgo = this["gpgpu"]["createFloat32MatrixTexture"](qgu[0], qgu[1]) : qgI === rG["UNPACKED_FLOAT16"] ? qgo = this["gpgpu"]["createFloat16MatrixTexture"](qgu[0], qgu[1]) : qgI === rG["PACKED_4X1_UNSIGNED_BYTE"] && (qgo = this["gpgpu"]["createUnsignedBytesMatrixTexture"](qgu[0], qgu[1])), this["usedTextures"][qgb]["push"](qgo), this["numUsedTextures"]++, this["_numBytesAllocated"] += qgR, this["log"](), qgo;
  }
  ["releaseTexture"](qgu, qgj, qgL, qgI) {
    if (this["freeTextures"] == null) return;
    const qgb = VJ(qgL, qgI), qgR = VY(qgj, qgb, qgI);
    qgR in this["freeTextures"] || (this["freeTextures"][qgR] = []);
    const qgo = VK(qgj, qgb, this["gpgpu"]["gl"], this["gpgpu"]["textureConfig"], qgI), qgr = qM()["getNumber"]("WEBGL_DELETE_TEXTURE_THRESHOLD");
    qgr !== -1 && this["_numBytesAllocated"] > qgr ? (this["gpgpu"]["deleteMatrixTexture"](qgu["texture"]), this["_numBytesAllocated"] -= qgo) : (this["freeTextures"][qgR]["push"](qgu), this["numFreeTextures"]++, this["_numBytesFree"] += qgo), this["numUsedTextures"]--;
    const qgQ = this["usedTextures"][qgR], qgd = qgQ && qgQ["indexOf"](qgu);
    if (qgd == null || qgd < 0) throw new Error("Cannot release a texture that was never provided by this texture manager");
    qgQ[qgd] = qgQ[qgQ["length"] - 1], qgQ["pop"](), this["log"]();
  }
  ["log"]() {
    if (!this["logEnabled"]) return;
    const qgu = this["numFreeTextures"] + this["numUsedTextures"];
    console["log"]("Free/Used", this["numFreeTextures"] + " / " + this["numUsedTextures"], "(" + qgu + ")");
    const qgj = this["_numBytesFree"] / this["_numBytesAllocated"];
    console["log"]("Bytes allocated: " + this["_numBytesAllocated"]), console["log"]("Bytes unused: " + this["_numBytesFree"] + " (" + Math["round"](100 * qgj) + "%)");
  }
  get ["numBytesAllocated"]() {
    return this["_numBytesAllocated"];
  }
  get ["numBytesFree"]() {
    return this["_numBytesFree"];
  }
  ["getNumUsedTextures"]() {
    return this["numUsedTextures"];
  }
  ["getNumFreeTextures"]() {
    return this["numFreeTextures"];
  }
  ["dispose"]() {
    if (this["freeTextures"] != null) {
      for (const qgu in this["freeTextures"]) this["freeTextures"][qgu]["forEach"]((qgj) => {
        this["gpgpu"]["deleteMatrixTexture"](qgj["texture"]);
      });
      for (const qgj in this["usedTextures"]) this["usedTextures"][qgj]["forEach"]((qgL) => {
        this["gpgpu"]["deleteMatrixTexture"](qgL["texture"]);
      });
      this["freeTextures"] = null, this["usedTextures"] = null, this["numUsedTextures"] = 0, this["numFreeTextures"] = 0, this["_numBytesAllocated"] = 0, this["_numBytesFree"] = 0;
    }
  }
};
function VH(qgu, qgj) {
  const qgL = qgu;
  if (qgj === qgL["R32F"]) return 4;
  if (qgj === qgL["R16F"]) return 2;
  if (qgj === qgL["RGBA32F"]) return 16;
  if (qgj === qgu["RGBA"]) return 16;
  if (qgj === qgL["RGBA16F"]) return 8;
  if (qgj === qgL["RGBA8"]) return 4;
  throw new Error("Unknown internal format " + qgj);
}
function VK(qgu, qgj, qgL, qgI, qgb) {
  const qgR = VB(qgj, qgI);
  let qgo;
  if (qgb) {
    const [qgQ, qgd] = ro(qgu[0], qgu[1]);
    qgo = qgQ * qgd;
  } else {
    const [qgv, qgy] = ru(qgu[0], qgu[1]);
    qgo = qgv * qgy;
  }
  const qgr = VH(qgL, qgR);
  return qgo * qgr;
}
function VB(qgu, qgj) {
  switch (qgu) {
    case rG["PACKED_2X2_FLOAT32"]:
      return lW(qgj);
    case rG["PACKED_2X2_FLOAT16"]:
      return la(qgj);
    case rG["UNPACKED_FLOAT32"]:
      return CU(qgj);
    case rG["UNPACKED_FLOAT16"]:
      return lq(qgj);
    case rG["PACKED_4X1_UNSIGNED_BYTE"]:
      return lM(qgj);
    default:
      throw new Error("Unknown physical texture type " + qgu);
  }
}
function VV(qgu) {
  return qM()["getBool"]("WEBGL_RENDER_FLOAT32_ENABLED") ? qgu ? rG["PACKED_2X2_FLOAT32"] : rG["UNPACKED_FLOAT32"] : qgu ? rG["PACKED_2X2_FLOAT16"] : rG["UNPACKED_FLOAT16"];
}
function VJ(qgu, qgj) {
  if (qgu === rX["UPLOAD"]) return rG["PACKED_2X2_FLOAT32"];
  if (qgu === rX["RENDER"] || qgu == null) return VV(qgj);
  if (qgu === rX["DOWNLOAD"] || qgu === rX["PIXELS"]) return rG["PACKED_4X1_UNSIGNED_BYTE"];
  throw new Error("Unknown logical texture type " + qgu);
}
function VY(qgu, qgj, qgL) {
  return qgu[0] + "_" + qgu[1] + "_" + qgj + "_" + qgL;
}
var VP = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"], this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]), this["userCode"] = "\n      float unaryOperation(float x) {\n        " + qgj + "\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  }
};
var VU = "if (isnan(x)) return x;";
var Jq = "return x;";
var JM = "return abs(x);";
var JF = "return (x >= 0.0) ? x : (exp(x) - 1.0);";
var JW = VU + "\n  return (x < 0.0) ? 0.0 : x;\n";
var JD = VU + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
var Ja = "return x;";
var JZ = "return 1.0 / (1.0 + exp(-1.0 * x));";
var Je = "return x;";
var Jz = "\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n";
var JX = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var JG = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var Jj = "return 1.0 / (1.0 + exp(-1.0 * x));";
var JL = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]), this["userCode"] = "\n      vec4 unaryOperation(vec4 x) {\n        " + qgj + "\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ";
  }
};
var JR = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = false, this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const qgj = qgu["length"], qgL = VX("rc", qgj), qgI = yU(qgj), qgb = VG(qgj, qgL), qgR = qgL["slice"](-2), qgo = qgj <= 1 ? "rc" : "vec2(" + qgR["join"](",") + ")";
    this["userCode"] = "\n      void main() {\n        " + qgI + " rc = getOutputCoords();\n        vec4 packedInput = getA(" + qgb + ");\n\n        setOutput(getChannel(packedInput, " + qgo + "));\n      }\n    ";
  }
};
var Jo = zR;
var JQ = 1e-7;
var JH = 1e-4;
var JK = {};
function JB(qgu) {
  return qgu in JK || (JK[qgu] = {}), JK[qgu];
}
var JV = qM()["getNumber"]("CPU_HANDOFF_SIZE_THRESHOLD");
var JJ = 600;
function JY() {
  return qM()["global"]["screen"] == null ? 1024 : qM()["global"]["screen"]["height"] * qM()["global"]["screen"]["width"] * window["devicePixelRatio"] * JJ / 1024 / 1024;
}
var JP = class _JP extends x2 {
  ["nextDataId"]() {
    return _JP["nextDataId"]++;
  }
  constructor(qgu) {
    if (super(), this["pendingRead"] = /* @__PURE__ */ new WeakMap(), this["pendingDisposal"] = /* @__PURE__ */ new WeakSet(), this["dataRefCount"] = /* @__PURE__ */ new WeakMap(), this["numBytesInGPU"] = 0, this["uploadWaitMs"] = 0, this["downloadWaitMs"] = 0, this["lastGlFlushTime"] = 0, this["warnedAboutMemory"] = false, this["pendingDeletes"] = 0, this["disposed"] = false, !qM()["getBool"]("HAS_WEBGL")) throw new Error("WebGL is not supported on this device");
    let qgj;
    if (qgu != null) {
      if (qgu instanceof lQ) qgj = qgu;
      else {
        const qgL = rW(qM()["getNumber"]("WEBGL_VERSION"), qgu);
        qgj = new lQ(qgL);
      }
      this["binaryCache"] = {}, this["gpgpuCreatedLocally"] = false;
    } else {
      const qgI = rW(qM()["getNumber"]("WEBGL_VERSION"));
      qgj = new lQ(qgI), this["binaryCache"] = JB(qM()["getNumber"]("WEBGL_VERSION")), this["gpgpuCreatedLocally"] = true;
    }
    this["gpgpu"] = qgj, this["canvas"] = this["gpgpu"]["gl"]["canvas"], this["textureManager"] = new VQ(this["gpgpu"]), this["numMBBeforeWarning"] = JY(), this["texData"] = new g(this, fU());
  }
  ["numDataIds"]() {
    return this["texData"]["numDataIds"]() - this["pendingDeletes"];
  }
  ["writeTexture"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = this["makeTensorInfo"](qgj, qgL), qgr = this["texData"]["get"](qgo["dataId"]);
    qgr["isPacked"] = false, qgr["texture"] = { "texture": qgu, "texShape": [qgI, qgb] }, qgr["texShape"] = [qgI, qgb];
    const qgQ = dq(qgj), qgd = new CK(qgQ, false, qgR), qgv = this["runWebGLProgram"](qgd, [qgo], qgL, [[qgI, qgb]]);
    return qgv["shape"] = qgj, qgr["texture"] = null, this["disposeIntermediateTensorInfo"](qgo), qgv["dataId"];
  }
  ["write"](qgu, qgj, qgL) {
    if ((qM()["getBool"]("WEBGL_CHECK_NUMERICAL_PROBLEMS") || qM()["getBool"]("DEBUG")) && this["checkNumericalProblems"](qgu), qgL === "complex64" && qgu != null) throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    const qgI = { "id": this["nextDataId"]() };
    return this["texData"]["set"](qgI, { "shape": qgj, "dtype": qgL, "values": qgu, "usage": rX["UPLOAD"], "refCount": 1 }), qgI;
  }
  ["refCount"](qgu) {
    return this["texData"]["has"](qgu) ? this["texData"]["get"](qgu)["refCount"] : 0;
  }
  ["incRef"](qgu) {
    const qgj = this["texData"]["get"](qgu);
    qgj["refCount"]++;
  }
  ["decRef"](qgu) {
    if (this["texData"]["has"](qgu)) {
      const qgj = this["texData"]["get"](qgu);
      qgj["refCount"]--;
    }
  }
  ["move"](qgu, qgj, qgL, qgI, qgb) {
    if (qM()["getBool"]("DEBUG") && this["checkNumericalProblems"](qgj), qgI === "complex64") throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");
    this["texData"]["set"](qgu, { "shape": qgL, "dtype": qgI, "values": qgj, "usage": rX["UPLOAD"], "refCount": qgb });
  }
  ["disposeIntermediateTensorInfo"](qgu) {
    this["disposeData"](qgu["dataId"]);
  }
  ["readSync"](qgu) {
    const qgj = this["texData"]["get"](qgu), { values: qgL, dtype: qgI, complexTensorInfos: qgb, slice: qgR, shape: qgo, isPacked: qgr } = qgj;
    if (qgR != null) {
      let qgy;
      qgr ? qgy = new JL(qgo, Ja) : qgy = new VP(qgo, Ja);
      const qgl = this["runWebGLProgram"](qgy, [{ "dataId": qgu, "shape": qgo, "dtype": qgI }], qgI), qgH = this["readSync"](qgl["dataId"]);
      return this["disposeIntermediateTensorInfo"](qgl), qgH;
    }
    if (qgL != null) return this["convertAndCacheOnCPU"](qgu);
    if (qgI === "string") return qgL;
    const qgQ = this["activeTimers"] != null;
    let qgd;
    qgQ && (qgd = EF());
    let qgv;
    if (qgI === "complex64") {
      const qgA = this["readSync"](qgb["real"]["dataId"]), qgh = this["readSync"](qgb["imag"]["dataId"]);
      qgv = Nt(qgA, qgh);
    } else qgv = this["getValuesFromTexture"](qgu);
    return qgQ && (this["downloadWaitMs"] += EF() - qgd), this["convertAndCacheOnCPU"](qgu, qgv);
  }
  async ["read"](qgu) {
    if (this["pendingRead"]["has"](qgu)) {
      const qgH = this["pendingRead"]["get"](qgu);
      return new Promise((qgA) => qgH["push"](qgA));
    }
    const qgj = this["texData"]["get"](qgu), { values: qgL, shape: qgI, slice: qgb, dtype: qgR, complexTensorInfos: qgo, isPacked: qgr } = qgj;
    if (qgb != null) {
      let qgA;
      qgr ? qgA = new JL(qgI, Ja) : qgA = new VP(qgI, Ja);
      const qgh = this["runWebGLProgram"](qgA, [{ "dataId": qgu, "shape": qgI, "dtype": qgR }], qgR), qgT = this["read"](qgh["dataId"]);
      return this["disposeIntermediateTensorInfo"](qgh), qgT;
    }
    if (qgL != null) return this["convertAndCacheOnCPU"](qgu);
    if (qM()["getBool"]("DEBUG") && !qM()["getBool"]("WEBGL_DOWNLOAD_FLOAT_ENABLED") && qM()["getNumber"]("WEBGL_VERSION") === 2) throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");
    let qgQ = null, qgd;
    if (qgR !== "complex64" && qM()["get"]("WEBGL_BUFFER_SUPPORTED")) {
      qgd = this["decode"](qgu);
      const qgK = this["texData"]["get"](qgd["dataId"]);
      qgQ = this["gpgpu"]["createBufferFromTexture"](qgK["texture"]["texture"], ...rL(qgI));
    }
    this["pendingRead"]["set"](qgu, []), qgR !== "complex64" && await this["gpgpu"]["createAndWaitForFence"]();
    let qgv;
    if (qgR === "complex64") {
      const qgB = await Promise["all"]([this["read"](qgo["real"]["dataId"]), this["read"](qgo["imag"]["dataId"])]), qgV = qgB[0], qgJ = qgB[1];
      qgv = Nt(qgV, qgJ);
    } else {
      if (qgQ == null) qgv = this["getValuesFromTexture"](qgu);
      else {
        const qgY = i2(qgI);
        qgv = this["gpgpu"]["downloadFloat32MatrixFromBuffer"](qgQ, qgY);
      }
    }
    if (qgd != null && this["disposeIntermediateTensorInfo"](qgd), qgQ != null) {
      const qgP = this["gpgpu"]["gl"];
      rK(qgP, () => qgP["deleteBuffer"](qgQ));
    }
    const qgy = this["convertAndCacheOnCPU"](qgu, qgv), qgl = this["pendingRead"]["get"](qgu);
    return this["pendingRead"]["delete"](qgu), qgl["forEach"]((qgU) => qgU(qgy)), this["pendingDisposal"]["has"](qgu) && (this["pendingDisposal"]["delete"](qgu), this["disposeData"](qgu) && fU()["removeDataId"](qgu, this), this["pendingDeletes"]--), qgy;
  }
  ["readToGPU"](qgu, qgj = {}) {
    const qgL = this["texData"]["get"](qgu), { values: qgI, shape: qgb, slice: qgR, dtype: qgo, isPacked: qgr, texture: qgQ } = qgL;
    if (qgo === "complex64") throw new Error("Does not support reading texture for complex64 dtype.");
    if (qgR != null) {
      let qgl;
      qgr ? qgl = new JL(qgb, Ja) : qgl = new VP(qgb, Ja);
      const qgH = this["runWebGLProgram"](qgl, [{ "dataId": qgu, "shape": qgb, "dtype": qgo }], qgo), qgA = this["readToGPU"](qgH, qgj);
      return this["disposeIntermediateTensorInfo"](qgH), qgA;
    }
    if (qgQ == null) throw qgI != null ? new Error("Data is not on GPU but on CPU.") : new Error("There is no data on GPU or CPU.");
    const qgd = this["decode"](qgu, qgj["customTexShape"]), qgv = fU()["makeTensorFromTensorInfo"](qgd), qgy = this["texData"]["get"](qgd["dataId"]);
    return Object["assign"]({ "tensorRef": qgv }, qgy["texture"]);
  }
  ["bufferSync"](qgu) {
    const qgj = this["readSync"](qgu["dataId"]);
    if (qgu["dtype"] === "string") try {
      const qgL = qgj["map"]((qgI) => EW(qgI));
      return DY(qgu["shape"], qgu["dtype"], qgL);
    } catch (qgI) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return DY(qgu["shape"], qgu["dtype"], qgj);
  }
  ["checkNumericalProblems"](qgu) {
    if (qgu != null) for (let qgj = 0; qgj < qgu["length"]; qgj++) {
      const qgL = qgu[qgj];
      if (!rY(qgL)) throw qM()["getBool"]("WEBGL_RENDER_FLOAT32_CAPABLE") ? Error("The value " + qgL + " cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'") : Error("The value " + qgL + " cannot be represented on this device.");
    }
  }
  ["getValuesFromTexture"](qgu) {
    const { shape: qgj, dtype: qgL, isPacked: qgI } = this["texData"]["get"](qgu), qgb = i2(qgj);
    if (qM()["getBool"]("WEBGL_DOWNLOAD_FLOAT_ENABLED")) {
      const qgy = this["decode"](qgu), qgl = this["texData"]["get"](qgy["dataId"]), qgH = this["gpgpu"]["downloadMatrixFromPackedTexture"](qgl["texture"]["texture"], ...rL(qgj))["subarray"](0, qgb);
      return this["disposeIntermediateTensorInfo"](qgy), qgH;
    }
    const qgR = qM()["getBool"]("WEBGL_PACK") && qgI === true, qgo = qgR ? dq(qgj) : qgj, qgr = qgR ? new CQ(qgo) : new CL(qgo), qgQ = this["runWebGLProgram"](qgr, [{ "shape": qgo, "dtype": qgL, "dataId": qgu }], "float32"), qgd = this["texData"]["get"](qgQ["dataId"]), qgv = this["gpgpu"]["downloadByteEncodedFloatMatrixFromOutputTexture"](qgd["texture"]["texture"], qgd["texShape"][0], qgd["texShape"][1])["subarray"](0, qgb);
    return this["disposeIntermediateTensorInfo"](qgQ), qgv;
  }
  ["timerAvailable"]() {
    return qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0;
  }
  ["time"](qgu) {
    const qgj = this["activeTimers"], qgL = [];
    let qgI = false;
    this["programTimersStack"] == null ? (this["programTimersStack"] = qgL, qgI = true) : this["activeTimers"]["push"](qgL), this["activeTimers"] = qgL, qgu();
    const qgb = EZ(this["activeTimers"]["map"]((qgr) => qgr["query"]))["filter"]((qgr) => qgr != null), qgR = EZ(this["activeTimers"]["map"]((qgr) => qgr["name"]))["filter"]((qgr) => qgr != null);
    this["activeTimers"] = qgj, qgI && (this["programTimersStack"] = null);
    const qgo = { "uploadWaitMs": this["uploadWaitMs"], "downloadWaitMs": this["downloadWaitMs"], "kernelMs": null, "wallMs": null };
    return (async () => {
      if (qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) {
        const qgr = await Promise["all"](qgb);
        qgo["kernelMs"] = F(qgr), qgo["getExtraProfileInfo"] = () => qgr["map"]((qgQ, qgd) => ({ "name": qgR[qgd], "ms": qgQ }))["map"]((qgQ) => qgQ["name"] + ": " + qgQ["ms"])["join"](", ");
      } else qgo["kernelMs"] = { "error": "WebGL query timers are not supported in this environment." };
      return this["uploadWaitMs"] = 0, this["downloadWaitMs"] = 0, qgo;
    })();
  }
  ["memory"]() {
    return { "unreliable": false, "numBytesInGPU": this["numBytesInGPU"], "numBytesInGPUAllocated": this["textureManager"]["numBytesAllocated"], "numBytesInGPUFree": this["textureManager"]["numBytesFree"] };
  }
  ["startTimer"]() {
    return qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? this["gpgpu"]["beginQuery"]() : { "startMs": EF(), "endMs": null };
  }
  ["endTimer"](qgu) {
    return qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0 ? (this["gpgpu"]["endQuery"](), qgu) : (qgu["endMs"] = EF(), qgu);
  }
  async ["getQueryTime"](qgu) {
    if (qM()["getNumber"]("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE") > 0) return this["gpgpu"]["waitForQueryAndGetTime"](qgu);
    const qgj = qgu;
    return qgj["endMs"] - qgj["startMs"];
  }
  ["disposeData"](qgu, qgj = false) {
    if (this["pendingDisposal"]["has"](qgu)) return false;
    if (!this["texData"]["has"](qgu)) return true;
    if (qgj ? this["texData"]["get"](qgu)["refCount"] = 0 : this["texData"]["get"](qgu)["refCount"]--, !qgj && this["texData"]["get"](qgu)["refCount"] > 0) return false;
    if (this["pendingRead"]["has"](qgu)) return this["pendingDisposal"]["add"](qgu), this["pendingDeletes"]++, false;
    this["releaseGPUData"](qgu);
    const { complexTensorInfos: qgL } = this["texData"]["get"](qgu);
    return qgL != null && (this["disposeData"](qgL["real"]["dataId"], qgj), this["disposeData"](qgL["imag"]["dataId"], qgj)), this["texData"]["delete"](qgu), true;
  }
  ["releaseGPUData"](qgu) {
    const { texture: qgj, dtype: qgL, texShape: qgI, usage: qgb, isPacked: qgR, slice: qgo } = this["texData"]["get"](qgu), qgr = qgo && qgo["origDataId"] || qgu, qgQ = this["dataRefCount"]["get"](qgr);
    qgQ > 1 ? this["dataRefCount"]["set"](qgr, qgQ - 1) : (this["dataRefCount"]["delete"](qgr), qgj != null && (this["numBytesInGPU"] -= this["computeBytes"](qgI, qgL), this["textureManager"]["releaseTexture"](qgj, qgI, qgb, qgR)));
    const qgd = this["texData"]["get"](qgu);
    qgd["texture"] = null, qgd["texShape"] = null, qgd["isPacked"] = false, qgd["slice"] = null;
  }
  ["getTexture"](qgu) {
    return this["uploadToGPU"](qgu), this["texData"]["get"](qgu)["texture"]["texture"];
  }
  ["getDataInfo"](qgu) {
    return this["texData"]["get"](qgu);
  }
  ["shouldExecuteOnCPU"](qgu, qgj = JV) {
    return qM()["getBool"]("WEBGL_CPU_FORWARD") && qgu["every"]((qgL) => this["texData"]["get"](qgL["dataId"])["texture"] == null && i2(qgL["shape"]) < qgj);
  }
  ["getGPGPUContext"]() {
    return this["gpgpu"];
  }
  ["where"](qgu) {
    gL("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");
    const qgj = qgu["dataSync"]();
    return Jo(qgu["shape"], qgj);
  }
  ["packedUnaryOp"](qgu, qgj, qgL) {
    const qgI = new JL(qgu["shape"], qgj), qgb = this["compileAndRun"](qgI, [qgu], qgL);
    return fU()["makeTensorFromTensorInfo"](qgb);
  }
  ["abs"](qgu) {
    if (this["shouldExecuteOnCPU"]([qgu]) && qgu["dtype"] !== "complex64") {
      const qgI = BK(this["texData"]["get"](qgu["dataId"])["values"]);
      return this["makeOutput"](qgu["shape"], qgu["dtype"], qgI);
    }
    if (qM()["getBool"]("WEBGL_PACK_UNARY_OPERATIONS")) return this["packedUnaryOp"](qgu, JM, qgu["dtype"]);
    const qgj = new VP(qgu["shape"], JM), qgL = this["compileAndRun"](qgj, [qgu]);
    return fU()["makeTensorFromTensorInfo"](qgL);
  }
  ["makeTensorInfo"](qgu, qgj, qgL) {
    let qgI;
    if (qgj === "string" && qgL != null && qgL["length"] > 0 && R(qgL[0])) {
      const qgb = qgL["map"]((qgR) => Et(qgR));
      qgI = this["write"](qgb, qgu, qgj);
    } else qgI = this["write"](qgL, qgu, qgj);
    return this["texData"]["get"](qgI)["usage"] = null, { "dataId": qgI, "shape": qgu, "dtype": qgj };
  }
  ["makeOutput"](qgu, qgj, qgL) {
    return fU()["makeTensorFromTensorInfo"](this["makeTensorInfo"](qgu, qgj, qgL), this);
  }
  ["unpackTensor"](qgu) {
    const qgj = new JR(qgu["shape"]);
    return this["runWebGLProgram"](qgj, [qgu], qgu["dtype"]);
  }
  ["packTensor"](qgu) {
    const qgj = new Vj(qgu["shape"]);
    return this["runWebGLProgram"](qgj, [qgu], qgu["dtype"], null, true);
  }
  ["packedReshape"](qgu, qgj) {
    const qgL = [QU(qgu["shape"]), ...d1(qgu["shape"])], qgI = { "dtype": qgu["dtype"], "shape": qgL, "dataId": qgu["dataId"] }, qgb = [QU(qgj), ...d1(qgj)], qgR = new VL(qgb, qgL), qgo = true, qgr = [qgL], qgQ = this["runWebGLProgram"](qgR, [qgI], qgu["dtype"], qgr, qgo);
    return { "dataId": qgQ["dataId"], "shape": qgj, "dtype": qgQ["dtype"] };
  }
  ["decode"](qgu, qgj) {
    const qgL = this["texData"]["get"](qgu), { isPacked: qgI, shape: qgb, dtype: qgR } = qgL;
    if (qgj != null) {
      const qgy = i2(qgb), qgl = qgj[0] * qgj[1] * 4;
      k(qgy <= qgl, () => "customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.");
    }
    const qgo = dq(qgb);
    let qgr;
    qgI ? qgr = new Cj(qgo) : qgr = new Cu(qgo);
    const qgQ = true, qgd = [qgj != null ? qgj : rL(qgo)], qgv = this["runWebGLProgram"](qgr, [{ "shape": qgo, "dtype": qgR, "dataId": qgu }], qgR, qgd, qgQ, qgj);
    return { "dtype": qgR, "shape": qgb, "dataId": qgv["dataId"] };
  }
  ["runWebGLProgram"](qgu, qgj, qgL, qgI, qgb = false, qgR) {
    const qgo = this["makeTensorInfo"](qgu["outputShape"], qgL), qgr = this["texData"]["get"](qgo["dataId"]);
    if (qgu["packedOutput"] && (qgr["isPacked"] = true), qgu["outPackingScheme"] === rz["DENSE"]) {
      const qgT = qgR != null ? qgR : rL(qgu["outputShape"]);
      qgr["texShape"] = qgT["map"]((qgK) => qgK * 2);
    }
    if (qgu["outTexUsage"] != null && (qgr["usage"] = qgu["outTexUsage"]), i2(qgo["shape"]) === 0) return qgr["values"] = X(qgo["dtype"], 0), qgo;
    const qgQ = [], qgd = qgj["map"]((qgK) => {
      if (qgK["dtype"] === "complex64") throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");
      let qgB = this["texData"]["get"](qgK["dataId"]);
      if (qgB["texture"] == null) {
        if (!qgu["packedInputs"] && i2(qgK["shape"]) <= qM()["getNumber"]("WEBGL_SIZE_UPLOAD_UNIFORM")) return { "shape": qgK["shape"], "texData": null, "isUniform": true, "uniformValues": qgB["values"] };
        qgu["packedInputs"] && (qgB["isPacked"] = true, qgB["shape"] = qgK["shape"]);
      }
      if (this["uploadToGPU"](qgK["dataId"]), !!qgB["isPacked"] != !!qgu["packedInputs"]) qgK = qgB["isPacked"] ? this["unpackTensor"](qgK) : this["packTensor"](qgK), qgQ["push"](qgK), qgB = this["texData"]["get"](qgK["dataId"]);
      else {
        if (qgB["isPacked"] && !dt(qgB["shape"], qgK["shape"])) {
          const qgV = qgK, qgJ = qgK["shape"];
          qgK["shape"] = qgB["shape"], qgK = this["packedReshape"](qgK, qgJ), qgQ["push"](qgK), qgB = this["texData"]["get"](qgK["dataId"]), qgV["shape"] = qgJ;
        }
      }
      return { "shape": qgK["shape"], "texData": qgB, "isUniform": false };
    });
    this["uploadToGPU"](qgo["dataId"]);
    const qgv = { "shape": qgo["shape"], "texData": qgr, "isUniform": false }, qgy = CX(qgu, qgd, qgv), qgl = this["getAndSaveBinary"](qgy, () => CW(this["gpgpu"], qgu, qgd, qgv)), qgH = this["activeTimers"] != null;
    let qgA;
    qgH && (qgA = this["startTimer"]()), qM()["get"]("ENGINE_COMPILE_ONLY") || Cz(this["gpgpu"], qgl, qgd, qgv, qgI), qgQ["forEach"]((qgK) => this["disposeIntermediateTensorInfo"](qgK)), qgH && (qgA = this["endTimer"](qgA), this["activeTimers"]["push"]({ "name": qgu["constructor"]["name"], "query": this["getQueryTime"](qgA) }));
    const qgh = qM()["getNumber"]("WEBGL_FLUSH_THRESHOLD");
    if (qgh > 0) {
      const qgK = EF();
      qgK - this["lastGlFlushTime"] > qgh && (this["gpgpu"]["gl"]["flush"](), this["lastGlFlushTime"] = qgK);
    }
    if (!qM()["getBool"]("WEBGL_LAZILY_UNPACK") && qgr["isPacked"] && qgb === false) {
      const qgB = this["unpackTensor"](qgo);
      return this["disposeIntermediateTensorInfo"](qgo), qgB;
    }
    return qgo;
  }
  ["compileAndRun"](qgu, qgj, qgL, qgI, qgb = false) {
    return qgL = qgL || qgj[0]["dtype"], this["runWebGLProgram"](qgu, qgj, qgL, qgI, qgb);
  }
  ["getAndSaveBinary"](qgu, qgj) {
    return qgu in this["binaryCache"] || (this["binaryCache"][qgu] = qgj()), this["binaryCache"][qgu];
  }
  ["getTextureManager"]() {
    return this["textureManager"];
  }
  ["dispose"]() {
    this["disposed"] || (qM()["getBool"]("IS_TEST") || Object["keys"](this["binaryCache"])["forEach"]((qgu) => {
      this["gpgpu"]["deleteProgram"](this["binaryCache"][qgu]["webGLProgram"]), delete this["binaryCache"][qgu];
    }), this["textureManager"]["dispose"](), this["canvas"] != null && typeof HTMLCanvasElement != "undefined" && this["canvas"] instanceof HTMLCanvasElement ? this["canvas"]["remove"]() : this["canvas"] = null, this["gpgpuCreatedLocally"] && (this["gpgpu"]["program"] = null, this["gpgpu"]["dispose"]()), this["disposed"] = true);
  }
  ["floatPrecision"]() {
    return this["floatPrecisionValue"] == null && (this["floatPrecisionValue"] = Sq(() => {
      if (!qM()["get"]("WEBGL_RENDER_FLOAT32_ENABLED")) {
        const qgu = qM()["getBool"]("DEBUG");
        qM()["set"]("DEBUG", false);
        const qgj = this["abs"](aL(1e-8))["dataSync"]()[0];
        if (qM()["set"]("DEBUG", qgu), qgj > 0) return 32;
      }
      return 16;
    })), this["floatPrecisionValue"];
  }
  ["epsilon"]() {
    return this["floatPrecision"]() === 32 ? JQ : JH;
  }
  ["uploadToGPU"](qgu) {
    const qgj = this["texData"]["get"](qgu), { shape: qgL, dtype: qgI, values: qgb, texture: qgR, usage: qgo, isPacked: qgr } = qgj;
    if (qgR != null) return;
    const qgQ = this["activeTimers"] != null;
    let qgd;
    qgQ && (qgd = EF());
    let qgv = qgj["texShape"];
    if (qgv == null && (qgv = dM(qgL, qgr), qgj["texShape"] = qgv), qgb != null) {
      const qgy = dq(qgL);
      let qgl, qgH = qgv[1], qgA = qgv[0];
      const qgh = qgb instanceof Uint8Array || qgb instanceof Uint8ClampedArray;
      (qgr || !qgh) && ([qgH, qgA] = ro(qgv[0], qgv[1])), qgr ? qgl = new CB(qgy, qgh) : qgl = new CK(qgy, qgh);
      const qgT = qgh ? [qgA, qgH] : qgv, qgK = this["makeTensorInfo"](qgT, qgI), qgB = this["texData"]["get"](qgK["dataId"]);
      qgh ? qgB["usage"] = rX["PIXELS"] : qgB["usage"] = rX["UPLOAD"], qgB["texShape"] = qgT, this["gpgpu"]["uploadDenseMatrixToTexture"](this["getTexture"](qgK["dataId"]), qgH, qgA, qgb);
      const qgV = [[qgA, qgH]], qgJ = this["runWebGLProgram"](qgl, [qgK], qgI, qgV, true), qgY = this["texData"]["get"](qgJ["dataId"]);
      qgj["texShape"] = qgY["texShape"], qgj["isPacked"] = qgY["isPacked"], qgj["usage"] = qgY["usage"], qM()["get"]("ENGINE_COMPILE_ONLY") ? this["disposeData"](qgJ["dataId"]) : (qgj["texture"] = qgY["texture"], qgj["values"] = null, this["texData"]["delete"](qgJ["dataId"])), this["disposeIntermediateTensorInfo"](qgK), qgQ && (this["uploadWaitMs"] += EF() - qgd);
    } else {
      const qgP = this["acquireTexture"](qgv, qgo, qgI, qgr);
      qgj["texture"] = qgP;
    }
  }
  ["convertAndCacheOnCPU"](qgu, qgj) {
    const qgL = this["texData"]["get"](qgu), { dtype: qgI } = qgL;
    return qgj != null && (qgL["values"] = JU(qgj, qgI)), qgL["values"];
  }
  ["acquireTexture"](qgu, qgj, qgL, qgI) {
    if (this["numBytesInGPU"] += this["computeBytes"](qgu, qgL), !this["warnedAboutMemory"] && this["numBytesInGPU"] > this["numMBBeforeWarning"] * 1024 * 1024) {
      const qgb = (this["numBytesInGPU"] / 1024 / 1024)["toFixed"](2);
      this["warnedAboutMemory"] = true, console["warn"]("High memory usage in GPU: " + qgb + " MB, most likely due to a memory leak");
    }
    return this["textureManager"]["acquireTexture"](qgu, qgj, qgI);
  }
  ["computeBytes"](qgu, qgj) {
    return qgu[0] * qgu[1] * L(qgj);
  }
  ["checkCompileCompletion"]() {
    for (const [, qgu] of Object["entries"](this["binaryCache"])) this["checkCompletion_"](qgu);
  }
  async ["checkCompileCompletionAsync"]() {
    const qgu = [];
    if (this["gpgpu"]["parallelCompilationExtension"]) {
      for (const [, qgj] of Object["entries"](this["binaryCache"])) qgu["push"](this["checkCompletionAsync_"](qgj));
      return Promise["all"](qgu);
    } else {
      for (const [, qgL] of Object["entries"](this["binaryCache"])) {
        const qgI = new Promise((qgb) => {
          try {
            this["checkCompletion_"](qgL), qgb(true);
          } catch (qgR) {
            throw qgR;
          }
        });
        qgu["push"](qgI);
      }
      return Promise["all"](qgu);
    }
  }
  async ["checkCompletionAsync_"](qgu) {
    return this["gpgpu"]["gl"]["getProgramParameter"](qgu["webGLProgram"], this["gpgpu"]["parallelCompilationExtension"]["COMPLETION_STATUS_KHR"]) ? this["checkCompletion_"](qgu) : (await GF(), this["checkCompletionAsync_"](qgu));
  }
  ["checkCompletion_"](qgu) {
    if (this["gpgpu"]["gl"]["getProgramParameter"](qgu["webGLProgram"], this["gpgpu"]["gl"]["LINK_STATUS"]) === false) throw console["log"](this["gpgpu"]["gl"]["getProgramInfoLog"](qgu["webGLProgram"])), this["gpgpu"]["gl"]["getShaderParameter"](qgu["fragmentShader"], this["gpgpu"]["gl"]["COMPILE_STATUS"]) === false ? (QW(qgu["source"], this["gpgpu"]["gl"]["getShaderInfoLog"](qgu["fragmentShader"])), new Error("Failed to compile fragment shader.")) : new Error("Failed to link vertex and fragment shaders.");
    return true;
  }
  ["getUniformLocations"]() {
    for (const qgu of Object["values"](this["binaryCache"])) {
      this["gpgpu"]["buildVao"](qgu["webGLProgram"]);
      const { variablesLocations: qgj, customUniformLocations: qgL, infLoc: qgI, nanLoc: qgb, outShapeLocation: qgR, outShapeStridesLocation: qgo, outTexShapeLocation: qgr } = CD(this["gpgpu"], qgu["program"], qgu["webGLProgram"]);
      qgu["variablesLocations"] = qgj, qgu["customUniformLocations"] = qgL, qgu["infLoc"] = qgI, qgu["nanLoc"] = qgb, qgu["outShapeLocation"] = qgR, qgu["outShapeStridesLocation"] = qgo, qgu["outTexShapeLocation"] = qgr;
    }
  }
  ["createTensorFromGPUData"](qgu, qgj, qgL) {
    qgu["channels"] = qgu["channels"] || "RGBA";
    const { texture: qgI, height: qgb, width: qgR, channels: qgo } = qgu, qgr = fU()["backend"];
    if (!qgr["gpgpu"]["gl"]["isTexture"](qgI)) throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");
    const qgQ = qgr["writeTexture"](qgI, qgj, qgL, qgb, qgR, qgo);
    return fU()["makeTensorFromDataId"](qgQ, qgj, qgL, qgr);
  }
};
JP["nextDataId"] = 0;
function JU(qgu, qgj) {
  if (qgj === "float32" || qgj === "complex64") return qgu;
  if (qgj === "int32" || qgj === "bool") {
    const qgL = qgj === "int32" ? new Int32Array(qgu["length"]) : new Uint8Array(qgu["length"]);
    for (let qgI = 0; qgI < qgL["length"]; ++qgI) qgL[qgI] = Math["round"](qgu[qgI]);
    return qgL;
  } else throw new Error("Unknown dtype " + qgj);
}
fD() && SW("webgl", () => new JP(), 2);
var Y6 = "return abs(x);";
function Yq(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  if (qgL["shouldExecuteOnCPU"]([qgI]) && qgI["dtype"] !== "complex64") {
    const qgR = qgL["texData"]["get"](qgI["dataId"]), qgo = BK(qgR["values"]);
    return qgL["makeTensorInfo"](qgI["shape"], qgI["dtype"], qgo);
  }
  let qgb;
  return qM()["getBool"]("WEBGL_PACK_UNARY_OPERATIONS") ? qgb = new JL(qgI["shape"], Y6) : qgb = new VP(qgI["shape"], Y6), qgL["runWebGLProgram"](qgb, [qgI], qgI["dtype"]);
}
var YM = { "kernelName": qX, "backendName": "webgl", "kernelFunc": Yq };
var YF = "\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";
var Yt = class {
  constructor(qgu, qgj, qgL) {
    this["variableNames"] = ["A", "B"], this["outputShape"] = OR(qgj, qgL), this["enableShapeUniforms"] = CG(this["outputShape"]["length"]), this["userCode"] = "\n      float binaryOperation(float a, float b) {\n        " + qgu + "\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ";
  }
};
var YW = "\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";
var YD = class {
  constructor(qgu, qgj, qgL, qgI = false) {
    this["variableNames"] = ["A", "B"], this["supportsBroadcasting"] = true, this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = OR(qgj, qgL);
    const qgb = this["outputShape"]["length"];
    this["enableShapeUniforms"] = CG(qgb);
    let qgR = "";
    if (qgI) {
      if (qgb === 0 || i2(this["outputShape"]) === 1) qgR = "\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";
      else {
        if (qgR = "\n          " + yU(qgb) + " coords = getOutputCoords();\n        ", qgb === 1) this["enableShapeUniforms"] ? qgR += "\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          " : qgR += "\n            result.y = (coords + 1) >= " + this["outputShape"][0] + " ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ";
        else {
          const qgo = VX("coords", qgb);
          this["enableShapeUniforms"] ? qgR += "\n            bool nextRowOutOfBounds =\n              (" + qgo[qgb - 2] + " + 1) >= outShape[" + qgb + " - 2];\n            bool nextColOutOfBounds =\n              (" + qgo[qgb - 1] + " + 1) >= outShape[" + qgb + " - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          " : qgR += "\n            bool nextRowOutOfBounds =\n              (" + qgo[qgb - 2] + " + 1) >= " + this["outputShape"][qgb - 2] + ";\n            bool nextColOutOfBounds =\n              (" + qgo[qgb - 1] + " + 1) >= " + this["outputShape"][qgb - 1] + ";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ";
        }
      }
    }
    this["userCode"] = "\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        " + qgu + "\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        " + qgR + "\n\n        setOutput(result);\n      }\n    ";
  }
};
function Ya(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  return qgL["incRef"](qgI["dataId"]), { "dataId": qgI["dataId"], "shape": qgI["shape"], "dtype": qgI["dtype"] };
}
var YZ = { "kernelName": no, "backendName": "webgl", "kernelFunc": Ya };
function Yz(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { real: qgI, imag: qgb } = qgj, qgR = qgL["makeTensorInfo"](qgI["shape"], "complex64"), qgo = qgL["texData"]["get"](qgR["dataId"]), qgr = Ya({ "inputs": { "x": qgI }, "backend": qgL }), qgQ = Ya({ "inputs": { "x": qgb }, "backend": qgL });
  return qgo["complexTensorInfos"] = { "real": qgr, "imag": qgQ }, qgR;
}
var YX = "return (a < 0.) ? b * a : a;";
var YG = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
var Yj = "return (a < 0.) ? b * a : a;";
var YL = "\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";
function YR(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI, alpha: qgb } = qgj, qgR = qM()["getBool"]("WEBGL_PACK_BINARY_OPERATIONS") ? new YD(YL, qgI["shape"], qgb["shape"]) : new Yt(Yj, qgI["shape"], qgb["shape"]);
  return qgL["runWebGLProgram"](qgR, [qgI, qgb], "float32");
}
var Yo = { "kernelName": pX, "backendName": "webgl", "kernelFunc": YR };
var YQ = "if (isnan(x)) return x;";
function YH({ opSnippet: qgu, packedOpSnippet: qgj, cpuKernelImpl: qgL, dtype: qgI }) {
  return ({ inputs: qgb, backend: qgR }) => {
    const { x: qgo } = qgb, qgr = qgR, qgQ = qgI || qgo["dtype"];
    if (qgr["shouldExecuteOnCPU"]([qgo]) && qgL != null) {
      const qgy = qgr["texData"]["get"](qgo["dataId"]), qgl = qgL(qgy["values"], qgQ);
      return qgr["makeTensorInfo"](qgo["shape"], qgQ, qgl);
    }
    const qgd = qM()["getBool"]("WEBGL_PACK_UNARY_OPERATIONS") && qgj != null;
    let qgv;
    return qgd ? qgv = new JL(qgo["shape"], qgj) : qgv = new VP(qgo["shape"], qgu), qgr["runWebGLProgram"](qgv, [qgo], qgQ);
  };
}
function YK({ opSnippet: qgu, packedOpSnippet: qgj, checkOutOfBounds: qgL = false, supportsComplex: qgI = false, cpuKernelImpl: qgb, dtype: qgR }) {
  return ({ inputs: qgo, backend: qgr }) => {
    const { a: qgQ, b: qgd } = qgo, qgv = qgr;
    if (qgI && qgQ["dtype"] === "complex64") {
      const qgA = qgv["texData"]["get"](qgQ["dataId"]), qgh = qgv["texData"]["get"](qgd["dataId"]), [qgT, qgK] = [[qgA["complexTensorInfos"]["real"], qgh["complexTensorInfos"]["real"]], [qgA["complexTensorInfos"]["imag"], qgh["complexTensorInfos"]["imag"]]]["map"]((qgV) => {
        const [qgJ, qgY] = qgV, qgP = { "dataId": qgJ["dataId"], "dtype": qgJ["dtype"], "shape": qgQ["shape"] }, qgU = { "dataId": qgY["dataId"], "dtype": qgY["dtype"], "shape": qgd["shape"] }, qx0 = new Yt(qgu, qgQ["shape"], qgd["shape"]);
        return qgv["runWebGLProgram"](qx0, [qgP, qgU], ML(qgJ["dtype"], qgY["dtype"]));
      }), qgB = Yz({ "inputs": { "real": qgT, "imag": qgK }, "backend": qgv });
      return qgv["disposeIntermediateTensorInfo"](qgT), qgv["disposeIntermediateTensorInfo"](qgK), qgB;
    }
    const qgy = qgR || ML(qgQ["dtype"], qgd["dtype"]);
    if ((qgQ["dtype"] === "string" || qgd["dtype"] === "string" || qgv["shouldExecuteOnCPU"]([qgQ, qgd])) && qgb != null) {
      const qgV = qgv["texData"]["get"](qgQ["dataId"])["values"], qgJ = qgv["texData"]["get"](qgd["dataId"])["values"], qgY = qgQ["dtype"] === "string" ? uo(qgV) : qgV, qgP = qgQ["dtype"] === "string" ? uo(qgJ) : qgJ, [qgU, qx0] = qgb(qgQ["shape"], qgd["shape"], qgY, qgP, qgy), qx1 = qgv["makeTensorInfo"](qx0, qgy), qx2 = qgv["texData"]["get"](qx1["dataId"]);
      return qx2["values"] = qgU, qx1;
    }
    const qgl = qM()["getBool"]("WEBGL_PACK_BINARY_OPERATIONS") && qgj != null;
    let qgH;
    return qgl ? qgH = new YD(qgj, qgQ["shape"], qgd["shape"], qgL) : qgH = new Yt(qgu, qgQ["shape"], qgd["shape"]), qgv["runWebGLProgram"](qgH, [qgQ, qgd], qgy);
  };
}
function YB(qgu, qgj = false) {
  if (qgu === "linear") return qgj ? Je : Jq;
  if (qgu === "relu") return qgj ? JX : JW;
  if (qgu === "elu") return qgj ? Jz : JF;
  if (qgu === "relu6") return qgj ? JG : JD;
  if (qgu === "prelu") return qgj ? YL : Yj;
  if (qgu === "leakyrelu") return qgj ? YG : YX;
  if (qgu === "sigmoid") return qgj ? Jj : JZ;
  throw new Error("Activation " + qgu + " has not been implemented for the WebGL backend.");
}
var YV = "return a + b;";
var YJ = YK({ "opSnippet": YV, "packedOpSnippet": YV, "supportsComplex": true, "cpuKernelImpl": Kz });
var YY = { "kernelName": qG, "backendName": "webgl", "kernelFunc": YJ };
var YP = class {
  constructor(qgu, qgj) {
    this["outputShape"] = [], this["outputShape"] = qgu, this["variableNames"] = qgj["map"]((qgb, qgR) => "T" + qgR);
    const qgL = [];
    this["variableNames"]["forEach"]((qgb) => {
      qgL["push"]("float v" + qgb + " = get" + qgb + "AtOutCoords();");
    });
    const qgI = this["variableNames"]["map"]((qgb) => "v" + qgb)["join"](" + ");
    this["userCode"] = "\n      void main() {\n        " + qgL["join"]("\n        ") + "\n\n        float result = " + qgI + ";\n        setOutput(result);\n      }\n    ";
  }
};
var YU = class {
  constructor(qgu, qgj) {
    this["outputShape"] = [], this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = qgu, this["variableNames"] = qgj["map"]((qgb, qgR) => "T" + qgR);
    const qgL = [];
    this["variableNames"]["forEach"]((qgb) => {
      qgL["push"]("vec4 v" + qgb + " = get" + qgb + "AtOutCoords();");
    });
    const qgI = this["variableNames"]["map"]((qgb) => "v" + qgb)["join"](" + ");
    this["userCode"] = "\n      void main() {\n        " + qgL["join"]("\n        ") + "\n\n        vec4 result = " + qgI + ";\n        setOutput(result);\n      }\n    ";
  }
};
function Pq(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, qgI = qgj;
  if (qgI["length"] === 1) return Ya({ "inputs": { "x": qgI[0] }, "backend": qgL });
  if (qgI["length"] > qM()["getNumber"]("WEBGL_MAX_TEXTURES_IN_SHADER")) {
    const qgr = Math["floor"](qgI["length"] / 2), qgQ = Pq({ "inputs": qgI["slice"](0, qgr), "backend": qgL }), qgd = Pq({ "inputs": qgI["slice"](qgr), "backend": qgL });
    return Pq({ "inputs": [qgQ, qgd], "backend": qgL });
  }
  const qgb = qgI["map"]((qgv) => qgv["dtype"])["reduce"]((qgv, qgy) => ML(qgv, qgy)), qgR = qgI["map"]((qgv) => qgv["shape"]), qgo = qM()["getBool"]("WEBGL_PACK") ? new YU(qgI[0]["shape"], qgR) : new YP(qgI[0]["shape"], qgR);
  return qgL["runWebGLProgram"](qgo, qgI, qgb);
}
var Ps = { "kernelName": qj, "backendName": "webgl", "kernelFunc": Pq };
var PM = YF + "\n  return atan(a, b);\n";
var PF = "\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + YW + "\n  return result;\n";
var PW = YK({ "opSnippet": PM, "packedOpSnippet": PF });
var PD = { "kernelName": qL, "backendName": "webgl", "kernelFunc": PW };
var PZ = class {
  constructor(qgu, qgj, qgL, qgI = false, qgb = false) {
    if (this["variableNames"] = ["x"], qgj === "avg" && qgL) throw new Error("Cannot compute positions for average pool.");
    const qgR = qgu["filterWidth"], qgo = qgu["strideHeight"], qgr = qgu["strideWidth"], qgQ = qgu["dilationHeight"], qgd = qgu["dilationWidth"], qgv = qgu["effectiveFilterHeight"], qgy = qgu["effectiveFilterWidth"], qgl = qgu["padInfo"]["top"], qgH = qgu["padInfo"]["left"];
    this["outputShape"] = qgu["outShape"];
    const qgA = qgj === "avg", qgh = "((batch  * " + qgu["inHeight"] + " + xR) * " + qgu["inWidth"] + " + xC) * " + qgu["inChannels"] + " + d", qgT = "(xR * " + qgu["inWidth"] + " + xC) * " + qgu["inChannels"] + " + d";
    let qgK = "0.0";
    if (qgA || (qgK = "-1.0 / 1e-20"), qgL) {
      const qgU = ">=";
      this["userCode"] = "\n        const ivec2 strides = ivec2(" + qgo + ", " + qgr + ");\n        const ivec2 pads = ivec2(" + qgl + ", " + qgH + ");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < " + qgv + ";\n              wR += " + qgQ + ") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= " + qgu["inHeight"] + ") {\n              continue;\n            }\n\n            for (int wC = 0; wC < " + qgy + ";\n                wC += " + qgd + ") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= " + qgu["inWidth"] + ") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value " + qgU + " currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = " + (qgI ? qgb ? qgh : qgT : "wR * " + qgy + " + wC") + ";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      ";
      return;
    }
    const qgB = "max";
    let qgV = qgj + "(" + qgj + "(" + qgj + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    qgj === "avg" && (qgV = "avgValue / max(count, 1.0)");
    const qgJ = Math["floor"](qgR / 4) * 4, qgY = qgR % 4, qgP = "\n      if (" + qgA + ") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = " + qgB + "(values, minMaxValue);\n      }\n    ";
    this["userCode"] = "\n      const ivec2 strides = ivec2(" + qgo + ", " + qgr + ");\n      const ivec2 pads = ivec2(" + qgl + ", " + qgH + ");\n      const float initializationValue = " + qgK + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= " + qgu["inWidth"] + ") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(" + qgK + ");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < " + qgv + ";\n            wR += " + qgQ + ") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= " + qgu["inHeight"] + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + qgJ + "; wC += 4) {\n            int xC = xCCorner + wC * " + qgd + ";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + qgd + ", d),\n              getValue(batch, xR, xC + 2 * " + qgd + ", d),\n              getValue(batch, xR, xC + 3 * " + qgd + ", d)\n            );\n\n            " + qgP + "\n          }\n\n          int xC = xCCorner + " + qgJ + ";\n          if (" + (qgY === 1) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            " + qgP + "\n          } else if (" + (qgY === 2) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + qgd + ", d),\n              initializationValue,\n              initializationValue\n            );\n\n            " + qgP + "\n          } else if (" + (qgY === 3) + ") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + " + qgd + ", d),\n              getValue(batch, xR, xC + 2 * " + qgd + ", d),\n              initializationValue\n            );\n\n            " + qgP + "\n          }\n        }\n        setOutput(" + qgV + ");\n      }\n    ";
  }
};
function Pz(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj;
  dH(qgb, "avgPool");
  const { filterSize: qgR, strides: qgo, pad: qgr, dimRoundingMode: qgQ } = qgI, qgd = 1;
  k(iU(qgo, qgd), () => "Error in avgPool: Either strides or dilations must be 1. Got strides " + qgo + " and dilations '" + qgd + "'");
  const qgv = iG(qgb["shape"], qgR, qgo, qgd, qgr, qgQ);
  if (qgv["filterWidth"] === 1 && qgv["filterHeight"] === 1 && D(qgv["inShape"], qgv["outShape"])) return Ya({ "inputs": { "x": qgb }, "backend": qgL });
  const qgy = new PZ(qgv, "avg", false);
  return qgL["runWebGLProgram"](qgy, [qgb], "float32");
}
var PX = { "kernelName": qR, "backendName": "webgl", "kernelFunc": Pz };
var PG = class {
  constructor(qgu, qgj, qgL, qgI = false, qgb = false, qgR = false, qgo = null, qgr = false, qgQ = false) {
    this["variableNames"] = ["matrixA", "matrixB"], this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = qgL, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const qgd = qgI ? qgu[1] : qgu[2], qgv = Math["ceil"](qgd / 2), qgy = qgI ? "i * 2, rc.y" : "rc.y, i * 2", qgl = qgb ? "rc.z, i * 2" : "i * 2, rc.z", qgH = qgI ? ["a.xxyy", "a.zzww"] : ["a.xxzz", "a.yyww"], qgA = qgb ? ["b.xzxz", "b.ywyw"] : ["b.xyxy", "b.zwzw"];
    let qgh = "", qgT = "";
    qgo && (qgr ? qgh = "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + qgo + "\n        }" : qgQ ? qgh = "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          " + qgo + "\n        }" : qgh = "vec4 activation(vec4 x) {\n          " + qgo + "\n        }", qgT = "result = activation(result);");
    const qgK = qgR ? "result += getBiasAtOutCoords();" : "";
    qgR && this["variableNames"]["push"]("bias"), qgr && this["variableNames"]["push"]("preluActivationWeights"), qgQ && this["variableNames"]["push"]("leakyreluAlpha");
    let qgB = "rc.x", qgV = "rc.x";
    qgu[0] < qgj[0] ? qgB = "imod(rc.x, " + qgu[0] + ")" : qgj[0] < qgu[0] && (qgV = "imod(rc.x, " + qgj[0] + ")"), this["userCode"] = "\n      " + qgh + "\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = " + qgv + ".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = " + qgB + ";\n        int batchB = " + qgV + ";\n        for (int i = 0; i < " + qgv + "; i++) {\n          vec4 a = getMatrixA(batchA, " + qgy + ");\n          vec4 b = getMatrixB(batchB, " + qgl + ");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (" + qgH[0] + " * " + qgA[0] + ");\n          result += (" + qgH[1] + " * " + qgA[1] + ");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        " + qgK + "\n\n        " + qgT + "\n\n        setOutput(result);\n      }\n    ";
  }
};
var Pj = { "REAL": "return areal * breal - aimag * bimag;", "IMAG": "return areal * bimag + aimag * breal;" };
var PL = class {
  constructor(qgu, qgj, qgL) {
    this["variableNames"] = ["AReal", "AImag", "BReal", "BImag"], this["outputShape"] = OR(qgj, qgL), this["userCode"] = "\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        " + qgu + "\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ";
  }
};
var PR = "return a * b;";
function PQ(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { a: qgI, b: qgb } = qgj, qgR = ML(qgI["dtype"], qgb["dtype"]);
  if (qgI["dtype"] === "complex64") {
    const qgr = qgL["texData"]["get"](qgI["dataId"]), qgQ = qgL["texData"]["get"](qgb["dataId"]), qgd = new PL(Pj["REAL"], qgI["shape"], qgb["shape"]), qgv = new PL(Pj["IMAG"], qgI["shape"], qgb["shape"]), qgy = [{ "dataId": qgr["complexTensorInfos"]["real"]["dataId"], "dtype": qgr["complexTensorInfos"]["real"]["dtype"], "shape": qgI["shape"] }, { "dataId": qgr["complexTensorInfos"]["imag"]["dataId"], "dtype": qgr["complexTensorInfos"]["imag"]["dtype"], "shape": qgI["shape"] }, { "dataId": qgQ["complexTensorInfos"]["real"]["dataId"], "dtype": qgQ["complexTensorInfos"]["real"]["dtype"], "shape": qgb["shape"] }, { "dataId": qgQ["complexTensorInfos"]["imag"]["dataId"], "dtype": qgQ["complexTensorInfos"]["imag"]["dtype"], "shape": qgb["shape"] }], qgl = qgL["runWebGLProgram"](qgd, qgy, "float32"), qgH = qgL["runWebGLProgram"](qgv, qgy, "float32"), qgA = Yz({ "inputs": { "real": qgl, "imag": qgH }, "backend": qgL });
    return qgL["disposeIntermediateTensorInfo"](qgl), qgL["disposeIntermediateTensorInfo"](qgH), qgA;
  }
  if (qgL["shouldExecuteOnCPU"]([qgI, qgb])) {
    const qgh = qgL["texData"]["get"](qgI["dataId"]), qgT = qgL["texData"]["get"](qgb["dataId"]), [qgK, qgB] = BW(qgI["shape"], qgb["shape"], qgh["values"], qgT["values"], qgR), qgV = qgL["makeTensorInfo"](qgB, qgR), qgJ = qgL["texData"]["get"](qgV["dataId"]);
    return qgJ["values"] = qgK, qgV;
  }
  let qgo;
  return qM()["getBool"]("WEBGL_PACK_BINARY_OPERATIONS") ? qgo = new YD(PR, qgI["shape"], qgb["shape"]) : qgo = new Yt(PR, qgI["shape"], qgb["shape"]), qgL["runWebGLProgram"](qgo, [qgI, qgb], qgR);
}
var PH = { "kernelName": pF, "backendName": "webgl", "kernelFunc": PQ };
function PK(qgu, qgj, qgL) {
  const qgI = [QU(qgu["shape"]), ...d1(qgu["shape"])], qgb = { "dtype": qgu["dtype"], "shape": qgI, "dataId": qgu["dataId"] }, qgR = [QU(qgj), ...d1(qgj)], qgo = new VL(qgR, qgI), qgr = true, qgQ = [qgI], qgd = qgL["runWebGLProgram"](qgo, [qgb], qgu["dtype"], qgQ, qgr);
  return { "dataId": qgd["dataId"], "shape": qgj, "dtype": qgd["dtype"] };
}
function PB(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { shape: qgR } = qgI, qgo = qgL, qgr = i2(qgb["shape"]), qgQ = e(qgR, qgr), qgd = i2(qgQ);
  k(qgr === qgd, () => "The new shape (" + qgQ + ") has " + qgd + " elements and the old shape (" + qgb["shape"] + ") has " + qgr + " elements. The new shape and old shape must have the same number of elements.");
  const qgv = qgo["texData"]["get"](qgb["dataId"]);
  return qgv["isPacked"] && !dt(qgb["shape"], qgQ) && !(qgv["texture"] !== null && dt(qgv["shape"], qgQ)) ? PK(qgb, qgQ, qgo) : (qgo["incRef"](qgb["dataId"]), { "dataId": qgb["dataId"], "shape": qgQ, "dtype": qgb["dtype"] });
}
var PV = { "kernelName": pL, "backendName": "webgl", "kernelFunc": PB };
var PJ = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["x"];
    const { windowSize: qgL, batchSize: qgI, inSize: qgb, outSize: qgR } = qgu;
    this["outputShape"] = [qgI, qgR];
    const qgo = Math["floor"](qgL / 4) * 4, qgr = qgL % 4;
    let qgQ = "sumValue += dot(values, ones);";
    if (qgj != null) {
      const qgv = 1 / qgj;
      qgQ = "sumValue += dot(values * " + (m(qgv) ? qgv["toPrecision"](2) : qgv) + ", ones);";
    }
    let qgd = "";
    qgb % qgL > 0 && (qgd = "\n        if (inIdx < 0 || inIdx >= " + qgb + ") {\n          return 0.0;\n        }\n      "), this["userCode"] = "\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + qgd + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + qgL + ";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < " + qgo + "; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + qgQ + "\n        }\n\n        int inIdx = inOffset + " + qgo + ";\n        if (" + (qgr === 1) + ") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          " + qgQ + "\n        } else if (" + (qgr === 2) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          " + qgQ + "\n        } else if (" + (qgr === 3) + ") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          " + qgQ + "\n        }\n        setOutput(sumValue);\n      }\n    ";
  }
};
var PY = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["x"];
    const { windowSize: qgL, batchSize: qgI, inSize: qgb, outSize: qgR } = qgu;
    this["outputShape"] = [qgI, qgR];
    let qgo = "0.0", qgr = "";
    qgj === "prod" ? qgo = "1.0" : qgj === "min" ? (qgo = "1.0 / 1e-20", qgr = "min") : qgj === "max" && (qgo = "-1.0 / 1e-20", qgr = "max");
    let qgQ = qgj + "(" + qgj + "(" + qgj + "(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";
    qgj === "sum" ? qgQ = "sumValue" : qgj === "prod" ? qgQ = "prodValue" : qgj === "all" ? qgQ = "allValue" : qgj === "any" && (qgQ = "anyValue");
    const qgd = Math["floor"](qgL / 4) * 4, qgv = qgL % 4;
    let qgy = "\n      if (" + (qgj === "sum") + ") {\n        sumValue += dot(values, ones);\n      } else if (" + (qgj === "prod") + ") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = " + qgr + "(values, minMaxValue);\n        if (" + (qgj === "min") + " || " + (qgj === "max") + ") {\n          minMaxValue = " + qgr + "(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    ", qgl = "vec4";
    qgj === "all" ? (qgo = "1.0", qgy = "\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ", qgl = "bvec4") : qgj === "any" && (qgo = "0.0", qgy = "\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ", qgl = "bvec4");
    let qgH = "";
    qgb % qgL > 0 && (qgH = "\n        if (inIdx < 0 || inIdx >= " + qgb + ") {\n          return initializationValue;\n        }\n      "), this["userCode"] = "\n      const float initializationValue = " + qgo + ";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        " + qgH + "\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * " + qgL + ";\n\n        vec4 minMaxValue = vec4(" + qgo + ");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < " + qgd + "; i += 4) {\n          int inIdx = inOffset + i;\n          " + qgl + " values = " + qgl + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          " + qgy + "\n        }\n\n        int inIdx = inOffset + " + qgd + ";\n        if (" + (qgv === 1) + ") {\n          " + qgl + " values = " + qgl + "(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          " + qgy + "\n        } else if (" + (qgv === 2) + ") {\n          " + qgl + " values = " + qgl + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          " + qgy + "\n        } else if (" + (qgv === 3) + ") {\n          " + qgl + " values = " + qgl + "(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          " + qgy + "\n        }\n        setOutput(" + qgQ + ");\n      }\n    ";
  }
};
function PP(qgu) {
  const qgj = [];
  for (; qgj["length"] === 0 || qgj[qgj["length"] - 1]["outSize"] !== 1; ) {
    const qgL = qgj["length"] ? qgj[qgj["length"] - 1]["outSize"] : qgu[1], qgI = GL(qgL);
    qgj["push"]({ "inSize": qgL, "windowSize": qgI, "outSize": Math["ceil"](qgL / qgI) });
  }
  return qgj;
}
function PU(qgu, qgj, qgL, qgI) {
  const qgb = PP(qgu["shape"]);
  let qgR = qgu;
  for (let qgo = 0; qgo < qgb["length"]; qgo++) {
    const { inSize: qgr, windowSize: qgQ, outSize: qgd } = qgb[qgo];
    let qgv, qgy;
    qgL === "mean" ? qgv = qgo === 0 ? new PJ({ "windowSize": qgQ, "inSize": qgr, "batchSize": qgu["shape"][0], "outSize": qgd }, qgr) : new PJ({ "windowSize": qgQ, "inSize": qgr, "batchSize": qgu["shape"][0], "outSize": qgd }) : qgv = new PY({ "windowSize": qgQ, "inSize": qgr, "batchSize": qgu["shape"][0], "outSize": qgd }, qgL), qgy = qgR, qgR = qgI["runWebGLProgram"](qgv, [qgR], qgj), qgy["dataId"] !== qgu["dataId"] && qgI["disposeIntermediateTensorInfo"](qgy);
  }
  return qgR;
}
var Uq = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"];
    const qgL = new Array(qgu["length"]);
    for (let qgR = 0; qgR < qgL["length"]; qgR++) qgL[qgR] = qgu[qgj[qgR]];
    this["outputShape"] = qgL, this["rank"] = qgL["length"];
    const qgI = yU(this["rank"]), qgb = Un(qgj);
    this["userCode"] = "\n    void main() {\n      " + qgI + " resRC = getOutputCoords();\n      setOutput(getA(" + qgb + "));\n    }\n    ";
  }
};
function Un(qgu) {
  const qgj = qgu["length"];
  if (qgj > 6) throw Error("Transpose for rank " + qgj + " is not yet supported");
  const qgL = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u", "resRC.v"], qgI = new Array(qgj);
  for (let qgb = 0; qgb < qgu["length"]; qgb++) qgI[qgu[qgb]] = qgL[qgb];
  return qgI["join"]();
}
var Us = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true;
    const qgL = new Array(qgu["length"]);
    for (let qgd = 0; qgd < qgL["length"]; qgd++) qgL[qgd] = qgu[qgj[qgd]];
    if (this["outputShape"] = qgL, this["rank"] = qgL["length"], this["rank"] > 6) throw Error("Packed transpose for rank " + this["rank"] + " is not yet supported.");
    const qgI = yU(this["rank"]), qgb = Vz("rc", this["rank"]), qgR = new Array(this["rank"]);
    for (let qgv = 0; qgv < qgj["length"]; qgv++) qgR[qgj[qgv]] = qgb[qgv];
    const qgo = "vec2(" + qgR["slice"](-2)["join"]() + ")", qgr = "++" + qgb[this["rank"] - 1] + " < " + qgL[this["rank"] - 1], qgQ = "getChannel(getA(" + qgR["join"]() + "), " + qgo + ")";
    this["userCode"] = "\n    void main() {\n      " + qgI + " rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = " + qgQ + ";\n      if(" + qgr + ") {\n        result[1] = " + qgQ + ";\n      }\n      --" + qgb[this["rank"] - 1] + ";\n      if(++" + qgb[this["rank"] - 2] + " < " + qgL[this["rank"] - 2] + ") {\n        result[2] = " + qgQ + ";\n        if(" + qgr + ") {\n          result[3] = " + qgQ + ";\n        }\n      }\n      setOutput(result);\n    }\n    ";
  }
};
function UM(qgu, qgj, qgL) {
  const qgI = qM()["getBool"]("WEBGL_PACK_ARRAY_OPERATIONS") ? new Us(qgu["shape"], qgj) : new Uq(qgu["shape"], qgj);
  return qgL["runWebGLProgram"](qgI, [qgu], qgu["dtype"]);
}
function UF(qgu, qgj, qgL, qgI) {
  const qgb = qgj, qgR = qgu["shape"]["length"], qgo = z(qgb, qgu["shape"]);
  let qgr = qgo;
  const qgQ = at(qgr, qgR), qgd = qgQ != null;
  let qgv = qgu;
  qgd && (qgv = UM(qgu, qgQ, qgI), qgr = aD(qgr["length"], qgR)), aF("sum", qgr, qgR);
  const [qgy, qgl] = aq(qgv["shape"], qgr);
  let qgH = qgy;
  qgL && (qgH = aM(qgy, qgo));
  const qgA = i2(qgl), qgh = i2(qgu["shape"]) / qgA, qgT = PB({ "inputs": { "x": qgv }, "attrs": { "shape": [qgh, qgA] }, "backend": qgI }), qgK = MR(qgu["dtype"]), qgB = PU(qgT, qgK, "sum", qgI), qgV = PB({ "inputs": { "x": qgB }, "attrs": { "shape": qgH }, "backend": qgI });
  return qgI["disposeIntermediateTensorInfo"](qgT), qgI["disposeIntermediateTensorInfo"](qgB), qgd && qgI["disposeIntermediateTensorInfo"](qgv), qgV;
}
function Ut(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { axis: qgR, keepDims: qgo } = qgI;
  return UF(qgb, qgR, qgo, qgL);
}
var UW = { "kernelName": pU, "backendName": "webgl", "kernelFunc": Ut };
function UD(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { perm: qgR } = qgI, qgo = qgL, qgr = qgb["shape"]["length"], qgQ = new Array(qgr);
  for (let qgv = 0; qgv < qgQ["length"]; qgv++) qgQ[qgv] = qgb["shape"][qgR[qgv]];
  let qgd;
  if (qgo["shouldExecuteOnCPU"]([qgb])) {
    const qgy = qgo["texData"]["get"](qgb["dataId"])["values"], qgl = VZ(qgy, qgb["shape"], qgb["dtype"], qgR, qgQ);
    qgd = qgo["makeTensorInfo"](qgQ, qgb["dtype"]);
    const qgH = qgo["texData"]["get"](qgd["dataId"]);
    qgH["values"] = qgl;
  } else qgd = UM(qgb, qgR, qgo);
  return qgd;
}
var UZ = { "kernelName": gD, "backendName": "webgl", "kernelFunc": UD };
var Ue = 1e3;
function Uz({ a: qgu, b: qgj, transposeA: qgL, transposeB: qgI, backend: qgb, bias: qgR = null, preluActivationWeights: qgo = null, leakyreluAlpha: qgr = 0, activation: qgQ = null }) {
  const qgd = qgu["shape"]["length"], qgv = qgj["shape"]["length"], qgy = qgL ? qgu["shape"][qgd - 2] : qgu["shape"][qgd - 1], qgl = qgI ? qgj["shape"][qgv - 1] : qgj["shape"][qgv - 2], qgH = qgL ? qgu["shape"][qgd - 1] : qgu["shape"][qgd - 2], qgA = qgI ? qgj["shape"][qgv - 2] : qgj["shape"][qgv - 1], qgh = qgu["shape"]["slice"](0, -2), qgT = qgj["shape"]["slice"](0, -2), qgK = i2(qgh), qgB = i2(qgT), qgV = OR(qgu["shape"]["slice"](0, -2), qgj["shape"]["slice"](0, -2))["concat"]([qgH, qgA]);
  k(qgy === qgl, () => "Error in matMul: inner shapes (" + qgy + ") and (" + qgl + ") of Tensors with shapes " + qgu["shape"] + " and " + qgj["shape"] + " and transposeA=" + qgL + " and transposeB=" + qgI + " must match.");
  const qgJ = qgL ? [qgK, qgy, qgH] : [qgK, qgH, qgy], qgY = qgI ? [qgB, qgA, qgl] : [qgB, qgl, qgA], qgP = PB({ "inputs": { "x": qgu }, "backend": qgb, "attrs": { "shape": qgJ } }), qgU = PB({ "inputs": { "x": qgj }, "backend": qgb, "attrs": { "shape": qgY } }), qx0 = [qgP, qgU], qx1 = Math["max"](qgK, qgB), qx2 = qgL ? qgP["shape"][1] : qgP["shape"][2], qx3 = qgR != null, qx4 = qgo != null, qx5 = qgQ === "leakyrelu", qx6 = qgQ != null ? YB(qgQ, true) : null, qx7 = qx3 || qx4 || qx5 || qx6 != null;
  let qx8;
  if ((qgH === 1 || qgA === 1) && qx2 > Ue && qx7 === false) {
    let qxq = qgP, qxn = qgU;
    qgL && (qxq = UD({ "inputs": { "x": qgP }, "backend": qgb, "attrs": { "perm": [0, 2, 1] } }), qx0["push"](qxq)), qgI && (qxn = UD({ "inputs": { "x": qgU }, "backend": qgb, "attrs": { "perm": [0, 2, 1] } }), qx0["push"](qxn));
    const qxp = qgA !== 1, qxs = qgA === 1;
    let qxE = qxq;
    qxp && (qxE = PB({ "inputs": { "x": qxq }, "backend": qgb, "attrs": { "shape": [qx1, qx2, 1] } }), qx0["push"](qxE));
    const qxM = qgA === 1 ? 2 : 1;
    let qxf = qxn;
    qxs && (qxf = PB({ "inputs": { "x": qxn }, "backend": qgb, "attrs": { "shape": [qx1, 1, qx2] } }), qx0["push"](qxf));
    const qxS = PQ({ "inputs": { "a": qxE, "b": qxf }, "backend": qgb });
    qx8 = Ut({ "inputs": { "x": qxS }, "backend": qgb, "attrs": { "axis": qxM, "keepDims": true } }), qx0["push"](qxS);
  } else {
    const qxF = ML(qgu["dtype"], qgj["dtype"]), qxt = new PG(qgJ, qgY, [qx1, qgH, qgA], qgL, qgI, qx3, qx6, qx4, qx5), qxk = [qgP, qgU];
    if (qgR != null && qxk["push"](qgR), qx4 && qxk["push"](qgo), qx5) {
      const qxO = qgb["makeTensorInfo"]([], "float32", Eq(qgr, "float32"));
      qxk["push"](qxO), qx0["push"](qxO);
    }
    qx8 = qgb["runWebGLProgram"](qxt, qxk, qxF);
  }
  const qx9 = PB({ "inputs": { "x": qx8 }, "backend": qgb, "attrs": { "shape": qgV } });
  qx0["push"](qx8);
  for (const qxW of qx0) qgb["disposeIntermediateTensorInfo"](qxW);
  return qx9;
}
function UX(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { a: qgb, b: qgR } = qgj, { transposeA: qgo, transposeB: qgr } = qgI;
  return Uz({ "a": qgb, "b": qgR, "transposeA": qgo, "transposeB": qgr, "backend": qgL });
}
var UG = { "kernelName": qo, "backendName": "webgl", "kernelFunc": UX };
var Uj = "return float(a != b);";
var UL = YK({ "opSnippet": Uj, "cpuKernelImpl": BZ, "dtype": "bool" });
function UR(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { input: qgI } = qgj, qgb = qgL["texData"]["get"](qgI["dataId"]);
  return Ya({ "inputs": { "x": qgb["complexTensorInfos"]["real"] }, "backend": qgL });
}
var UQ = "return float(int(x));";
function UH(qgu, qgj) {
  const qgL = new VP(qgu["shape"], UQ), qgI = qgj["runWebGLProgram"](qgL, [qgu], "int32");
  return { "dataId": qgI["dataId"], "shape": qgI["shape"], "dtype": qgI["dtype"] };
}
function UK(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { dtype: qgR } = qgI;
  if (qgR === "complex64") {
    if (qgb["dtype"] === "complex64") return Ya({ "inputs": { "x": qgb }, "backend": qgL });
    const qgo = wF(qgb["shape"]), qgr = UK({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "dtype": "float32" } }), qgQ = Yz({ "inputs": { "real": qgr, "imag": qgo }, "backend": qgL });
    return qgo["dispose"](), qgL["disposeIntermediateTensorInfo"](qgr), qgQ;
  }
  if (qgb["dtype"] === "complex64") {
    const qgd = UR({ "inputs": { "input": qgb }, "backend": qgL }), qgv = UK({ "inputs": { "x": qgd }, "backend": qgL, "attrs": { "dtype": qgR } });
    return qgL["disposeIntermediateTensorInfo"](qgd), qgv;
  }
  if (!j(qgb["dtype"], qgR)) {
    const qgy = Ya({ "inputs": { "x": qgb }, "backend": qgL });
    return { "dataId": qgy["dataId"], "shape": qgy["shape"], "dtype": qgR };
  }
  if (qgL["shouldExecuteOnCPU"]([qgb])) {
    const qgl = qgL["texData"]["get"](qgb["dataId"])["values"], [qgH, qgA, qgh] = KL(qgl, qgb["shape"], qgb["dtype"], qgR);
    return qgL["makeTensorInfo"](qgH, qgA, qgh);
  }
  if (qgR === "int32") return UH(qgb, qgL);
  if (qgR === "bool") {
    const qgT = qgL["makeTensorInfo"]([], "bool", X("bool", 1)), qgK = UL({ "inputs": { "a": qgb, "b": qgT }, "backend": qgL });
    return qgL["disposeIntermediateTensorInfo"](qgT), qgK;
  }
  throw new Error("Error in Cast: failed to cast " + qgb["dtype"] + " to " + qgR);
}
var UB = { "kernelName": qH, "backendName": "webgl", "kernelFunc": UK };
var UV = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["customUniforms"] = [{ "name": "minVal", "type": "float" }, { "name": "maxVal", "type": "float" }], this["outputShape"] = qgu, this["userCode"] = "\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    ";
  }
};
var UJ = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "minVal", "type": "float" }, { "name": "maxVal", "type": "float" }], this["outputShape"] = qgu, this["userCode"] = "\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    ";
  }
};
function UY(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { clipValueMin: qgR, clipValueMax: qgo } = qgI;
  let qgr;
  qM()["getBool"]("WEBGL_PACK_CLIP") ? qgr = new UJ(qgb["shape"]) : qgr = new UV(qgb["shape"]);
  const qgQ = [[qgR], [qgo]];
  return qgL["runWebGLProgram"](qgr, [qgb], qgb["dtype"], qgQ);
}
var UP = { "kernelName": qK, "backendName": "webgl", "kernelFunc": UY };
var UU = class {
  constructor(qgu) {
    this["outputShape"] = [], this["outputShape"] = GD(qgu, 1), this["variableNames"] = qgu["map"]((qgR, qgo) => "T" + qgo);
    const qgj = new Array(qgu["length"] - 1);
    qgj[0] = qgu[0][1];
    for (let qgR = 1; qgR < qgj["length"]; qgR++) qgj[qgR] = qgj[qgR - 1] + qgu[qgR][1];
    const qgL = ["if (yC < " + qgj[0] + ") setOutput(getT0(yR, yC));"];
    for (let qgo = 1; qgo < qgj["length"]; qgo++) {
      const qgr = qgj[qgo - 1];
      qgL["push"]("else if (yC < " + qgj[qgo] + ") setOutput(getT" + qgo + "(yR, yC-" + qgr + "));");
    }
    const qgI = qgj["length"], qgb = qgj[qgj["length"] - 1];
    qgL["push"]("else setOutput(getT" + qgI + "(yR, yC-" + qgb + "));"), this["userCode"] = "\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        " + qgL["join"]("\n        ") + "\n      }\n    ";
  }
};
var q00 = class {
  constructor(qgu, qgj) {
    this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = [], this["outputShape"] = GD(qgu, qgj);
    const qgL = this["outputShape"], qgI = qgL["length"], qgb = yU(qgI), qgR = VX("coords", qgI), qgo = ["x", "y", "z", "w", "u", "v"]["slice"](0, qgI);
    this["variableNames"] = qgu["map"]((qgA, qgh) => "T" + qgh);
    const qgr = new Array(qgu["length"] - 1);
    qgr[0] = qgu[0][qgj];
    for (let qgA = 1; qgA < qgr["length"]; qgA++) qgr[qgA] = qgr[qgA - 1] + qgu[qgA][qgj];
    const qgQ = qgo[qgj], qgd = qgo["slice"](-2), qgv = qgo["join"]();
    let qgy = "if (" + qgQ + " < " + qgr[0] + ") {\n        return getChannel(\n            getT0(" + qgv + "), vec2(" + qgd["join"]() + "));\n        }";
    for (let qgh = 1; qgh < qgr["length"]; qgh++) {
      const qgT = qgr[qgh - 1];
      qgy += "\n        if (" + qgQ + " < " + qgr[qgh] + "  && " + qgQ + " >= " + qgr[qgh - 1] + ") {\n          return getChannel(\n            getT" + qgh + "(" + q01(qgo, qgQ, qgT) + "),\n            vec2(" + q01(qgd, qgQ, qgT) + "));\n        }";
    }
    const qgl = qgr["length"], qgH = qgr[qgr["length"] - 1];
    qgy += "\n        return getChannel(\n          getT" + qgl + "(" + q01(qgo, qgQ, qgH) + "),\n          vec2(" + q01(qgd, qgQ, qgH) + "));", this["userCode"] = "\n      float getValue(" + qgo["map"]((qgK) => "int " + qgK) + ") {\n        " + qgy + "\n      }\n\n      void main() {\n        " + qgb + " coords = getOutputCoords();\n        vec4 result = vec4(getValue(" + qgR + "), 0., 0., 0.);\n\n        " + qgR[qgI - 1] + " = " + qgR[qgI - 1] + " + 1;\n        if (" + qgR[qgI - 1] + " < " + qgL[qgI - 1] + ") {\n          result.g = getValue(" + qgR + ");\n        }\n\n        " + qgR[qgI - 2] + " = " + qgR[qgI - 2] + " + 1;\n        if (" + qgR[qgI - 2] + " < " + qgL[qgI - 2] + ") {\n          result.a = getValue(" + qgR + ");\n        }\n\n        " + qgR[qgI - 1] + " = " + qgR[qgI - 1] + " - 1;\n        if (" + qgR[qgI - 2] + " < " + qgL[qgI - 2] + " &&\n            " + qgR[qgI - 1] + " < " + qgL[qgI - 1] + ") {\n          result.b = getValue(" + qgR + ");\n        }\n        setOutput(result);\n      }\n    ";
  }
};
function q01(qgu, qgj, qgL) {
  const qgI = qgu["indexOf"](qgj);
  return qgu["map"]((qgb, qgR) => qgR === qgI ? qgb + " - " + qgL : qgb)["join"]();
}
function q02(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { input: qgI } = qgj, qgb = qgL["texData"]["get"](qgI["dataId"]);
  return Ya({ "inputs": { "x": qgb["complexTensorInfos"]["imag"] }, "backend": qgL });
}
function q03(qgu, qgj, qgL) {
  const qgI = qgu[0]["dtype"];
  if (qgI === "complex64") {
    const qgH = qgu["map"]((qgB) => UR({ "inputs": { "input": qgB }, "backend": qgL })), qgA = qgu["map"]((qgB) => q02({ "inputs": { "input": qgB }, "backend": qgL })), qgh = q03(qgH, qgj, qgL), qgT = q03(qgA, qgj, qgL), qgK = Yz({ "inputs": { "real": qgh, "imag": qgT }, "backend": qgL });
    return qgH["forEach"]((qgB) => qgL["disposeIntermediateTensorInfo"](qgB)), qgA["forEach"]((qgB) => qgL["disposeIntermediateTensorInfo"](qgB)), qgL["disposeIntermediateTensorInfo"](qgh), qgL["disposeIntermediateTensorInfo"](qgT), qgK;
  }
  let qgb = qgL["shouldExecuteOnCPU"](qgu);
  if (qgI === "string" && (qgb = true), qgb) {
    const qgB = qgu["map"]((qx1) => {
      const qx2 = [-1, i2(qx1["shape"]["slice"](qgj))];
      return PB({ "inputs": { "x": qx1 }, "backend": qgL, "attrs": { "shape": qx2 } });
    }), qgV = qgB["map"]((qx1) => ({ "vals": qgL["readSync"](qx1["dataId"]), "shape": qx1["shape"] })), qgJ = GD(qgB["map"]((qx1) => qx1["shape"]), 1), qgY = qgB[0]["shape"][0] === 1, qgP = Ko(qgV, qgJ, qgI, qgY), qgU = GD(qgu["map"]((qx1) => qx1["shape"]), qgj), qx0 = qgL["makeTensorInfo"](qgU, qgI, qgP);
    return qgB["forEach"]((qx1) => qgL["disposeIntermediateTensorInfo"](qx1)), qx0;
  }
  const qgR = qgu["filter"]((qx1) => i2(qx1["shape"]) > 0), qgo = qM()["getBool"]("WEBGL_PACK_ARRAY_OPERATIONS") && qgR[0]["shape"]["length"] > 1;
  if (qgR["length"] === 1) {
    const qx1 = qgo ? new VP(qgu[0]["shape"], Ja) : new JL(qgu[0]["shape"], Ja);
    return qgL["runWebGLProgram"](qx1, qgu, qgI);
  }
  const qgr = qM()["getNumber"]("WEBGL_MAX_TEXTURES_IN_SHADER");
  if (qgR["length"] > qgr) {
    const qx2 = [];
    for (let qx4 = 0; qx4 < qgR["length"]; qx4 += qgr) {
      const qx5 = qgR["slice"](qx4, qx4 + qgr);
      qx2["push"](q03(qx5, qgj, qgL));
    }
    const qx3 = q03(qx2, qgj, qgL);
    for (const qx6 of qx2) qgL["disposeIntermediateTensorInfo"](qx6);
    return qx3;
  }
  if (qgo) {
    const qx7 = new q00(qgR["map"]((qx8) => qx8["shape"]), qgj);
    return qgL["runWebGLProgram"](qx7, qgR, qgI);
  }
  const { tensors2D: qgQ, outShape: qgd } = q04(qgR, qgj, qgL), qgv = new UU(qgQ["map"]((qx8) => qx8["shape"])), qgy = qgL["runWebGLProgram"](qgv, qgQ, qgI);
  qgQ["forEach"]((qx8) => qgL["disposeIntermediateTensorInfo"](qx8));
  const qgl = PB({ "inputs": { "x": qgy }, "attrs": { "shape": qgd }, "backend": qgL });
  return qgL["disposeIntermediateTensorInfo"](qgy), qgl;
}
function q04(qgu, qgj, qgL) {
  const qgI = GD(qgu["map"]((qgb) => qgb["shape"]), qgj);
  return { "tensors2D": qgu["map"]((qgb) => PB({ "inputs": { "x": qgb }, "attrs": { "shape": [-1, i2(qgb["shape"]["slice"](qgj))] }, "backend": qgL })), "outShape": qgI };
}
function q05(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { axis: qgb } = qgI, qgR = z(qgb, qgj[0]["shape"])[0], qgo = qgj["map"]((qgd) => qgd["shape"]);
  GW(qgo, qgR);
  const qgr = GD(qgj["map"]((qgd) => qgd["shape"]), qgR);
  if (i2(qgr) === 0) return qgL["makeTensorInfo"](qgr, qgj[0]["dtype"], []);
  const qgQ = qgj["filter"]((qgd) => i2(qgd["shape"]) > 0);
  return qgQ["length"] === 1 ? Ya({ "inputs": { "x": qgQ[0] }, "backend": qgL }) : q03(qgQ, qgR, qgL);
}
var q06 = { "kernelName": qJ, "backendName": "webgl", "kernelFunc": q05 };
var q07 = class {
  constructor(qgu, qgj = false, qgL = null, qgI = false, qgb = false) {
    this["variableNames"] = ["x", "W"], this["outputShape"] = qgu["outShape"];
    const qgR = qgu["padInfo"]["top"], qgo = qgu["padInfo"]["left"], qgr = qgu["strideHeight"], qgQ = qgu["strideWidth"], qgd = qgu["dilationHeight"], qgv = qgu["dilationWidth"], qgy = qgu["filterHeight"], qgl = qgu["filterWidth"], qgH = Math["floor"](qgu["inChannels"] / 4) * 4, qgA = qgu["inChannels"] % 4, qgh = qgu["dataFormat"] === "channelsLast", qgT = qgh ? 1 : 2, qgK = qgh ? 2 : 3, qgB = qgh ? 3 : 1;
    let qgV = "", qgJ = "";
    qgL && (qgI ? qgV = "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + qgL + "\n        }" : qgb ? qgV = "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          " + qgL + "\n        }" : qgV = "\n          float activation(float x) {\n            " + qgL + "\n          }\n        ", qgJ = "result = activation(result);");
    const qgY = qgj ? "result += getBiasAtOutCoords();" : "";
    qgj && this["variableNames"]["push"]("bias"), qgI && this["variableNames"]["push"]("preluActivationWeights"), qgb && this["variableNames"]["push"]("leakyreluAlpha"), this["userCode"] = "\n      " + qgV + "\n\n      const ivec2 strides = ivec2(" + qgr + ", " + qgQ + ");\n      const ivec2 pads = ivec2(" + qgR + ", " + qgo + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[" + qgB + "];\n\n        ivec2 xRCCorner =\n            ivec2(coords[" + qgT + "], coords[" + qgK + "]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + qgy + "; wR++) {\n          int xR = xRCorner + wR * " + qgd + ";\n\n          if (xR < 0 || xR >= " + qgu["inHeight"] + ") {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + qgl + "; wC++) {\n            int xC = xCCorner + wC * " + qgv + ";\n\n            if (xC < 0 || xC >= " + qgu["inWidth"] + ") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < " + qgH + "; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (" + qgh + ") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (" + (qgA === 1) + ") {\n\n              if (" + qgh + ") {\n                dotProd +=\n                    getX(batch, xR, xC, " + qgH + ") *\n                    getW(wR, wC, " + qgH + ", d2);\n              } else {\n                dotProd +=\n                    getX(batch, " + qgH + ", xR, xC) *\n                    getW(wR, wC, " + qgH + ", d2);\n              }\n\n            } else if (" + (qgA === 2) + ") {\n              vec2 wValues = vec2(\n                getW(wR, wC, " + qgH + ", d2),\n                getW(wR, wC, " + qgH + " + 1, d2)\n              );\n\n              if (" + qgh + ") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, " + qgH + "),\n                  getX(batch, xR, xC, " + qgH + " + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, " + qgH + ", xR, xC),\n                  getX(batch, " + qgH + " + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (" + (qgA === 3) + ") {\n              vec3 wValues = vec3(\n                getW(wR, wC, " + qgH + ", d2),\n                getW(wR, wC, " + qgH + " + 1, d2),\n                getW(wR, wC, " + qgH + " + 2, d2)\n              );\n\n              if (" + qgh + ") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, " + qgH + "),\n                  getX(batch, xR, xC, " + qgH + " + 1),\n                  getX(batch, xR, xC, " + qgH + " + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, " + qgH + ", xR, xC),\n                  getX(batch, " + qgH + " + 1, xR, xC),\n                  getX(batch, " + qgH + " + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        " + qgY + "\n        " + qgJ + "\n        setOutput(result);\n      }\n    ";
  }
};
var q08 = class {
  constructor(qgu, qgj = false, qgL = null, qgI = false, qgb = false) {
    this["variableNames"] = ["x", "W"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "pads", "type": "ivec2" }, { "name": "strides", "type": "ivec2" }, { "name": "dilations", "type": "ivec2" }, { "name": "inDims", "type": "ivec2" }], this["outputShape"] = qgu["outShape"], this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const qgR = qgu["padInfo"]["left"], qgo = qgu["strideWidth"], qgr = qgu["dilationWidth"], qgQ = qgu["filterHeight"], qgd = qgu["filterWidth"], qgv = qgd;
    let qgy = "\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";
    for (let qgh = 0; qgh < qgd; qgh++) qgy += "\n           vec4 xTexelC" + qgh * 2 + ";\n           int xTexelC" + qgh * 2 + "Ready;\n           vec4 xTexelC" + (qgh * 2 + 1) + ";\n           int xTexelC" + (qgh * 2 + 1) + "Ready;\n           vec4 xC" + qgh + ";";
    qgy += "\n     for (int r = 0; r < " + qgQ + "; r++) {\n      for (int d1 = 0; d1 < " + qgu["inChannels"] + "; d1 += 2) {\n       ";
    for (let qgT = 0; qgT < qgd; qgT++) qgy += "\n           xTexelC" + qgT * 2 + " = vec4(0.0);\n           xTexelC" + qgT * 2 + "Ready = 0;\n           xTexelC" + (qgT * 2 + 1) + " = vec4(0.0);\n           xTexelC" + (qgT * 2 + 1) + "Ready = 0;\n           xC" + qgT + " = vec4(0.0);";
    qgy += "\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";
    for (let qgK = 0; qgK < (qgv + 1) / 2; qgK++) {
      const qgB = qgK * 2;
      if (qgy += "\n           xC = xCCorner + " + qgB * qgr + ";\n           ", qgo === 1) {
        if (qgB < qgd && (qgR % 2 === 1 ? (qgy += "\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + qgB + "Ready == 0) {\n                   xTexelC" + qgB + " = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC" + qgB + ".zw = vec2(0.0);\n                   }\n                   xTexelC" + qgB + "Ready = 1;\n                 }\n               ", qgr === 1 && qgB > 0 ? qgy += "\n                 xC" + qgB + " = vec4(xTexelC" + (qgB - 2) + ".zw, xTexelC" + qgB + ".xy);\n                 " : qgy += "\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC" + qgB + " = vec4(previous.zw, xTexelC" + qgB + ".xy);\n                   } else {\n                     xC" + qgB + " = vec4(0.0, 0.0, xTexelC" + qgB + ".xy);\n                   }\n                   ") : qgy += "\n                 if (xC >= 0 && xC < inDims[1] && xTexelC" + qgB + "Ready == 0) {\n                   xTexelC" + qgB + " = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC" + qgB + ".zw = vec2(0.0);\n                   }\n                   xTexelC" + qgB + "Ready = 1;\n                 }\n\n                 xC" + qgB + " = xTexelC" + qgB + ";\n                 ", qgB + 1 < qgd)) {
          const qgV = qgR % 2 === 0 ? f(qgr) : qgr;
          qgr % 2 === 0 && qgR % 2 === 1 || qgr % 2 !== 0 && qgR % 2 !== 1 ? (qgy += "\n                   xCOffset = xC + imod(pads[1], 2) + " + qgV + ";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + (qgB + 1) + "Ready == 0) {\n                     xTexelC" + (qgB + 1) + " = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC" + (qgB + 1) + ".zw = vec2(0.0);\n                     }\n                     xTexelC" + (qgB + 1) + "Ready = 1;\n                   }\n                   ", qgr > 1 ? qgy += "\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC" + (qgB + 1) + " = vec4(previous.zw, xTexelC" + (qgB + 1) + ".xy);\n                     } else {\n                      xC" + (qgB + 1) + " = vec4(0.0, 0.0, xTexelC" + (qgB + 1) + ".xy);\n                     }\n                     " : qgy += "\n                     xC" + (qgB + 1) + " = vec4(xTexelC" + qgB + ".zw, xTexelC" + (qgB + 1) + ".xy);\n                     ") : qgV === 1 ? qgy += "\n                     xC" + (qgB + 1) + " = xTexelC" + qgB + ";\n                     " : qgy += "\n                     xCOffset = xC + " + qgV + ";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + (qgB + 1) + "Ready == 0) {\n                       xTexelC" + (qgB + 1) + " = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC" + (qgB + 1) + ".zw = vec2(0.0);\n                       }\n                       xTexelC" + (qgB + 1) + "Ready = 1;\n                     }\n\n                     xC" + (qgB + 1) + " = xTexelC" + (qgB + 1) + ";\n                     ";
        }
      } else qgB < qgd && (qgR % 2 === 1 ? (qgy += "\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + qgB + "Ready == 0) {\n                   xTexelC" + qgB + " = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC" + qgB + ".zw = vec2(0.0);\n                   }\n                   xTexelC" + qgB + "Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC" + (qgB + 1) + "Ready == 0) {\n                   xTexelC" + (qgB + 1) + " = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC" + (qgB + 1) + ".zw = vec2(0.0);\n                   }\n                   xTexelC" + (qgB + 1) + "Ready = 1;\n                 }\n\n                 xC" + qgB + " = vec4(xTexelC" + qgB + ".zw, xTexelC" + (qgB + 1) + ".zw);\n               ", qgB + 1 < qgd && (qgy += "\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC" + (qgB + 1) + " = vec4(xTexelC" + (qgB + 1) + ".xy, final.xy);\n                 ")) : (qgy += "\n                 if(xC >= 0 && xC < inDims[1] && xTexelC" + qgB + "Ready == 0) {\n                   xTexelC" + qgB + " = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC" + qgB + ".zw = vec2(0.0);\n                   }\n                   xTexelC" + qgB + "Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + (qgB + 1) + "Ready == 0) {\n                   xTexelC" + (qgB + 1) + " = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC" + (qgB + 1) + ".zw = vec2(0.);\n                   }\n                   xTexelC" + (qgB + 1) + "Ready = 1;\n                 }\n\n                 xC" + qgB + " = vec4(\n                   xTexelC" + qgB + ".xy, xTexelC" + (qgB + 1) + ".xy);\n               ", qgB + 1 < qgd && (qgy += "\n                   xC" + (qgB + 1) + " = vec4(xTexelC" + qgB + ".zw, xTexelC" + (qgB + 1) + ".zw);\n                 ")));
      qgB < qgd && (qgy += "\n             wTexel = getW(r, " + qgB + ", d1, d2);\n             dotProd += xC" + qgB + ".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < " + qgu["inChannels"] + ") {\n               dotProd += xC" + qgB + ".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           ", qgB + 1 < qgd && (qgy += "\n               wTexel = getW(r, " + (qgB + 1) + ", d1, d2);\n               dotProd += xC" + (qgB + 1) + ".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < " + qgu["inChannels"] + ") {\n                 dotProd += xC" + (qgB + 1) + ".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             "));
    }
    qgy += "\n     }\n   ", qgy += "\n     }\n   ", qgy += "\n     }\n   ";
    let qgl = "", qgH = "";
    qgL && (qgI ? qgl = "vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           " + qgL + "\n         }" : qgb ? qgl = "vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           " + qgL + "\n         }" : qgl = "vec4 activation(vec4 x) {\n           " + qgL + "\n         }", qgH = "result = activation(result);");
    const qgA = qgj ? "result += getBiasAtOutCoords();" : "";
    qgj && this["variableNames"]["push"]("bias"), qgI && this["variableNames"]["push"]("preluActivationWeights"), qgb && this["variableNames"]["push"]("leakyreluAlpha"), this["userCode"] = "\n       " + qgl + "\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         " + qgy + "\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         " + qgA + "\n         " + qgH + "\n         setOutput(result);\n       }\n     ";
  }
};
var q09 = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "inputShape", "type": "ivec4" }, { "name": "pad", "type": "ivec2" }, { "name": "stride", "type": "ivec2" }, { "name": "dilation", "type": "ivec2" }, { "name": "inChannels", "type": "int" }, { "name": "itemsPerBlockRow", "type": "int" }, { "name": "outWidth", "type": "int" }], this["outputShape"] = qgu, this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const { dataFormat: qgL } = qgj, qgI = dB(), qgb = qgL === "channelsLast", qgR = qgb ? 1 : 2, qgo = qgb ? 2 : 3, qgr = this["enableShapeUniforms"] ? "if(blockIndex < outShape[2] && pos < outShape[1]) {" : "if(blockIndex < " + qgu[2] + " && pos < " + qgu[1] + ") {";
    let qgQ = "";
    for (let qgd = 0; qgd <= 1; qgd++) for (let qgv = 0; qgv <= 1; qgv++) qgQ += "\n          blockIndex = rc.z + " + qgv + ";\n          pos = rc.y + " + qgd + ";\n\n          " + qgr + "\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[" + qgR + "] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[" + qgo + "] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (" + qgb + ") {\n                  innerDims = vec2(d1, ch);\n                  result[" + (qgd * 2 + qgv) + "] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[" + (qgd * 2 + qgv) + "] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ";
    this["userCode"] = "\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        " + qgQ + "\n\n        " + qgI["output"] + " = result;\n      }\n    ";
  }
};
function q0q(qgu, qgj) {
  const qgL = qgu["length"];
  return qgL >= 3 ? qgj ? [...qgu["slice"](0, -3), qgu[qgL - 3] * qgu[qgL - 2], qgu[qgL - 1]] : [...qgu["slice"](0, -3), qgu[qgL - 3], qgu[qgL - 2] * qgu[qgL - 1]] : !qgj && qgL === 1 && qgu[0] > 1 ? [qgu[0], 1] : null;
}
function q0n({ x: qgu, filter: qgj, convInfo: qgL, backend: qgI, bias: qgb = null, preluActivationWeights: qgR = null, leakyreluAlpha: qgo = 0, activation: qgr = null }) {
  const qgQ = qgu["shape"], qgd = qgI["texData"]["get"](qgu["dataId"]), qgv = qgL["inChannels"], qgy = qgQ[0] * qgQ[1] * qgQ[2], qgl = qgL["outChannels"], qgH = qgL["dataFormat"] === "channelsLast", qgA = false, qgh = false;
  let qgT;
  const qgK = [];
  if (qgR != null) {
    const qgB = q0q(qgR["shape"], qgH);
    qgB != null && (qgR = PB({ "inputs": { "x": qgR }, "backend": qgI, "attrs": { "shape": qgB } }), qgK["push"](qgR));
  }
  if (qgb != null) {
    const qgV = q0q(qgb["shape"], qgH);
    qgV != null && (qgb = PB({ "inputs": { "x": qgb }, "backend": qgI, "attrs": { "shape": qgV } }), qgK["push"](qgb));
  }
  if (!((qgy === 1 || qgl === 1) && qgv > Ue) && qgd["isPacked"] && qgH && qgd["texture"] != null && qgQ[2] % 2 !== 0 && D(qgd["shape"]["slice"](-3), qgQ["slice"](-3))) {
    const qgJ = qgQ[0] * qgQ[1] * (qgQ[2] + 1), qgY = { "dataId": qgu["dataId"], "shape": [1, qgJ, qgL["inChannels"]], "dtype": qgu["dtype"] }, qgP = qgd["shape"];
    qgd["shape"] = qgd["shape"]["slice"](), qgd["shape"][qgd["shape"]["length"] - 2]++, k(dt(qgd["shape"], qgY["shape"]), () => "packed reshape " + qgd["shape"] + " to " + qgY["shape"] + " isn't free");
    const qgU = PB({ "inputs": { "x": qgj }, "backend": qgI, "attrs": { "shape": [1, qgL["inChannels"], qgL["outChannels"]] } });
    qgK["push"](qgU);
    const qx0 = Uz({ "a": qgY, "b": qgU, "backend": qgI, "transposeA": qgA, "transposeB": qgh, "bias": qgb, "activation": qgr, "preluActivationWeights": qgR, "leakyreluAlpha": qgo }), qx1 = qgI["texData"]["get"](qx0["dataId"]);
    k(qx1["isPacked"], () => "batchMatMul result is expected to be packed"), qgd["shape"] = qgP, qx1["shape"] = qgL["outShape"], qgT = Ya({ "inputs": { "x": qx0 }, "backend": qgI }), qgT["shape"] = qgL["outShape"], qgK["push"](qx0);
  } else {
    const qx2 = qgL["outHeight"] * qgL["outWidth"], qx3 = PB({ "inputs": { "x": qgu }, "backend": qgI, "attrs": { "shape": qgH ? [qgL["batchSize"], qx2, qgL["inChannels"]] : [qgL["batchSize"], qgL["inChannels"], qx2] } }), qx4 = PB({ "inputs": { "x": qgj }, "backend": qgI, "attrs": { "shape": [1, qgL["inChannels"], qgL["outChannels"]] } }), qx5 = Uz({ "a": qgH ? qx3 : qx4, "b": qgH ? qx4 : qx3, "transposeA": !qgH, "transposeB": qgh, "backend": qgI, "bias": qgb, "activation": qgr, "preluActivationWeights": qgR, "leakyreluAlpha": qgo });
    qgT = PB({ "inputs": { "x": qx5 }, "backend": qgI, "attrs": { "shape": qgL["outShape"] } }), qgK["push"](qx3), qgK["push"](qx4), qgK["push"](qx5);
  }
  for (const qx6 of qgK) qgI["disposeIntermediateTensorInfo"](qx6);
  return qgT;
}
function q0p({ x: qgu, filter: qgj, convInfo: qgL, backend: qgI, bias: qgb = null, preluActivationWeights: qgR = null, leakyreluAlpha: qgo = 0, activation: qgr = null }) {
  const { filterWidth: qgQ, filterHeight: qgd, inChannels: qgv, outWidth: qgy, outHeight: qgl, dataFormat: qgH } = qgL, qgA = qgH === "channelsLast", qgh = qgQ * qgd * qgv, qgT = qgl * qgy, qgK = [qgL["batchSize"], qgh, qgT], qgB = true, qgV = false, qgJ = [];
  if (qgR != null) {
    const qxq = q0q(qgR["shape"], qgA);
    qxq != null && (qgR = PB({ "inputs": { "x": qgR }, "backend": qgI, "attrs": { "shape": qxq } }), qgJ["push"](qgR));
  }
  if (qgb != null) {
    const qxn = q0q(qgb["shape"], qgA);
    qxn != null && (qgb = PB({ "inputs": { "x": qgb }, "backend": qgI, "attrs": { "shape": qxn } }), qgJ["push"](qgb));
  }
  const qgY = PB({ "inputs": { "x": qgj }, "backend": qgI, "attrs": { "shape": [1, qgh, i2(qgj["shape"]) / qgh] } });
  qgJ["push"](qgY);
  const qgP = new q09(qgK, qgL), qgU = [qgu["shape"], [qgL["padInfo"]["top"], qgL["padInfo"]["left"]], [qgL["strideHeight"], qgL["strideWidth"]], [qgL["dilationHeight"], qgL["dilationWidth"]], [qgL["inChannels"]], [qgL["filterWidth"] * qgL["inChannels"]], [qgL["outWidth"]]], qx0 = qgI["runWebGLProgram"](qgP, [qgu], "float32", qgU), qx1 = PB({ "inputs": { "x": qx0 }, "backend": qgI, "attrs": { "shape": qgK } });
  qgJ["push"](qx0), qgJ["push"](qx1);
  const qx2 = qgb != null, qx3 = qgR != null, qx4 = qgr === "leakyrelu", qx5 = qgr ? YB(qgr, true) : null, qx6 = new PG(qgA ? qx1["shape"] : qgY["shape"], qgA ? qgY["shape"] : qx1["shape"], qgA ? [qgL["batchSize"], qgT, qgL["outChannels"]] : [qgL["batchSize"], qgL["outChannels"], qgT], qgB, qgV, qx2, qx5, qx3, qx4), qx7 = qgA ? [qx1, qgY] : [qgY, qx1];
  if (qgb && qx7["push"](qgb), qx3 && qx7["push"](qgR), qx4) {
    const qxp = qgI["makeTensorInfo"]([], "float32", Eq(qgo, "float32"));
    qx7["push"](qxp), qgJ["push"](qxp);
  }
  const qx8 = qgI["runWebGLProgram"](qx6, qx7, "float32"), qx9 = PB({ "inputs": { "x": qx8 }, "backend": qgI, "attrs": { "shape": qgL["outShape"] } });
  qgJ["push"](qx8);
  for (const qxs of qgJ) qgI["disposeIntermediateTensorInfo"](qxs);
  return qx9;
}
function q0g(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR } = qgj, { strides: qgo, pad: qgr, dataFormat: qgQ, dilations: qgd, dimRoundingMode: qgv } = qgI, qgy = Ds(qgQ), qgl = ij(qgb["shape"], qgR["shape"], qgo, qgd, qgr, qgv, false, qgy);
  let qgH;
  if (qgl["filterHeight"] === 1 && qgl["filterWidth"] === 1 && qgl["dilationHeight"] === 1 && qgl["dilationWidth"] === 1 && qgl["strideHeight"] === 1 && qgl["strideWidth"] === 1 && (qgl["padInfo"]["type"] === "SAME" || qgl["padInfo"]["type"] === "VALID")) qgH = q0n({ "x": qgb, "filter": qgR, "convInfo": qgl, "backend": qgL });
  else {
    if (qgl["strideWidth"] <= 2 && qgy === "channelsLast" && qM()["getBool"]("WEBGL_EXP_CONV")) {
      const qgh = new q08(qgl), qgT = [[qgl["padInfo"]["top"], qgl["padInfo"]["left"]], [qgl["strideHeight"], qgl["strideWidth"]], [qgl["dilationHeight"], qgl["dilationWidth"]], [qgl["inHeight"], qgl["inWidth"]]];
      qgH = qgL["runWebGLProgram"](qgh, [qgb, qgR], "float32", qgT);
    } else {
      if (qM()["getBool"]("WEBGL_CONV_IM2COL")) qgH = q0p({ "x": qgb, "filter": qgR, "convInfo": qgl, "backend": qgL });
      else {
        const qgK = new q07(qgl);
        qgH = qgL["runWebGLProgram"](qgK, [qgb, qgR], "float32");
      }
    }
  }
  const qgA = PB({ "inputs": { "x": qgH }, "backend": qgL, "attrs": { "shape": qgl["outShape"] } });
  return qgL["disposeIntermediateTensorInfo"](qgH), qgA;
}
var q0x = { "kernelName": qY, "backendName": "webgl", "kernelFunc": q0g };
var q0s = class {
  constructor(qgu) {
    this["variableNames"] = ["dy", "W"], this["outputShape"] = qgu["inShape"];
    const qgj = qgu["filterHeight"], qgL = qgu["filterWidth"], qgI = qgu["strideHeight"], qgb = qgu["strideWidth"], qgR = qgu["dataFormat"] === "channelsLast", qgo = qgj - 1 - qgu["padInfo"]["top"], qgr = qgL - 1 - qgu["padInfo"]["left"], qgQ = qgR ? 1 : 2, qgd = qgR ? 2 : 3, qgv = qgR ? 3 : 1;
    this["userCode"] = "\n      const ivec2 pads = ivec2(" + qgo + ", " + qgr + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[" + qgv + "];\n\n        ivec2 dyCorner = ivec2(coords[" + qgQ + "], coords[" + qgd + "]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < " + qgj + "; wR++) {\n          float dyR = float(dyRCorner + wR) / " + qgI + ".0;\n\n          if (dyR < 0.0 || dyR >= " + qgu["outHeight"] + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = " + qgj + " - 1 - wR;\n\n          for (int wC = 0; wC < " + qgL + "; wC++) {\n            float dyC = float(dyCCorner + wC) / " + qgb + ".0;\n\n            if (dyC < 0.0 || dyC >= " + qgu["outWidth"] + ".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = " + qgL + " - 1 - wC;\n\n            for (int d2 = 0; d2 < " + qgu["outChannels"] + "; d2++) {\n\n              if (" + qgR + ") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ";
  }
};
var q0E = class {
  constructor(qgu) {
    this["variableNames"] = ["dy", "W"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "strides", "type": "vec2" }], this["outputShape"] = qgu["inShape"], this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const qgj = qgu["filterHeight"], qgL = qgu["filterWidth"], qgI = qgj - 1 - qgu["padInfo"]["top"], qgb = qgL - 1 - qgu["padInfo"]["left"];
    this["userCode"] = "\n      const ivec2 pads = ivec2(" + qgI + ", " + qgb + ");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < " + qgj + "; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= " + qgu["outHeight"] + ".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = " + qgj + " - 1 - wR;\n\n          for (int wC = 0; wC < " + qgL + "; wC++) {\n            int wCPerm = " + qgL + " - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < " + qgu["outWidth"] + ".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < " + qgu["outWidth"] + ".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < " + qgu["outChannels"] + "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < " + qgu["outChannels"] + "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < " + qgu["outChannels"] + "; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ";
  }
};
function q0M(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { dy: qgb, filter: qgR } = qgj, { inputShape: qgo, strides: qgr, pad: qgQ, dataFormat: qgd, dimRoundingMode: qgv } = qgI, qgy = Ds(qgd), qgl = ij(qgo, qgR["shape"], qgr, 1, qgQ, qgv, false, qgy);
  if (qM()["getBool"]("WEBGL_PACK_CONV2DTRANSPOSE") && qgy === "channelsLast") {
    const qgH = [[qgl["strideHeight"], qgl["strideWidth"]]], qgA = new q0E(qgl);
    return qgL["runWebGLProgram"](qgA, [qgb, qgR], "float32", qgH);
  } else {
    const qgh = new q0s(qgl);
    return qgL["runWebGLProgram"](qgh, [qgb, qgR], "float32");
  }
}
var q0f = { "kernelName": qU, "backendName": "webgl", "kernelFunc": q0M };
var q0S = YQ + "\n  return cos(x);\n";
var q0F = "\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  " + YW + "\n  return result;\n";
var q0t = YH({ "opSnippet": q0S, "packedOpSnippet": q0F });
var q0k = { "kernelName": nq, "backendName": "webgl", "kernelFunc": q0t };
var q0O = class {
  constructor(qgu, qgj, qgL, qgI, qgb) {
    this["variableNames"] = ["Image", "Boxes", "BoxInd"], this["outputShape"] = [];
    const [qgR, qgo, qgr, qgQ] = qgu, [qgd] = qgj, [qgv, qgy] = qgL;
    this["outputShape"] = [qgd, qgv, qgy, qgQ];
    const qgl = qgI === "bilinear" ? 1 : 0, [qgH, qgA] = [qgo - 1 + ".0", qgr - 1 + ".0"], [qgh, qgT, qgK] = qgv > 1 ? ["" + (qgo - 1) / (qgv - 1), "(y2-y1) * height_ratio", "y1*" + qgH + " + float(y)*(height_scale)"] : ["0.0", "0.0", "0.5 * (y1+y2) * " + qgH], [qgB, qgV, qgJ] = qgy > 1 ? ["" + (qgr - 1) / (qgy - 1), "(x2-x1) * width_ratio", "x1*" + qgA + " + float(x)*(width_scale)"] : ["0.0", "0.0", "0.5 * (x1+x2) * " + qgA];
    this["userCode"] = "\n      const float height_ratio = float(" + qgh + ");\n      const float width_ratio = float(" + qgB + ");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= " + qgR + ") {\n          return;\n        }\n\n        float height_scale = " + qgT + ";\n        float width_scale = " + qgV + ";\n\n        float in_y = " + qgK + ";\n        if( in_y < 0.0 || in_y > " + qgH + " ) {\n          setOutput(float(" + qgb + "));\n          return;\n        }\n        float in_x = " + qgJ + ";\n        if( in_x < 0.0 || in_x > " + qgA + " ) {\n          setOutput(float(" + qgb + "));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(" + qgl + " == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ";
  }
};
var q0W = (qgu) => {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { image: qgb, boxes: qgR, boxInd: qgo } = qgj, { cropSize: qgr, method: qgQ, extrapolationValue: qgd } = qgI, qgv = new q0O(qgb["shape"], qgR["shape"], qgr, qgQ, qgd);
  return qgL["runWebGLProgram"](qgv, [qgb, qgR, qgo], "float32");
};
var q0i = { "kernelName": nn, "backendName": "webgl", "kernelFunc": q0W };
var q0D = class {
  constructor(qgu, qgj, qgL) {
    this["variableNames"] = ["x"], this["outputShape"] = [], this["outputShape"] = qgu, this["blockSize"] = qgj, this["dataFormat"] = qgL, this["userCode"] = "\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = " + this["getHeightCoordString"]() + ";\n      int w = " + this["getWidthCoordString"]() + ";\n      int d = " + this["getDepthCoordString"]() + ";\n\n      int in_h = h / " + qgj + ";\n      int offset_h = imod(h, " + qgj + ");\n      int in_w = w / " + qgj + ";\n      int offset_w = imod(w, " + qgj + ");\n      int offset_d = (offset_h * " + qgj + " + offset_w) *\n        " + this["getOutputDepthSize"]() + ";\n      int in_d = d + offset_d;\n\n      float result = " + this["getInputSamplingString"]() + ";\n      setOutput(result);\n    }\n  ";
  }
  ["getHeightCoordString"]() {
    return this["dataFormat"] === "NHWC" ? "coords[1]" : "coords[2]";
  }
  ["getWidthCoordString"]() {
    return this["dataFormat"] === "NHWC" ? "coords[2]" : "coords[3]";
  }
  ["getDepthCoordString"]() {
    return this["dataFormat"] === "NHWC" ? "coords[3]" : "coords[1]";
  }
  ["getOutputDepthSize"]() {
    return this["dataFormat"] === "NHWC" ? this["outputShape"][3] : this["outputShape"][1];
  }
  ["getInputSamplingString"]() {
    return this["dataFormat"] === "NHWC" ? "getX(b, in_h, in_w, in_d)" : "getX(b, in_d, in_h, in_w)";
  }
};
function q0m(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { blockSize: qgR, dataFormat: qgo } = qgI, qgr = qgb["shape"][0], qgQ = qgo === "NHWC" ? qgb["shape"][1] : qgb["shape"][2], qgd = qgo === "NHWC" ? qgb["shape"][2] : qgb["shape"][3], qgv = qgo === "NHWC" ? qgb["shape"][3] : qgb["shape"][1], qgy = qgQ * qgR, qgl = qgd * qgR, qgH = qgv / (qgR * qgR), qgA = qgo === "NHWC" ? [qgr, qgy, qgl, qgH] : [qgr, qgH, qgy, qgl], qgh = new q0D(qgA, qgR, qgo);
  return qgL["runWebGLProgram"](qgh, [qgb], qgb["dtype"]);
}
var q0a = { "kernelName": ns, "backendName": "webgl", "kernelFunc": q0m };
var q0Z = class {
  constructor(qgu, qgj = false, qgL = null, qgI = false, qgb = false) {
    this["variableNames"] = ["x", "W"], this["customUniforms"] = [{ "name": "pads", "type": "ivec2" }, { "name": "strides", "type": "ivec2" }, { "name": "dilations", "type": "ivec2" }, { "name": "inDims", "type": "ivec2" }], this["outputShape"] = qgu["outShape"], this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const qgR = qgu["filterHeight"], qgo = qgu["filterWidth"], qgr = qgu["outChannels"] / qgu["inChannels"];
    let qgQ = "", qgd = "";
    qgL && (qgI ? qgQ = "float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          " + qgL + "\n        }" : qgb ? qgQ = "float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          " + qgL + "\n        }" : qgQ = "\n          float activation(float x) {\n            " + qgL + "\n          }\n        ", qgd = "result = activation(result);");
    const qgv = qgj ? "result += getBiasAtOutCoords();" : "";
    qgj && this["variableNames"]["push"]("bias"), qgI && this["variableNames"]["push"]("preluActivationWeights"), qgb && this["variableNames"]["push"]("leakyreluAlpha"), this["userCode"] = "\n      " + qgQ + "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + qgr + ";\n        int q = d2 - d1 * " + qgr + ";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < " + qgR + "; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < " + qgo + "; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        " + qgv + "\n        " + qgd + "\n        setOutput(result);\n      }\n    ";
  }
};
var q0w = class {
  constructor(qgu, qgj = false, qgL = null, qgI = false, qgb = false) {
    this["variableNames"] = ["x", "W"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "pads", "type": "ivec2" }, { "name": "strides", "type": "ivec2" }, { "name": "dilations", "type": "ivec2" }, { "name": "inDims", "type": "ivec2" }], this["outputShape"] = qgu["outShape"], this["enableShapeUniforms"] = CG(this["outputShape"]["length"]);
    const qgR = qgu["outChannels"] / qgu["inChannels"], qgo = qgu["padInfo"]["left"], qgr = qgu["strideWidth"], qgQ = qgu["dilationWidth"], qgd = qgu["filterHeight"], qgv = qgu["filterWidth"], qgy = qgv;
    let qgl = "\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";
    for (let qgT = 0; qgT < qgv; qgT++) qgl += "\n          vec4 xTexelC" + qgT * 2 + ";\n          int xTexelC" + qgT * 2 + "Ready;\n          vec4 xTexelC" + (qgT * 2 + 1) + ";\n          int xTexelC" + (qgT * 2 + 1) + "Ready;\n          vec4 xC" + qgT + ";";
    qgl += "\n    for (int r = 0; r < " + qgd + "; r++) {\n      ";
    for (let qgK = 0; qgK < qgv; qgK++) qgl += "\n          xTexelC" + qgK * 2 + " = vec4(0.0);\n          xTexelC" + qgK * 2 + "Ready = 0;\n          xTexelC" + (qgK * 2 + 1) + " = vec4(0.0);\n          xTexelC" + (qgK * 2 + 1) + "Ready = 0;\n          xC" + qgK + " = vec4(0.0);";
    qgl += "\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";
    for (let qgB = 0; qgB < (qgy + 1) / 2; qgB++) {
      const qgV = qgB * 2;
      if (qgl += "\n          xC = xCCorner + " + qgV * qgQ + ";\n          ", qgr === 1) {
        if (qgV < qgv && (qgo % 2 === 1 ? (qgl += "\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + qgV + "Ready == 0) {\n                  xTexelC" + qgV + " = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC" + qgV + ".zw = vec2(0.0);\n                  }\n                  xTexelC" + qgV + "Ready = 1;\n                }\n              ", qgQ === 1 && qgV > 0 ? qgl += "\n                xC" + qgV + " = vec4(xTexelC" + (qgV - 2) + ".zw, xTexelC" + qgV + ".xy);\n                " : qgl += "\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC" + qgV + " = vec4(previous.zw, xTexelC" + qgV + ".xy);\n                  } else {\n                    xC" + qgV + " = vec4(0.0, 0.0, xTexelC" + qgV + ".xy);\n                  }\n                  ") : qgl += "\n                if (xC >= 0 && xC < inDims[1] && xTexelC" + qgV + "Ready == 0) {\n                  xTexelC" + qgV + " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC" + qgV + ".zw = vec2(0.0);\n                  }\n                  xTexelC" + qgV + "Ready = 1;\n                }\n\n                xC" + qgV + " = xTexelC" + qgV + ";\n                ", qgV + 1 < qgv)) {
          const qgJ = qgo % 2 === 0 ? f(qgQ) : qgQ;
          qgQ % 2 === 0 && qgo % 2 === 1 || qgQ % 2 !== 0 && qgo % 2 !== 1 ? (qgl += "\n                  xCOffset = xC + imod(pads[1], 2) + " + qgJ + ";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + (qgV + 1) + "Ready == 0) {\n                    xTexelC" + (qgV + 1) + " = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC" + (qgV + 1) + ".zw = vec2(0.0);\n                    }\n                    xTexelC" + (qgV + 1) + "Ready = 1;\n                  }\n                  ", qgQ > 1 ? qgl += "\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC" + (qgV + 1) + " = vec4(previous.zw, xTexelC" + (qgV + 1) + ".xy);\n                    } else {\n                     xC" + (qgV + 1) + " = vec4(0.0, 0.0, xTexelC" + (qgV + 1) + ".xy);\n                    }\n                    " : qgl += "\n                    xC" + (qgV + 1) + " = vec4(xTexelC" + qgV + ".zw, xTexelC" + (qgV + 1) + ".xy);\n                    ") : qgJ === 1 ? qgl += "\n                    xC" + (qgV + 1) + " = xTexelC" + qgV + ";\n                    " : qgl += "\n                    xCOffset = xC + " + qgJ + ";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + (qgV + 1) + "Ready == 0) {\n                      xTexelC" + (qgV + 1) + " = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC" + (qgV + 1) + ".zw = vec2(0.0);\n                      }\n                      xTexelC" + (qgV + 1) + "Ready = 1;\n                    }\n\n                    xC" + (qgV + 1) + " = xTexelC" + (qgV + 1) + ";\n                    ";
        }
      } else qgV < qgv && (qgo % 2 === 1 ? (qgl += "\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + qgV + "Ready == 0) {\n                  xTexelC" + qgV + " = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC" + qgV + ".zw = vec2(0.0);\n                  }\n                  xTexelC" + qgV + "Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC" + (qgV + 1) + "Ready == 0) {\n                  xTexelC" + (qgV + 1) + " = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC" + (qgV + 1) + ".zw = vec2(0.0);\n                  }\n                  xTexelC" + (qgV + 1) + "Ready = 1;\n                }\n\n                xC" + qgV + " = vec4(xTexelC" + qgV + ".zw, xTexelC" + (qgV + 1) + ".zw);\n              ", qgV + 1 < qgv && (qgl += "\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC" + (qgV + 1) + " = vec4(xTexelC" + (qgV + 1) + ".xy, final.xy);\n                ")) : (qgl += "\n                if(xC >= 0 && xC < inDims[1] && xTexelC" + qgV + "Ready == 0) {\n                  xTexelC" + qgV + " = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC" + qgV + ".zw = vec2(0.0);\n                  }\n                  xTexelC" + qgV + "Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC" + (qgV + 1) + "Ready == 0) {\n                  xTexelC" + (qgV + 1) + " = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC" + (qgV + 1) + ".zw = vec2(0.);\n                  }\n                  xTexelC" + (qgV + 1) + "Ready = 1;\n                }\n\n                xC" + qgV + " = vec4(\n                  xTexelC" + qgV + ".xy, xTexelC" + (qgV + 1) + ".xy);\n              ", qgV + 1 < qgv && (qgl += "\n                  xC" + (qgV + 1) + " = vec4(xTexelC" + qgV + ".zw, xTexelC" + (qgV + 1) + ".zw);\n                ")));
      qgV < qgv && (qgl += "\n            wTexel = getW(r, " + qgV + ", d1, q);\n            dotProd += xC" + qgV + " * vec4(wTexel.xz, wTexel.xz);\n          ", qgV + 1 < qgv && (qgl += "\n              wTexel = getW(r, " + (qgV + 1) + ", d1, q);\n              dotProd += xC" + (qgV + 1) + " * vec4(wTexel.xz, wTexel.xz);\n            "));
    }
    qgl += "\n    }\n  ", qgl += "\n      }\n    ";
    let qgH = "", qgA = "";
    qgL && (qgI ? qgH = "vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          " + qgL + "\n        }" : qgb ? qgH = "vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          " + qgL + "\n        }" : qgH = "vec4 activation(vec4 x) {\n          " + qgL + "\n        }", qgA = "result = activation(result);");
    const qgh = qgj ? "result += getBiasAtOutCoords();" : "";
    qgj && this["variableNames"]["push"]("bias"), qgI && this["variableNames"]["push"]("preluActivationWeights"), qgb && this["variableNames"]["push"]("leakyreluAlpha"), this["userCode"] = "\n      " + qgH + "\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / " + qgR + ";\n        int q = d2 - d1 * " + qgR + ";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        " + qgl + "\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        " + qgh + "\n        " + qgA + "\n        setOutput(result);\n      }\n    ";
  }
};
function q0e(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR } = qgj, { strides: qgo, pad: qgr, dilations: qgQ, dimRoundingMode: qgd } = qgI;
  let qgv = qgQ;
  qgv == null && (qgv = [1, 1]), k(iU(qgo, qgv), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + qgo + " and dilations '" + qgv + "'");
  const qgy = ij(qgb["shape"], qgR["shape"], qgo, qgv, qgr, qgd, true);
  let qgl;
  qM()["getBool"]("WEBGL_PACK_DEPTHWISECONV") && qgy["strideWidth"] <= 2 && qgy["outChannels"] / qgy["inChannels"] === 1 ? qgl = new q0w(qgy) : qgl = new q0Z(qgy);
  const qgH = [[qgy["padInfo"]["top"], qgy["padInfo"]["left"]], [qgy["strideHeight"], qgy["strideWidth"]], [qgy["dilationHeight"], qgy["dilationWidth"]], [qgy["inHeight"], qgy["inWidth"]]];
  return qgL["runWebGLProgram"](qgl, [qgb, qgR], "float32", qgH);
}
var q0z = { "kernelName": nM, "backendName": "webgl", "kernelFunc": q0e };
function q0c(qgu) {
  const { inputs: qgj, attrs: qgL, backend: qgI } = qgu, { dim: qgb } = qgL, { input: qgR } = qgj, qgo = qgR["shape"]["length"], qgr = qgR["shape"]["slice"]();
  let qgQ = qgb;
  return qgb < 0 && (k(-(qgo + 1) <= qgb, () => "Axis must be in the interval [" + -(qgo + 1) + ", " + qgo + "]"), qgQ = qgo + qgb + 1), qgr["splice"](qgQ, 0, 1), PB({ "inputs": { "x": qgR }, "backend": qgI, "attrs": { "shape": qgr } });
}
var q0X = { "kernelName": nZ, "backendName": "webgl", "kernelFunc": q0c };
var q0G = class {
  constructor(qgu, qgj) {
    this["outputShape"] = [], this["customUniforms"] = [{ "name": "value", "type": "float" }], this["variableNames"] = ["x"], this["outputShape"] = qgu, this["userCode"] = "\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    ";
  }
};
function q0N(qgu) {
  const { backend: qgj, attrs: qgL } = qgu, { shape: qgI, value: qgb } = qgL;
  let { dtype: qgR } = qgL;
  if (qgR = qgR || Q(qgb), qgR === "string") {
    const qgo = G(qgR, i2(qgI));
    return qgo["fill"](qgb), qgj["makeTensorInfo"](qgI, qgR, qgo);
  } else {
    const qgr = new q0G(qgI, qgb), qgQ = [[qgb]];
    return qgj["runWebGLProgram"](qgr, [], qgR, qgQ);
  }
}
var q0u = { "kernelName": ne, "backendName": "webgl", "kernelFunc": q0N };
var q0j = "return floor(x);";
var q0L = YH({ "opSnippet": q0j, "packedOpSnippet": q0j, "cpuKernelImpl": KB });
var q0I = { "kernelName": nX, "backendName": "webgl", "kernelFunc": q0L };
var q0b = class {
  constructor(qgu) {
    this["variableNames"] = ["A"];
    const qgj = dB(), [qgL, qgI] = qgu;
    this["outputShape"] = qgu, this["userCode"] = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(" + qgI + ".0, " + qgL + ".0);\n\n        vec4 values = " + qgj["texture2D"] + "(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ";
  }
};
var q0R = class {
  constructor(qgu) {
    this["variableNames"] = ["A"], this["packedInputs"] = false, this["packedOutput"] = true;
    const qgj = dB(), [qgL, qgI] = qgu;
    this["outputShape"] = qgu, this["userCode"] = "\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(" + qgI + ".0, " + qgL + ".0);\n            vec4 values = " + qgj["texture2D"] + "(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        " + qgj["output"] + " = result;\n      }\n    ";
  }
};
var q0o = { "kernelName": gz, "backendName": "webgl", "kernelFunc": q0d };
var q0r;
var q0Q = qM()["getBool"]("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
function q0d(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu;
  let { pixels: qgb } = qgj;
  const { numChannels: qgR } = qgI, qgo = typeof HTMLVideoElement != "undefined" && qgb instanceof HTMLVideoElement, qgr = typeof HTMLImageElement != "undefined" && qgb instanceof HTMLImageElement, [qgQ, qgd] = qgo ? [qgb["videoWidth"], qgb["videoHeight"]] : [qgb["width"], qgb["height"]], qgv = [qgd, qgQ], qgy = [qgd, qgQ, qgR];
  if (qgr || qgo) {
    const qgh = qM()["getBool"]("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");
    (q0r == null || qgh !== q0Q) && (q0Q = qgh, q0r = document["createElement"]("canvas")["getContext"]("2d", { "willReadFrequently": q0Q })), q0r["canvas"]["width"] = qgQ, q0r["canvas"]["height"] = qgd, q0r["drawImage"](qgb, 0, 0, qgQ, qgd), qgb = q0r["canvas"];
  }
  const qgl = qgL["makeTensorInfo"](qgv, "int32");
  qgL["texData"]["get"](qgl["dataId"])["usage"] = rX["PIXELS"], qgL["gpgpu"]["uploadPixelDataToTexture"](qgL["getTexture"](qgl["dataId"]), qgb);
  const qgH = qM()["getBool"]("WEBGL_PACK") ? new q0R(qgy) : new q0b(qgy), qgA = qgL["runWebGLProgram"](qgH, [qgl], "int32");
  return qgL["disposeData"](qgl["dataId"]), qgA;
}
function q0v(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR, bias: qgo, preluActivationWeights: qgr } = qgj, { strides: qgQ, pad: qgd, dataFormat: qgv, dilations: qgy, dimRoundingMode: qgl, activation: qgH, leakyreluAlpha: qgA } = qgI, qgh = Ds(qgv), qgT = ij(qgb["shape"], qgR["shape"], qgQ, qgy, qgd, qgl, false, qgh);
  let qgK;
  const qgB = [], qgV = qgo != null, qgJ = qgr != null, qgY = qgH === "leakyrelu", qgP = () => {
    const qx0 = [qgb, qgR], qx1 = (qx2, qx3) => {
      if (qx3 === "NCHW" && qx2["shape"]["length"] === 1 && qx2["shape"][0] !== 1) {
        const qx4 = PB({ "inputs": { "x": qx2 }, "backend": qgL, "attrs": { "shape": [qx2["shape"][0], 1, 1] } });
        return qgB["push"](qx4), qx4;
      }
      return qx2;
    };
    if (qgV && qx0["push"](qx1(qgo, qgv)), qgJ && qx0["push"](qx1(qgr, qgv)), qgY) {
      const qx2 = qgL["makeTensorInfo"]([], "float32", Eq(qgA, "float32"));
      qx0["push"](qx2), qgB["push"](qx2);
    }
    return qx0;
  };
  if (qgT["filterHeight"] === 1 && qgT["filterWidth"] === 1 && qgT["dilationHeight"] === 1 && qgT["dilationWidth"] === 1 && qgT["strideHeight"] === 1 && qgT["strideWidth"] === 1 && (qgT["padInfo"]["type"] === "SAME" || qgT["padInfo"]["type"] === "VALID")) qgK = q0n({ "x": qgb, "filter": qgR, "convInfo": qgT, "backend": qgL, "bias": qgo, "activation": qgH, "preluActivationWeights": qgr, "leakyreluAlpha": qgA });
  else {
    if (qgT["strideWidth"] <= 2 && qgh === "channelsLast" && qM()["getBool"]("WEBGL_EXP_CONV")) {
      const qx0 = qgH ? YB(qgH, true) : null, qx1 = new q08(qgT, qgV, qx0, qgJ, qgY), qx2 = [[qgT["padInfo"]["top"], qgT["padInfo"]["left"]], [qgT["strideHeight"], qgT["strideWidth"]], [qgT["dilationHeight"], qgT["dilationWidth"]], [qgT["inHeight"], qgT["inWidth"]]], qx3 = qgP();
      qgK = qgL["runWebGLProgram"](qx1, qx3, "float32", qx2);
    } else {
      if (qM()["getBool"]("WEBGL_CONV_IM2COL")) qgK = q0p({ "x": qgb, "filter": qgR, "convInfo": qgT, "backend": qgL, "bias": qgo, "activation": qgH, "preluActivationWeights": qgr, "leakyreluAlpha": qgA });
      else {
        const qx4 = qgH ? YB(qgH, false) : null, qx5 = new q07(qgT, qgV, qx4, qgJ, qgY), qx6 = qgP();
        qgK = qgL["runWebGLProgram"](qx5, qx6, "float32");
      }
    }
  }
  const qgU = PB({ "inputs": { "x": qgK }, "backend": qgL, "attrs": { "shape": qgT["outShape"] } });
  return qgB["push"](qgK), qgB["forEach"]((qx7) => qgL["disposeIntermediateTensorInfo"](qx7)), qgU;
}
var q0y = { "kernelName": gu, "backendName": "webgl", "kernelFunc": q0v };
function q0C(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR, bias: qgo, preluActivationWeights: qgr } = qgj, { strides: qgQ, pad: qgd, dilations: qgv, dimRoundingMode: qgy, activation: qgl, leakyreluAlpha: qgH } = qgI, qgA = [];
  let qgh = qgv;
  qgh == null && (qgh = [1, 1]), k(iU(qgQ, qgh), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + qgQ + " and dilations '" + qgh + "'");
  const qgT = ij(qgb["shape"], qgR["shape"], qgQ, qgh, qgd, qgy, true), qgK = qM()["getBool"]("WEBGL_PACK_DEPTHWISECONV") && qgT["strideWidth"] <= 2 && qgT["outChannels"] / qgT["inChannels"] === 1, qgB = qgl ? YB(qgl, qgK) : null, qgV = [qgb, qgR], qgJ = qgo != null, qgY = qgr != null, qgP = qgl === "leakyrelu";
  if (qgJ && qgV["push"](qgo), qgY && qgV["push"](qgr), qgP) {
    const qx2 = qgL["makeTensorInfo"]([], "float32", Eq(qgH, "float32"));
    qgV["push"](qx2), qgA["push"](qx2);
  }
  let qgU;
  qgK ? qgU = new q0w(qgT, qgJ, qgB, qgY, qgP) : qgU = new q0Z(qgT, qgJ, qgB, qgY, qgP);
  const qx0 = [[qgT["padInfo"]["top"], qgT["padInfo"]["left"]], [qgT["strideHeight"], qgT["strideWidth"]], [qgT["dilationHeight"], qgT["dilationWidth"]], [qgT["inHeight"], qgT["inWidth"]]], qx1 = qgL["runWebGLProgram"](qgU, qgV, "float32", qx0);
  return qgA["forEach"]((qx3) => qgL["disposeIntermediateTensorInfo"](qx3)), qx1;
}
var q0l = { "kernelName": gj, "backendName": "webgl", "kernelFunc": q0C };
var q0H = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A", "indices"], this["outputShape"] = qgj, this["rank"] = qgj["length"];
    const qgL = yU(this["rank"]), qgI = q0A(qgu);
    this["userCode"] = "\n      void main() {\n        " + qgL + " resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < " + qgu[2] + ") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(" + qgI + "));\n      }\n    ";
  }
};
function q0A(qgu, qgj) {
  const qgL = ["resRC.x", "resRC.y", "resRC.z", "resRC.w"], qgI = [];
  for (let qgb = 0; qgb < qgu["length"]; qgb++) qgb === 2 ? qgI["push"]("index") : qgI["push"]("" + qgL[qgb]);
  return qgI["join"]();
}
function q0h(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, indices: qgR } = qgj, { axis: qgo, batchDims: qgr } = qgI, qgQ = z(qgo, qgb["shape"])[0];
  if (qM()["get"]("DEBUG")) {
    const qgB = qgL["readSync"](qgR["dataId"]), qgV = qgb["shape"][qgQ];
    for (let qgJ = 0; qgJ < qgB["length"]; ++qgJ) {
      const qgY = qgB[qgJ];
      k(qgY <= qgV - 1 && qgY >= 0, () => "GatherV2: the index value " + qgY + " is not in [0, " + (qgV - 1) + "]");
    }
  }
  const qgd = uj(qgb, qgR, qgQ, qgr), qgv = i2(qgR["shape"]), qgy = [], qgl = PB({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "shape": [qgd["batchSize"], qgd["outerSize"], qgd["dimSize"], qgd["sliceSize"]] } }), qgH = PB({ "inputs": { "x": qgR }, "backend": qgL, "attrs": { "shape": [qgd["batchSize"], qgv / qgd["batchSize"]] } });
  qgy["push"](qgl), qgy["push"](qgH);
  const qgA = [qgd["batchSize"], qgd["outerSize"], qgv / qgd["batchSize"], qgd["sliceSize"]];
  if (qgL["shouldExecuteOnCPU"]([qgb, qgR]) || qgb["dtype"] === "string") {
    const qgP = qgL["bufferSync"](qgH), qgU = qgL["bufferSync"](qgl), qx0 = KJ(qgU, qgP, qgA);
    return qgy["forEach"]((qx1) => qgL["disposeIntermediateTensorInfo"](qx1)), qgL["makeTensorInfo"](qgd["outputShape"], qx0["dtype"], qx0["values"]);
  }
  const qgh = new q0H(qgl["shape"], qgA), qgT = qgL["runWebGLProgram"](qgh, [qgl, qgH], qgl["dtype"]);
  qgy["push"](qgT);
  const qgK = PB({ "inputs": { "x": qgT }, "backend": qgL, "attrs": { "shape": qgd["outputShape"] } });
  return qgy["forEach"]((qx1) => qgL["disposeIntermediateTensorInfo"](qx1)), qgK;
}
var q0T = { "kernelName": nu, "backendName": "webgl", "kernelFunc": q0h };
var q0K = "return float(a >= b);";
var q0B = "\n  return vec4(greaterThanEqual(a, b));\n";
var q0V = YK({ "opSnippet": q0K, "packedOpSnippet": q0B, "dtype": "bool", "cpuKernelImpl": KP });
var q0J = { "kernelName": nL, "backendName": "webgl", "kernelFunc": q0V };
var q0Y = "return float(a < b);";
var q0P = "\n  return vec4(lessThan(a, b));\n";
var q0U = YK({ "opSnippet": q0Y, "packedOpSnippet": q0P, "cpuKernelImpl": KU, "dtype": "bool" });
var q10 = { "kernelName": nK, "backendName": "webgl", "kernelFunc": q0U };
var q11 = "return float(a <= b);";
var q12 = "\n  return vec4(lessThanEqual(a, b));\n";
var q13 = YK({ "opSnippet": q11, "packedOpSnippet": q12, "cpuKernelImpl": Bq, "dtype": "bool" });
var q14 = { "kernelName": nB, "backendName": "webgl", "kernelFunc": q13 };
var q15 = "return float(a >= 1.0 && b >= 1.0);";
var q16 = "\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n";
var q17 = YK({ "opSnippet": q15, "packedOpSnippet": q16, "dtype": "bool" });
var q18 = { "kernelName": nV, "backendName": "webgl", "kernelFunc": q17 };
var q19 = "return float(a >= 1.0 || b >= 1.0);";
var q1q = "\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n";
var q1n = YK({ "opSnippet": q19, "packedOpSnippet": q1q, "dtype": "bool" });
var q1p = { "kernelName": nJ, "backendName": "webgl", "kernelFunc": q1n };
function q1g(qgu, qgj, qgL, qgI) {
  const qgb = i2(qgj), qgR = i2(qgu["shape"]) / qgb, qgo = PB({ "inputs": { "x": qgu }, "attrs": { "shape": [qgR, qgb] }, "backend": qgI }), qgr = PU(qgo, qgu["dtype"], "max", qgI), qgQ = PB({ "inputs": { "x": qgr }, "attrs": { "shape": qgL }, "backend": qgI });
  return qgI["disposeIntermediateTensorInfo"](qgo), qgI["disposeIntermediateTensorInfo"](qgr), qgQ;
}
function q1x(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { reductionIndices: qgR, keepDims: qgo } = qgI, qgr = qgb["shape"]["length"], qgQ = z(qgR, qgb["shape"]);
  let qgd = qgQ;
  const qgv = at(qgd, qgr), qgy = qgv != null, qgl = qgL["shouldExecuteOnCPU"]([qgb]);
  let qgH = qgb;
  if (qgy) {
    if (qgl) {
      const qgB = qgL["texData"]["get"](qgH["dataId"])["values"], qgV = new Array(qgr);
      for (let qgP = 0; qgP < qgV["length"]; qgP++) qgV[qgP] = qgb["shape"][qgv[qgP]];
      const qgJ = VZ(qgB, qgb["shape"], qgb["dtype"], qgv, qgV);
      qgH = qgL["makeTensorInfo"](qgV, qgb["dtype"]);
      const qgY = qgL["texData"]["get"](qgH["dataId"]);
      qgY["values"] = qgJ;
    } else qgH = UM(qgb, qgv, qgL);
    qgd = aD(qgd["length"], qgr);
  }
  aF("max", qgd, qgr);
  const [qgA, qgh] = aq(qgH["shape"], qgd);
  let qgT = qgA;
  qgo && (qgT = aM(qgA, qgQ));
  let qgK;
  if (qgl) {
    const qgU = qgL["texData"]["get"](qgH["dataId"])["values"], qx0 = BM(qgU, i2(qgh), qgT, qgb["dtype"]);
    qgK = qgL["makeTensorInfo"](qgT, qgb["dtype"]);
    const qx1 = qgL["texData"]["get"](qgK["dataId"]);
    qx1["values"] = qx0;
  } else qgK = q1g(qgH, qgh, qgT, qgL);
  return qgy && qgL["disposeIntermediateTensorInfo"](qgH), qgK;
}
var q1s = { "kernelName": nY, "backendName": "webgl", "kernelFunc": q1x };
function q1E(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj;
  dH(qgb, "maxPool");
  const { filterSize: qgR, strides: qgo, pad: qgr, dimRoundingMode: qgQ } = qgI, qgd = 1;
  k(iU(qgo, qgd), () => "Error in maxPool: Either strides or dilations must be 1. Got strides " + qgo + " and dilations '" + qgd + "'");
  const qgv = iG(qgb["shape"], qgR, qgo, qgd, qgr, qgQ);
  if (qgv["filterWidth"] === 1 && qgv["filterHeight"] === 1 && D(qgv["inShape"], qgv["outShape"])) return Ya({ "inputs": { "x": qgb }, "backend": qgL });
  const qgy = new PZ(qgv, "max", false);
  return qgL["runWebGLProgram"](qgy, [qgb], qgb["dtype"]);
}
var q1M = { "kernelName": nU, "backendName": "webgl", "kernelFunc": q1E };
var q1f = YF + "\n  return max(a, b);\n";
var q1S = "\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + YW + "\n  return result;\n";
var q1F = YK({ "opSnippet": q1f, "packedOpSnippet": q1S, "cpuKernelImpl": BF });
var q1t = { "kernelName": nP, "backendName": "webgl", "kernelFunc": q1F };
function q1k(qgu, qgj, qgL, qgI) {
  const qgb = i2(qgj), qgR = i2(qgu["shape"]) / qgb, qgo = PB({ "inputs": { "x": qgu }, "attrs": { "shape": [qgR, qgb] }, "backend": qgI }), qgr = PU(qgo, "float32", "mean", qgI), qgQ = PB({ "inputs": { "x": qgr }, "attrs": { "shape": qgL }, "backend": qgI });
  return qgI["disposeIntermediateTensorInfo"](qgo), qgI["disposeIntermediateTensorInfo"](qgr), qgQ;
}
var q1O = { "kernelName": p1, "backendName": "webgl", "kernelFunc": ({ inputs: qgu, attrs: qgj, backend: qgL }) => {
  const { x: qgI } = qgu, { keepDims: qgb, axis: qgR } = qgj, qgo = qgL, qgr = qgI["shape"]["length"], qgQ = z(qgR, qgI["shape"]);
  let qgd = qgQ;
  const qgv = at(qgd, qgr), qgy = qgv != null, qgl = qgo["shouldExecuteOnCPU"]([qgI]), qgH = [];
  let qgA = qgI;
  if (qgy) {
    if (qgl) {
      const qgV = qgo["texData"]["get"](qgA["dataId"])["values"], qgJ = new Array(qgr);
      for (let qgU = 0; qgU < qgJ["length"]; qgU++) qgJ[qgU] = qgI["shape"][qgv[qgU]];
      const qgY = VZ(qgV, qgI["shape"], qgI["dtype"], qgv, qgJ);
      qgA = qgo["makeTensorInfo"](qgJ, qgI["dtype"]);
      const qgP = qgo["texData"]["get"](qgA["dataId"]);
      qgP["values"] = qgY;
    } else qgA = UM(qgI, qgv, qgo);
    qgH["push"](qgA), qgd = aD(qgd["length"], qgr);
  }
  aF("sum", qgd, qgr);
  const [qgh, qgT] = aq(qgA["shape"], qgd);
  let qgK = qgh;
  qgb && (qgK = aM(qgh, qgQ));
  const qgB = q1k(qgA, qgT, qgK, qgo);
  for (const qx0 of qgH) qgo["disposeIntermediateTensorInfo"](qx0);
  return qgB;
} };
function q1W(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { axis: qgR, keepDims: qgo } = qgI, qgr = qgb["shape"]["length"], qgQ = z(qgR, qgb["shape"]);
  let qgd = qgQ;
  const qgv = at(qgd, qgr);
  let qgy = qgb;
  qgv != null && (qgy = UD({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "perm": qgv } }), qgd = aD(qgd["length"], qgb["shape"]["length"])), aF("min", qgd, qgr);
  const [qgl, qgH] = aq(qgy["shape"], qgd), qgA = i2(qgH), qgh = PB({ "inputs": { "x": qgy }, "backend": qgL, "attrs": { "shape": [-1, qgA] } }), qgT = PU(qgh, qgh["dtype"], "min", qgL);
  let qgK;
  if (qgo) {
    const qgB = aM(qgl, qgQ);
    qgK = PB({ "inputs": { "x": qgT }, "backend": qgL, "attrs": { "shape": qgB } });
  } else qgK = PB({ "inputs": { "x": qgT }, "backend": qgL, "attrs": { "shape": qgl } });
  return qgL["disposeIntermediateTensorInfo"](qgh), qgL["disposeIntermediateTensorInfo"](qgT), qgv != null && qgL["disposeIntermediateTensorInfo"](qgy), qgK;
}
var q1i = { "kernelName": pq, "backendName": "webgl", "kernelFunc": q1W };
var q1D = YF + "\n  return min(a, b);\n";
var q1m = "\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  " + YW + "\n  return result;\n";
var q1a = YK({ "opSnippet": q1D, "packedOpSnippet": q1m, "cpuKernelImpl": Bt });
var q1Z = { "kernelName": pM, "backendName": "webgl", "kernelFunc": q1a };
var q1w = VU + "\n  return -x;\n";
var q1e = "\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
function q1z(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  if (qgL["shouldExecuteOnCPU"]([qgI])) {
    const qgR = qgL["texData"]["get"](qgI["dataId"]), [qgo, qgr] = BD(qgR["values"], qgI["shape"], qgI["dtype"]);
    return qgL["makeTensorInfo"](qgr, qgI["dtype"], qgo);
  }
  let qgb;
  return qM()["getBool"]("WEBGL_PACK_UNARY_OPERATIONS") ? qgb = new JL(qgI["shape"], q1e) : qgb = new VP(qgI["shape"], q1w), qgL["runWebGLProgram"](qgb, [qgI], qgI["dtype"]);
}
var q1c = { "kernelName": pt, "backendName": "webgl", "kernelFunc": q1z };
function q1X(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { axis: qgb } = qgI;
  if (qgj["length"] === 1) return q0c({ "inputs": { "input": qgj[0] }, "backend": qgL, "attrs": { "dim": qgb } });
  const qgR = qgj[0]["shape"], qgo = qgj[0]["dtype"];
  qgj["forEach"]((qgv) => {
    O(qgR, qgv["shape"], "All tensors passed to stack must have matching shapes"), k(qgo === qgv["dtype"], () => "All tensors passed to stack must have matching dtypes");
  });
  const qgr = [], qgQ = qgj["map"]((qgv) => {
    const qgy = q0c({ "inputs": { "input": qgv }, "backend": qgL, "attrs": { "dim": qgb } });
    return qgr["push"](qgy), qgy;
  }), qgd = q05({ "inputs": qgQ, "backend": qgL, "attrs": { "axis": qgb } });
  return qgr["forEach"]((qgv) => qgL["disposeIntermediateTensorInfo"](qgv)), qgd;
}
var q1G = { "kernelName": pZ, "backendName": "webgl", "kernelFunc": q1X };
var q1N = class {
  constructor(qgu, qgj, qgL) {
    this["variableNames"] = ["x"], this["customUniforms"] = [{ "name": "value", "type": "float" }], this["outputShape"] = qgj["map"]((qgQ, qgd) => qgQ[0] + qgu[qgd] + qgQ[1]);
    const qgI = qgu["length"], qgb = yU(qgI), qgR = qgj["map"]((qgQ) => qgQ[0])["join"](","), qgo = qgj["map"]((qgQ, qgd) => qgQ[0] + qgu[qgd])["join"](","), qgr = ["coords[0]", "coords[1]", "coords[2]", "coords[3]"]["slice"](0, qgI);
    if (qgI === 1) {
      this["userCode"] = "\n        int start = " + qgR + ";\n        int end = " + qgo + ";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ";
      return;
    }
    this["userCode"] = "\n      " + qgb + " start = " + qgb + "(" + qgR + ");\n      " + qgb + " end = " + qgb + "(" + qgo + ");\n\n      void main() {\n        " + qgb + " outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          " + qgb + " coords = outC - start;\n          setOutput(getX(" + qgr + "));\n        }\n      }\n    ";
  }
};
var q1u = class {
  constructor(qgu, qgj, qgL) {
    this["variableNames"] = ["x"], this["packedInputs"] = true, this["packedOutput"] = true, this["customUniforms"] = [{ "name": "value", "type": "float" }], this["outputShape"] = qgj["map"]((qgA, qgh) => qgA[0] + qgu[qgh] + qgA[1]);
    const qgI = qgu["length"], qgb = yU(qgI), qgR = qgj["map"]((qgA) => qgA[0])["join"](","), qgo = qgj["map"]((qgA, qgh) => qgA[0] + qgu[qgh])["join"](","), qgr = VX("rc", qgI), qgQ = VX("source", qgI), qgd = qgr[qgI - 1] + " < " + this["outputShape"][qgI - 1], qgv = qgI === 1 ? "source" : "vec2(" + qgQ["slice"](-2)["join"]() + ")", qgy = [qgb + " rc = outputLoc;", qgr[qgI - 1] + " += 1;\n       if(" + qgd + ") {\n      ", qgI === 1 ? "" : "}\n       rc = outputLoc;\n       " + qgr[qgI - 2] + " += 1;\n       if(" + qgr[qgI - 2] + " < " + this["outputShape"][qgI - 2] + ") {", qgI === 1 ? "" : "  " + qgr[qgI - 1] + " += 1;\n         if(" + qgd + ") {"], qgl = qgI === 1 ? "rc < start || rc >= end" : "any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";
    let qgH = "";
    for (let qgA = 0, qgh = qgI === 1 ? 2 : 4; qgA < qgh; qgA++) qgH += "\n        " + qgy[qgA] + "\n        if (" + qgl + ") {\n          result[" + qgA + "] = float(value);\n        } else {\n          " + qgb + " source = rc - start;\n          result[" + qgA + "] = getChannel(getX(" + qgQ["join"]() + "), " + qgv + ");\n        }\n      ";
    qgH += qgI === 1 ? "} " : "}}", this["userCode"] = "\n      const " + qgb + " start = " + qgb + "(" + qgR + ");\n      const " + qgb + " end = " + qgb + "(" + qgo + ");\n\n      void main() {\n        " + qgb + " outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        " + qgH + "\n        setOutput(result);\n      }\n    ";
  }
};
var q1j = (qgu) => {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { paddings: qgR, constantValue: qgo } = qgI;
  if (i2(qgb["shape"]) === 0) {
    const qgd = qgR["map"]((qgv, qgy) => qgv[0] + qgb["shape"][qgy] + qgv[1]);
    return q0N({ "backend": qgL, "attrs": { "shape": qgd, "value": qgo, "dtype": qgb["dtype"] } });
  }
  const qgr = qM()["getBool"]("WEBGL_PACK_ARRAY_OPERATIONS") ? new q1u(qgb["shape"], qgR, qgo) : new q1N(qgb["shape"], qgR, qgo), qgQ = [[qgo]];
  return qgL["runWebGLProgram"](qgr, [qgb], qgb["dtype"], qgQ);
};
var q1L = { "kernelName": pe, "backendName": "webgl", "kernelFunc": q1j };
var q1I = "\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n";
var q1b = "\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  " + YW + "\n  return result;\n";
var q1R = YK({ "opSnippet": q1I, "packedOpSnippet": q1b });
var q1o = { "kernelName": pz, "backendName": "webgl", "kernelFunc": q1R };
var q1r = (qgu) => {
  const { backend: qgj, attrs: qgL } = qgu, { start: qgI, stop: qgb, step: qgR, dtype: qgo } = qgL, qgr = BL(qgI, qgb, qgR, qgo);
  return qgj["makeTensorInfo"]([qgr["length"]], qgo, qgr);
};
var q1Q = { "kernelName": pG, "backendName": "webgl", "kernelFunc": q1r };
var q1d = "\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;";
var q1v = "\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n";
var q1y = YK({ "opSnippet": q1d, "packedOpSnippet": q1v, "checkOutOfBounds": true });
var q1C = { "kernelName": nW, "backendName": "webgl", "kernelFunc": q1y };
var q1l = VU + "\n  return (x < 0.0) ? 0.0 : x;\n";
var q1H = "\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var q1A = YH({ "opSnippet": q1l, "packedOpSnippet": q1H });
var q1h = { "kernelName": pj, "backendName": "webgl", "kernelFunc": q1A };
var q1T = VU + "\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n";
var q1K = "\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var q1B = YH({ "opSnippet": q1T, "packedOpSnippet": q1K });
var q1V = { "kernelName": pQ, "backendName": "webgl", "kernelFunc": q1B };
var q1J = class {
  constructor(qgu, qgj, qgL, qgI, qgb) {
    this["variableNames"] = ["A"], this["outputShape"] = [];
    const [qgR, qgo, qgr, qgQ] = qgu;
    this["outputShape"] = [qgR, qgj, qgL, qgQ];
    const qgd = [qgI && qgj > 1 ? qgo - 1 : qgo, qgI && qgL > 1 ? qgr - 1 : qgr], qgv = [qgI && qgj > 1 ? qgj - 1 : qgj, qgI && qgL > 1 ? qgL - 1 : qgL];
    let qgy;
    qgb ? qgy = "(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)" : qgy = "vec2(yRC) * effectiveInputOverOutputRatioRC", this["userCode"] = "\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          " + qgd[0] / qgv[0] + ",\n          " + qgd[1] / qgv[1] + ");\n      const vec2 inputShapeRC = vec2(" + qgo + ".0, " + qgr + ".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = " + qgy + ";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ";
  }
};
var q1Y = class {
  constructor(qgu, qgj, qgL, qgI, qgb) {
    this["variableNames"] = ["A"], this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = [];
    const [qgR, qgo, qgr, qgQ] = qgu;
    this["outputShape"] = [qgR, qgj, qgL, qgQ];
    const qgd = [qgI && qgj > 1 ? qgo - 1 : qgo, qgI && qgL > 1 ? qgr - 1 : qgr], qgv = [qgI && qgj > 1 ? qgj - 1 : qgj, qgI && qgL > 1 ? qgL - 1 : qgL];
    let qgy;
    qgb ? qgy = "(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)" : qgy = "vec3(yRC) * effectiveInputOverOutputRatioRC", this["userCode"] = "\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          " + qgd[0] / qgv[0] + ",\n          " + qgd[1] / qgv[1] + ",\n          " + qgd[1] / qgv[1] + ");\n      const vec3 inputShapeRC = vec3(" + qgo + ".0, " + qgr + ".0,\n                                     " + qgr + ".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = " + qgy + ";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < " + (qgQ - 1) + ";\n        bool hasNextRow = coords.z < " + (qgL - 1) + ";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ";
  }
};
function q1P(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { images: qgb } = qgj, { alignCorners: qgR, halfPixelCenters: qgo, size: qgr } = qgI, [qgQ, qgd] = qgr, qgv = qM()["getBool"]("WEBGL_PACK_IMAGE_OPERATIONS") ? new q1Y(qgb["shape"], qgQ, qgd, qgR, qgo) : new q1J(qgb["shape"], qgQ, qgd, qgR, qgo);
  return qgL["runWebGLProgram"](qgv, [qgb], "float32");
}
var q1U = { "kernelName": pr, "backendName": "webgl", "kernelFunc": q1P };
var q20 = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["Image"], this["outputShape"] = [], this["customUniforms"] = [{ "name": "params", "type": "vec4" }];
    const qgL = qgu[1], qgI = qgu[2];
    this["outputShape"] = qgu;
    let qgb = "";
    typeof qgj == "number" ? qgb = "float outputValue = " + qgj["toFixed"](2) + ";" : qgb = "\n        vec3 fill = vec3(" + qgj["join"](",") + ");\n        float outputValue = fill[coords[3]];", this["userCode"] = "\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          " + qgb + "\n          if(coordX >= 0 && coordX < " + qgI + " && coordY >= 0 && coordY < " + qgL + ") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ";
  }
};
var q21 = { "kernelName": gX, "backendName": "webgl", "kernelFunc": ({ inputs: qgu, attrs: qgj, backend: qgL }) => {
  const { image: qgI } = qgu, { radians: qgb, fillValue: qgR, center: qgo } = qgj, qgr = qgL, qgQ = new q20(qgI["shape"], qgR), [qgd, qgv] = GR(qgo, qgI["shape"][1], qgI["shape"][2]), qgy = [[qgd, qgv, Math["sin"](qgb), Math["cos"](qgb)]];
  return qgr["runWebGLProgram"](qgQ, [qgI], qgI["dtype"], qgy);
} };
var q22 = YQ + "\n  return 1.0 / (1.0 + exp(-1.0 * x));\n";
var q23 = "\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n";
var q24 = YH({ "opSnippet": q22, "packedOpSnippet": q23, "cpuKernelImpl": BH });
var q25 = { "kernelName": pY, "backendName": "webgl", "kernelFunc": q24 };
var q26 = YQ + "\n  return sin(x);\n";
var q27 = "\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  " + YW + "\n  return result;\n";
var q28 = YH({ "opSnippet": q26, "packedOpSnippet": q27 });
var q29 = { "kernelName": pJ, "backendName": "webgl", "kernelFunc": q28 };
var q2q = class {
  constructor(qgu) {
    this["variableNames"] = ["source"], this["outputShape"] = qgu, this["rank"] = qgu["length"];
    const qgj = yU(this["rank"]);
    this["customUniforms"] = [{ "name": "start", "arrayIndex": this["rank"], "type": "int" }];
    const qgL = q2p(this["rank"]);
    let qgI;
    const qgb = qgu["map"]((qgR, qgo) => "sourceLoc." + q2n[qgo] + " = start[" + qgo + "] + coords." + q2n[qgo] + ";");
    qgI = "\n        " + qgj + " sourceLoc;\n        " + qgj + " coords = getOutputCoords();\n        " + qgb["join"]("\n") + "\n      ", this["userCode"] = "\n      void main() {\n        " + qgI + "\n        setOutput(getSource(" + qgL + "));\n      }\n    ";
  }
};
var q2n = ["x", "y", "z", "w", "u", "v"];
function q2p(qgu) {
  if (qgu === 1) return "sourceLoc";
  if (qgu <= 6) return q2n["slice"](0, qgu)["map"]((qgj) => "sourceLoc." + qgj)["join"](",");
  throw Error("Slicing for rank " + qgu + " is not yet supported");
}
var q2g = class {
  constructor(qgu) {
    this["variableNames"] = ["source"], this["packedInputs"] = true, this["packedOutput"] = true, this["outputShape"] = qgu, this["rank"] = qgu["length"], this["customUniforms"] = [{ "name": "start", "arrayIndex": this["rank"], "type": "int" }];
    const qgj = yU(this["rank"]), qgL = VX("coords", this["rank"]), qgI = VX("sourceLoc", this["rank"]), qgb = this["rank"] === 1 ? "sourceLoc" : "vec2(" + qgI["slice"](-2)["join"]() + ")", qgR = "getChannel(getSource(" + qgI["join"]() + "), " + qgb + ")", qgo = "\n      result.x = " + qgR + ";\n      if (++" + qgL[this["rank"] - 1] + " < " + qgu[this["rank"] - 1] + ") {\n        ++" + qgI[this["rank"] - 1] + ";\n        result.y = " + qgR + ";\n        --" + qgI[this["rank"] - 1] + ";\n      }\n    ", qgr = this["rank"] === 1 ? "" : "\n      --" + qgL[this["rank"] - 1] + ";\n      if (++" + qgL[this["rank"] - 2] + " < " + qgu[this["rank"] - 2] + ") {\n        ++" + qgI[this["rank"] - 2] + ";\n        result.z = " + qgR + ";\n        if (++" + qgL[this["rank"] - 1] + " < " + qgu[this["rank"] - 1] + ") {\n          ++" + qgI[this["rank"] - 1] + ";\n          result.w = " + qgR + ";\n        }\n      }\n    ", qgQ = this["rank"] <= 4 ? "sourceLoc = coords +\n            " + qgj + "(" + qgu["map"]((qgd, qgv) => "start[" + qgv + "]")["join"]() + ");" : qgu["map"]((qgd, qgv) => qgI[qgv] + " = " + qgL[qgv] + " + start[" + qgv + "];")["join"]("\n");
    this["userCode"] = "\n      void main() {\n        " + qgj + " coords = getOutputCoords();\n        " + qgj + " sourceLoc;\n        " + qgQ + "\n        vec4 result = vec4(0.);\n        " + qgo + "\n        " + qgr + "\n        setOutput(result);\n      }\n    ";
  }
};
function q2x(qgu, qgj, qgL, qgI) {
  const qgb = qgI["texData"]["get"](qgu["dataId"]), qgR = qgI["makeTensorInfo"](qgL, qgu["dtype"]), qgo = qgI["texData"]["get"](qgR["dataId"]);
  Object["assign"](qgo, qgb), qgo["refCount"] = 1, qgo["shape"] = qgL, qgo["dtype"] = qgu["dtype"];
  let qgr = WR(qgj, y(qgu["shape"]));
  qgb["slice"] && (qgr += qgb["slice"]["flatOffset"]), qgo["slice"] = { "flatOffset": qgr, "origDataId": qgb["slice"] && qgb["slice"]["origDataId"] || qgu["dataId"] };
  const qgQ = qgI["dataRefCount"]["get"](qgo["slice"]["origDataId"]) || 1;
  return qgI["dataRefCount"]["set"](qgo["slice"]["origDataId"], qgQ + 1), qgR;
}
function q2s(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { begin: qgR, size: qgo } = qgI, [qgr, qgQ] = WQ(qgb, qgR, qgo);
  if (Wq(qgb, qgr, qgQ), i2(qgQ) === 0) return qgL["makeTensorInfo"](qgQ, qgb["dtype"], []);
  if (qgL["shouldExecuteOnCPU"]([qgb]) || qgb["dtype"] === "string") {
    const qgy = qgL["texData"]["get"](qgb["dataId"]), qgl = BB(qgy["values"], qgr, qgQ, qgb["shape"], qgb["dtype"]);
    return qgL["makeTensorInfo"](qgQ, qgb["dtype"], qgl);
  }
  const { isPacked: qgd } = qgL["texData"]["get"](qgb["dataId"]), qgv = WL(qgb["shape"], qgr, qgQ);
  if (qgd || !qgv) {
    const qgH = qM()["getBool"]("WEBGL_PACK_ARRAY_OPERATIONS") ? new q2g(qgQ) : new q2q(qgQ), qgA = [qgr];
    return qgL["runWebGLProgram"](qgH, [qgb], qgb["dtype"], qgA);
  }
  return qgL["uploadToGPU"](qgb["dataId"]), q2x(qgb, qgr, qgQ, qgL);
}
var q2E = { "kernelName": pV, "backendName": "webgl", "kernelFunc": q2s };
var q2M = "return sqrt(x);";
var q2f = YH({ "opSnippet": q2M, "packedOpSnippet": q2M, "cpuKernelImpl": BP });
var q2S = { "kernelName": pP, "backendName": "webgl", "kernelFunc": q2f };
var q2F = "return x * x;";
var q2t = YH({ "opSnippet": q2F });
var q2k = { "kernelName": gn, "backendName": "webgl", "kernelFunc": q2t };
var q2O = class {
  constructor(qgu, qgj, qgL) {
    this["variableNames"] = ["x"], this["outputShape"] = qgL;
    const qgI = qgL["length"], qgb = yU(qgL["length"]), qgR = yU(qgL["length"]);
    let qgo = "";
    if (qgI === 1) qgo = "coords * strides + begin";
    else {
      let qgr = 0;
      qgo = qgL["map"]((qgQ, qgd) => (qgr++, qgL["length"] === 1 ? "coords * strides[" + qgd + "] + begin[" + qgd + "]" : "coords[" + (qgr - 1) + "] * strides[" + qgd + "] + begin[" + qgd + "]"))["join"](",");
    }
    this["userCode"] = "\n      " + qgb + " begin = " + qgb + "(" + qgu + ");\n      " + qgb + " strides = " + qgb + "(" + qgj + ");\n\n      void main() {\n        " + qgR + " coords = getOutputCoords();\n        setOutput(getX(" + qgo + "));\n      }\n    ";
  }
};
function q2W(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { begin: qgR, end: qgo, strides: qgr, beginMask: qgQ, endMask: qgd, ellipsisMask: qgv, newAxisMask: qgy, shrinkAxisMask: qgl } = qgI, { finalShapeSparse: qgH, finalShape: qgA, isIdentity: qgh, sliceDim0: qgT, isSimpleSlice: qgK, begin: qgB, end: qgV, strides: qgJ } = WH(qgb["shape"], qgR, qgo, qgr, qgQ, qgd, qgv, qgy, qgl);
  let qgY;
  if (qgh) qgY = PB({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "shape": qgA } });
  else {
    if (qgT || qgK) {
      k(qgb["shape"]["length"] >= 1, () => "Input must have rank at least 1, got: " + qgb["shape"]["length"]);
      const qgU = WF(qgB, qgV, qgJ), qx0 = q2s({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "begin": qgB, "size": qgU } });
      qgY = PB({ "inputs": { "x": qx0 }, "backend": qgL, "attrs": { "shape": qgA } }), qgL["disposeIntermediateTensorInfo"](qx0);
    } else {
      if (qgL["shouldExecuteOnCPU"]([qgb])) {
        const qx1 = qgL["readSync"](qgb["dataId"]), qx2 = DY(qgb["shape"], qgb["dtype"], qx1), qx3 = Vq(qgH, qx2, qgJ, qgB);
        qgY = qgL["makeTensorInfo"](qgA, qgb["dtype"], qx3["values"]);
      } else {
        const qx4 = new q2O(qgB, qgJ, qgH);
        qgY = qgL["runWebGLProgram"](qx4, [qgb], qgb["dtype"]);
      }
    }
  }
  const qgP = PB({ "inputs": { "x": qgY }, "backend": qgL, "attrs": { "shape": qgA } });
  return qgL["disposeIntermediateTensorInfo"](qgY), qgP;
}
var q2i = { "kernelName": gs, "backendName": "webgl", "kernelFunc": q2W };
var q2D = "return a - b;";
var q2m = YK({ "opSnippet": q2D, "packedOpSnippet": q2D, "supportsComplex": true, "cpuKernelImpl": VF });
var q2a = { "kernelName": gM, "backendName": "webgl", "kernelFunc": q2m };
var q2Z = class {
  constructor(qgu, qgj) {
    this["variableNames"] = ["A"];
    const qgL = new Array(qgu["length"]);
    for (let qgR = 0; qgR < qgL["length"]; qgR++) qgL[qgR] = qgu[qgR] * qgj[qgR];
    this["outputShape"] = qgL, this["rank"] = qgL["length"];
    const qgI = yU(this["rank"]), qgb = q2w(qgu);
    this["userCode"] = "\n      void main() {\n        " + qgI + " resRC = getOutputCoords();\n        setOutput(getA(" + qgb + "));\n      }\n    ";
  }
};
function q2w(qgu) {
  const qgj = qgu["length"];
  if (qgj > 5) throw Error("Tile for rank " + qgj + " is not yet supported");
  if (qgj === 1) return "imod(resRC, " + qgu[0] + ")";
  const qgL = ["resRC.x", "resRC.y", "resRC.z", "resRC.w", "resRC.u"], qgI = [];
  for (let qgb = 0; qgb < qgu["length"]; qgb++) qgI["push"]("imod(" + qgL[qgb] + ", " + qgu[qgb] + ")");
  return qgI["join"]();
}
function q2e(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { reps: qgR } = qgI;
  if (qgb["dtype"] === "string" || qgb["shape"]["length"] > 5) {
    const qgr = qgL["readSync"](qgb["dataId"]), qgQ = qgb["dtype"] === "string" ? qgr["map"]((qgy) => EW(qgy)) : qgr, qgd = DY(qgb["shape"], qgb["dtype"], qgQ), qgv = VW(qgd, qgR);
    return qgL["makeTensorInfo"](qgv["shape"], qgv["dtype"], qgv["values"]);
  }
  const qgo = new q2Z(qgb["shape"], qgR);
  return qgL["runWebGLProgram"](qgo, [qgb], qgb["dtype"]);
}
var q2z = { "kernelName": gF, "backendName": "webgl", "kernelFunc": q2e };
var q2c = class {
  constructor(qgu, qgj, qgL, qgI, qgb, qgR) {
    this["variableNames"] = ["Image", "Transforms"], this["outputShape"] = qgR;
    const qgo = qgL === "nearest" ? 1 : 2;
    let qgr;
    switch (qgI) {
      case "constant":
        qgr = 1;
        break;
      case "reflect":
        qgr = 2;
        break;
      case "wrap":
        qgr = 3;
        break;
      case "nearest":
        qgr = 4;
        break;
      default:
        qgr = 1;
        break;
    }
    this["userCode"] = "\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(" + qgr + " == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (" + qgr + " == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (" + qgr + " == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < " + qgu + " && 0 <= coordX && coordX < " + qgj + ") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(" + qgb + ");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(" + qgb + ");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(" + qgj + "));\n                float mapY = mapCoord(inY, float(" + qgu + "));\n\n                if (" + qgo + " == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ";
  }
};
function q2X(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { image: qgb, transforms: qgR } = qgj, { interpolation: qgo, fillMode: qgr, fillValue: qgQ, outputShape: qgd } = qgI, [qgv, qgy, qgl, qgH] = qgb["shape"], [qgA, qgh] = qgd != null ? qgd : [qgy, qgl], qgT = [qgv, qgA, qgh, qgH], qgK = new q2c(qgy, qgl, qgo, qgr, qgQ, qgT);
  return qgL["runWebGLProgram"](qgK, [qgb, qgR], "float32");
}
var q2G = { "kernelName": gW, "backendName": "webgl", "kernelFunc": q2X };
function q2N(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  if (qgI["dtype"] === "complex64") {
    const qgb = UR({ "inputs": { "input": qgI }, "backend": qgL }), qgR = q2N({ "inputs": { "x": qgb }, "backend": qgL }), qgo = q02({ "inputs": { "input": qgI }, "backend": qgL }), qgr = q2N({ "inputs": { "x": qgo }, "backend": qgL }), qgQ = Yz({ "inputs": { "real": qgR, "imag": qgr }, "backend": qgL });
    return qgL["disposeIntermediateTensorInfo"](qgb), qgL["disposeIntermediateTensorInfo"](qgR), qgL["disposeIntermediateTensorInfo"](qgo), qgL["disposeIntermediateTensorInfo"](qgr), qgQ;
  } else return q0N({ "attrs": { "shape": qgI["shape"], "dtype": qgI["dtype"], "value": qgI["dtype"] === "string" ? "" : 0 }, "backend": qgL });
}
var q2u = { "kernelName": gZ, "backendName": "webgl", "kernelFunc": q2N };
function q2j(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { a: qgb, b: qgR, bias: qgo, preluActivationWeights: qgr } = qgj, { transposeA: qgQ, transposeB: qgd, activation: qgv, leakyreluAlpha: qgy } = qgI;
  return Uz({ "a": qgb, "b": qgR, "transposeA": qgQ, "transposeB": qgd, "backend": qgL, "bias": qgo, "preluActivationWeights": qgr, "leakyreluAlpha": qgy, "activation": qgv });
}
var q2L = { "kernelName": gG, "backendName": "webgl", "kernelFunc": q2j };
var q2I = zR;
var q2b = class _q2b extends x2 {
  ["nextDataId"]() {
    return _q2b["nextDataId"]++;
  }
  constructor() {
    super(), this["blockSize"] = 48, this["firstUse"] = true, this["data"] = new g(this, fU());
  }
  ["write"](qgu, qgj, qgL) {
    this["firstUse"] && (this["firstUse"] = false, qM()["get"]("IS_NODE") && gL("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));
    const qgI = { "id": this["nextDataId"]() };
    return this["data"]["set"](qgI, { "values": qgu, "dtype": qgL, "refCount": 1 }), qgI;
  }
  ["makeTensorInfo"](qgu, qgj, qgL) {
    let qgI;
    if (qgj === "string" && qgL != null && qgL["length"] > 0 && R(qgL[0])) {
      const qgb = qgL["map"]((qgR) => Et(qgR));
      qgI = this["write"](qgb, qgu, qgj);
    } else qgI = this["write"](qgL, qgu, qgj);
    return { "dataId": qgI, "shape": qgu, "dtype": qgj };
  }
  ["refCount"](qgu) {
    return this["data"]["has"](qgu) ? this["data"]["get"](qgu)["refCount"] : 0;
  }
  ["incRef"](qgu) {
    const qgj = this["data"]["get"](qgu);
    qgj["refCount"]++;
  }
  ["decRef"](qgu) {
    if (this["data"]["has"](qgu)) {
      const qgj = this["data"]["get"](qgu);
      qgj["refCount"]--;
    }
  }
  ["move"](qgu, qgj, qgL, qgI, qgb) {
    this["data"]["set"](qgu, { "values": qgj, "dtype": qgI, "refCount": qgb });
  }
  ["numDataIds"]() {
    return this["data"]["numDataIds"]();
  }
  async ["read"](qgu) {
    return this["readSync"](qgu);
  }
  ["readSync"](qgu) {
    const { dtype: qgj, complexTensorInfos: qgL } = this["data"]["get"](qgu);
    if (qgj === "complex64") {
      const qgI = this["readSync"](qgL["real"]["dataId"]), qgb = this["readSync"](qgL["imag"]["dataId"]);
      return Nt(qgI, qgb);
    }
    return A(this["data"]["get"](qgu)["values"], qgj);
  }
  ["bufferSync"](qgu) {
    const qgj = this["readSync"](qgu["dataId"]);
    if (qgu["dtype"] === "string") try {
      const qgL = qgj["map"]((qgI) => EW(qgI));
      return DY(qgu["shape"], qgu["dtype"], qgL);
    } catch (qgI) {
      throw new Error("Failed to decode encoded string bytes into utf-8");
    }
    return DY(qgu["shape"], qgu["dtype"], qgj);
  }
  ["makeOutput"](qgu, qgj, qgL) {
    return fU()["makeTensorFromTensorInfo"](this["makeTensorInfo"](qgj, qgL, qgu), this);
  }
  ["disposeData"](qgu, qgj = false) {
    if (this["data"]["has"](qgu)) {
      if (this["data"]["get"](qgu)["refCount"]--, !qgj && this["data"]["get"](qgu)["refCount"] > 0) return false;
      const { complexTensorInfos: qgL } = this["data"]["get"](qgu);
      qgL != null && (this["disposeData"](qgL["real"]["dataId"], true), this["disposeData"](qgL["imag"]["dataId"], true)), this["data"]["delete"](qgu);
    }
    return true;
  }
  ["disposeIntermediateTensorInfo"](qgu) {
    this["disposeData"](qgu["dataId"]);
  }
  async ["time"](qgu) {
    const qgj = EF();
    return qgu(), { "kernelMs": EF() - qgj };
  }
  ["memory"]() {
    return { "unreliable": true, "reasons": ["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."] };
  }
  ["where"](qgu) {
    lK([qgu], "where");
    const qgj = this["readSync"](qgu["dataId"]);
    return q2I(qgu["shape"], qgj);
  }
  ["dispose"]() {
  }
  ["floatPrecision"]() {
    return 32;
  }
  ["epsilon"]() {
    return super["epsilon"]();
  }
};
q2b["nextDataId"] = 0, SW("cpu", () => new q2b(), 1);
function q2R(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, qgI = qgj;
  lK(qgj, "addN");
  const qgb = qgI["map"]((qgr) => qgL["data"]["get"](qgr["dataId"])["values"]), qgR = DY(qgI[0]["shape"], qgI[0]["dtype"]), qgo = qgR["values"];
  for (let qgr = 0; qgr < qgI["length"]; qgr++) {
    const qgQ = qgb[qgr];
    for (let qgd = 0; qgd < qgo["length"]; qgd++) qgo[qgd] += qgQ[qgd];
  }
  return qgL["makeTensorInfo"](qgR["shape"], qgR["dtype"], qgR["values"]);
}
var q2o = { "kernelName": qj, "backendName": "cpu", "kernelFunc": q2R };
var q2r = lY((qgu, qgj) => Math["atan2"](qgu, qgj));
var q2Q = HZ(qL, q2r);
var q2d = { "kernelName": qL, "backendName": "cpu", "kernelFunc": q2Q };
function q2v(qgu, qgj, qgL, qgI, qgb, qgR) {
  const qgo = qgb["strideHeight"], qgr = qgb["strideWidth"], qgQ = qgb["dilationHeight"], qgd = qgb["dilationWidth"], qgv = qgb["effectiveFilterHeight"], qgy = qgb["effectiveFilterWidth"], qgl = qgb["padInfo"]["top"], qgH = qgb["padInfo"]["left"], qgA = qgR === "max" ? Number["NEGATIVE_INFINITY"] : Number["POSITIVE_INFINITY"], qgh = DY(qgb["outShape"], qgL), qgT = qgh["values"], qgK = qgb["outShape"][1] * qgb["outShape"][2] * qgb["outShape"][3], qgB = qgb["outShape"][2] * qgb["outShape"][3], qgV = qgb["outShape"][3];
  for (let qgJ = 0; qgJ < qgb["batchSize"]; ++qgJ) {
    const qgY = qgJ * qgK, qgP = qgJ * qgI[0];
    for (let qgU = 0; qgU < qgb["inChannels"]; ++qgU) for (let qx0 = 0; qx0 < qgb["outHeight"]; ++qx0) {
      const qx1 = qx0 * qgo - qgl, qx2 = Math["max"](0, qx1), qx3 = Math["min"](qgb["inHeight"], qgv + qx1), qx4 = qgY + qx0 * qgB;
      for (let qx5 = 0; qx5 < qgb["outWidth"]; ++qx5) {
        const qx6 = qx5 * qgr - qgH, qx7 = Math["max"](0, qx6), qx8 = Math["min"](qgb["inWidth"], qgy + qx6);
        let qx9 = qgA, qxq = 0, qxn = 0;
        for (let qxs = qx2; qxs < qx3; qxs += qgQ) {
          const qxE = qgP + qxs * qgI[1];
          for (let qxM = qx7; qxM < qx8; qxM += qgd) {
            const qxf = qxE + qxM * qgI[2], qxS = qgu[qxf + qgU];
            qgR === "max" && qxS > qx9 ? qx9 = qxS : qgR === "avg" && (qxq += qxS, qxn++);
          }
          if (isNaN(qx9)) break;
        }
        const qxp = qx4 + qx5 * qgV + qgU;
        qgT[qxp] = qgR === "avg" ? qxq / qxn : qx9;
      }
    }
  }
  return qgh;
}
function q2y(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj;
  lK(qgb, "avgPool");
  const { filterSize: qgR, strides: qgo, pad: qgr, dimRoundingMode: qgQ } = qgI, qgd = 1;
  k(iU(qgo, qgd), () => "Error in avgPool: Either strides or dilations must be 1. Got strides " + qgo + " and dilations '" + qgd + "'");
  const qgv = iG(qgb["shape"], qgR, qgo, qgd, qgr, qgQ);
  let qgy;
  if (qgv["filterWidth"] === 1 && qgv["filterHeight"] === 1 && D(qgv["inShape"], qgv["outShape"])) qgy = H6({ "inputs": { "x": qgb }, "backend": qgL });
  else {
    const qgl = qgL["data"]["get"](qgb["dataId"])["values"], qgH = y(qgb["shape"]), qgA = q2v(qgl, qgb["shape"], qgb["dtype"], qgH, qgv, "avg");
    qgy = qgL["makeTensorInfo"](qgv["outShape"], qgb["dtype"], qgA["values"]);
  }
  return qgy;
}
var q2C = { "kernelName": qR, "backendName": "cpu", "kernelFunc": q2y };
function q2l(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { shape: qgR } = qgI, qgo = i2(qgb["shape"]), qgr = e(qgR, qgo), qgQ = i2(qgr);
  k(qgo === qgQ, () => "The new shape (" + qgr + ") has " + qgQ + " elements and the old shape (" + qgb["shape"] + ") has " + qgo + " elements. The new shape and old shape must have the same number of elements."), qgL["incRef"](qgb["dataId"]);
  const qgd = qgL["data"]["get"](qgb["dataId"]);
  if (qgd["complexTensorInfos"] != null) {
    const qgv = qgd["complexTensorInfos"]["real"], qgy = qgd["complexTensorInfos"]["imag"];
    qgv["shape"] = qgr, qgy["shape"] = qgr;
  }
  return { "dataId": qgb["dataId"], "shape": qgr, "dtype": qgb["dtype"] };
}
var q2H = { "kernelName": pL, "backendName": "cpu", "kernelFunc": q2l };
function q2A(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { a: qgb, b: qgR } = qgj, { transposeA: qgo, transposeB: qgr } = qgI;
  lK([qgb, qgR], "matMul");
  const qgQ = qgb["shape"]["length"], qgd = qgR["shape"]["length"], qgv = qgo ? qgb["shape"][qgQ - 2] : qgb["shape"][qgQ - 1], qgy = qgr ? qgR["shape"][qgd - 1] : qgR["shape"][qgd - 2], qgl = qgo ? qgb["shape"][qgQ - 1] : qgb["shape"][qgQ - 2], qgH = qgr ? qgR["shape"][qgd - 2] : qgR["shape"][qgd - 1], qgA = qgb["shape"]["slice"](0, -2), qgh = qgR["shape"]["slice"](0, -2), qgT = i2(qgA), qgK = i2(qgh), qgB = OR(qgb["shape"]["slice"](0, -2), qgR["shape"]["slice"](0, -2))["concat"]([qgl, qgH]);
  k(qgv === qgy, () => "Error in matMul: inner shapes (" + qgv + ") and (" + qgy + ") of Tensors with shapes " + qgb["shape"] + " and " + qgR["shape"] + " and transposeA=" + qgo + " and transposeB=" + qgr + " must match.");
  const qgV = qgo ? [qgT, qgv, qgl] : [qgT, qgl, qgv], qgJ = qgr ? [qgK, qgH, qgy] : [qgK, qgy, qgH], qgY = q2l({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "shape": qgV } }), qgP = q2l({ "inputs": { "x": qgR }, "backend": qgL, "attrs": { "shape": qgJ } }), qgU = qgo ? qgY["shape"][1] : qgY["shape"][2], qx0 = qgo ? qgY["shape"][2] : qgY["shape"][1], qx1 = qgr ? qgP["shape"][1] : qgP["shape"][2], qx2 = Math["max"](qgT, qgK), qx3 = qgL["data"]["get"](qgY["dataId"])["values"], qx4 = qgL["data"]["get"](qgP["dataId"])["values"], qx5 = y(qgY["shape"]), qx6 = y(qgP["shape"]), [qx7, qx8, qx9] = qgo ? [qx5[0], 1, qx5[1]] : [qx5[0], qx5[1], 1], [qxq, qxn, qxp] = qgr ? [1, qx6[1], qx6[0]] : [qx6[1], 1, qx6[0]], qxs = qx0 * qx1, qxE = DY([qx2, qx0, qx1], qgY["dtype"]), qxM = qxE["values"], qxf = qgL["blockSize"];
  for (let qxS = 0; qxS < qx2; qxS++) {
    const qxF = qxS % qgT, qxt = qxS % qgK;
    for (let qxk = 0; qxk < qx0; qxk += qxf) {
      const qxO = Math["min"](qxk + qxf, qx0);
      for (let qxW = 0; qxW < qx1; qxW += qxf) {
        const qxi = Math["min"](qxW + qxf, qx1);
        for (let qxD = 0; qxD < qgU; qxD += qxf) {
          const qxm = Math["min"](qxD + qxf, qgU);
          for (let qxa = qxk; qxa < qxO; qxa++) for (let qxZ = qxW; qxZ < qxi; qxZ++) {
            let qxw = 0;
            for (let qxe = qxD; qxe < qxm; qxe++) {
              const qxz = qx3[qxF * qx7 + qxa * qx8 + qxe * qx9], qxc = qx4[qxe * qxq + qxZ * qxn + qxt * qxp];
              qxw += qxz * qxc;
            }
            qxM[qxS * qxs + (qxa * qx1 + qxZ)] += qxw;
          }
        }
      }
    }
  }
  return qgL["disposeIntermediateTensorInfo"](qgY), qgL["disposeIntermediateTensorInfo"](qgP), qgL["makeTensorInfo"](qgB, qxE["dtype"], qxE["values"]);
}
var q2h = { "kernelName": qo, "backendName": "cpu", "kernelFunc": q2A };
var q2T = HK(qK, (qgu, qgj) => {
  const qgL = qgj;
  return qgu > qgL["clipValueMax"] ? qgL["clipValueMax"] : qgu < qgL["clipValueMin"] ? qgL["clipValueMin"] : qgu;
});
var q2K = { "kernelName": qK, "backendName": "cpu", "kernelFunc": q2T };
function q2B(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { input: qgI } = qgj, qgb = qgL["data"]["get"](qgI["dataId"])["complexTensorInfos"]["imag"], qgR = qgL["data"]["get"](qgb["dataId"])["values"];
  return qgL["makeTensorInfo"](qgb["shape"], qgb["dtype"], qgR);
}
function q2V(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { axis: qgb } = qgI, qgR = z(qgb, qgj[0]["shape"])[0], qgo = qgj["map"]((qgh) => qgh["shape"]);
  GW(qgo, qgR);
  let qgr = GD(qgj["map"]((qgh) => qgh["shape"]), qgR);
  if (i2(qgr) === 0) return qgL["makeTensorInfo"](qgr, qgj[0]["dtype"], []);
  const qgQ = qgj["filter"]((qgh) => i2(qgh["shape"]) > 0);
  if (qgQ["length"] === 1) return H6({ "inputs": { "x": qgQ[0] }, "backend": qgL });
  if (qgQ[0]["dtype"] === "complex64") {
    const qgh = qgQ["map"]((qgJ) => HM({ "inputs": { "input": qgJ }, "backend": qgL })), qgT = qgQ["map"]((qgJ) => q2B({ "inputs": { "input": qgJ }, "backend": qgL })), qgK = q2V({ "inputs": qgh, "backend": qgL, "attrs": { "axis": qgR } }), qgB = q2V({ "inputs": qgT, "backend": qgL, "attrs": { "axis": qgR } }), qgV = lP({ "inputs": { "real": qgK, "imag": qgB }, "backend": qgL });
    return qgh["forEach"]((qgJ) => qgL["disposeIntermediateTensorInfo"](qgJ)), qgT["forEach"]((qgJ) => qgL["disposeIntermediateTensorInfo"](qgJ)), qgL["disposeIntermediateTensorInfo"](qgK), qgL["disposeIntermediateTensorInfo"](qgB), qgV;
  }
  const qgd = qgQ["map"]((qgJ) => {
    const qgY = [-1, i2(qgJ["shape"]["slice"](qgR))];
    return q2l({ "inputs": { "x": qgJ }, "backend": qgL, "attrs": { "shape": qgY } });
  }), qgv = qgd["map"]((qgJ) => ({ "vals": qgL["data"]["get"](qgJ["dataId"])["values"], "shape": qgJ["shape"] }));
  qgr = GD(qgd["map"]((qgJ) => qgJ["shape"]), 1);
  const qgy = qgd[0]["shape"][0] === 1, qgl = HJ(qgv, qgr, qgj[0]["dtype"], qgy), qgH = GD(qgQ["map"]((qgJ) => qgJ["shape"]), qgR), qgA = qgL["makeTensorInfo"](qgH, qgj[0]["dtype"], qgl);
  return qgd["forEach"]((qgJ) => qgL["disposeIntermediateTensorInfo"](qgJ)), qgA;
}
var q2J = { "kernelName": qJ, "backendName": "cpu", "kernelFunc": q2V };
function q2Y(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR } = qgj, { strides: qgo, pad: qgr, dataFormat: qgQ, dilations: qgd, dimRoundingMode: qgv } = qgI;
  lK([qgb, qgR], "conv2d");
  const qgy = Ds(qgQ), qgl = ij(qgb["shape"], qgR["shape"], qgo, qgd, qgr, qgv, false, qgy), qgH = qgl["filterHeight"], qgA = qgl["filterWidth"], qgh = qgl["dilationHeight"], qgT = qgl["dilationWidth"], qgK = qgl["padInfo"]["left"], qgB = qgl["padInfo"]["top"], qgV = qgl["dataFormat"] === "channelsLast", qgJ = new EU(qgl["outShape"], qgb["dtype"]), qgY = y(qgb["shape"]), qgP = y(qgR["shape"]), qgU = qgY[0], qx0 = qgV ? qgY[1] : qgY[2], qx1 = qgV ? qgY[2] : 1, qx2 = qgV ? 1 : qgY[1], qx3 = qgJ["strides"][0], qx4 = qgV ? qgJ["strides"][1] : qgJ["strides"][2], qx5 = qgV ? qgJ["strides"][2] : 1, qx6 = qgV ? 1 : qgJ["strides"][1], qx7 = qgL["data"]["get"](qgb["dataId"])["values"], qx8 = qgL["data"]["get"](qgR["dataId"])["values"], qx9 = qgJ["values"];
  for (let qxq = 0; qxq < qgl["batchSize"]; ++qxq) {
    const qxn = qxq * qgU, qxp = qxq * qx3;
    for (let qxs = 0; qxs < qgl["outHeight"]; ++qxs) {
      const qxE = qxp + qxs * qx4, qxM = qxs * qgl["strideHeight"] - qgB;
      for (let qxf = 0; qxf < qgH; ++qxf) {
        const qxS = qxM + qxf * qgh;
        if (qxS < 0 || qxS >= qgl["inHeight"]) continue;
        const qxF = qxf * qgP[0], qxt = qxn + qxS * qx0;
        for (let qxk = 0; qxk < qgl["outWidth"]; ++qxk) {
          const qxO = qxE + qxk * qx5, qxW = qxk * qgl["strideWidth"] - qgK;
          for (let qxi = 0; qxi < qgA; ++qxi) {
            const qxD = qxW + qxi * qgT;
            if (qxD < 0 || qxD >= qgl["inWidth"]) continue;
            const qxm = qxF + qxi * qgP[1], qxa = qxt + qxD * qx1;
            let qxZ = qxm;
            for (let qxw = 0; qxw < qgl["inChannels"]; ++qxw) {
              const qxe = qx7[qxa + qxw * qx2];
              for (let qxz = 0; qxz < qgl["outChannels"]; ++qxz) qx9[qxO + qxz * qx6] += qxe * qx8[qxZ + qxz];
              qxZ += qgl["outChannels"];
            }
          }
        }
      }
    }
  }
  return qgL["makeTensorInfo"](qgJ["shape"], qgJ["dtype"], qx9);
}
var q2P = { "kernelName": qY, "backendName": "cpu", "kernelFunc": q2Y };
function q2U(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { dy: qgb, filter: qgR } = qgj, { inputShape: qgo, strides: qgr, pad: qgQ, dataFormat: qgd, dimRoundingMode: qgv } = qgI;
  lK([qgb, qgR], "conv2dBackpropInput");
  const qgy = y(qgR["shape"]), qgl = y(qgb["shape"]);
  let qgH = Ds(qgd);
  const qgA = ij(qgo, qgR["shape"], qgr, 1, qgQ, qgv, false, qgH), qgh = new EU(qgA["inShape"], "float32"), qgT = qgh["values"], qgK = qgL["data"]["get"](qgb["dataId"])["values"], qgB = qgL["data"]["get"](qgR["dataId"])["values"], [qgV, qgJ, qgY] = qgy, { batchSize: qgP, filterHeight: qgU, filterWidth: qx0, inChannels: qx1, inHeight: qx2, inWidth: qx3, outChannels: qx4, outHeight: qx5, outWidth: qx6, strideHeight: qx7, strideWidth: qx8 } = qgA;
  qgH = qgA["dataFormat"];
  const qx9 = qgU - 1 - qgA["padInfo"]["top"], qxq = qx0 - 1 - qgA["padInfo"]["left"], qxn = qgH === "channelsLast", qxp = qgh["strides"][0], qxs = qxn ? qgh["strides"][1] : qgh["strides"][2], qxE = qxn ? qgh["strides"][2] : 1, qxM = qxn ? 1 : qgh["strides"][1], qxf = qgl[0], qxS = qxn ? qgl[1] : qgl[2], qxF = qxn ? qgl[2] : 1, qxt = qxn ? 1 : qgl[1];
  for (let qxk = 0; qxk < qgP; ++qxk) for (let qxO = 0; qxO < qx1; ++qxO) for (let qxW = 0; qxW < qx2; ++qxW) {
    const qxi = qxW - qx9, qxD = Math["max"](0, Math["ceil"](qxi / qx7)), qxm = Math["min"](qx5, (qgU + qxi) / qx7);
    for (let qxa = 0; qxa < qx3; ++qxa) {
      const qxZ = qxa - qxq, qxw = Math["max"](0, Math["ceil"](qxZ / qx8)), qxe = Math["min"](qx6, (qx0 + qxZ) / qx8);
      let qxz = 0;
      for (let qxX = qxD; qxX < qxm; ++qxX) {
        const qxG = qxX * qx7 - qxi;
        for (let qxN = qxw; qxN < qxe; ++qxN) {
          const qxu = qxN * qx8 - qxZ, qxj = qxf * qxk + qxS * qxX + qxF * qxN, qxL = qgV * (qgU - 1 - qxG) + qgJ * (qx0 - 1 - qxu) + qgY * qxO;
          for (let qxI = 0; qxI < qx4; ++qxI) {
            const qxb = qgK[qxj + qxt * qxI], qxR = qgB[qxL + qxI];
            qxz += qxb * qxR;
          }
        }
      }
      const qxc = qxp * qxk + qxs * qxW + qxE * qxa + qxM * qxO;
      qgT[qxc] = qxz;
    }
  }
  return qgL["makeTensorInfo"](qgh["shape"], qgh["dtype"], qgh["values"]);
}
var q30 = { "kernelName": qU, "backendName": "cpu", "kernelFunc": q2U };
var q31 = HK(nq, (qgu) => Math["cos"](qgu));
var q32 = { "kernelName": nq, "backendName": "cpu", "kernelFunc": q31 };
function q33(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { image: qgb, boxes: qgR, boxInd: qgo } = qgj, { cropSize: qgr, method: qgQ, extrapolationValue: qgd } = qgI, [qgv, qgy, qgl, qgH] = qgb["shape"], qgA = qgR["shape"][0], [qgh, qgT] = qgr, qgK = DY([qgA, qgh, qgT, qgH], "float32"), qgB = qgL["data"]["get"](qgR["dataId"])["values"], qgV = qgL["data"]["get"](qgo["dataId"])["values"], qgJ = qgL["data"]["get"](qgb["dataId"])["values"], qgY = y(qgb["shape"]), qgP = y(qgK["shape"]);
  for (let qgU = 0; qgU < qgA; qgU++) {
    const qx0 = qgU * 4, qx1 = qgB[qx0], qx2 = qgB[qx0 + 1], qx3 = qgB[qx0 + 2], qx4 = qgB[qx0 + 3], qx5 = qgV[qgU];
    if (qx5 >= qgv) continue;
    const qx6 = qgh > 1 ? (qx3 - qx1) * (qgy - 1) / (qgh - 1) : 0, qx7 = qgT > 1 ? (qx4 - qx2) * (qgl - 1) / (qgT - 1) : 0;
    for (let qx8 = 0; qx8 < qgh; qx8++) {
      const qx9 = qgh > 1 ? qx1 * (qgy - 1) + qx8 * qx6 : 0.5 * (qx1 + qx3) * (qgy - 1);
      if (qx9 < 0 || qx9 > qgy - 1) {
        for (let qxq = 0; qxq < qgT; qxq++) for (let qxn = 0; qxn < qgH; qxn++) {
          const qxp = qxn + qxq * qgP[2] + qx8 * qgP[1] + qgU * qgP[0];
          qgK["values"][qxp] = qgd;
        }
        continue;
      }
      if (qgQ === "bilinear") {
        const qxs = Math["floor"](qx9), qxE = Math["ceil"](qx9), qxM = qx9 - qxs;
        for (let qxf = 0; qxf < qgT; qxf++) {
          const qxS = qgT > 1 ? qx2 * (qgl - 1) + qxf * qx7 : 0.5 * (qx2 + qx4) * (qgl - 1);
          if (qxS < 0 || qxS > qgl - 1) {
            for (let qxO = 0; qxO < qgH; qxO++) {
              const qxW = qxO + qxf * qgP[2] + qx8 * qgP[1] + qgU * qgP[0];
              qgK["values"][qxW] = qgd;
            }
            continue;
          }
          const qxF = Math["floor"](qxS), qxt = Math["ceil"](qxS), qxk = qxS - qxF;
          for (let qxi = 0; qxi < qgH; qxi++) {
            let qxD = qxi + qxF * qgY[2] + qxs * qgY[1] + qx5 * qgY[0];
            const qxm = qgJ[qxD];
            qxD = qxi + qxt * qgY[2] + qxs * qgY[1] + qx5 * qgY[0];
            const qxa = qgJ[qxD];
            qxD = qxi + qxF * qgY[2] + qxE * qgY[1] + qx5 * qgY[0];
            const qxZ = qgJ[qxD];
            qxD = qxi + qxt * qgY[2] + qxE * qgY[1] + qx5 * qgY[0];
            const qxw = qgJ[qxD], qxe = qxm + (qxa - qxm) * qxk, qxz = qxZ + (qxw - qxZ) * qxk;
            qxD = qxi + qxf * qgP[2] + qx8 * qgP[1] + qgU * qgP[0], qgK["values"][qxD] = qxe + (qxz - qxe) * qxM;
          }
        }
      } else for (let qxc = 0; qxc < qgT; ++qxc) {
        const qxX = qgT > 1 ? qx2 * (qgl - 1) + qxc * qx7 : 0.5 * (qx2 + qx4) * (qgl - 1);
        if (qxX < 0 || qxX > qgl - 1) {
          for (let qxu = 0; qxu < qgH; qxu++) {
            const qxj = qxu + qxc * qgP[2] + qx8 * qgP[1] + qgU * qgP[0];
            qgK["values"][qxj] = qgd;
          }
          continue;
        }
        const qxG = Math["round"](qxX), qxN = Math["round"](qx9);
        for (let qxL = 0; qxL < qgH; qxL++) {
          const qxI = qxL + qxG * qgY[2] + qxN * qgY[1] + qx5 * qgY[0], qxb = qxL + qxc * qgP[2] + qx8 * qgP[1] + qgU * qgP[0];
          qgK["values"][qxb] = qgJ[qxI];
        }
      }
    }
  }
  return qgL["makeTensorInfo"](qgK["shape"], qgK["dtype"], qgK["values"]);
}
var q34 = { "kernelName": nn, "backendName": "cpu", "kernelFunc": q33 };
function q35(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { blockSize: qgR, dataFormat: qgo } = qgI;
  k(qgo === "NHWC", () => "Only NHWC dataFormat supported on CPU for depthToSpace. Got " + qgo);
  const qgr = qgb["shape"][0], qgQ = qgb["shape"][1], qgd = qgb["shape"][2], qgv = qgb["shape"][3], qgy = qgQ * qgR, qgl = qgd * qgR, qgH = qgv / (qgR * qgR), qgA = qgL["data"]["get"](qgb["dataId"])["values"], qgh = new Float32Array(qgr * qgy * qgl * qgH);
  let qgT = 0;
  for (let qgK = 0; qgK < qgr; ++qgK) for (let qgB = 0; qgB < qgy; ++qgB) {
    const qgV = Math["floor"](qgB / qgR), qgJ = qgB % qgR;
    for (let qgY = 0; qgY < qgl; ++qgY) {
      const qgP = Math["floor"](qgY / qgR), qgU = qgY % qgR, qx0 = (qgJ * qgR + qgU) * qgH;
      for (let qx1 = 0; qx1 < qgH; ++qx1) {
        const qx2 = qx1 + qx0 + qgv * (qgP + qgd * (qgV + qgQ * qgK));
        qgh[qgT++] = qgA[qx2];
      }
    }
  }
  return qgL["makeTensorInfo"]([qgr, qgy, qgl, qgH], qgb["dtype"], qgh);
}
var q36 = { "kernelName": ns, "backendName": "cpu", "kernelFunc": q35 };
function q37(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR } = qgj, { strides: qgo, pad: qgr, dilations: qgQ, dimRoundingMode: qgd } = qgI;
  lK([qgb, qgR], "depthwiseConv2DNative");
  const qgv = y(qgb["shape"]), qgy = y(qgR["shape"]);
  let qgl = qgQ;
  qgl == null && (qgl = [1, 1]), k(iU(qgo, qgl), () => "Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides " + qgo + " and dilations '" + qgl + "'");
  const qgH = ij(qgb["shape"], qgR["shape"], qgo, qgl, qgr, qgd, true), { filterHeight: qgA, filterWidth: qgh, dilationHeight: qgT, dilationWidth: qgK, padInfo: qgB } = qgH, qgV = qgB["left"], qgJ = qgB["top"], qgY = qgH["outChannels"] / qgH["inChannels"], qgP = new EU(qgH["outShape"], qgb["dtype"]), qgU = qgL["data"]["get"](qgb["dataId"])["values"], qx0 = qgL["data"]["get"](qgR["dataId"])["values"], qx1 = qgP["values"];
  for (let qx2 = 0; qx2 < qgH["batchSize"]; ++qx2) {
    const qx3 = qx2 * qgv[0], qx4 = qx2 * qgP["strides"][0];
    for (let qx5 = 0; qx5 < qgH["outHeight"]; ++qx5) {
      const qx6 = qx4 + qx5 * qgP["strides"][1], qx7 = qx5 * qgH["strideHeight"] - qgJ;
      for (let qx8 = 0; qx8 < qgA; ++qx8) {
        const qx9 = qx7 + qx8 * qgT;
        if (qx9 < 0 || qx9 >= qgH["inHeight"]) continue;
        const qxq = qx8 * qgy[0], qxn = qx3 + qx9 * qgv[1];
        for (let qxp = 0; qxp < qgH["outWidth"]; ++qxp) {
          const qxs = qx6 + qxp * qgP["strides"][2], qxE = qxp * qgH["strideWidth"] - qgV;
          for (let qxM = 0; qxM < qgh; ++qxM) {
            const qxf = qxE + qxM * qgK;
            if (qxf < 0 || qxf >= qgH["inWidth"]) continue;
            const qxS = qxq + qxM * qgy[1], qxF = qxn + qxf * qgH["inChannels"];
            let qxt = qxs, qxk = qxS;
            for (let qxO = 0; qxO < qgH["inChannels"]; ++qxO) {
              const qxW = qgU[qxF + qxO];
              for (let qxi = 0; qxi < qgY; ++qxi) qx1[qxt + qxi] += qxW * qx0[qxk + qxi];
              qxt += qgY, qxk += qgY;
            }
          }
        }
      }
    }
  }
  return qgL["makeTensorInfo"](qgP["shape"], qgP["dtype"], qgP["values"]);
}
var q38 = { "kernelName": nM, "backendName": "cpu", "kernelFunc": q37 };
function q39(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { input: qgb } = qgj, { dim: qgR } = qgI, qgo = qgb["shape"]["length"], qgr = qgb["shape"]["slice"]();
  let qgQ = qgR;
  return qgR < 0 && (k(-(qgo + 1) <= qgR, () => "Axis must be in the interval [" + -(qgo + 1) + ", " + qgo + "]"), qgQ = qgo + qgR + 1), qgr["splice"](qgQ, 0, 1), q2l({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "shape": qgr } });
}
var q3q = { "kernelName": nZ, "backendName": "cpu", "kernelFunc": q39 };
function q3n(qgu) {
  const { backend: qgj, attrs: qgL } = qgu, { shape: qgI, value: qgb, dtype: qgR } = qgL, qgo = qgR || Q(qgb), qgr = G(qgo, i2(qgI));
  return q3g(qgr, qgb, qgo), qgj["makeTensorInfo"](qgI, qgo, qgr);
}
var q3p = { "kernelName": ne, "backendName": "cpu", "kernelFunc": q3n };
function q3g(qgu, qgj, qgL) {
  qgu["fill"](qgj);
}
var q3x = HK(nD, (qgu) => qgu >= 0 ? qgu : Math["exp"](qgu) - 1);
function q3s(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { alpha: qgR } = qgI;
  lK([qgb], "leakyRelu");
  const qgo = i2(qgb["shape"]), qgr = qgL["data"]["get"](qgb["dataId"])["values"], qgQ = X("float32", qgo);
  for (let qgd = 0; qgd < qgr["length"]; qgd++) qgQ[qgd] = qgr[qgd] < 0 ? qgR * qgr[qgd] : qgr[qgd];
  return qgL["makeTensorInfo"](qgb["shape"], "float32", qgQ);
}
var q3E = lY((qgu, qgj) => qgu < 0 ? qgj * qgu : qgu);
function q3M(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI, alpha: qgb } = qgj;
  lK([qgI, qgb], "prelu");
  const qgR = qgL["data"]["get"](qgI["dataId"])["values"], qgo = qgL["data"]["get"](qgb["dataId"])["values"], [qgr, qgQ] = q3E(qgI["shape"], qgb["shape"], qgR, qgo, "float32");
  return qgL["makeTensorInfo"](qgQ, "float32", qgr);
}
var q3f = { "kernelName": pX, "backendName": "cpu", "kernelFunc": q3M };
var q3S = HK(pj, (qgu) => Math["max"](0, qgu));
var q3F = { "kernelName": pj, "backendName": "cpu", "kernelFunc": q3S };
var q3t = HK(pQ, (qgu) => Math["min"](Math["max"](0, qgu), 6));
var q3k = { "kernelName": pQ, "backendName": "cpu", "kernelFunc": q3t };
function q3O(qgu, qgj, qgL, qgI, qgb) {
  if (qgL === "linear") return H6({ "inputs": { "x": qgj }, "backend": qgu });
  if (qgL === "relu") return q3S({ "inputs": { "x": qgj }, "backend": qgu });
  if (qgL === "elu") return q3x({ "inputs": { "x": qgj }, "backend": qgu });
  if (qgL === "relu6") return q3t({ "inputs": { "x": qgj }, "backend": qgu });
  if (qgL === "prelu") return q3M({ "inputs": { "x": qgj, "alpha": qgI }, "backend": qgu });
  if (qgL === "leakyrelu") return q3s({ "inputs": { "x": qgj }, "backend": qgu, "attrs": { "alpha": qgb } });
  if (qgL === "sigmoid") return TD({ "inputs": { "x": qgj }, "backend": qgu });
  throw new Error("Activation " + qgL + " has not been implemented for the CPU backend.");
}
function q3W(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR, bias: qgo, preluActivationWeights: qgr } = qgj, { strides: qgQ, pad: qgd, dataFormat: qgv, dilations: qgy, dimRoundingMode: qgl, activation: qgH, leakyreluAlpha: qgA } = qgI;
  let qgh = q2Y({ "inputs": { "x": qgb, "filter": qgR }, "backend": qgL, "attrs": { "strides": qgQ, "pad": qgd, "dataFormat": qgv, "dilations": qgy, "dimRoundingMode": qgl } });
  if (qgo) {
    const qgT = qgh;
    if (qgv === "NCHW" && qgo["shape"]["length"] === 1 && qgo["shape"][0] !== 1) {
      const qgK = q2l({ "inputs": { "x": qgo }, "backend": qgL, "attrs": { "shape": [qgo["shape"][0], 1, 1] } });
      qgh = Hj({ "inputs": { "a": qgh, "b": qgK }, "backend": qgL }), qgL["disposeIntermediateTensorInfo"](qgK);
    } else qgh = Hj({ "inputs": { "a": qgh, "b": qgo }, "backend": qgL });
    qgL["disposeIntermediateTensorInfo"](qgT);
  }
  if (qgH) {
    const qgB = qgh;
    if (qgv === "NCHW" && qgH === "prelu" && qgr["shape"]["length"] === 1 && qgr["shape"][0] !== 1) {
      const qgV = q2l({ "inputs": { "x": qgr }, "backend": qgL, "attrs": { "shape": [qgr["shape"][0], 1, 1] } });
      qgh = q3O(qgL, qgh, qgH, qgV, qgA), qgL["disposeIntermediateTensorInfo"](qgV);
    } else qgh = q3O(qgL, qgh, qgH, qgr, qgA);
    qgL["disposeIntermediateTensorInfo"](qgB);
  }
  return qgh;
}
var q3i = { "kernelName": gu, "backendName": "cpu", "kernelFunc": q3W };
function q3D(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, filter: qgR, bias: qgo, preluActivationWeights: qgr } = qgj, { strides: qgQ, pad: qgd, dataFormat: qgv, dilations: qgy, dimRoundingMode: qgl, activation: qgH, leakyreluAlpha: qgA } = qgI;
  let qgh = q37({ "inputs": { "x": qgb, "filter": qgR }, "backend": qgL, "attrs": { "strides": qgQ, "pad": qgd, "dataFormat": qgv, "dilations": qgy, "dimRoundingMode": qgl } });
  if (qgo) {
    const qgT = qgh;
    qgh = Hj({ "inputs": { "a": qgh, "b": qgo }, "backend": qgL }), qgL["disposeIntermediateTensorInfo"](qgT);
  }
  if (qgH) {
    const qgK = qgh;
    qgh = q3O(qgL, qgh, qgH, qgr, qgA), qgL["disposeIntermediateTensorInfo"](qgK);
  }
  return qgh;
}
var q3m = { "kernelName": gj, "backendName": "cpu", "kernelFunc": q3D };
function q3a(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb, indices: qgR } = qgj, { axis: qgo, batchDims: qgr } = qgI;
  lK([qgb, qgR], "gatherV2");
  const qgQ = z(qgo, qgb["shape"])[0], qgd = qgL["data"]["get"](qgR["dataId"])["values"], qgv = qgb["shape"][qgQ];
  for (let qgJ = 0; qgJ < qgd["length"]; ++qgJ) {
    const qgY = qgd[qgJ];
    k(qgY <= qgv - 1 && qgY >= 0, () => "GatherV2: the index value " + qgY + " is not in [0, " + (qgv - 1) + "]");
  }
  let qgy = qgr;
  qgr == null && (qgy = 0);
  const qgl = i2(qgR["shape"]), qgH = uj(qgb, qgR, qgQ, qgy), qgA = q2l({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "shape": [qgH["batchSize"], qgH["outerSize"], qgH["dimSize"], qgH["sliceSize"]] } }), qgh = q2l({ "inputs": { "x": qgR }, "backend": qgL, "attrs": { "shape": [qgH["batchSize"], qgl / qgH["batchSize"]] } }), qgT = [qgH["batchSize"], qgH["outerSize"], qgl / qgH["batchSize"], qgH["sliceSize"]], qgK = qgL["bufferSync"](qgh), qgB = qgL["bufferSync"](qgA), qgV = AD(qgB, qgK, qgT);
  return qgL["disposeIntermediateTensorInfo"](qgA), qgL["disposeIntermediateTensorInfo"](qgh), qgL["makeTensorInfo"](qgH["outputShape"], qgV["dtype"], qgV["values"]);
}
var q3Z = { "kernelName": nu, "backendName": "cpu", "kernelFunc": q3a };
var q3w = lY((qgu, qgj) => qgu && qgj);
var q3e = HZ(nV, q3w, null, "bool");
var q3z = { "kernelName": nV, "backendName": "cpu", "kernelFunc": q3e };
var q3c = lY((qgu, qgj) => qgu || qgj);
var q3X = HZ(nJ, q3c, null, "bool");
var q3G = { "kernelName": nJ, "backendName": "cpu", "kernelFunc": q3X };
function q3N(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { reductionIndices: qgR, keepDims: qgo } = qgI, qgr = qgL;
  let qgQ = qgb["shape"];
  const qgd = qgQ["length"], qgv = z(qgR, qgQ);
  let qgy = qgv;
  const qgl = at(qgy, qgd);
  let qgH = qgr["data"]["get"](qgb["dataId"])["values"];
  if (qgl != null) {
    const qgJ = new Array(qgd);
    for (let qgY = 0; qgY < qgJ["length"]; qgY++) qgJ[qgY] = qgQ[qgl[qgY]];
    qgH = hZ(qgH, qgQ, qgb["dtype"], qgl, qgJ), qgy = aD(qgy["length"], qgd), qgQ = qgJ;
  }
  lK(qgb, "max"), aF("max", qgy, qgd);
  const [qgA, qgh] = aq(qgQ, qgy), qgT = i2(qgh), qgK = AB(qgH, qgT, qgA, qgb["dtype"]), qgB = qgr["write"](qgK, qgA, qgb["dtype"]);
  let qgV = qgA;
  return qgo && (qgV = aM(qgA, qgv)), { "dataId": qgB, "shape": qgV, "dtype": qgb["dtype"] };
}
var q3u = { "kernelName": nY, "backendName": "cpu", "kernelFunc": q3N };
function q3j(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj;
  lK(qgb, "maxPool");
  const { filterSize: qgR, strides: qgo, pad: qgr, dimRoundingMode: qgQ } = qgI, qgd = 1;
  k(iU(qgo, qgd), () => "Error in maxPool: Either strides or dilations must be 1. Got strides " + qgo + " and dilations '" + qgd + "'");
  const qgv = iG(qgb["shape"], qgR, qgo, qgd, qgr, qgQ);
  let qgy;
  if (qgv["filterWidth"] === 1 && qgv["filterHeight"] === 1 && D(qgv["inShape"], qgv["outShape"])) qgy = H6({ "inputs": { "x": qgb }, "backend": qgL });
  else {
    const qgl = qgL["data"]["get"](qgb["dataId"])["values"], qgH = y(qgb["shape"]), qgA = q2v(qgl, qgb["shape"], qgb["dtype"], qgH, qgv, "max");
    qgy = qgL["makeTensorInfo"](qgv["outShape"], qgb["dtype"], qgA["values"]);
  }
  return qgy;
}
var q3L = { "kernelName": nU, "backendName": "cpu", "kernelFunc": q3j };
var q3I = lY((qgu, qgj) => qgu / qgj);
var q3b = HZ(nW, q3I);
var q3R = { "kernelName": nW, "backendName": "cpu", "kernelFunc": q3b };
function q3o(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { axis: qgR, keepDims: qgo } = qgI;
  lK(qgb, "sum");
  let qgr;
  qgb["dtype"] === "bool" ? qgr = HW({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "dtype": "int32" } }) : qgr = H6({ "inputs": { "x": qgb }, "backend": qgL });
  const qgQ = qgr["shape"]["length"], qgd = z(qgR, qgr["shape"]), qgv = at(qgd, qgQ);
  let qgy = qgd, qgl = qgr;
  qgv != null && (qgl = he({ "inputs": { "x": qgr }, "backend": qgL, "attrs": { "perm": qgv } }), qgy = aD(qgy["length"], qgQ)), aF("sum", qgy, qgl["shape"]["length"]);
  const [qgH, qgA] = aq(qgl["shape"], qgy), qgh = ML(qgl["dtype"], "int32");
  let qgT = lU(qgL, qgH, qgh);
  const qgK = i2(qgA), qgB = qgL["data"]["get"](qgT["dataId"])["values"], qgV = qgL["data"]["get"](qgl["dataId"])["values"];
  for (let qgJ = 0; qgJ < qgB["length"]; ++qgJ) {
    const qgY = qgJ * qgK;
    let qgP = 0;
    for (let qgU = 0; qgU < qgK; ++qgU) qgP += qgV[qgY + qgU];
    qgB[qgJ] = qgP;
  }
  if (qgo) {
    const qx0 = aM(qgT["shape"], qgd), qx1 = qgT;
    qgT = q2l({ "inputs": { "x": qgT }, "backend": qgL, "attrs": { "shape": qx0 } }), qgL["disposeIntermediateTensorInfo"](qx1);
  }
  return qgL["disposeIntermediateTensorInfo"](qgr), qgv != null && qgL["disposeIntermediateTensorInfo"](qgl), qgT;
}
var q3r = { "kernelName": pU, "backendName": "cpu", "kernelFunc": q3o };
function q3Q(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { axis: qgR, keepDims: qgo } = qgI, qgr = z(qgR, qgb["shape"]), qgQ = aq(qgb["shape"], qgr)[1], qgd = i2(qgQ), qgv = [], qgy = qgL["makeTensorInfo"]([], "float32", new Float32Array([qgd]));
  qgv["push"](qgy);
  const qgl = HW({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "dtype": "float32" } });
  qgv["push"](qgl);
  const qgH = q3b({ "inputs": { "a": qgl, "b": qgy }, "backend": qgL });
  qgv["push"](qgH);
  const qgA = q3o({ "inputs": { "x": qgH }, "backend": qgL, "attrs": { "axis": qgR, "keepDims": qgo } });
  return qgv["forEach"]((qgh) => qgL["disposeIntermediateTensorInfo"](qgh)), qgA;
}
var q3d = { "kernelName": p1, "backendName": "cpu", "kernelFunc": q3Q };
function q3v(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { axis: qgR, keepDims: qgo } = qgI;
  lK(qgb, "min");
  const qgr = z(qgR, qgb["shape"]);
  let qgQ = qgr;
  const qgd = at(qgQ, qgb["shape"]["length"]);
  let qgv = qgb;
  qgd != null && (qgv = he({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "perm": qgd } }), qgQ = aD(qgQ["length"], qgb["shape"]["length"])), aF("min", qgQ, qgv["shape"]["length"]);
  const [qgy, qgl] = aq(qgv["shape"], qgQ), qgH = i2(qgl), qgA = T(i2(qgy), qgv["dtype"]), qgh = qgL["data"]["get"](qgv["dataId"])["values"];
  for (let qgK = 0; qgK < qgA["length"]; ++qgK) {
    const qgB = qgK * qgH;
    let qgV = qgh[qgB];
    for (let qgJ = 0; qgJ < qgH; ++qgJ) {
      const qgY = qgh[qgB + qgJ];
      (Number["isNaN"](qgY) || qgY < qgV) && (qgV = qgY);
    }
    qgA[qgK] = qgV;
  }
  qgd != null && qgL["disposeIntermediateTensorInfo"](qgv);
  const qgT = qgL["makeTensorInfo"](qgy, qgv["dtype"], qgA);
  if (qgo) {
    const qgP = aM(qgy, qgr), qgU = q2l({ "inputs": { "x": qgT }, "backend": qgL, "attrs": { "shape": qgP } });
    return qgL["disposeIntermediateTensorInfo"](qgT), qgU;
  }
  return qgT;
}
var q3y = { "kernelName": pq, "backendName": "cpu", "kernelFunc": q3v };
function q3C(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { axis: qgb } = qgI;
  if (qgj["length"] === 1) return q39({ "inputs": { "input": qgj[0] }, "backend": qgL, "attrs": { "dim": qgb } });
  const qgR = qgj[0]["shape"], qgo = qgj[0]["dtype"];
  qgj["forEach"]((qgv) => {
    O(qgR, qgv["shape"], "All tensors passed to stack must have matching shapes"), k(qgo === qgv["dtype"], () => "All tensors passed to stack must have matching dtypes");
  });
  const qgr = [], qgQ = qgj["map"]((qgv) => {
    const qgy = q39({ "inputs": { "input": qgv }, "backend": qgL, "attrs": { "dim": qgb } });
    return qgr["push"](qgy), qgy;
  }), qgd = q2V({ "inputs": qgQ, "backend": qgL, "attrs": { "axis": qgb } });
  return qgr["forEach"]((qgv) => qgL["disposeIntermediateTensorInfo"](qgv)), qgd;
}
var q3l = { "kernelName": pZ, "backendName": "cpu", "kernelFunc": q3C };
function q3H(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { paddings: qgR, constantValue: qgo } = qgI;
  lK(qgb, "pad");
  const qgr = qgR["map"]((qgK, qgB) => qgK[0] + qgb["shape"][qgB] + qgK[1]), qgQ = qgR["map"]((qgK) => qgK[0]), qgd = qgL["data"]["get"](qgb["dataId"])["values"], qgv = i2(qgb["shape"]), qgy = qgb["shape"]["length"], qgl = y(qgb["shape"]), qgH = i2(qgr), qgA = qgr["length"], qgh = y(qgr), qgT = X(qgb["dtype"], qgH);
  qgo !== 0 && qgT["fill"](qgo);
  for (let qgK = 0; qgK < qgv; qgK++) {
    const qgB = V(qgK, qgy, qgl)["map"]((qgJ, qgY) => qgJ + qgQ[qgY]), qgV = B(qgB, qgA, qgh);
    qgT[qgV] = qgd[qgK];
  }
  return { "dataId": qgL["write"](qgT, qgr, qgb["dtype"]), "shape": qgr, "dtype": qgb["dtype"] };
}
var q3A = { "kernelName": pe, "backendName": "cpu", "kernelFunc": q3H };
var q3h = lY((qgu, qgj) => Math["pow"](qgu, qgj));
var q3T = HZ(pz, q3h);
var q3K = { "kernelName": pz, "backendName": "cpu", "kernelFunc": q3T };
function q3B(qgu) {
  const { backend: qgj, attrs: qgL } = qgu, { start: qgI, stop: qgb, dtype: qgR, step: qgo } = qgL, qgr = Tq(qgI, qgb, qgo, qgR);
  return qgj["makeTensorInfo"]([qgr["length"]], qgR, qgr);
}
var q3V = { "kernelName": pG, "backendName": "cpu", "kernelFunc": q3B };
function q3J(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { images: qgb } = qgj, { alignCorners: qgR, halfPixelCenters: qgo, size: qgr } = qgI;
  lK(qgb, "resizeBilinear");
  const qgQ = y(qgb["shape"]), [qgd, qgv] = qgr, [qgy, qgl, qgH, qgA] = qgb["shape"], qgh = qgL["data"]["get"](qgb["dataId"])["values"], qgT = new Float32Array(i2([qgy, qgd, qgv, qgA])), qgK = [qgR && qgd > 1 ? qgl - 1 : qgl, qgR && qgv > 1 ? qgH - 1 : qgH], qgB = [qgR && qgd > 1 ? qgd - 1 : qgd, qgR && qgv > 1 ? qgv - 1 : qgv];
  let qgV = 0;
  const qgJ = qgK[0] / qgB[0], qgY = qgK[1] / qgB[1];
  for (let qgP = 0; qgP < qgy; qgP++) for (let qgU = 0; qgU < qgd; qgU++) {
    let qx0;
    qgo ? qx0 = qgJ * (qgU + 0.5) - 0.5 : qx0 = qgJ * qgU;
    const qx1 = Math["max"](0, Math["floor"](qx0)), qx2 = qx0 - qx1, qx3 = Math["min"](qgl - 1, Math["ceil"](qx0)), qx4 = qgP * qgQ[0] + qx1 * qgQ[1], qx5 = qgP * qgQ[0] + qx3 * qgQ[1];
    for (let qx6 = 0; qx6 < qgv; qx6++) {
      let qx7;
      qgo ? qx7 = qgY * (qx6 + 0.5) - 0.5 : qx7 = qgY * qx6;
      const qx8 = Math["max"](0, Math["floor"](qx7)), qx9 = qx7 - qx8, qxq = Math["min"](qgH - 1, Math["ceil"](qx7)), qxn = qx4 + qx8 * qgQ[2], qxp = qx5 + qx8 * qgQ[2], qxs = qx4 + qxq * qgQ[2], qxE = qx5 + qxq * qgQ[2];
      for (let qxM = 0; qxM < qgA; qxM++) {
        const qxf = qgh[qxn + qxM], qxS = qgh[qxp + qxM], qxF = qgh[qxs + qxM], qxt = qgh[qxE + qxM], qxk = qxf + (qxF - qxf) * qx9, qxO = qxS + (qxt - qxS) * qx9, qxW = qxk + (qxO - qxk) * qx2;
        qgT[qgV++] = qxW;
      }
    }
  }
  return qgL["makeTensorInfo"]([qgy, qgd, qgv, qgA], "float32", qgT);
}
var q3Y = { "kernelName": pr, "backendName": "cpu", "kernelFunc": q3J };
var q3P = { "kernelName": gX, "backendName": "cpu", "kernelFunc": ({ inputs: qgu, attrs: qgj, backend: qgL }) => {
  const { image: qgI } = qgu, { radians: qgb, fillValue: qgR, center: qgo } = qgj, qgr = qgL, qgQ = X(qgI["dtype"], i2(qgI["shape"])), [qgd, qgv, qgy, qgl] = qgI["shape"], [qgH, qgA] = GR(qgo, qgv, qgy), qgh = 255, qgT = Math["sin"](qgb), qgK = Math["cos"](qgb), qgB = qgr["data"]["get"](qgI["dataId"])["values"];
  for (let qgV = 0; qgV < qgd; qgV++) {
    const qgJ = qgV * qgy * qgv * qgl;
    for (let qgY = 0; qgY < qgv; qgY++) {
      const qgP = qgY * (qgy * qgl);
      for (let qgU = 0; qgU < qgy; qgU++) {
        const qx0 = qgU * qgl;
        for (let qx1 = 0; qx1 < qgl; qx1++) {
          const qx2 = [qgd, qgY, qgU, qx1], qx3 = qx2[2], qx4 = qx2[1];
          let qx5 = (qx3 - qgH) * qgK - (qx4 - qgA) * qgT, qx6 = (qx3 - qgH) * qgT + (qx4 - qgA) * qgK;
          qx5 = Math["round"](qx5 + qgH), qx6 = Math["round"](qx6 + qgA);
          let qx7 = qgR;
          if (typeof qgR != "number" && (qx1 === 3 ? qx7 = qgh : qx7 = qgR[qx1]), qx5 >= 0 && qx5 < qgy && qx6 >= 0 && qx6 < qgv) {
            const qx9 = qx6 * (qgy * qgl), qxq = qx5 * qgl, qxn = qgJ + qx9 + qxq + qx1;
            qx7 = qgB[qxn];
          }
          const qx8 = qgJ + qgP + qx0 + qx1;
          qgQ[qx8] = qx7;
        }
      }
    }
  }
  return { "dataId": qgr["write"](qgQ, qgI["shape"], qgI["dtype"]), "shape": qgI["shape"], "dtype": qgI["dtype"] };
} };
var q3U = HK(pJ, (qgu) => Math["sin"](qgu));
var q40 = { "kernelName": pJ, "backendName": "cpu", "kernelFunc": q3U };
var q41 = { "kernelName": gn, "backendName": "cpu", "kernelFunc": ({ inputs: qgu, backend: qgj }) => {
  const { x: qgL } = qgu, qgI = qgj;
  lK(qgL, "square");
  const qgb = qgI["data"]["get"](qgL["dataId"])["values"], qgR = new Float32Array(qgb["length"]);
  for (let qgo = 0; qgo < qgb["length"]; ++qgo) {
    const qgr = qgb[qgo];
    qgR[qgo] = qgr * qgr;
  }
  return { "dataId": qgI["write"](qgR, qgL["shape"], qgL["dtype"]), "shape": qgL["shape"], "dtype": qgL["dtype"] };
} };
function q42(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { begin: qgR, end: qgo, strides: qgr, beginMask: qgQ, endMask: qgd, ellipsisMask: qgv, newAxisMask: qgy, shrinkAxisMask: qgl } = qgI;
  lK(qgb, "stridedSlice");
  const { finalShapeSparse: qgH, finalShape: qgA, isIdentity: qgh, sliceDim0: qgT, isSimpleSlice: qgK, begin: qgB, end: qgV, strides: qgJ } = WH(qgb["shape"], qgR, qgo, qgr, qgQ, qgd, qgv, qgy, qgl);
  let qgY;
  if (qgh) qgY = q2l({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "shape": qgA } });
  else {
    if (qgT || qgK) {
      k(qgb["shape"]["length"] >= 1, () => "Input must have rank at least 1, got: " + qgb["shape"]["length"]);
      const qgP = WF(qgB, qgV, qgJ), qgU = Tz({ "inputs": { "x": qgb }, "backend": qgL, "attrs": { "begin": qgB, "size": qgP } });
      qgY = q2l({ "inputs": { "x": qgU }, "backend": qgL, "attrs": { "shape": qgA } }), qgL["disposeIntermediateTensorInfo"](qgU);
    } else {
      const qx0 = qgL["bufferSync"](qgb), qx1 = TV(qgH, qx0, qgJ, qgB);
      qgY = qgL["makeTensorInfo"](qgA, qx1["dtype"], qx1["values"]);
    }
  }
  return qgY;
}
var q43 = { "kernelName": gs, "backendName": "cpu", "kernelFunc": q42 };
function q44(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { x: qgb } = qgj, { reps: qgR } = qgI;
  lK(qgb, "tile");
  const qgo = Kt(qgL["bufferSync"](qgb), qgR);
  return qgL["makeTensorInfo"](qgo["shape"], qgo["dtype"], qgo["values"]);
}
var q45 = { "kernelName": gF, "backendName": "cpu", "kernelFunc": q44 };
function q46(qgu) {
  const { inputs: qgj, attrs: qgL, backend: qgI } = qgu, { image: qgb, transforms: qgR } = qgj, { interpolation: qgo, fillMode: qgr, fillValue: qgQ, outputShape: qgd } = qgL, [qgv, qgy, qgl, qgH] = qgb["shape"], [qgA, qgh] = qgd != null ? qgd : [qgy, qgl], qgT = [qgv, qgA, qgh, qgH], qgK = y(qgb["shape"]), qgB = qgK[0], qgV = qgK[1], qgJ = qgK[2], qgY = y(qgT), qgP = qgY[0], qgU = qgY[1], qx0 = qgY[2], qx1 = X(qgb["dtype"], i2(qgT));
  qx1["fill"](qgQ);
  const qx2 = qgI["data"]["get"](qgb["dataId"])["values"], qx3 = qgI["data"]["get"](qgR["dataId"])["values"];
  for (let qx4 = 0; qx4 < qgv; ++qx4) {
    const qx5 = qgR["shape"][0] === 1 ? qx3 : qx3["subarray"](qx4 * 8, qx4 * 8 + 8);
    for (let qx6 = 0; qx6 < qgA; ++qx6) for (let qx7 = 0; qx7 < qgh; ++qx7) for (let qx8 = 0; qx8 < qgH; ++qx8) {
      let qx9;
      const qxq = qx5[6] * qx7 + qx5[7] * qx6 + 1;
      if (qxq === 0) continue;
      const qxn = (qx5[0] * qx7 + qx5[1] * qx6 + qx5[2]) / qxq, qxp = (qx5[3] * qx7 + qx5[4] * qx6 + qx5[5]) / qxq, qxs = q48(qxn, qgl, qgr), qxE = q48(qxp, qgy, qgr);
      switch (qgo) {
        case "nearest":
          qx9 = q4x(qx2, qgy, qgl, qgB, qgV, qgJ, qx4, qxE, qxs, qx8, qgQ);
          break;
        case "bilinear":
          qx9 = q4s(qx2, qgy, qgl, qgB, qgV, qgJ, qx4, qxE, qxs, qx8, qgQ);
          break;
        default:
          throw new Error("Error in Transform: Expect 'nearest' or 'bilinear', but got " + qgo);
      }
      const qxM = qx4 * qgP + qx6 * qgU + qx7 * qx0 + qx8;
      qx1[qxM] = qx9;
    }
    return qgI["makeTensorInfo"](qgT, qgb["dtype"], qx1);
  }
  return { "dataId": qgI["write"](qx1, qgT, qgb["dtype"]), "shape": qgb["shape"], "dtype": qgb["dtype"] };
}
var q47 = { "kernelName": gW, "backendName": "cpu", "kernelFunc": q46 };
function q48(qgu, qgj, qgL) {
  switch (qgL) {
    case "reflect":
      return q49(qgu, qgj);
    case "wrap":
      return q4q(qgu, qgj);
    case "nearest":
      return q4p(qgu, qgj);
    case "constant":
    default:
      return q4n(qgu);
  }
}
function q49(qgu, qgj) {
  let qgL = qgu;
  if (qgL < 0) {
    if (qgj <= 1) qgL = 0;
    else {
      const qgI = 2 * qgj;
      qgL < qgI && (qgL = qgI * Math["trunc"](-qgL / qgI) + qgL), qgL = qgL < -qgj ? qgL + qgI : -qgL - 1;
    }
  } else {
    if (qgL > qgj - 1) {
      if (qgj <= 1) qgL = 0;
      else {
        const qgb = 2 * qgj;
        qgL -= qgb * Math["trunc"](qgL / qgb), qgL >= qgj && (qgL = qgb - qgL - 1);
      }
    }
  }
  return E(0, qgL, qgj - 1);
}
function q4q(qgu, qgj) {
  let qgL = qgu;
  if (qgL < 0) {
    if (qgj <= 1) qgL = 0;
    else {
      const qgI = qgj - 1;
      qgL += qgj * (Math["trunc"](-qgL / qgI) + 1);
    }
  } else {
    if (qgL > qgj - 1) {
      if (qgj <= 1) qgL = 0;
      else {
        const qgb = qgj - 1;
        qgL -= qgj * Math["trunc"](qgL / qgb);
      }
    }
  }
  return E(0, qgL, qgj - 1);
}
function q4n(qgu, qgj) {
  return qgu;
}
function q4p(qgu, qgj) {
  return E(0, qgu, qgj - 1);
}
function q4g(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd, qgv) {
  const qgy = qgo * qgI + qgr * qgb + qgQ * qgR + qgd;
  return 0 <= qgr && qgr < qgj && 0 <= qgQ && qgQ < qgL ? qgu[qgy] : qgv;
}
function q4x(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd, qgv) {
  const qgy = Math["round"](qgr), qgl = Math["round"](qgQ);
  return q4g(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgy, qgl, qgd, qgv);
}
function q4s(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd, qgv) {
  const qgy = Math["floor"](qgr), qgl = Math["floor"](qgQ), qgH = qgy + 1, qgA = qgl + 1, qgh = (qgA - qgQ) * q4g(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgy, qgl, qgd, qgv) + (qgQ - qgl) * q4g(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgy, qgA, qgd, qgv), qgT = (qgA - qgQ) * q4g(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgH, qgl, qgd, qgv) + (qgQ - qgl) * q4g(qgu, qgj, qgL, qgI, qgb, qgR, qgo, qgH, qgA, qgd, qgv);
  return (qgH - qgr) * qgh + (qgr - qgy) * qgT;
}
function q4E(qgu) {
  const { inputs: qgj, backend: qgL } = qgu, { x: qgI } = qgj;
  if (qgI["dtype"] === "string") throw new Error("zerosLike is not supported for string tensors");
  if (qgI["dtype"] === "complex64") {
    const qgb = HM({ "inputs": { "input": qgI }, "backend": qgL }), qgR = q4E({ "inputs": { "x": qgb }, "backend": qgL }), qgo = q2B({ "inputs": { "input": qgI }, "backend": qgL }), qgr = q4E({ "inputs": { "x": qgo }, "backend": qgL }), qgQ = lP({ "inputs": { "real": qgR, "imag": qgr }, "backend": qgL });
    return qgL["disposeIntermediateTensorInfo"](qgb), qgL["disposeIntermediateTensorInfo"](qgR), qgL["disposeIntermediateTensorInfo"](qgo), qgL["disposeIntermediateTensorInfo"](qgr), qgQ;
  } else return q3n({ "backend": qgL, "attrs": { "shape": qgI["shape"], "value": 0, "dtype": qgI["dtype"] } });
}
var q4M = { "kernelName": gZ, "backendName": "cpu", "kernelFunc": q4E };
function q4f(qgu) {
  const { inputs: qgj, backend: qgL, attrs: qgI } = qgu, { a: qgb, b: qgR, bias: qgo, preluActivationWeights: qgr } = qgj, { transposeA: qgQ, transposeB: qgd, activation: qgv, leakyreluAlpha: qgy } = qgI;
  let qgl, qgH, qgA;
  const qgh = [];
  qgl = q2A({ "inputs": { "a": qgb, "b": qgR }, "attrs": { "transposeA": qgQ, "transposeB": qgd }, "backend": qgL }), qgo && (qgH = Hj({ "inputs": { "a": qgl, "b": qgo }, "backend": qgL }), qgh["push"](qgl), qgl = qgH), qgv && (qgA = q3O(qgL, qgl, qgv, qgr, qgy), qgh["push"](qgl), qgl = qgA);
  for (const qgT of qgh) qgL["disposeIntermediateTensorInfo"](qgT);
  return qgl;
}
var q4S = { "kernelName": gG, "backendName": "cpu", "kernelFunc": q4f };
gY(YM), gY(YY), gY(Ps), gY(PD), gY(PX), gY(UG), gY(UB), gY(UP), gY(q06), gY(q0x), gY(q0f), gY(q0k), gY(q0i), gY(q0a), gY(q0z), gY(q0X), gY(q0u), gY(q0I), gY(q0o), gY(q0y), gY(q0l), gY(q0T), gY(q0J), gY(YZ), gY(q10), gY(q14), gY(q18), gY(q1p), gY(q1s), gY(q1M), gY(q1t), gY(q1O), gY(q1i), gY(q1Z), gY(PH), gY(q1c), gY(q1G), gY(q1L), gY(q1o), gY(Yo), gY(q1Q), gY(q1C), gY(q1h), gY(q1V), gY(PV), gY(q1U), gY(q21), gY(q25), gY(q29), gY(q2E), gY(q2S), gY(q2k), gY(q2i), gY(q2a), gY(UW), gY(q2z), gY(q2G), gY(UZ), gY(q2u), gY(q2L), gY(lJ), gY(HL), gY(q2o), gY(q2d), gY(q2C), gY(q2h), gY(HD), gY(q2K), gY(q2J), gY(q2P), gY(q30), gY(q32), gY(q34), gY(q36), gY(q38), gY(q3q), gY(q3p), gY(AF), gY(q3i), gY(q3m), gY(q3Z), gY(AX), gY(Hq), gY(Aj), gY(AQ), gY(q3z), gY(q3G), gY(q3u), gY(q3L), gY(AY), gY(q3d), gY(q3y), gY(h1), gY(hF), gY(hD), gY(q3l), gY(q3A), gY(q3K), gY(q3f), gY(q3V), gY(q3R), gY(q3F), gY(q3k), gY(q2H), gY(q3Y), gY(q3P), gY(TZ), gY(q40), gY(TX), gY(TH), gY(q41), gY(q43), gY(KF), gY(q3r), gY(q45), gY(q47), gY(hz), gY(q4M), gY(q4S);
var q4F = function(qgu, qgj, qgL, qgI, qgb) {
  if (qgj = qgj !== void 0 ? qgj : true, qgL = qgL !== void 0 ? qgL : true, qgI = qgI || Math["pow"](2, -52), qgb = 1e-64 / qgI, !qgu) throw new TypeError("Matrix a is not defined");
  var qgR = qgu[0]["length"], qgo = qgu["length"];
  if (qgo < qgR) throw new TypeError("Invalid matrix: m < n");
  var qgr, qgQ, qgd, qgv, qgy, qgl, qgH, qgA, qgh, qgT, qgK, qgB, qgV;
  qgA = 0, qgK = 0;
  var qgJ = [], qgY = [], qgP = [], qgU = qgj === "f" ? qgo : qgR;
  for (qgr = 0; qgr < qgo; qgr++) qgY[qgr] = new Array(qgU)["fill"](0);
  for (qgr = 0; qgr < qgR; qgr++) qgP[qgr] = new Array(qgR)["fill"](0);
  var qx0 = new Array(qgR)["fill"](0);
  for (qgr = 0; qgr < qgo; qgr++) for (qgQ = 0; qgQ < qgR; qgQ++) qgY[qgr][qgQ] = qgu[qgr][qgQ];
  for (qgr = 0; qgr < qgR; qgr++) {
    for (qgJ[qgr] = qgA, qgT = 0, qgv = qgr + 1, qgQ = qgr; qgQ < qgo; qgQ++) qgT += Math["pow"](qgY[qgQ][qgr], 2);
    if (qgT < qgb) qgA = 0;
    else for (qgH = qgY[qgr][qgr], qgA = qgH < 0 ? Math["sqrt"](qgT) : -Math["sqrt"](qgT), qgh = qgH * qgA - qgT, qgY[qgr][qgr] = qgH - qgA, qgQ = qgv; qgQ < qgR; qgQ++) {
      for (qgT = 0, qgd = qgr; qgd < qgo; qgd++) qgT += qgY[qgd][qgr] * qgY[qgd][qgQ];
      for (qgH = qgT / qgh, qgd = qgr; qgd < qgo; qgd++) qgY[qgd][qgQ] = qgY[qgd][qgQ] + qgH * qgY[qgd][qgr];
    }
    for (qx0[qgr] = qgA, qgT = 0, qgQ = qgv; qgQ < qgR; qgQ++) qgT += Math["pow"](qgY[qgr][qgQ], 2);
    if (qgT < qgb) qgA = 0;
    else {
      for (qgH = qgY[qgr][qgr + 1], qgA = qgH < 0 ? Math["sqrt"](qgT) : -Math["sqrt"](qgT), qgh = qgH * qgA - qgT, qgY[qgr][qgr + 1] = qgH - qgA, qgQ = qgv; qgQ < qgR; qgQ++) qgJ[qgQ] = qgY[qgr][qgQ] / qgh;
      for (qgQ = qgv; qgQ < qgo; qgQ++) {
        for (qgT = 0, qgd = qgv; qgd < qgR; qgd++) qgT += qgY[qgQ][qgd] * qgY[qgr][qgd];
        for (qgd = qgv; qgd < qgR; qgd++) qgY[qgQ][qgd] = qgY[qgQ][qgd] + qgT * qgJ[qgd];
      }
    }
    qgB = Math["abs"](qx0[qgr]) + Math["abs"](qgJ[qgr]), qgB > qgK && (qgK = qgB);
  }
  if (qgL) for (qgr = qgR - 1; qgr >= 0; qgr--) {
    if (qgA !== 0) {
      for (qgh = qgY[qgr][qgr + 1] * qgA, qgQ = qgv; qgQ < qgR; qgQ++) qgP[qgQ][qgr] = qgY[qgr][qgQ] / qgh;
      for (qgQ = qgv; qgQ < qgR; qgQ++) {
        for (qgT = 0, qgd = qgv; qgd < qgR; qgd++) qgT += qgY[qgr][qgd] * qgP[qgd][qgQ];
        for (qgd = qgv; qgd < qgR; qgd++) qgP[qgd][qgQ] = qgP[qgd][qgQ] + qgT * qgP[qgd][qgr];
      }
    }
    for (qgQ = qgv; qgQ < qgR; qgQ++) qgP[qgr][qgQ] = 0, qgP[qgQ][qgr] = 0;
    qgP[qgr][qgr] = 1, qgA = qgJ[qgr], qgv = qgr;
  }
  if (qgj) {
    if (qgj === "f") for (qgr = qgR; qgr < qgo; qgr++) {
      for (qgQ = qgR; qgQ < qgo; qgQ++) qgY[qgr][qgQ] = 0;
      qgY[qgr][qgr] = 1;
    }
    for (qgr = qgR - 1; qgr >= 0; qgr--) {
      for (qgv = qgr + 1, qgA = qx0[qgr], qgQ = qgv; qgQ < qgU; qgQ++) qgY[qgr][qgQ] = 0;
      if (qgA !== 0) {
        for (qgh = qgY[qgr][qgr] * qgA, qgQ = qgv; qgQ < qgU; qgQ++) {
          for (qgT = 0, qgd = qgv; qgd < qgo; qgd++) qgT += qgY[qgd][qgr] * qgY[qgd][qgQ];
          for (qgH = qgT / qgh, qgd = qgr; qgd < qgo; qgd++) qgY[qgd][qgQ] = qgY[qgd][qgQ] + qgH * qgY[qgd][qgr];
        }
        for (qgQ = qgr; qgQ < qgo; qgQ++) qgY[qgQ][qgr] = qgY[qgQ][qgr] / qgA;
      } else {
        for (qgQ = qgr; qgQ < qgo; qgQ++) qgY[qgQ][qgr] = 0;
      }
      qgY[qgr][qgr] = qgY[qgr][qgr] + 1;
    }
  }
  qgI = qgI * qgK;
  var qx1;
  for (qgd = qgR - 1; qgd >= 0; qgd--) for (var qx2 = 0; qx2 < 50; qx2++) {
    for (qx1 = false, qgv = qgd; qgv >= 0; qgv--) {
      if (Math["abs"](qgJ[qgv]) <= qgI) {
        qx1 = true;
        break;
      }
      if (Math["abs"](qx0[qgv - 1]) <= qgI) break;
    }
    if (!qx1) {
      for (qgl = 0, qgT = 1, qgy = qgv - 1, qgr = qgv; qgr < qgd + 1 && (qgH = qgT * qgJ[qgr], qgJ[qgr] = qgl * qgJ[qgr], !(Math["abs"](qgH) <= qgI)); qgr++) if (qgA = qx0[qgr], qx0[qgr] = Math["sqrt"](qgH * qgH + qgA * qgA), qgh = qx0[qgr], qgl = qgA / qgh, qgT = -qgH / qgh, qgj) {
        for (qgQ = 0; qgQ < qgo; qgQ++) qgB = qgY[qgQ][qgy], qgV = qgY[qgQ][qgr], qgY[qgQ][qgy] = qgB * qgl + qgV * qgT, qgY[qgQ][qgr] = -qgB * qgT + qgV * qgl;
      }
    }
    if (qgV = qx0[qgd], qgv === qgd) {
      if (qgV < 0 && (qx0[qgd] = -qgV, qgL)) {
        for (qgQ = 0; qgQ < qgR; qgQ++) qgP[qgQ][qgd] = -qgP[qgQ][qgd];
      }
      break;
    }
    for (qgK = qx0[qgv], qgB = qx0[qgd - 1], qgA = qgJ[qgd - 1], qgh = qgJ[qgd], qgH = ((qgB - qgV) * (qgB + qgV) + (qgA - qgh) * (qgA + qgh)) / (2 * qgh * qgB), qgA = Math["sqrt"](qgH * qgH + 1), qgH = ((qgK - qgV) * (qgK + qgV) + qgh * (qgB / (qgH < 0 ? qgH - qgA : qgH + qgA) - qgh)) / qgK, qgl = 1, qgT = 1, qgr = qgv + 1; qgr < qgd + 1; qgr++) {
      if (qgA = qgJ[qgr], qgB = qx0[qgr], qgh = qgT * qgA, qgA = qgl * qgA, qgV = Math["sqrt"](qgH * qgH + qgh * qgh), qgJ[qgr - 1] = qgV, qgl = qgH / qgV, qgT = qgh / qgV, qgH = qgK * qgl + qgA * qgT, qgA = -qgK * qgT + qgA * qgl, qgh = qgB * qgT, qgB = qgB * qgl, qgL) {
        for (qgQ = 0; qgQ < qgR; qgQ++) qgK = qgP[qgQ][qgr - 1], qgV = qgP[qgQ][qgr], qgP[qgQ][qgr - 1] = qgK * qgl + qgV * qgT, qgP[qgQ][qgr] = -qgK * qgT + qgV * qgl;
      }
      if (qgV = Math["sqrt"](qgH * qgH + qgh * qgh), qx0[qgr - 1] = qgV, qgl = qgH / qgV, qgT = qgh / qgV, qgH = qgl * qgA + qgT * qgB, qgK = -qgT * qgA + qgl * qgB, qgj) {
        for (qgQ = 0; qgQ < qgo; qgQ++) qgB = qgY[qgQ][qgr - 1], qgV = qgY[qgQ][qgr], qgY[qgQ][qgr - 1] = qgB * qgl + qgV * qgT, qgY[qgQ][qgr] = -qgB * qgT + qgV * qgl;
      }
    }
    qgJ[qgv] = 0, qgJ[qgd] = qgH, qx0[qgd] = qgK;
  }
  for (qgr = 0; qgr < qgR; qgr++) qx0[qgr] < qgI && (qx0[qgr] = 0);
  return { "u": qgY, "q": qx0, "v": qgP };
};
var q4t = class {
  constructor() {
    this["bodyTracks"] = [], this["poseFilters"] = [], this["angle"] = 15 / 180 * Math["PI"], this["ratio"] = 1920 / 1080, this["near"] = 1, this["poseScore"] = 0.6, this["alignScore"] = 0.9, this["alignVisibility"] = 0.9, this["skipCount"] = 2, this["skipMax"] = 2;
  }
  async ["process"](qgu, qgj) {
    var qgL, qgI;
    if (this["bodyTracks"]["length"] < 1 && this["skipCount"] < this["skipMax"]) return this["skipCount"]++, [];
    this["skipCount"] = 0;
    const qgb = Sq(() => {
      const qgy = OM(OK(qgu, 3), "float32"), qgl = ZK(iM(qgy, 255 * 0.5), 1);
      return ZM(qgl, 0);
    }), [qgR, qgo] = [qgb["shape"][1], qgb["shape"][2]];
    if (this["bodyTracks"]["length"] === 0) {
      const qgy = await ((qgL = this["bodyDetector"]) == null ? void 0 : qgL["process"](qgb)) || [];
      this["bodyTracks"] = qgy["map"]((qgl) => ({ "center": qgl["points"][0], "top": qgl["points"][1] })), this["bodyTracks"]["forEach"](() => this["poseFilters"]["push"](new jL()));
    }
    const qgr = this["bodyTracks"]["length"] > 0 ? ((qgI = this["poseDetector"]) == null ? void 0 : qgI["process"](qgb, this["bodyTracks"])) || [] : [];
    qgr["forEach"]((qgl, qgH) => {
      var qgA;
      if (qgj !== void 0) {
        const qgh = qgo / qgR, qgT = qgl["top"][0] - qgl["center"][0], qgK = (qgl["top"][1] - qgl["center"][1]) / qgh, qgB = Math["sqrt"](qgT * qgT + qgK * qgK) * 2 * (1 + qgh) * 0.5;
        qgr[qgH] = this["poseFilters"][qgH]["filter"](qgl, qgj, 1 / qgB);
      }
      (qgA = this["poseAligner"]) == null || qgA["alignPoints"](qgr[qgH]["keypoints"]);
    }), qgb["dispose"]();
    let qgQ = [], qgd = [], qgv = [];
    for (let qgl = 0; qgl < this["bodyTracks"]["length"]; qgl++) {
      const qgH = { "center": [this["bodyTracks"][qgl]["center"][0] * qgo, this["bodyTracks"][qgl]["center"][1] * qgR], "top": [this["bodyTracks"][qgl]["top"][0] * qgo, this["bodyTracks"][qgl]["top"][1] * qgR] };
      let qgA = { "center": [qgr[qgl]["center"][0] * qgo, qgr[qgl]["center"][1] * qgR], "top": [qgr[qgl]["top"][0] * qgo, qgr[qgl]["top"][1] * qgR] };
      const qgh = [qgH, qgA]["map"]((qgT) => {
        const { center: qgK, top: qgB } = qgT, qgV = [qgB[0] - qgK[0], qgB[1] - qgK[1]], qgJ = Math["sqrt"](qgV[0] * qgV[0] + qgV[1] * qgV[1]);
        return [[qgK[0] - qgJ, qgK[1] - qgJ], [qgK[0] + qgJ, qgK[1] + qgJ]];
      });
      jo(qgh[0], qgh[1]) > 0.5 && qgr[qgl]["score"] > this["poseScore"] && (qgQ["push"]({ "center": [...qgr[qgl]["center"]], "top": [...qgr[qgl]["top"]] }), qgd["push"](this["poseFilters"][qgl]), qgv["push"](qgr[qgl]));
    }
    return this["bodyTracks"] = qgQ, this["poseFilters"] = qgd, qgv;
  }
  ["setCamera"](qgu, qgj, qgL = 1) {
    var qgI;
    this["angle"] = qgu, this["ratio"] = qgj, this["near"] = qgL, (qgI = this["poseAligner"]) == null || qgI["setCamera"](qgu, qgj, qgL);
  }
  async ["init"](qgu, qgj = "./", qgL = false, qgI = false, qgb = "webgl") {
    const qgR = await jB(qgu, qgj, qgL), qgo = new qgR["ParseLoader"](qgj);
    if (qgL || (await qgo["remove"]("pose.wasm"), await qgo["remove"]("poseutils.wasm")), !await qgo["loadDict"](["pose.wasm", "poseutils.wasm"]) || !await qgo["load"]("pose.wasm") || !qgo["parse"]()) return;
    qM()["set"]("WEBGL_USE_SHAPES_UNIFORMS", true), fP(), await SF(qgb);
    const qgr = { "weightUrlConverter": async (qgy) => qgy, "fetchFunc": async (qgy) => {
      const qgl = new Blob([qgo["file"](qgy)]);
      return fetch(URL["createObjectURL"](qgl));
    } }, qgQ = await rq("bodymodel.def", qgr), qgd = await rq("posemodel.def", qgr);
    if (this["bodyDetector"] = new jF(qgQ), this["poseDetector"] = new jD(qgd, qgI), !await qgo["load"]("poseutils.wasm")) return;
    const qgv = await jV({ "wasmBinary": qgo["data"]() });
    qgo["delete"](), qgv["PoseAligner"]["prototype"]["alignPoints"] = function(qgy) {
      const qgl = new qgv["VectorFloat"](), qgH = new qgv["VectorFloat"](), qgA = new qgv["VectorFloat"](), qgh = new qgv["VectorFloat"]();
      qgy["forEach"]((qgK) => {
        qgl["push_back"](qgK["pixel"][0]), qgl["push_back"](qgK["pixel"][1]), qgl["push_back"](qgK["pixel"][2]), qgH["push_back"](qgK["metric"][0]), qgH["push_back"](qgK["metric"][1]), qgH["push_back"](qgK["metric"][2]), qgA["push_back"](qgK["score"]), qgh["push_back"](qgK["visibility"]);
      });
      const qgT = this["align"](qgl, qgH, qgA, qgh);
      qgy["forEach"]((qgK, qgB) => {
        qgK["metric"] = [qgT["get"](qgB * 3), qgT["get"](qgB * 3 + 1), qgT["get"](qgB * 3 + 2)];
      }), qgl["delete"](), qgH["delete"](), qgA["delete"](), qgh["delete"](), qgT["delete"]();
    }, this["poseModule"] = qgv, this["poseAligner"] = new this["poseModule"]["PoseAligner"](), this["poseAligner"]["setThresh"](this["alignScore"], this["alignVisibility"]);
  }
  ["reset"]() {
    var qgu;
    this["bodyTracks"] = [], this["poseFilters"] = [], this["skipCount"] = this["skipMax"], (qgu = this["poseDetector"]) == null || qgu["reset"]();
  }
  async ["prepare"]() {
    var qgu, qgj;
    qM()["set"]("ENGINE_COMPILE_ONLY", true), await ((qgu = this["bodyDetector"]) == null ? void 0 : qgu["prepare"]()), await ((qgj = this["poseDetector"]) == null ? void 0 : qgj["prepare"]());
    const qgL = SD();
    qgL instanceof JP && (qgL["checkCompileCompletion"](), qgL["getUniformLocations"]()), qM()["set"]("ENGINE_COMPILE_ONLY", false);
  }
  ["dispose"]() {
    var qgu, qgj, qgL;
    this["reset"](), (qgu = this["bodyDetector"]) == null || qgu["dispose"](), delete this["bodyDetector"], (qgj = this["poseDetector"]) == null || qgj["dispose"](), delete this["poseDetector"], (qgL = this["poseAligner"]) == null || qgL["delete"](), delete this["poseAligner"];
  }
};
var q4O = Object["defineProperty"];
var q4W = Object["getOwnPropertySymbols"];
var q4i = Object["prototype"]["hasOwnProperty"];
var q4D = Object["prototype"]["propertyIsEnumerable"];
var q4m = (qgu, qgj, qgL) => qgj in qgu ? q4O(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var q4a = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) q4i["call"](qgj, qgL) && q4m(qgu, qgL, qgj[qgL]);
  if (q4W) {
    for (var qgL of q4W(qgj)) q4D["call"](qgj, qgL) && q4m(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var q4Z = class {
  constructor(qgu) {
    this["model"] = qgu, this["facesMax"] = 3, this["iouThresh"] = 0.3, this["scoreThresh"] = 0.5, this["keypointCount"] = 6, this["model"] = qgu, this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 128, "height": 128 }, this["modelRatio"] = this["modelSize"]["width"] / this["modelSize"]["height"], this["anchorsData"] = this["buildAnchors"](this["modelSize"]), this["anchors"] = zX(this["anchorsData"]), this["size"] = zz([this["modelSize"]["width"], this["modelSize"]["height"]]);
  }
  async ["process"](qgu, qgj) {
    let qgL = { "x": 0, "y": 0 };
    const [qgI, qgb, qgR] = Sq(() => {
      const qgA = { "width": qgu["shape"][2], "height": qgu["shape"][1] }, qgh = qgA["width"] / qgA["height"];
      let qgT = q4a({}, qgA), qgK = { "x": 0, "y": 0 };
      qgh > this["modelRatio"] ? (qgT["height"] = qgA["width"] / this["modelRatio"], qgK["y"] = Math["floor"]((qgT["height"] - qgA["height"]) * 0.5), qgL["y"] = qgK["y"] / qgT["height"]) : qgh < this["modelRatio"] && (qgT["width"] = qgA["height"] * this["modelRatio"], qgK["x"] = Math["floor"]((qgT["width"] - qgA["width"]) * 0.5), qgL["x"] = qgK["x"] / qgT["width"]);
      const qgB = wz(qgu, [[0, 0], [qgK["y"], qgK["y"]], [qgK["x"], qgK["x"]], [0, 0]], 0), qgV = Gq["resizeBilinear"](qgB, [this["modelSize"]["height"], this["modelSize"]["width"]]), qgJ = WY(it(qgV, 2), -1), qgY = zq(this["model"]["execute"](qgJ, "objects")), qgP = DH(qgY, [0, 0], [-1, 1]), qgU = zq(DR(qgP)), qx0 = this["decodeBoxes"](qgY, this["anchors"], this["size"]);
      return [qgY, qx0, qgU];
    }), qgo = await Gq["nonMaxSuppressionAsync"](qgb, qgR, this["facesMax"], this["iouThresh"], this["scoreThresh"]), qgr = await qgo["data"]();
    qgo["dispose"]();
    const qgQ = [];
    for (let qgA = 0; qgA < qgr["length"]; qgA++) {
      const qgh = qgr[qgA];
      qgQ["push"]({ "box": DH(qgb, [qgh, 0], [1, -1]), "score": DH(qgR, qgh, 1), "anchorI": qgh, "points": qgj ? DH(qgI, [qgh, 5], [1, -1]) : void 0 });
    }
    const qgd = await Promise["all"](qgQ["map"](async (qgT) => {
      var qgK, qgB;
      const qgV = await qgT["box"]["data"](), qgJ = await qgT["score"]["data"](), qgY = await ((qgK = qgT["points"]) == null ? void 0 : qgK["data"]());
      return qgT["box"]["dispose"](), qgT["score"]["dispose"](), (qgB = qgT["points"]) == null || qgB["dispose"](), { "box": qgV, "score": qgJ[0], "anchorI": qgT["anchorI"], "points": qgY };
    })), qgv = { "width": 1 - 2 * qgL["x"], "height": 1 - 2 * qgL["y"] };
    qgL["x"] /= qgv["width"], qgL["y"] /= qgv["height"];
    const qgy = this["modelSize"]["width"] * qgv["width"], qgl = this["modelSize"]["height"] * qgv["height"], qgH = [];
    for (let qgT = 0; qgT < qgd["length"]; qgT++) {
      const qgK = qgd[qgT]["box"], qgB = this["anchorsData"][qgd[qgT]["anchorI"]], qgV = qgd[qgT]["points"], qgJ = [];
      for (let qgY = 0; qgY < this["keypointCount"] && qgV; qgY++) qgJ["push"]({ "x": (qgV[qgY * 2 + 0] + qgB[0]) / qgy - qgL["x"], "y": (qgV[qgY * 2 + 1] + qgB[1]) / qgl - qgL["y"] });
      qgH["push"]({ "box": [[qgK[0] / qgy - qgL["x"], qgK[1] / qgl - qgL["y"]], [qgK[2] / qgy - qgL["x"], qgK[3] / qgl - qgL["y"]]], "score": qgd[qgT]["score"], "keypoints": qgV && qgJ });
    }
    return qgI["dispose"](), qgb["dispose"](), qgR["dispose"](), qgH;
  }
  ["decodeBoxes"](qgu, qgj, qgL) {
    const qgI = DH(qgu, [0, 1], [-1, 2]), qgb = WY(qgI, qgj), qgR = DH(qgu, [0, 3], [-1, 2]), qgo = iM(qgR, 2), qgr = ZK(qgb, qgo), qgQ = WY(qgb, qgo);
    return ms([qgr, qgQ], 1);
  }
  ["buildAnchors"](qgu) {
    const qgj = [8, 16], qgL = [2, 6], qgI = [];
    for (let qgb = 0; qgb < qgj["length"]; qgb++) {
      const qgR = qgj[qgb], qgo = Math["floor"]((qgu["height"] + qgR - 1) / qgR), qgr = Math["floor"]((qgu["width"] + qgR - 1) / qgR), qgQ = qgL[qgb];
      for (let qgd = 0; qgd < qgo; qgd++) {
        const qgv = qgR * (qgd + 0.5);
        for (let qgy = 0; qgy < qgr; qgy++) {
          const qgl = qgR * (qgy + 0.5);
          for (let qgH = 0; qgH < qgQ; qgH++) qgI["push"]([qgl, qgv]);
        }
      }
    }
    return qgI;
  }
  async ["prepare"]() {
    const { width: qgu, height: qgj } = this["modelSize"], qgL = wF([1, qgj, qgu, 3]), qgI = this["model"]["execute"](qgL, "objects");
    await qgI["data"](), qgL["dispose"](), qgI["dispose"]();
  }
  ["dispose"]() {
    this["model"]["dispose"](), this["anchors"]["dispose"]();
  }
};
var q4w = ((qgu) => (qgu[qgu["EyeR"] = 0] = "EyeR", qgu[qgu["EyeL"] = 1] = "EyeL", qgu[qgu["Nose"] = 2] = "Nose", qgu[qgu["Mouth"] = 3] = "Mouth", qgu[qgu["EarR"] = 4] = "EarR", qgu[qgu["EarL"] = 5] = "EarL", qgu))(q4w || {});
var q4e = class {
  constructor(qgu) {
    this["model"] = qgu, this["boxFactor"] = 1.5, this["symmetryPoints"] = [13, 168], this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 192, "height": 192 }, this["modelHighP"] = this["model"]["outputs"]["length"] === 7;
  }
  ["process"](qgu, qgj) {
    const qgL = qgj["map"]((qgo) => {
      const { box: qgr, symmetry: qgQ } = qgo, qgd = 0.5 * (this["boxFactor"] - 1), qgv = { "x": qgd * (qgr[1][0] - qgr[0][0]), "y": qgd * (qgr[1][1] - qgr[0][1]) };
      return { "box": [[qgr[0][0] - qgv["x"], qgr[0][1] - qgv["y"]], [qgr[1][0] + qgv["x"], qgr[1][1] + qgv["y"]]], "symmetry": qgQ };
    }), [qgI, qgb] = [qgu["shape"][1], qgu["shape"][2]], { modelSize: qgR } = this;
    return qgL["map"]((qgo) => {
      const { box: qgr, symmetry: qgQ } = qgo, qgd = Math["atan2"]((qgQ[1]["x"] - qgQ[0]["x"]) * qgb, (qgQ[0]["y"] - qgQ[1]["y"]) * qgI), qgv = [0.5 * (qgr[0][0] + qgr[1][0]), 0.5 * (qgr[0][1] + qgr[1][1])], qgy = { "width": qgr[1][0] - qgr[0][0], "height": qgr[1][1] - qgr[0][1] }, qgl = [qgr[0][1] * qgI, qgr[0][0] * qgb, qgr[1][1] * qgI, qgr[1][0] * qgb], qgH = this["rotatedRect"](qgu, qgl, qgd, qgR), qgA = this["modelHighP"] ? ["output_mesh_identity", "output_faceflag", "output_lips", "Identity_1:0", "Identity_5:0", "Identity_2:0", "Identity_6:0"] : ["output_mesh", "output_faceflag"], [qgh, qgT, qgK, qgB, qgV, qgJ, qgY] = this["model"]["execute"](qgH, qgA), qgP = qgh["dataSync"](), qgU = qgT["dataSync"]()[0];
      let qx0 = [];
      for (let qxq = 0; qxq < qgP["length"] / 3; qxq++) qx0["push"]([qgP[qxq * 3 + 0], qgP[qxq * 3 + 1], qgP[qxq * 3 + 2]]);
      if (qgK) {
        const qxn = qgK["dataSync"]();
        q4c(qx0, qxn, q4G);
      }
      if (qgB && qgV) {
        const qxp = qgB["dataSync"](), qxs = qgV["dataSync"]();
        q4c(qx0, qxp, q4N), q4c(qx0, qxs, q4u);
      }
      if (qgJ && qgY) {
        const qxE = qgJ["dataSync"](), qxM = qgY["dataSync"](), qxf = [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173]["map"]((qxF) => qx0[qxF]), qxS = [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398]["map"]((qxF) => qx0[qxF]);
        for (let qxF = 0; qxF < qxE["length"] / 2; qxF++) {
          const qxt = [qxE[qxF * 2 + 0], qxE[qxF * 2 + 1]];
          qx0["push"]([qxt[0], qxt[1], q4X(qxt, qxf)]);
        }
        for (let qxk = 0; qxk < qxM["length"] / 2; qxk++) {
          const qxO = [qxM[qxk * 2 + 0], qxM[qxk * 2 + 1]];
          qx0["push"]([qxO[0], qxO[1], q4X(qxO, qxS)]);
        }
      }
      const qx1 = [qgy["width"] * qgb / qgR["width"], qgy["height"] * qgI / qgR["height"]], qx2 = qx0["map"]((qxW) => [(qxW[0] - qgR["width"] / 2) * qx1[0], (qxW[1] - qgR["height"] / 2) * qx1[1], qxW[2] * qx1[0]]), qx3 = Math["sin"](qgd), qx4 = Math["cos"](qgd), qx5 = qx2["map"]((qxW) => [(qxW[0] * qx4 - qxW[1] * qx3) / qgb + qgv[0], (qxW[0] * qx3 + qxW[1] * qx4) / qgI + qgv[1], qxW[2] / qgb]), qx6 = qx5["map"]((qxW) => qxW[0]), qx7 = qx5["map"]((qxW) => qxW[1]), qx8 = [Math["min"](...qx6), Math["min"](...qx7)], qx9 = [Math["max"](...qx6), Math["max"](...qx7)];
      return qgH["dispose"](), qgh["dispose"](), qgT["dispose"](), qgK == null || qgK["dispose"](), qgB == null || qgB["dispose"](), qgV == null || qgV["dispose"](), qgJ == null || qgJ["dispose"](), qgY == null || qgY["dispose"](), { "keypoints": qx5, "score": qgU, "box": [[qx8[0], qx8[1]], [qx9[0], qx9[1]]] };
    });
  }
  ["rotatedRect"](qgu, qgj, qgL, qgI) {
    const [qgb, qgR] = [qgj[2] - qgj[0], qgj[3] - qgj[1]], [qgo, qgr] = [(qgj[2] + qgj[0]) * 0.5, (qgj[3] + qgj[1]) * 0.5], [qgQ, qgd] = [qgb / qgI["height"], qgR / qgI["width"]], [qgv, qgy] = [Math["cos"](qgL), Math["sin"](qgL)], qgl = [qgv * qgd, -qgy * qgQ, (-qgv * qgR + qgy * qgb) * 0.5 + qgr, qgy * qgd, qgv * qgQ, (-qgy * qgR - qgv * qgb) * 0.5 + qgo, 0, 0];
    return Gq["transform"](qgu, [qgl], "bilinear", "constant", 0, [qgI["height"], qgI["width"]]);
  }
  async ["prepare"]() {
    const { width: qgu, height: qgj } = this["modelSize"], qgL = wF([1, qgj, qgu, 3]), qgI = this["model"]["execute"](qgL);
    await Promise["all"](qgI["map"](async (qgb) => {
      await qgb["data"](), qgb["dispose"]();
    })), qgL["dispose"]();
  }
  ["dispose"]() {
    this["model"]["dispose"]();
  }
};
function q4c(qgu, qgj, qgL) {
  for (let qgI = 0; qgI < qgL["length"]; qgI++) qgu[qgL[qgI]][0] = qgj[qgI * 2 + 0], qgu[qgL[qgI]][1] = qgj[qgI * 2 + 1];
}
function q4X(qgu, qgj) {
  let qgL = 0, qgI = Number["MAX_VALUE"];
  for (let qgb = 0; qgb < qgj["length"]; qgb++) {
    const qgR = [qgj[qgb][0] - qgu[0], qgj[qgb][1] - qgu[1]], qgo = qgR[0] * qgR[0] + qgR[1] * qgR[1];
    qgo < qgI && (qgI = qgo, qgL = qgb);
  }
  return qgj[qgL][2];
}
var q4G = [61, 146, 91, 181, 84, 17, 314, 405, 321, 375, 291, 185, 40, 39, 37, 0, 267, 269, 270, 409, 78, 95, 88, 178, 87, 14, 317, 402, 318, 324, 308, 191, 80, 81, 82, 13, 312, 311, 310, 415, 76, 77, 90, 180, 85, 16, 315, 404, 320, 307, 306, 184, 74, 73, 72, 11, 302, 303, 304, 408, 62, 96, 89, 179, 86, 15, 316, 403, 319, 325, 292, 183, 42, 41, 38, 12, 268, 271, 272, 407];
var q4N = [33, 7, 163, 144, 145, 153, 154, 155, 133, 246, 161, 160, 159, 158, 157, 173, 130, 25, 110, 24, 23, 22, 26, 112, 243, 247, 30, 29, 27, 28, 56, 190, 226, 31, 228, 229, 230, 231, 232, 233, 244, 113, 225, 224, 223, 222, 221, 189, 35, 124, 46, 53, 52, 65, 143, 111, 117, 118, 119, 120, 121, 128, 245, 156, 70, 63, 105, 66, 107, 55, 193];
var q4u = [263, 249, 390, 373, 374, 380, 381, 382, 362, 466, 388, 387, 386, 385, 384, 398, 359, 255, 339, 254, 253, 252, 256, 341, 463, 467, 260, 259, 257, 258, 286, 414, 446, 261, 448, 449, 450, 451, 452, 453, 464, 342, 445, 444, 443, 442, 441, 413, 265, 353, 276, 283, 282, 295, 372, 340, 346, 347, 348, 349, 350, 357, 465, 383, 300, 293, 334, 296, 336, 285, 417];
var q4j = Object["defineProperty"];
var q4L = Object["getOwnPropertySymbols"];
var q4I = Object["prototype"]["hasOwnProperty"];
var q4b = Object["prototype"]["propertyIsEnumerable"];
var q4R = (qgu, qgj, qgL) => qgj in qgu ? q4j(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var q4o = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) q4I["call"](qgj, qgL) && q4R(qgu, qgL, qgj[qgL]);
  if (q4L) {
    for (var qgL of q4L(qgj)) q4b["call"](qgj, qgL) && q4R(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var q4r = class {
  constructor(qgu, qgj = false) {
    this["model"] = qgu, this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 256, "height": 256 }, this["modelRatio"] = this["modelSize"]["width"] / this["modelSize"]["height"], qgj && (this["maskFilter"] = new jW(this["modelSize"]));
  }
  ["process"](qgu, qgj) {
    var qgL, qgI;
    const { modelSize: qgb } = this, qgR = qgu["shape"][2] / qgu["shape"][1], qgo = this["modelRatio"] / qgR, qgr = { "width": qgj[1][0] - qgj[0][0], "height": qgj[1][1] - qgj[0][1] }, qgQ = { "x": (qgj[1][0] + qgj[0][0]) * 0.5, "y": (qgj[1][1] + qgj[0][1]) * 0.5 };
    qgr["width"] / qgr["height"] > qgo ? qgr["height"] = qgr["width"] / qgo : qgr["width"] = qgr["height"] * qgo;
    const qgd = [qgQ["y"] - qgr["height"] * 0.5, qgQ["x"] - qgr["width"] * 0.5, qgQ["y"] + qgr["height"] * 0.5, qgQ["x"] + qgr["width"] * 0.5], qgv = Gq["cropAndResize"](qgu, [qgd], [0], [qgb["height"], qgb["width"]]), qgy = (qgL = this["model"]) == null ? void 0 : qgL["execute"](qgv), qgl = DH(qgy, [0, 0, 0, 1], -1), qgH = zq(qgl), qgA = ((qgI = this["maskFilter"]) == null ? void 0 : qgI["process"](qgH)) || qgH, qgh = it(qgA, 255), qgT = new Uint8Array(qgh["dataSync"]());
    return qgv["dispose"](), qgy["dispose"](), qgl["dispose"](), qgH["dispose"](), qgh["dispose"](), { "buffer": qgT, "size": q4o({}, this["modelSize"]), "box": [[qgd[1], qgd[0]], [qgd[3], qgd[2]]] };
  }
  ["resize"](qgu) {
    var qgj;
    if (this["modelSize"]["width"] === qgu["width"] && this["modelSize"]["height"] === qgu["height"]) return;
    const { model: qgL } = this, qgI = [Math["round"](qgu["height"] / 16), Math["round"](qgu["width"] / 16)];
    qgL["weights"]["up_sampling2d/mul"][0] = zz([qgI[0] * 2, qgI[1] * 2], "int32"), qgL["weights"]["up_sampling2d_1/mul"][0] = zz([qgI[0] * 4, qgI[1] * 4], "int32"), qgL["weights"]["up_sampling2d_2/mul"][0] = zz([qgI[0] * 8, qgI[1] * 8], "int32"), qgL["weights"]["segment/stack/1"][0] = zz([qgI[0] * 16], "int32"), qgL["weights"]["segment/stack/2"][0] = zz([qgI[1] * 16], "int32");
    const qgb = qgL["executor"];
    qgb["_inputs"][0]["attrParams"]["shape"]["value"][1] = qgI[0] * 16, qgb["_inputs"][0]["attrParams"]["shape"]["value"][2] = qgI[1] * 16;
    const qgR = qgL["executor"]["graph"]["nodes"], qgo = (qgr, qgQ) => {
      const qgd = qgR[qgr]["attrParams"];
      qgd["kernelSize"]["value"][1] = qgQ[0], qgd["kernelSize"]["value"][2] = qgQ[1], qgd["strides"]["value"][1] = qgQ[0], qgd["strides"]["value"][2] = qgQ[1];
    };
    qgo("average_pooling2d/AvgPool", [qgI[0] * 4, qgI[1] * 4]), qgo("average_pooling2d_1/AvgPool", [qgI[0], qgI[1]]), qgo("average_pooling2d_2/AvgPool", [qgI[0], qgI[1]]), qgo("average_pooling2d_3/AvgPool", [qgI[0], qgI[1]]), qgo("average_pooling2d_4/AvgPool", [qgI[0], qgI[1]]), qgo("average_pooling2d_5/AvgPool", [qgI[0], qgI[1]]), qgo("average_pooling2d_6/AvgPool", [qgI[0], qgI[1]]), qgo("average_pooling2d_7/AvgPool", [qgI[0] * 2, qgI[1] * 2]), qgo("average_pooling2d_8/AvgPool", [qgI[0] * 4, qgI[1] * 4]), qgo("average_pooling2d_9/AvgPool", [qgI[0] * 8, qgI[1] * 8]), this["modelSize"] = qgu, this["modelRatio"] = qgu["width"] / qgu["height"], (qgj = this["maskFilter"]) == null || qgj["resize"](this["modelSize"]);
  }
  ["size"]() {
    return this["modelSize"];
  }
  ["reset"]() {
    var qgu;
    (qgu = this["maskFilter"]) == null || qgu["reset"]();
  }
  async ["prepare"]() {
    var qgu;
    const { width: qgj, height: qgL } = this["modelSize"], qgI = wF([1, qgL, qgj, 3]), qgb = this["model"]["execute"](qgI), qgR = DH(qgb, [0, 0, 0, 1], -1), qgo = zq(qgR);
    await (((qgu = this["maskFilter"]) == null ? void 0 : qgu["process"](qgo)) || qgo)["data"](), qgI["dispose"](), qgb["dispose"](), qgR["dispose"](), qgo["dispose"]();
  }
  ["dispose"]() {
    var qgu;
    this["model"]["dispose"](), (qgu = this["maskFilter"]) == null || qgu["dispose"](), delete this["maskFilter"];
  }
};
var q4Q = (() => {
  var qgu = typeof document != "undefined" && document["currentScript"] ? document["currentScript"]["src"] : void 0;
  return function(qgj = {}) {
    var qgL = qgj, qgI, qgb;
    qgL["ready"] = new Promise((qEw, qEe) => {
      qgI = qEw, qgb = qEe;
    });
    var qgR = Object["assign"]({}, qgL), qgo = true, qgr = "";
    function qgQ(qEw) {
      return qgL["locateFile"] ? qgL["locateFile"](qEw, qgr) : qgr + qEw;
    }
    typeof document != "undefined" && document["currentScript"] && (qgr = document["currentScript"]["src"]), qgu && (qgr = qgu), qgr["startsWith"]("blob:") ? qgr = "" : qgr = qgr["substr"](0, qgr["replace"](/[?#].*/, "")["lastIndexOf"]("/") + 1), qgL["print"] || console["log"]["bind"](console);
    var qgd = qgL["printErr"] || console["error"]["bind"](console);
    Object["assign"](qgL, qgR), qgR = null, qgL["arguments"] && qgL["arguments"], qgL["thisProgram"] && qgL["thisProgram"], qgL["quit"] && qgL["quit"];
    var qgv;
    qgL["wasmBinary"] && (qgv = qgL["wasmBinary"]);
    var qgy, qgl = false, qgH, qgA, qgh, qgT, qgK, qgB, qgV, qgJ;
    function qgY() {
      var qEw = qgy["buffer"];
      qgL["HEAP8"] = qgH = new Int8Array(qEw), qgL["HEAP16"] = qgh = new Int16Array(qEw), qgL["HEAPU8"] = qgA = new Uint8Array(qEw), qgL["HEAPU16"] = qgT = new Uint16Array(qEw), qgL["HEAP32"] = qgK = new Int32Array(qEw), qgL["HEAPU32"] = qgB = new Uint32Array(qEw), qgL["HEAPF32"] = qgV = new Float32Array(qEw), qgL["HEAPF64"] = qgJ = new Float64Array(qEw);
    }
    var qgP = [], qgU = [], qx0 = [];
    function qx1() {
      if (qgL["preRun"]) {
        for (typeof qgL["preRun"] == "function" && (qgL["preRun"] = [qgL["preRun"]]); qgL["preRun"]["length"]; ) qx4(qgL["preRun"]["shift"]());
      }
      qxk(qgP);
    }
    function qx2() {
      qxk(qgU);
    }
    function qx3() {
      if (qgL["postRun"]) {
        for (typeof qgL["postRun"] == "function" && (qgL["postRun"] = [qgL["postRun"]]); qgL["postRun"]["length"]; ) qx6(qgL["postRun"]["shift"]());
      }
      qxk(qx0);
    }
    function qx4(qEw) {
      qgP["unshift"](qEw);
    }
    function qx5(qEw) {
      qgU["unshift"](qEw);
    }
    function qx6(qEw) {
      qx0["unshift"](qEw);
    }
    var qx7 = 0, qx8 = null;
    function qx9(qEw) {
      var qEe;
      qx7++, (qEe = qgL["monitorRunDependencies"]) == null || qEe["call"](qgL, qx7);
    }
    function qxq(qEw) {
      var qEe;
      if (qx7--, (qEe = qgL["monitorRunDependencies"]) == null || qEe["call"](qgL, qx7), qx7 == 0 && qx8) {
        var qEz = qx8;
        qx8 = null, qEz();
      }
    }
    function qxn(qEw) {
      var qEe;
      (qEe = qgL["onAbort"]) == null || qEe["call"](qgL, qEw), qEw = "Aborted(" + qEw + ")", qgd(qEw), qgl = true, qEw += ". Build with -sASSERTIONS for more info.";
      var qEz = new WebAssembly["RuntimeError"](qEw);
      throw qgb(qEz), qEz;
    }
    var qxp = "data:application/octet-stream;base64,", qxs = (qEw) => qEw["startsWith"](qxp), qxE;
    qxE = "faceutils.wasm", qxs(qxE) || (qxE = qgQ(qxE));
    function qxM(qEw) {
      if (qEw == qxE && qgv) return new Uint8Array(qgv);
      throw "both async and sync fetching of the wasm failed";
    }
    function qxf(qEw) {
      return !qgv && qgo && typeof fetch == "function" ? fetch(qEw, { "credentials": "same-origin" })["then"]((qEe) => {
        if (!qEe["ok"]) throw "failed to load wasm binary file at '" + qEw + "'";
        return qEe["arrayBuffer"]();
      })["catch"](() => qxM(qEw)) : Promise["resolve"]()["then"](() => qxM(qEw));
    }
    function qxS(qEw, qEe, qEz) {
      return qxf(qEw)["then"]((qEc) => WebAssembly["instantiate"](qEc, qEe))["then"](qEz, (qEc) => {
        qgd("failed to asynchronously prepare wasm: " + qEc), qxn(qEc);
      });
    }
    function qxF(qEw, qEe, qEz, qEc) {
      return !qEw && typeof WebAssembly["instantiateStreaming"] == "function" && !qxs(qEe) && typeof fetch == "function" ? fetch(qEe, { "credentials": "same-origin" })["then"]((qEX) => {
        var qEG = WebAssembly["instantiateStreaming"](qEX, qEz);
        return qEG["then"](qEc, function(qEN) {
          return qgd("wasm streaming compile failed: " + qEN), qgd("falling back to ArrayBuffer instantiation"), qxS(qEe, qEz, qEc);
        });
      }) : qxS(qEe, qEz, qEc);
    }
    function qxt() {
      var qEw = { "a": qEk };
      function qEe(qEc, qEX) {
        return qEO = qEc["exports"], qgy = qEO["y"], qgY(), qsi = qEO["C"], qx5(qEO["z"]), qxq(), qEO;
      }
      qx9();
      function qEz(qEc) {
        qEe(qEc["instance"]);
      }
      if (qgL["instantiateWasm"]) try {
        return qgL["instantiateWasm"](qEw, qEe);
      } catch (qEc) {
        qgd("Module.instantiateWasm callback failed with error: " + qEc), qgb(qEc);
      }
      return qxF(qgv, qxE, qEw, qEz)["catch"](qgb), {};
    }
    var qxk = (qEw) => {
      for (; qEw["length"] > 0; ) qEw["shift"]()(qgL);
    };
    qgL["noExitRuntime"];
    class qxO {
      constructor(qEw) {
        this["excPtr"] = qEw, this["ptr"] = qEw - 24;
      }
      ["set_type"](qEw) {
        qgB[this["ptr"] + 4 >> 2] = qEw;
      }
      ["get_type"]() {
        return qgB[this["ptr"] + 4 >> 2];
      }
      ["set_destructor"](qEw) {
        qgB[this["ptr"] + 8 >> 2] = qEw;
      }
      ["get_destructor"]() {
        return qgB[this["ptr"] + 8 >> 2];
      }
      ["set_caught"](qEw) {
        qEw = qEw ? 1 : 0, qgH[this["ptr"] + 12] = qEw;
      }
      ["get_caught"]() {
        return qgH[this["ptr"] + 12] != 0;
      }
      ["set_rethrown"](qEw) {
        qEw = qEw ? 1 : 0, qgH[this["ptr"] + 13] = qEw;
      }
      ["get_rethrown"]() {
        return qgH[this["ptr"] + 13] != 0;
      }
      ["init"](qEw, qEe) {
        this["set_adjusted_ptr"](0), this["set_type"](qEw), this["set_destructor"](qEe);
      }
      ["set_adjusted_ptr"](qEw) {
        qgB[this["ptr"] + 16 >> 2] = qEw;
      }
      ["get_adjusted_ptr"]() {
        return qgB[this["ptr"] + 16 >> 2];
      }
      ["get_exception_ptr"]() {
        var qEw = qEm(this["get_type"]());
        if (qEw) return qgB[this["excPtr"] >> 2];
        var qEe = this["get_adjusted_ptr"]();
        return qEe !== 0 ? qEe : this["excPtr"];
      }
    }
    var qxW = 0, qxi = (qEw, qEe, qEz) => {
      var qEc = new qxO(qEw);
      throw qEc["init"](qEe, qEz), qxW = qEw, qxW;
    }, qxD = {}, qxm = (qEw) => {
      for (; qEw["length"]; ) {
        var qEe = qEw["pop"](), qEz = qEw["pop"]();
        qEz(qEe);
      }
    };
    function qxa(qEw) {
      return this["fromWireType"](qgB[qEw >> 2]);
    }
    var qxZ = {}, qxw = {}, qxe = {}, qxz, qxc = (qEw) => {
      throw new qxz(qEw);
    }, qxX = (qEw, qEe, qEz) => {
      qEw["forEach"](function(qEu) {
        qxe[qEu] = qEe;
      });
      function qEc(qEu) {
        var qEj = qEz(qEu);
        qEj["length"] !== qEw["length"] && qxc("Mismatched type converter count");
        for (var qEL = 0; qEL < qEw["length"]; ++qEL) qxQ(qEw[qEL], qEj[qEL]);
      }
      var qEX = new Array(qEe["length"]), qEG = [], qEN = 0;
      qEe["forEach"]((qEu, qEj) => {
        qxw["hasOwnProperty"](qEu) ? qEX[qEj] = qxw[qEu] : (qEG["push"](qEu), qxZ["hasOwnProperty"](qEu) || (qxZ[qEu] = []), qxZ[qEu]["push"](() => {
          qEX[qEj] = qxw[qEu], ++qEN, qEN === qEG["length"] && qEc(qEX);
        }));
      }), qEG["length"] === 0 && qEc(qEX);
    }, qxG = (qEw) => {
      var qEe = qxD[qEw];
      delete qxD[qEw];
      var qEz = qEe["elements"], qEc = qEz["length"], qEX = qEz["map"]((qEu) => qEu["getterReturnType"])["concat"](qEz["map"]((qEu) => qEu["setterArgumentType"])), qEG = qEe["rawConstructor"], qEN = qEe["rawDestructor"];
      qxX([qEw], qEX, (qEu) => (qEz["forEach"]((qEj, qEL) => {
        var qEI = qEu[qEL], qEb = qEj["getter"], qER = qEj["getterContext"], qEo = qEu[qEL + qEc], qEr = qEj["setter"], qEQ = qEj["setterContext"];
        qEj["read"] = (qEd) => qEI["fromWireType"](qEb(qER, qEd)), qEj["write"] = (qEd, qEv) => {
          var qEy = [];
          qEr(qEQ, qEd, qEo["toWireType"](qEy, qEv)), qxm(qEy);
        };
      }), [{ "name": qEe["name"], "fromWireType": (qEj) => {
        for (var qEL = new Array(qEc), qEI = 0; qEI < qEc; ++qEI) qEL[qEI] = qEz[qEI]["read"](qEj);
        return qEN(qEj), qEL;
      }, "toWireType": (qEj, qEL) => {
        if (qEc !== qEL["length"]) throw new TypeError("Incorrect number of tuple elements for " + qEe["name"] + ": expected=" + qEc + ", actual=" + qEL["length"]);
        for (var qEI = qEG(), qEb = 0; qEb < qEc; ++qEb) qEz[qEb]["write"](qEI, qEL[qEb]);
        return qEj !== null && qEj["push"](qEN, qEI), qEI;
      }, "argPackAdvance": qxd, "readValueFromPointer": qxa, "destructorFunction": qEN }]));
    }, qxN = {}, qxu = (qEw) => {
      var qEe = qxN[qEw];
      delete qxN[qEw];
      var qEz = qEe["rawConstructor"], qEc = qEe["rawDestructor"], qEX = qEe["fields"], qEG = qEX["map"]((qEN) => qEN["getterReturnType"])["concat"](qEX["map"]((qEN) => qEN["setterArgumentType"]));
      qxX([qEw], qEG, (qEN) => {
        var qEu = {};
        return qEX["forEach"]((qEj, qEL) => {
          var qEI = qEj["fieldName"], qEb = qEN[qEL], qER = qEj["getter"], qEo = qEj["getterContext"], qEr = qEN[qEL + qEX["length"]], qEQ = qEj["setter"], qEd = qEj["setterContext"];
          qEu[qEI] = { "read": (qEv) => qEb["fromWireType"](qER(qEo, qEv)), "write": (qEv, qEy) => {
            var qEC = [];
            qEQ(qEd, qEv, qEr["toWireType"](qEC, qEy)), qxm(qEC);
          } };
        }), [{ "name": qEe["name"], "fromWireType": (qEj) => {
          var qEL = {};
          for (var qEI in qEu) qEL[qEI] = qEu[qEI]["read"](qEj);
          return qEc(qEj), qEL;
        }, "toWireType": (qEj, qEL) => {
          for (var qEI in qEu) if (!(qEI in qEL)) throw new TypeError('Missing field: "' + qEI + '"');
          var qEb = qEz();
          for (qEI in qEu) qEu[qEI]["write"](qEb, qEL[qEI]);
          return qEj !== null && qEj["push"](qEc, qEb), qEb;
        }, "argPackAdvance": qxd, "readValueFromPointer": qxa, "destructorFunction": qEc }];
      });
    }, qxj = (qEw, qEe, qEz, qEc, qEX) => {
    }, qxL = () => {
      for (var qEw = new Array(256), qEe = 0; qEe < 256; ++qEe) qEw[qEe] = String["fromCharCode"](qEe);
      qxI = qEw;
    }, qxI, qxb = (qEw) => {
      for (var qEe = "", qEz = qEw; qgA[qEz]; ) qEe += qxI[qgA[qEz++]];
      return qEe;
    }, qxR, qxo = (qEw) => {
      throw new qxR(qEw);
    };
    function qxr(qEw, qEe, qEz = {}) {
      var qEc = qEe["name"];
      if (qEw || qxo('type "' + qEc + '" must have a positive integer typeid pointer'), qxw["hasOwnProperty"](qEw)) {
        if (qEz["ignoreDuplicateRegistrations"]) return;
        qxo("Cannot register type '" + qEc + "' twice");
      }
      if (qxw[qEw] = qEe, delete qxe[qEw], qxZ["hasOwnProperty"](qEw)) {
        var qEX = qxZ[qEw];
        delete qxZ[qEw], qEX["forEach"]((qEG) => qEG());
      }
    }
    function qxQ(qEw, qEe, qEz = {}) {
      if (!("argPackAdvance" in qEe)) throw new TypeError("registerType registeredInstance requires argPackAdvance");
      return qxr(qEw, qEe, qEz);
    }
    var qxd = 8, qxv = (qEw, qEe, qEz, qEc) => {
      qEe = qxb(qEe), qxQ(qEw, { "name": qEe, "fromWireType": function(qEX) {
        return !!qEX;
      }, "toWireType": function(qEX, qEG) {
        return qEG ? qEz : qEc;
      }, "argPackAdvance": qxd, "readValueFromPointer": function(qEX) {
        return this["fromWireType"](qgA[qEX]);
      }, "destructorFunction": null });
    }, qxy = (qEw) => ({ "count": qEw["count"], "deleteScheduled": qEw["deleteScheduled"], "preservePointerOnDelete": qEw["preservePointerOnDelete"], "ptr": qEw["ptr"], "ptrType": qEw["ptrType"], "smartPtr": qEw["smartPtr"], "smartPtrType": qEw["smartPtrType"] }), qxC = (qEw) => {
      function qEe(qEz) {
        return qEz["$$"]["ptrType"]["registeredClass"]["name"];
      }
      qxo(qEe(qEw) + " instance already deleted");
    }, qxl = false, qxH = (qEw) => {
    }, qxA = (qEw) => {
      qEw["smartPtr"] ? qEw["smartPtrType"]["rawDestructor"](qEw["smartPtr"]) : qEw["ptrType"]["registeredClass"]["rawDestructor"](qEw["ptr"]);
    }, qxh = (qEw) => {
      qEw["count"]["value"] -= 1;
      var qEe = qEw["count"]["value"] === 0;
      qEe && qxA(qEw);
    }, qxT = (qEw, qEe, qEz) => {
      if (qEe === qEz) return qEw;
      if (qEz["baseClass"] === void 0) return null;
      var qEc = qxT(qEw, qEe, qEz["baseClass"]);
      return qEc === null ? null : qEz["downcast"](qEc);
    }, qxK = {}, qxB = () => Object["keys"](qs1)["length"], qxV = () => {
      var qEw = [];
      for (var qEe in qs1) qs1["hasOwnProperty"](qEe) && qEw["push"](qs1[qEe]);
      return qEw;
    }, qxJ = [], qxY = () => {
      for (; qxJ["length"]; ) {
        var qEw = qxJ["pop"]();
        qEw["$$"]["deleteScheduled"] = false, qEw["delete"]();
      }
    }, qxP, qxU = (qEw) => {
      qxP = qEw, qxJ["length"] && qxP && qxP(qxY);
    }, qs0 = () => {
      qgL["getInheritedInstanceCount"] = qxB, qgL["getLiveInheritedInstances"] = qxV, qgL["flushPendingDeletes"] = qxY, qgL["setDelayFunction"] = qxU;
    }, qs1 = {}, qs2 = (qEw, qEe) => {
      for (qEe === void 0 && qxo("ptr should not be undefined"); qEw["baseClass"]; ) qEe = qEw["upcast"](qEe), qEw = qEw["baseClass"];
      return qEe;
    }, qs3 = (qEw, qEe) => (qEe = qs2(qEw, qEe), qs1[qEe]), qs4 = (qEw, qEe) => {
      (!qEe["ptrType"] || !qEe["ptr"]) && qxc("makeClassHandle requires ptr and ptrType");
      var qEz = !!qEe["smartPtrType"], qEc = !!qEe["smartPtr"];
      return qEz !== qEc && qxc("Both smartPtrType and smartPtr must be specified"), qEe["count"] = { "value": 1 }, qs6(Object["create"](qEw, { "$$": { "value": qEe, "writable": true } }));
    };
    function qs5(qEw) {
      var qEe = this["getPointee"](qEw);
      if (!qEe) return this["destructor"](qEw), null;
      var qEz = qs3(this["registeredClass"], qEe);
      if (qEz !== void 0) {
        if (qEz["$$"]["count"]["value"] === 0) return qEz["$$"]["ptr"] = qEe, qEz["$$"]["smartPtr"] = qEw, qEz["clone"]();
        var qEc = qEz["clone"]();
        return this["destructor"](qEw), qEc;
      }
      function qEX() {
        return this["isSmartPointer"] ? qs4(this["registeredClass"]["instancePrototype"], { "ptrType": this["pointeeType"], "ptr": qEe, "smartPtrType": this, "smartPtr": qEw }) : qs4(this["registeredClass"]["instancePrototype"], { "ptrType": this, "ptr": qEw });
      }
      var qEG = this["registeredClass"]["getActualType"](qEe), qEN = qxK[qEG];
      if (!qEN) return qEX["call"](this);
      var qEu;
      this["isConst"] ? qEu = qEN["constPointerType"] : qEu = qEN["pointerType"];
      var qEj = qxT(qEe, this["registeredClass"], qEu["registeredClass"]);
      return qEj === null ? qEX["call"](this) : this["isSmartPointer"] ? qs4(qEu["registeredClass"]["instancePrototype"], { "ptrType": qEu, "ptr": qEj, "smartPtrType": this, "smartPtr": qEw }) : qs4(qEu["registeredClass"]["instancePrototype"], { "ptrType": qEu, "ptr": qEj });
    }
    var qs6 = (qEw) => typeof FinalizationRegistry == "undefined" ? (qs6 = (qEe) => qEe, qEw) : (qxl = new FinalizationRegistry((qEe) => {
      qxh(qEe["$$"]);
    }), qs6 = (qEe) => {
      var qEz = qEe["$$"], qEc = !!qEz["smartPtr"];
      if (qEc) {
        var qEX = { "$$": qEz };
        qxl["register"](qEe, qEX, qEe);
      }
      return qEe;
    }, qxH = (qEe) => qxl["unregister"](qEe), qs6(qEw)), qs7 = () => {
      Object["assign"](qs8["prototype"], { "isAliasOf"(qEw) {
        if (!(this instanceof qs8) || !(qEw instanceof qs8)) return false;
        var qEe = this["$$"]["ptrType"]["registeredClass"], qEz = this["$$"]["ptr"];
        qEw["$$"] = qEw["$$"];
        for (var qEc = qEw["$$"]["ptrType"]["registeredClass"], qEX = qEw["$$"]["ptr"]; qEe["baseClass"]; ) qEz = qEe["upcast"](qEz), qEe = qEe["baseClass"];
        for (; qEc["baseClass"]; ) qEX = qEc["upcast"](qEX), qEc = qEc["baseClass"];
        return qEe === qEc && qEz === qEX;
      }, "clone"() {
        if (this["$$"]["ptr"] || qxC(this), this["$$"]["preservePointerOnDelete"]) return this["$$"]["count"]["value"] += 1, this;
        var qEw = qs6(Object["create"](Object["getPrototypeOf"](this), { "$$": { "value": qxy(this["$$"]) } }));
        return qEw["$$"]["count"]["value"] += 1, qEw["$$"]["deleteScheduled"] = false, qEw;
      }, "delete"() {
        this["$$"]["ptr"] || qxC(this), this["$$"]["deleteScheduled"] && !this["$$"]["preservePointerOnDelete"] && qxo("Object already scheduled for deletion"), qxH(this), qxh(this["$$"]), this["$$"]["preservePointerOnDelete"] || (this["$$"]["smartPtr"] = void 0, this["$$"]["ptr"] = void 0);
      }, "isDeleted"() {
        return !this["$$"]["ptr"];
      }, "deleteLater"() {
        return this["$$"]["ptr"] || qxC(this), this["$$"]["deleteScheduled"] && !this["$$"]["preservePointerOnDelete"] && qxo("Object already scheduled for deletion"), qxJ["push"](this), qxJ["length"] === 1 && qxP && qxP(qxY), this["$$"]["deleteScheduled"] = true, this;
      } });
    };
    function qs8() {
    }
    var qs9 = (qEw, qEe) => Object["defineProperty"](qEe, "name", { "value": qEw }), qsq = (qEw, qEe, qEz) => {
      if (qEw[qEe]["overloadTable"] === void 0) {
        var qEc = qEw[qEe];
        qEw[qEe] = function(...qEX) {
          return qEw[qEe]["overloadTable"]["hasOwnProperty"](qEX["length"]) || qxo("Function '" + qEz + "' called with an invalid number of arguments (" + qEX["length"] + ") - expects one of (" + qEw[qEe]["overloadTable"] + ")!"), qEw[qEe]["overloadTable"][qEX["length"]]["apply"](this, qEX);
        }, qEw[qEe]["overloadTable"] = [], qEw[qEe]["overloadTable"][qEc["argCount"]] = qEc;
      }
    }, qsn = (qEw, qEe, qEz) => {
      qgL["hasOwnProperty"](qEw) ? (qxo("Cannot register public name '" + qEw + "' twice"), qsq(qgL, qEw, qEw), qgL["hasOwnProperty"](qEz) && qxo("Cannot register multiple overloads of a function with the same number of arguments (" + qEz + ")!"), qgL[qEw]["overloadTable"][qEz] = qEe) : qgL[qEw] = qEe;
    }, qsp = 48, qsg = 57, qsx = (qEw) => {
      if (qEw === void 0) return "_unknown";
      qEw = qEw["replace"](/[^a-zA-Z0-9_]/g, "$");
      var qEe = qEw["charCodeAt"](0);
      return qEe >= qsp && qEe <= qsg ? "_" + qEw : qEw;
    };
    function qss(qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu) {
      this["name"] = qEw, this["constructor"] = qEe, this["instancePrototype"] = qEz, this["rawDestructor"] = qEc, this["baseClass"] = qEX, this["getActualType"] = qEG, this["upcast"] = qEN, this["downcast"] = qEu, this["pureVirtualFunctions"] = [];
    }
    var qsE = (qEw, qEe, qEz) => {
      for (; qEe !== qEz; ) qEe["upcast"] || qxo("Expected null or instance of " + qEz["name"] + ", got an instance of " + qEe["name"]), qEw = qEe["upcast"](qEw), qEe = qEe["baseClass"];
      return qEw;
    };
    function qsM(qEw, qEe) {
      if (qEe === null) return this["isReference"] && qxo("null is not a valid " + this["name"]), 0;
      qEe["$$"] || qxo('Cannot pass "' + qsH(qEe) + '" as a ' + this["name"]), qEe["$$"]["ptr"] || qxo("Cannot pass deleted object as a pointer of type " + this["name"]);
      var qEz = qEe["$$"]["ptrType"]["registeredClass"], qEc = qsE(qEe["$$"]["ptr"], qEz, this["registeredClass"]);
      return qEc;
    }
    function qsf(qEw, qEe) {
      var qEz;
      if (qEe === null) return this["isReference"] && qxo("null is not a valid " + this["name"]), this["isSmartPointer"] ? (qEz = this["rawConstructor"](), qEw !== null && qEw["push"](this["rawDestructor"], qEz), qEz) : 0;
      (!qEe || !qEe["$$"]) && qxo('Cannot pass "' + qsH(qEe) + '" as a ' + this["name"]), qEe["$$"]["ptr"] || qxo("Cannot pass deleted object as a pointer of type " + this["name"]), !this["isConst"] && qEe["$$"]["ptrType"]["isConst"] && qxo("Cannot convert argument of type " + (qEe["$$"]["smartPtrType"] ? qEe["$$"]["smartPtrType"]["name"] : qEe["$$"]["ptrType"]["name"]) + " to parameter type " + this["name"]);
      var qEc = qEe["$$"]["ptrType"]["registeredClass"];
      if (qEz = qsE(qEe["$$"]["ptr"], qEc, this["registeredClass"]), this["isSmartPointer"]) switch (qEe["$$"]["smartPtr"] === void 0 && qxo("Passing raw pointer to smart pointer is illegal"), this["sharingPolicy"]) {
        case 0:
          qEe["$$"]["smartPtrType"] === this ? qEz = qEe["$$"]["smartPtr"] : qxo("Cannot convert argument of type " + (qEe["$$"]["smartPtrType"] ? qEe["$$"]["smartPtrType"]["name"] : qEe["$$"]["ptrType"]["name"]) + " to parameter type " + this["name"]);
          break;
        case 1:
          qEz = qEe["$$"]["smartPtr"];
          break;
        case 2:
          if (qEe["$$"]["smartPtrType"] === this) qEz = qEe["$$"]["smartPtr"];
          else {
            var qEX = qEe["clone"]();
            qEz = this["rawShare"](qEz, qsy["toHandle"](() => qEX["delete"]())), qEw !== null && qEw["push"](this["rawDestructor"], qEz);
          }
          break;
        default:
          qxo("Unsupporting sharing policy");
      }
      return qEz;
    }
    function qsS(qEw, qEe) {
      if (qEe === null) return this["isReference"] && qxo("null is not a valid " + this["name"]), 0;
      qEe["$$"] || qxo('Cannot pass "' + qsH(qEe) + '" as a ' + this["name"]), qEe["$$"]["ptr"] || qxo("Cannot pass deleted object as a pointer of type " + this["name"]), qEe["$$"]["ptrType"]["isConst"] && qxo("Cannot convert argument of type " + qEe["$$"]["ptrType"]["name"] + " to parameter type " + this["name"]);
      var qEz = qEe["$$"]["ptrType"]["registeredClass"], qEc = qsE(qEe["$$"]["ptr"], qEz, this["registeredClass"]);
      return qEc;
    }
    var qsF = () => {
      Object["assign"](qst["prototype"], { "getPointee"(qEw) {
        return this["rawGetPointee"] && (qEw = this["rawGetPointee"](qEw)), qEw;
      }, "destructor"(qEw) {
        var qEe;
        (qEe = this["rawDestructor"]) == null || qEe["call"](this, qEw);
      }, "argPackAdvance": qxd, "readValueFromPointer": qxa, "fromWireType": qs5 });
    };
    function qst(qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj, qEL, qEI) {
      this["name"] = qEw, this["registeredClass"] = qEe, this["isReference"] = qEz, this["isConst"] = qEc, this["isSmartPointer"] = qEX, this["pointeeType"] = qEG, this["sharingPolicy"] = qEN, this["rawGetPointee"] = qEu, this["rawConstructor"] = qEj, this["rawShare"] = qEL, this["rawDestructor"] = qEI, !qEX && qEe["baseClass"] === void 0 ? qEc ? (this["toWireType"] = qsM, this["destructorFunction"] = null) : (this["toWireType"] = qsS, this["destructorFunction"] = null) : this["toWireType"] = qsf;
    }
    var qsk = (qEw, qEe, qEz) => {
      qgL["hasOwnProperty"](qEw) || qxc("Replacing nonexistent public symbol"), qgL[qEw]["overloadTable"] !== void 0 && qEz !== void 0 ? qgL[qEw]["overloadTable"][qEz] = qEe : (qgL[qEw] = qEe, qgL[qEw]["argCount"] = qEz);
    }, qsO = (qEw, qEe, qEz) => {
      var qEc = qgL["dynCall_" + qEw];
      return qEc(qEe, ...qEz);
    }, qsW = [], qsi, qsD = (qEw) => {
      var qEe = qsW[qEw];
      return qEe || (qEw >= qsW["length"] && (qsW["length"] = qEw + 1), qsW[qEw] = qEe = qsi["get"](qEw)), qEe;
    }, qsm = (qEw, qEe, qEz = []) => {
      if (qEw["includes"]("j")) return qsO(qEw, qEe, qEz);
      var qEc = qsD(qEe)(...qEz);
      return qEc;
    }, qsa = (qEw, qEe) => (...qEz) => qsm(qEw, qEe, qEz), qsZ = (qEw, qEe) => {
      qEw = qxb(qEw);
      function qEz() {
        return qEw["includes"]("j") ? qsa(qEw, qEe) : qsD(qEe);
      }
      var qEc = qEz();
      return typeof qEc != "function" && qxo("unknown function pointer with signature " + qEw + ": " + qEe), qEc;
    }, qsw = (qEw, qEe) => {
      var qEz = qs9(qEe, function(qEc) {
        this["name"] = qEe, this["message"] = qEc;
        var qEX = new Error(qEc)["stack"];
        qEX !== void 0 && (this["stack"] = this["toString"]() + "\n" + qEX["replace"](/^Error(:[^\n]*)?\n/, ""));
      });
      return qEz["prototype"] = Object["create"](qEw["prototype"]), qEz["prototype"]["constructor"] = qEz, qEz["prototype"]["toString"] = function() {
        return this["message"] === void 0 ? this["name"] : this["name"] + ": " + this["message"];
      }, qEz;
    }, qse, qsz = (qEw) => {
      var qEe = qED(qEw), qEz = qxb(qEe);
      return qEW(qEe), qEz;
    }, qsc = (qEw, qEe) => {
      var qEz = [], qEc = {};
      function qEX(qEG) {
        if (!qEc[qEG] && !qxw[qEG]) {
          if (qxe[qEG]) {
            qxe[qEG]["forEach"](qEX);
            return;
          }
          qEz["push"](qEG), qEc[qEG] = true;
        }
      }
      throw qEe["forEach"](qEX), new qse(qEw + ": " + qEz["map"](qsz)["join"]([", "]));
    }, qsX = (qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj, qEL, qEI, qEb, qER) => {
      qEI = qxb(qEI), qEG = qsZ(qEX, qEG), qEu && (qEu = qsZ(qEN, qEu)), qEL && (qEL = qsZ(qEj, qEL)), qER = qsZ(qEb, qER);
      var qEo = qsx(qEI);
      qsn(qEo, function() {
        qsc("Cannot construct " + qEI + " due to unbound types", [qEc]);
      }), qxX([qEw, qEe, qEz], qEc ? [qEc] : [], (qEr) => {
        var qEQ;
        qEr = qEr[0];
        var qEd, qEv;
        qEc ? (qEd = qEr["registeredClass"], qEv = qEd["instancePrototype"]) : qEv = qs8["prototype"];
        var qEy = qs9(qEI, function(...qET) {
          if (Object["getPrototypeOf"](this) !== qEC) throw new qxR("Use 'new' to construct " + qEI);
          if (qEl["constructor_body"] === void 0) throw new qxR(qEI + " has no accessible constructor");
          var qEK = qEl["constructor_body"][qET["length"]];
          if (qEK === void 0) throw new qxR("Tried to invoke ctor of " + qEI + " with invalid number of parameters (" + qET["length"] + ") - expected (" + Object["keys"](qEl["constructor_body"])["toString"]() + ") parameters instead!");
          return qEK["apply"](this, qET);
        }), qEC = Object["create"](qEv, { "constructor": { "value": qEy } });
        qEy["prototype"] = qEC;
        var qEl = new qss(qEI, qEy, qEC, qER, qEd, qEG, qEu, qEL);
        qEl["baseClass"] && ((qEQ = qEl["baseClass"])["__derivedClasses"] != null || (qEQ["__derivedClasses"] = []), qEl["baseClass"]["__derivedClasses"]["push"](qEl));
        var qEH = new qst(qEI, qEl, true, false, false), qEA = new qst(qEI + "*", qEl, false, false, false), qEh = new qst(qEI + " const*", qEl, false, true, false);
        return qxK[qEw] = { "pointerType": qEA, "constPointerType": qEh }, qsk(qEo, qEy), [qEH, qEA, qEh];
      });
    }, qsG = (qEw, qEe) => {
      for (var qEz = [], qEc = 0; qEc < qEw; qEc++) qEz["push"](qgB[qEe + qEc * 4 >> 2]);
      return qEz;
    };
    function qsN(qEw) {
      for (var qEe = 1; qEe < qEw["length"]; ++qEe) if (qEw[qEe] !== null && qEw[qEe]["destructorFunction"] === void 0) return true;
      return false;
    }
    function qsu(qEw, qEe, qEz, qEc, qEX, qEG) {
      var qEN = qEe["length"];
      qEN < 2 && qxo("argTypes array size mismatch! Must at least get return value and 'this' types!");
      var qEu = qEe[1] !== null && qEz !== null, qEj = qsN(qEe), qEL = qEe[0]["name"] !== "void", qEI = qEN - 2, qEb = new Array(qEI), qER = [], qEo = [], qEr = function(...qEQ) {
        qEQ["length"] !== qEI && qxo("function " + qEw + " called with " + qEQ["length"] + " arguments, expected " + qEI), qEo["length"] = 0;
        var qEd;
        qER["length"] = qEu ? 2 : 1, qER[0] = qEX, qEu && (qEd = qEe[1]["toWireType"](qEo, this), qER[1] = qEd);
        for (var qEv = 0; qEv < qEI; ++qEv) qEb[qEv] = qEe[qEv + 2]["toWireType"](qEo, qEQ[qEv]), qER["push"](qEb[qEv]);
        var qEy = qEc(...qER);
        function qEC(qEl) {
          if (qEj) qxm(qEo);
          else for (var qEH = qEu ? 1 : 2; qEH < qEe["length"]; qEH++) {
            var qEA = qEH === 1 ? qEd : qEb[qEH - 2];
            qEe[qEH]["destructorFunction"] !== null && qEe[qEH]["destructorFunction"](qEA);
          }
          if (qEL) return qEe[0]["fromWireType"](qEl);
        }
        return qEC(qEy);
      };
      return qs9(qEw, qEr);
    }
    var qsj = (qEw, qEe, qEz, qEc, qEX, qEG) => {
      var qEN = qsG(qEe, qEz);
      qEX = qsZ(qEc, qEX), qxX([], [qEw], (qEu) => {
        qEu = qEu[0];
        var qEj = "constructor " + qEu["name"];
        if (qEu["registeredClass"]["constructor_body"] === void 0 && (qEu["registeredClass"]["constructor_body"] = []), qEu["registeredClass"]["constructor_body"][qEe - 1] !== void 0) throw new qxR("Cannot register multiple constructors with identical number of parameters (" + (qEe - 1) + ") for class '" + qEu["name"] + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
        return qEu["registeredClass"]["constructor_body"][qEe - 1] = () => {
          qsc("Cannot construct " + qEu["name"] + " due to unbound types", qEN);
        }, qxX([], qEN, (qEL) => (qEL["splice"](1, 0, null), qEu["registeredClass"]["constructor_body"][qEe - 1] = qsu(qEj, qEL, null, qEX, qEG), [])), [];
      });
    }, qsL = (qEw) => {
      qEw = qEw["trim"]();
      const qEe = qEw["indexOf"]("(");
      return qEe !== -1 ? qEw["substr"](0, qEe) : qEw;
    }, qsI = (qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj) => {
      var qEL = qsG(qEz, qEc);
      qEe = qxb(qEe), qEe = qsL(qEe), qEG = qsZ(qEX, qEG), qxX([], [qEw], (qEI) => {
        qEI = qEI[0];
        var qEb = qEI["name"] + "." + qEe;
        qEe["startsWith"]("@@") && (qEe = Symbol[qEe["substring"](2)]), qEu && qEI["registeredClass"]["pureVirtualFunctions"]["push"](qEe);
        function qER() {
          qsc("Cannot call " + qEb + " due to unbound types", qEL);
        }
        var qEo = qEI["registeredClass"]["instancePrototype"], qEr = qEo[qEe];
        return qEr === void 0 || qEr["overloadTable"] === void 0 && qEr["className"] !== qEI["name"] && qEr["argCount"] === qEz - 2 ? (qER["argCount"] = qEz - 2, qER["className"] = qEI["name"], qEo[qEe] = qER) : (qsq(qEo, qEe, qEb), qEo[qEe]["overloadTable"][qEz - 2] = qER), qxX([], qEL, (qEQ) => {
          var qEd = qsu(qEb, qEQ, qEI, qEG, qEN);
          return qEo[qEe]["overloadTable"] === void 0 ? (qEd["argCount"] = qEz - 2, qEo[qEe] = qEd) : qEo[qEe]["overloadTable"][qEz - 2] = qEd, [];
        }), [];
      });
    }, qsb = (qEw, qEe, qEz) => (qEw instanceof Object || qxo(qEz + ' with invalid "this": ' + qEw), qEw instanceof qEe["registeredClass"]["constructor"] || qxo(qEz + ' incompatible with "this" of type ' + qEw["constructor"]["name"]), qEw["$$"]["ptr"] || qxo("cannot call emscripten binding method " + qEz + " on deleted object"), qsE(qEw["$$"]["ptr"], qEw["$$"]["ptrType"]["registeredClass"], qEe["registeredClass"])), qsR = (qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj, qEL) => {
      qEe = qxb(qEe), qEX = qsZ(qEc, qEX), qxX([], [qEw], (qEI) => {
        qEI = qEI[0];
        var qEb = qEI["name"] + "." + qEe, qER = { "get"() {
          qsc("Cannot access " + qEb + " due to unbound types", [qEz, qEN]);
        }, "enumerable": true, "configurable": true };
        return qEj ? qER["set"] = () => qsc("Cannot access " + qEb + " due to unbound types", [qEz, qEN]) : qER["set"] = (qEo) => qxo(qEb + " is a read-only property"), Object["defineProperty"](qEI["registeredClass"]["instancePrototype"], qEe, qER), qxX([], qEj ? [qEz, qEN] : [qEz], (qEo) => {
          var qEr = qEo[0], qEQ = { "get"() {
            var qEv = qsb(this, qEI, qEb + " getter");
            return qEr["fromWireType"](qEX(qEG, qEv));
          }, "enumerable": true };
          if (qEj) {
            qEj = qsZ(qEu, qEj);
            var qEd = qEo[1];
            qEQ["set"] = function(qEv) {
              var qEy = qsb(this, qEI, qEb + " setter"), qEC = [];
              qEj(qEL, qEy, qEd["toWireType"](qEC, qEv)), qxm(qEC);
            };
          }
          return Object["defineProperty"](qEI["registeredClass"]["instancePrototype"], qEe, qEQ), [];
        }), [];
      });
    }, qso = [], qsr = [], qsQ = (qEw) => {
      qEw > 9 && --qsr[qEw + 1] === 0 && (qsr[qEw] = void 0, qso["push"](qEw));
    }, qsd = () => qsr["length"] / 2 - 5 - qso["length"], qsv = () => {
      qsr["push"](0, 1, void 0, 1, null, 1, true, 1, false, 1), qgL["count_emval_handles"] = qsd;
    }, qsy = { "toValue": (qEw) => (qEw || qxo("Cannot use deleted val. handle = " + qEw), qsr[qEw]), "toHandle": (qEw) => {
      switch (qEw) {
        case void 0:
          return 2;
        case null:
          return 4;
        case true:
          return 6;
        case false:
          return 8;
        default: {
          const qEe = qso["pop"]() || qsr["length"];
          return qsr[qEe] = qEw, qsr[qEe + 1] = 1, qEe;
        }
      }
    } }, qsC = { "name": "emscripten::val", "fromWireType": (qEw) => {
      var qEe = qsy["toValue"](qEw);
      return qsQ(qEw), qEe;
    }, "toWireType": (qEw, qEe) => qsy["toHandle"](qEe), "argPackAdvance": qxd, "readValueFromPointer": qxa, "destructorFunction": null }, qsl = (qEw) => qxQ(qEw, qsC), qsH = (qEw) => {
      if (qEw === null) return "null";
      var qEe = typeof qEw;
      return qEe === "object" || qEe === "array" || qEe === "function" ? qEw["toString"]() : "" + qEw;
    }, qsA = (qEw, qEe) => {
      switch (qEe) {
        case 4:
          return function(qEz) {
            return this["fromWireType"](qgV[qEz >> 2]);
          };
        case 8:
          return function(qEz) {
            return this["fromWireType"](qgJ[qEz >> 3]);
          };
        default:
          throw new TypeError("invalid float width (" + qEe + "): " + qEw);
      }
    }, qsh = (qEw, qEe, qEz) => {
      qEe = qxb(qEe), qxQ(qEw, { "name": qEe, "fromWireType": (qEc) => qEc, "toWireType": (qEc, qEX) => qEX, "argPackAdvance": qxd, "readValueFromPointer": qsA(qEe, qEz), "destructorFunction": null });
    }, qsT = (qEw, qEe, qEz) => {
      switch (qEe) {
        case 1:
          return qEz ? (qEc) => qgH[qEc] : (qEc) => qgA[qEc];
        case 2:
          return qEz ? (qEc) => qgh[qEc >> 1] : (qEc) => qgT[qEc >> 1];
        case 4:
          return qEz ? (qEc) => qgK[qEc >> 2] : (qEc) => qgB[qEc >> 2];
        default:
          throw new TypeError("invalid integer width (" + qEe + "): " + qEw);
      }
    }, qsK = (qEw, qEe, qEz, qEc, qEX) => {
      qEe = qxb(qEe);
      var qEG = (qEI) => qEI;
      if (qEc === 0) {
        var qEN = 32 - 8 * qEz;
        qEG = (qEI) => qEI << qEN >>> qEN;
      }
      var qEu = qEe["includes"]("unsigned"), qEj = (qEI, qEb) => {
      }, qEL;
      qEu ? qEL = function(qEI, qEb) {
        return qEj(qEb, this["name"]), qEb >>> 0;
      } : qEL = function(qEI, qEb) {
        return qEj(qEb, this["name"]), qEb;
      }, qxQ(qEw, { "name": qEe, "fromWireType": qEG, "toWireType": qEL, "argPackAdvance": qxd, "readValueFromPointer": qsT(qEe, qEz, qEc !== 0), "destructorFunction": null });
    }, qsB = (qEw, qEe, qEz) => {
      var qEc = [Int8Array, Uint8Array, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], qEX = qEc[qEe];
      function qEG(qEN) {
        var qEu = qgB[qEN >> 2], qEj = qgB[qEN + 4 >> 2];
        return new qEX(qgH["buffer"], qEj, qEu);
      }
      qEz = qxb(qEz), qxQ(qEw, { "name": qEz, "fromWireType": qEG, "argPackAdvance": qxd, "readValueFromPointer": qEG }, { "ignoreDuplicateRegistrations": true });
    }, qsV = (qEw, qEe, qEz, qEc) => {
      if (!(qEc > 0)) return 0;
      for (var qEX = qEz, qEG = qEz + qEc - 1, qEN = 0; qEN < qEw["length"]; ++qEN) {
        var qEu = qEw["charCodeAt"](qEN);
        if (qEu >= 55296 && qEu <= 57343) {
          var qEj = qEw["charCodeAt"](++qEN);
          qEu = 65536 + ((qEu & 1023) << 10) | qEj & 1023;
        }
        if (qEu <= 127) {
          if (qEz >= qEG) break;
          qEe[qEz++] = qEu;
        } else {
          if (qEu <= 2047) {
            if (qEz + 1 >= qEG) break;
            qEe[qEz++] = 192 | qEu >> 6, qEe[qEz++] = 128 | qEu & 63;
          } else {
            if (qEu <= 65535) {
              if (qEz + 2 >= qEG) break;
              qEe[qEz++] = 224 | qEu >> 12, qEe[qEz++] = 128 | qEu >> 6 & 63, qEe[qEz++] = 128 | qEu & 63;
            } else {
              if (qEz + 3 >= qEG) break;
              qEe[qEz++] = 240 | qEu >> 18, qEe[qEz++] = 128 | qEu >> 12 & 63, qEe[qEz++] = 128 | qEu >> 6 & 63, qEe[qEz++] = 128 | qEu & 63;
            }
          }
        }
      }
      return qEe[qEz] = 0, qEz - qEX;
    }, qsJ = (qEw, qEe, qEz) => qsV(qEw, qgA, qEe, qEz), qsY = (qEw) => {
      for (var qEe = 0, qEz = 0; qEz < qEw["length"]; ++qEz) {
        var qEc = qEw["charCodeAt"](qEz);
        qEc <= 127 ? qEe++ : qEc <= 2047 ? qEe += 2 : qEc >= 55296 && qEc <= 57343 ? (qEe += 4, ++qEz) : qEe += 3;
      }
      return qEe;
    }, qsP = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0, qsU = (qEw, qEe, qEz) => {
      for (var qEc = qEe + qEz, qEX = qEe; qEw[qEX] && !(qEX >= qEc); ) ++qEX;
      if (qEX - qEe > 16 && qEw["buffer"] && qsP) return qsP["decode"](qEw["subarray"](qEe, qEX));
      for (var qEG = ""; qEe < qEX; ) {
        var qEN = qEw[qEe++];
        if (!(qEN & 128)) {
          qEG += String["fromCharCode"](qEN);
          continue;
        }
        var qEu = qEw[qEe++] & 63;
        if ((qEN & 224) == 192) {
          qEG += String["fromCharCode"]((qEN & 31) << 6 | qEu);
          continue;
        }
        var qEj = qEw[qEe++] & 63;
        if ((qEN & 240) == 224 ? qEN = (qEN & 15) << 12 | qEu << 6 | qEj : qEN = (qEN & 7) << 18 | qEu << 12 | qEj << 6 | qEw[qEe++] & 63, qEN < 65536) qEG += String["fromCharCode"](qEN);
        else {
          var qEL = qEN - 65536;
          qEG += String["fromCharCode"](55296 | qEL >> 10, 56320 | qEL & 1023);
        }
      }
      return qEG;
    }, qE0 = (qEw, qEe) => qEw ? qsU(qgA, qEw, qEe) : "", qE1 = (qEw, qEe) => {
      qEe = qxb(qEe);
      var qEz = qEe === "std::string";
      qxQ(qEw, { "name": qEe, "fromWireType"(qEc) {
        var qEX = qgB[qEc >> 2], qEG = qEc + 4, qEN;
        if (qEz) for (var qEu = qEG, qEj = 0; qEj <= qEX; ++qEj) {
          var qEL = qEG + qEj;
          if (qEj == qEX || qgA[qEL] == 0) {
            var qEI = qEL - qEu, qEb = qE0(qEu, qEI);
            qEN === void 0 ? qEN = qEb : (qEN += "\0", qEN += qEb), qEu = qEL + 1;
          }
        }
        else {
          for (var qER = new Array(qEX), qEj = 0; qEj < qEX; ++qEj) qER[qEj] = String["fromCharCode"](qgA[qEG + qEj]);
          qEN = qER["join"]("");
        }
        return qEW(qEc), qEN;
      }, "toWireType"(qEc, qEX) {
        qEX instanceof ArrayBuffer && (qEX = new Uint8Array(qEX));
        var qEG, qEN = typeof qEX == "string";
        qEN || qEX instanceof Uint8Array || qEX instanceof Uint8ClampedArray || qEX instanceof Int8Array || qxo("Cannot pass non-string to std::string"), qEz && qEN ? qEG = qsY(qEX) : qEG = qEX["length"];
        var qEu = qEi(4 + qEG + 1), qEj = qEu + 4;
        if (qgB[qEu >> 2] = qEG, qEz && qEN) qsJ(qEX, qEj, qEG + 1);
        else {
          if (qEN) for (var qEL = 0; qEL < qEG; ++qEL) {
            var qEI = qEX["charCodeAt"](qEL);
            qEI > 255 && (qEW(qEj), qxo("String has UTF-16 code units that do not fit in 8 bits")), qgA[qEj + qEL] = qEI;
          }
          else {
            for (var qEL = 0; qEL < qEG; ++qEL) qgA[qEj + qEL] = qEX[qEL];
          }
        }
        return qEc !== null && qEc["push"](qEW, qEu), qEu;
      }, "argPackAdvance": qxd, "readValueFromPointer": qxa, "destructorFunction"(qEc) {
        qEW(qEc);
      } });
    }, qE2 = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0, qE3 = (qEw, qEe) => {
      for (var qEz = qEw, qEc = qEz >> 1, qEX = qEc + qEe / 2; !(qEc >= qEX) && qgT[qEc]; ) ++qEc;
      if (qEz = qEc << 1, qEz - qEw > 32 && qE2) return qE2["decode"](qgA["subarray"](qEw, qEz));
      for (var qEG = "", qEN = 0; !(qEN >= qEe / 2); ++qEN) {
        var qEu = qgh[qEw + qEN * 2 >> 1];
        if (qEu == 0) break;
        qEG += String["fromCharCode"](qEu);
      }
      return qEG;
    }, qE4 = (qEw, qEe, qEz) => {
      if (qEz != null || (qEz = 2147483647), qEz < 2) return 0;
      qEz -= 2;
      for (var qEc = qEe, qEX = qEz < qEw["length"] * 2 ? qEz / 2 : qEw["length"], qEG = 0; qEG < qEX; ++qEG) {
        var qEN = qEw["charCodeAt"](qEG);
        qgh[qEe >> 1] = qEN, qEe += 2;
      }
      return qgh[qEe >> 1] = 0, qEe - qEc;
    }, qE5 = (qEw) => qEw["length"] * 2, qE6 = (qEw, qEe) => {
      for (var qEz = 0, qEc = ""; !(qEz >= qEe / 4); ) {
        var qEX = qgK[qEw + qEz * 4 >> 2];
        if (qEX == 0) break;
        if (++qEz, qEX >= 65536) {
          var qEG = qEX - 65536;
          qEc += String["fromCharCode"](55296 | qEG >> 10, 56320 | qEG & 1023);
        } else qEc += String["fromCharCode"](qEX);
      }
      return qEc;
    }, qE7 = (qEw, qEe, qEz) => {
      if (qEz != null || (qEz = 2147483647), qEz < 4) return 0;
      for (var qEc = qEe, qEX = qEc + qEz - 4, qEG = 0; qEG < qEw["length"]; ++qEG) {
        var qEN = qEw["charCodeAt"](qEG);
        if (qEN >= 55296 && qEN <= 57343) {
          var qEu = qEw["charCodeAt"](++qEG);
          qEN = 65536 + ((qEN & 1023) << 10) | qEu & 1023;
        }
        if (qgK[qEe >> 2] = qEN, qEe += 4, qEe + 4 > qEX) break;
      }
      return qgK[qEe >> 2] = 0, qEe - qEc;
    }, qE8 = (qEw) => {
      for (var qEe = 0, qEz = 0; qEz < qEw["length"]; ++qEz) {
        var qEc = qEw["charCodeAt"](qEz);
        qEc >= 55296 && qEc <= 57343 && ++qEz, qEe += 4;
      }
      return qEe;
    }, qE9 = (qEw, qEe, qEz) => {
      qEz = qxb(qEz);
      var qEc, qEX, qEG, qEN;
      qEe === 2 ? (qEc = qE3, qEX = qE4, qEN = qE5, qEG = (qEu) => qgT[qEu >> 1]) : qEe === 4 && (qEc = qE6, qEX = qE7, qEN = qE8, qEG = (qEu) => qgB[qEu >> 2]), qxQ(qEw, { "name": qEz, "fromWireType": (qEu) => {
        for (var qEj = qgB[qEu >> 2], qEL, qEI = qEu + 4, qEb = 0; qEb <= qEj; ++qEb) {
          var qER = qEu + 4 + qEb * qEe;
          if (qEb == qEj || qEG(qER) == 0) {
            var qEo = qER - qEI, qEr = qEc(qEI, qEo);
            qEL === void 0 ? qEL = qEr : (qEL += "\0", qEL += qEr), qEI = qER + qEe;
          }
        }
        return qEW(qEu), qEL;
      }, "toWireType": (qEu, qEj) => {
        typeof qEj != "string" && qxo("Cannot pass non-string to C++ string type " + qEz);
        var qEL = qEN(qEj), qEI = qEi(4 + qEL + qEe);
        return qgB[qEI >> 2] = qEL / qEe, qEX(qEj, qEI + 4, qEL + qEe), qEu !== null && qEu["push"](qEW, qEI), qEI;
      }, "argPackAdvance": qxd, "readValueFromPointer": qxa, "destructorFunction"(qEu) {
        qEW(qEu);
      } });
    }, qEq = (qEw, qEe, qEz, qEc, qEX, qEG) => {
      qxD[qEw] = { "name": qxb(qEe), "rawConstructor": qsZ(qEz, qEc), "rawDestructor": qsZ(qEX, qEG), "elements": [] };
    }, qEn = (qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj) => {
      qxD[qEw]["elements"]["push"]({ "getterReturnType": qEe, "getter": qsZ(qEz, qEc), "getterContext": qEX, "setterArgumentType": qEG, "setter": qsZ(qEN, qEu), "setterContext": qEj });
    }, qEp = (qEw, qEe, qEz, qEc, qEX, qEG) => {
      qxN[qEw] = { "name": qxb(qEe), "rawConstructor": qsZ(qEz, qEc), "rawDestructor": qsZ(qEX, qEG), "fields": [] };
    }, qEg = (qEw, qEe, qEz, qEc, qEX, qEG, qEN, qEu, qEj, qEL) => {
      qxN[qEw]["fields"]["push"]({ "fieldName": qxb(qEe), "getterReturnType": qEz, "getter": qsZ(qEc, qEX), "getterContext": qEG, "setterArgumentType": qEN, "setter": qsZ(qEu, qEj), "setterContext": qEL });
    }, qEx = (qEw, qEe) => {
      qEe = qxb(qEe), qxQ(qEw, { "isVoid": true, "name": qEe, "argPackAdvance": 0, "fromWireType": () => {
      }, "toWireType": (qEz, qEc) => {
      } });
    }, qEs = (qEw, qEe) => {
      var qEz = qxw[qEw];
      return qEz === void 0 && qxo(qEe + " has unknown type " + qsz(qEw)), qEz;
    }, qEE = (qEw, qEe) => {
      qEw = qEs(qEw, "_emval_take_value");
      var qEz = qEw["readValueFromPointer"](qEe);
      return qsy["toHandle"](qEz);
    }, qEM = () => {
      qxn("");
    }, qEf = (qEw, qEe, qEz) => qgA["copyWithin"](qEw, qEe, qEe + qEz), qES = () => 2147483648, qEF = (qEw) => {
      var qEe = qgy["buffer"], qEz = (qEw - qEe["byteLength"] + 65535) / 65536;
      try {
        return qgy["grow"](qEz), qgY(), 1;
      } catch (qEc) {
      }
    }, qEt = (qEw) => {
      var qEe = qgA["length"];
      qEw >>>= 0;
      var qEz = qES();
      if (qEw > qEz) return false;
      for (var qEc = (qEj, qEL) => qEj + (qEL - qEj % qEL) % qEL, qEX = 1; qEX <= 4; qEX *= 2) {
        var qEG = qEe * (1 + 0.2 / qEX);
        qEG = Math["min"](qEG, qEw + 100663296);
        var qEN = Math["min"](qEz, qEc(Math["max"](qEw, qEG), 65536)), qEu = qEF(qEN);
        if (qEu) return true;
      }
      return false;
    };
    qxz = qgL["InternalError"] = class extends Error {
      constructor(qEw) {
        super(qEw), this["name"] = "InternalError";
      }
    }, qxL(), qxR = qgL["BindingError"] = class extends Error {
      constructor(qEw) {
        super(qEw), this["name"] = "BindingError";
      }
    }, qs7(), qs0(), qsF(), qse = qgL["UnboundTypeError"] = qsw(Error, "UnboundTypeError"), qsv();
    var qEk = { "b": qxi, "h": qxG, "x": qxu, "q": qxj, "v": qxv, "l": qsX, "g": qsj, "c": qsI, "f": qsR, "u": qsl, "n": qsh, "e": qsK, "a": qsB, "m": qE1, "j": qE9, "i": qEq, "d": qEn, "o": qEp, "k": qEg, "w": qEx, "p": qEE, "r": qEM, "t": qEf, "s": qEt }, qEO = qxt(), qEW = (qEw) => (qEW = qEO["A"])(qEw), qEi = (qEw) => (qEi = qEO["B"])(qEw), qED = (qEw) => (qED = qEO["D"])(qEw), qEm = (qEw) => (qEm = qEO["E"])(qEw), qEa;
    qx8 = function qEw() {
      qEa || qEZ(), qEa || (qx8 = qEw);
    };
    function qEZ() {
      if (qx7 > 0 || (qx1(), qx7 > 0)) return;
      function qEe() {
        qEa || (qEa = true, qgL["calledRun"] = true, !qgl && (qx2(), qgI(qgL), qgL["onRuntimeInitialized"] && qgL["onRuntimeInitialized"](), qx3()));
      }
      qgL["setStatus"] ? (qgL["setStatus"]("Running..."), setTimeout(function() {
        setTimeout(function() {
          qgL["setStatus"]("");
        }, 1), qEe();
      }, 1)) : qEe();
    }
    if (qgL["preInit"]) {
      for (typeof qgL["preInit"] == "function" && (qgL["preInit"] = [qgL["preInit"]]); qgL["preInit"]["length"] > 0; ) qgL["preInit"]["pop"]()();
    }
    return qEZ(), qgj["ready"];
  };
})();
var q4d = class {
  constructor() {
    this["faceTracks"] = [], this["faceFilters"] = [], this["meshScore"] = 0.9, this["maskSize"] = 256;
  }
  async ["process"](qgu, qgj) {
    var qgL, qgI, qgb, qgR, qgo;
    const qgr = Sq(() => {
      const qgH = OM(OK(qgu, 3), "float32"), qgA = it(qgH, 1 / 255);
      return ZM(qgA, 0);
    });
    let qgQ = [];
    this["faceTracks"]["length"] === 0 && (qgQ = await ((qgL = this["faceDetector"]) == null ? void 0 : qgL["process"](qgr, true)) || [], qgQ["forEach"]((qgH) => {
      if (!qgH["keypoints"]) return;
      const { box: qgA } = qgH, qgh = 0.5 * 0.3 * (qgH["box"][1][1] - qgH["box"][0][1]);
      this["faceTracks"]["push"]({ "box": [[qgA[0][0], qgA[0][1] - qgh], [qgA[1][0], qgA[1][1] + qgh]], "symmetry": [qgH["keypoints"][q4w["Mouth"]], qgH["keypoints"][q4w["Nose"]]] }), this["faceFilters"]["push"](new this["faceModule"]["FaceFilter"]({ "minCutOff": 1, "minCutOffD": 2, "beta": 30 }, { "minCutOff": 1, "minCutOffD": 2, "beta": 30 }, 1));
    }), (qgI = this["bodySegmenter"]) == null || qgI["reset"]());
    const qgd = this["faceTracks"]["length"] > 0 ? ((qgb = this["meshDetector"]) == null ? void 0 : qgb["process"](qgr, this["faceTracks"])) || [] : [], qgv = [], qgy = [], qgl = [];
    for (let qgH = 0; qgH < this["faceTracks"]["length"]; qgH++) {
      const qgA = qgd[qgH], { box: qgh } = qgA, qgT = [qgA["keypoints"][((qgR = this["meshDetector"]) == null ? void 0 : qgR["symmetryPoints"][0]) || 0], qgA["keypoints"][((qgo = this["meshDetector"]) == null ? void 0 : qgo["symmetryPoints"][1]) || 0]];
      if (jo(this["faceTracks"][qgH]["box"], qgh) > 0.5 && qgA["score"] > this["meshScore"]) {
        if (qgl["push"](qgA), qgv["push"]({ "box": qgh, "symmetry": [{ "x": qgT[0][0], "y": qgT[0][1] }, { "x": qgT[1][0], "y": qgT[1][1] }] }), qgj === void 0) continue;
        const [qgK, qgB] = [qgr["shape"][1], qgr["shape"][2]], [qgV, qgJ] = [qgh[1][0] - qgh[0][0], qgh[1][1] - qgh[0][1]], qgY = (qgV + qgJ * qgB / qgK) * 0.5;
        this["faceFilters"][qgH]["smoothFilter"](qgA, qgj, 1 / qgY), qgA["keypoints"] = this["faceFilters"][qgH]["smoothPixel"](), qgA["box"] = this["faceFilters"][qgH]["smoothBox"]();
        const { bodySegmenter: qgP, maskExt: qgU } = this;
        if (qgP) {
          const qx0 = qgP["size"](), qx1 = qgB / qgK, qx2 = qx0["width"] / qx0["height"] / qx1, qx3 = qx2 < 1 ? { "width": qx2, "height": 1 } : { "width": 1, "height": 1 / qx2 }, qx4 = [0.5 * (qgh[0][0] + qgh[1][0]), 0.5 * (qgh[0][1] + qgh[1][1])], qx5 = qgU ? [[qgh[0][0] - qgV * qgU, qgh[0][1] - qgJ * qgU], [qgh[1][0] + qgV * qgU, qgh[1][1] + qgJ * qgU]] : [[qx4[0] - 0.5 * qx3["width"], qx4[1] - 0.5 * qx3["height"]], [qx4[0] + 0.5 * qx3["width"], qx4[1] + 0.5 * qx3["height"]]];
          qx5[0][0] < 0 && (qx5[1][0] -= qx5[0][0], qx5[0][0] = 0), qx5[0][1] < 0 && (qx5[1][1] -= qx5[0][1], qx5[0][1] = 0), qx5[1][0] > 1 && (qx5[0][0] -= qx5[1][0] - 1, qx5[1][0] = 1), qx5[1][1] > 1 && (qx5[0][1] -= qx5[1][1] - 1, qx5[1][1] = 1), qx5[0][0] < 0 && (qx5[0][0] *= 0.5, qx5[1][0] -= qx5[0][0]), qx5[0][1] < 0 && (qx5[0][1] *= 0.5, qx5[1][1] -= qx5[0][1]), qgA["mask"] = qgP["process"](qgr, qx5);
        }
        qgy["push"](this["faceFilters"][qgH]);
      } else this["faceFilters"][qgH]["delete"]();
    }
    return qgr["dispose"](), this["faceTracks"] = qgv, this["faceFilters"] = qgy, qgl;
  }
  ["align"](qgu) {
    var qgj;
    const qgL = new this["faceModule"]["VectorFloat"]();
    return qgu["flat"]()["forEach"]((qgI) => qgL["push_back"](qgI)), (qgj = this["faceAligner"]) == null || qgj["align"](qgL), qgL["delete"](), this["alignTransform"]();
  }
  ["alignTransform"]() {
    if (!this["faceAligner"]) return;
    const qgu = this["faceAligner"]["rotation"], qgj = this["faceAligner"]["translation"], qgL = this["faceAligner"]["scale"], qgI = this["faceAligner"]["shapeScale"];
    return { "rotation": [qgu[0], qgu[1], qgu[2], qgu[3]], "translation": [qgj[0], qgj[1], qgj[2]], "scale": qgL, "shapeScale": [qgI[0], qgI[1], qgI[2]] };
  }
  ["metricPoints"]() {
    if (!this["faceAligner"]) return;
    let qgu = [];
    const qgj = this["faceAligner"]["metricPoints"]();
    for (let qgL = 0; qgL < qgj["size"](); qgL += 3) qgu["push"]([qgj["get"](qgL + 0), qgj["get"](qgL + 1), qgj["get"](qgL + 2)]);
    return qgj["delete"](), qgu;
  }
  ["referencePoints"]() {
    if (!this["faceAligner"]) return;
    let qgu = [];
    const qgj = this["faceAligner"]["referencePoints"]();
    for (let qgL = 0; qgL < qgj["size"](); qgL += 3) qgu["push"]([qgj["get"](qgL + 0), qgj["get"](qgL + 1), qgj["get"](qgL + 2)]);
    return qgj["delete"](), qgu;
  }
  ["backprojPoints"]() {
    if (!this["faceAligner"]) return;
    let qgu = [];
    const qgj = this["faceAligner"]["backprojPoints"]();
    for (let qgL = 0; qgL < qgj["size"](); qgL += 3) qgu["push"]([qgj["get"](qgL + 0), qgj["get"](qgL + 1), qgj["get"](qgL + 2)]);
    return qgj["delete"](), qgu;
  }
  ["setCamera"](qgu, qgj, qgL) {
    var qgI;
    if ((qgI = this["faceAligner"]) == null || qgI["setCamera"](qgu, qgj, qgL), this["bodySegmenter"] && !this["maskExt"]) {
      const qgb = this["maskSize"] / 16, [qgR, qgo] = qgj > 1 ? [qgb, Math["round"](qgb / qgj)] : [Math["round"](qgb * qgj), qgb];
      this["bodySegmenter"]["resize"]({ "width": qgR * 16, "height": qgo * 16 });
    }
  }
  async ["init"](qgu, qgj = "./", qgL = false, qgI = false, qgb = false, qgR, qgo = 256, qgr = "webgl") {
    const qgQ = await jB(qgu, qgj, qgL), qgd = new qgQ["ParseLoader"](qgj), [qgv, qgy] = qgI ? ["faceext.wasm", "meshextmodel.def"] : ["face.wasm", "meshmodel.def"], qgl = [qgv, "faceutils.wasm"];
    if (qgb && qgl["push"]("mask.wasm"), !qgL) {
      for (const qgB of qgl) await qgd["remove"](qgB);
    }
    if (!await qgd["loadDict"](qgl) || !await qgd["load"](qgv) || !qgd["parse"]()) return;
    qM()["set"]("WEBGL_USE_SHAPES_UNIFORMS", true), fP(), await SF(qgr);
    const qgH = { "weightUrlConverter": async (qgV) => qgV, "fetchFunc": async (qgV) => {
      const qgJ = new Blob([qgd["file"](qgV)]);
      return fetch(URL["createObjectURL"](qgJ));
    } }, qgA = await rq("facemodel.def", qgH), qgh = await rq(qgy, qgH), qgT = qgb && await qgd["load"]("mask.wasm") && qgd["parse"]() && await rq("maskmodel.def", qgH);
    if (this["faceDetector"] = new q4Z(qgA), this["meshDetector"] = new q4e(qgh), qgT && (this["bodySegmenter"] = new q4r(qgT, typeof qgb == "object" && qgb["smooth"]), this["bodySegmenter"]["resize"]({ "width": qgo, "height": qgo }), this["maskSize"] = this["bodySegmenter"]["size"]()["width"], this["maskExt"] = qgR), !await qgd["load"]("faceutils.wasm")) return;
    const qgK = await q4Q({ "wasmBinary": qgd["data"]() });
    qgd["delete"](), qgK["FaceFilter"]["prototype"]["smoothFilter"] = function(qgV, qgJ) {
      const qgY = new qgK["VectorFloat"](), qgP = new qgK["VectorFloat"]();
      qgV["keypoints"]["flat"]()["forEach"]((qgU) => qgY["push_back"](qgU)), qgV["box"]["flat"]()["forEach"]((qgU) => qgP["push_back"](qgU)), this["filter"](qgY, qgP, qgV["score"], qgJ, 1), qgY["delete"](), qgP["delete"]();
    }, qgK["FaceFilter"]["prototype"]["smoothPixel"] = function() {
      let qgV = [];
      const qgJ = this["pixel"]();
      for (let qgY = 0; qgY < qgJ["size"](); qgY += 3) qgV["push"]([qgJ["get"](qgY + 0), qgJ["get"](qgY + 1), qgJ["get"](qgY + 2)]);
      return qgJ["delete"](), qgV;
    }, qgK["FaceFilter"]["prototype"]["smoothBox"] = function() {
      const qgV = this["box"](), qgJ = [[qgV[0], qgV[1]], [qgV[2], qgV[3]]];
      return qgV["delete"](), qgJ;
    }, this["faceModule"] = qgK, this["faceAligner"] = new this["faceModule"]["FaceAligner"]();
  }
  ["reset"]() {
    var qgu;
    this["faceFilters"]["forEach"]((qgj) => qgj["delete"]()), this["faceFilters"] = [], this["faceTracks"] = [], (qgu = this["bodySegmenter"]) == null || qgu["reset"]();
  }
  async ["prepare"]() {
    var qgu, qgj, qgL;
    qM()["set"]("ENGINE_COMPILE_ONLY", true), await ((qgu = this["faceDetector"]) == null ? void 0 : qgu["prepare"]()), await ((qgj = this["meshDetector"]) == null ? void 0 : qgj["prepare"]()), await ((qgL = this["bodySegmenter"]) == null ? void 0 : qgL["prepare"]());
    const qgI = SD();
    qgI instanceof JP && (qgI["checkCompileCompletion"](), qgI["getUniformLocations"]()), qM()["set"]("ENGINE_COMPILE_ONLY", false);
  }
  ["dispose"]() {
    var qgu, qgj, qgL, qgI;
    this["reset"](), (qgu = this["faceDetector"]) == null || qgu["dispose"](), (qgj = this["meshDetector"]) == null || qgj["dispose"](), (qgL = this["bodySegmenter"]) == null || qgL["dispose"](), (qgI = this["faceAligner"]) == null || qgI["delete"]();
  }
};
var q4v = Object["defineProperty"];
var q4y = Object["getOwnPropertySymbols"];
var q4C = Object["prototype"]["hasOwnProperty"];
var q4l = Object["prototype"]["propertyIsEnumerable"];
var q4H = (qgu, qgj, qgL) => qgj in qgu ? q4v(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var q4A = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) q4C["call"](qgj, qgL) && q4H(qgu, qgL, qgj[qgL]);
  if (q4y) {
    for (var qgL of q4y(qgj)) q4l["call"](qgj, qgL) && q4H(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var q4h = class {
  constructor(qgu) {
    this["model"] = qgu, this["handsMax"] = 1, this["iouThresh"] = 0.3, this["scoreThresh"] = 0.45, this["model"] = qgu, this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 192, "height": 192 }, this["modelRatio"] = this["modelSize"]["width"] / this["modelSize"]["height"], this["anchorsData"] = this["buildAnchors"](this["modelSize"]), this["anchorsX"] = zz(this["anchorsData"]["map"]((qgj) => qgj["x"])), this["anchorsY"] = zz(this["anchorsData"]["map"]((qgj) => qgj["y"]));
  }
  async ["process"](qgu) {
    let qgj = { "x": 0, "y": 0 };
    const [qgL, qgI] = Sq(() => {
      const qgQ = { "width": qgu["shape"][2], "height": qgu["shape"][1] }, qgd = qgQ["width"] / qgQ["height"];
      let qgv = q4A({}, qgQ), qgy = { "x": 0, "y": 0 };
      qgd > this["modelRatio"] ? (qgv["height"] = qgu["shape"][2] / this["modelRatio"], qgy["y"] = Math["floor"]((qgv["height"] - qgu["shape"][1]) * 0.5), qgj["y"] = qgy["y"] / qgv["height"]) : qgd < this["modelRatio"] && (qgv["width"] = qgu["shape"][1] * this["modelRatio"], qgy["x"] = Math["floor"]((qgv["width"] - qgu["shape"][2]) * 0.5), qgj["x"] = qgy["x"] / qgv["width"]);
      const qgl = wz(qgu, [[0, 0], [qgy["y"], qgy["y"]], [qgy["x"], qgy["x"]], [0, 0]], 0), qgH = Gq["resizeBilinear"](qgl, [this["modelSize"]["height"], this["modelSize"]["width"]]), qgA = this["model"]["execute"](qgH, "palm"), qgh = zq(DH(qgA, [0, 0, 1], [1, -1, -1])), qgT = zq(DH(qgA, [0, 0, 0], [1, -1, 1])), qgK = DR(mq(qgT, -100, 100));
      return [this["decodeBoxes"](qgh, [this["anchorsX"], this["anchorsY"]], this["modelSize"]), qgK];
    }), qgb = await qgL["data"](), qgR = await qgI["data"]();
    let qgo = [];
    for (let qgQ = 0; qgQ < qgR["length"]; qgQ++) {
      if (qgR[qgQ] < this["scoreThresh"]) continue;
      const qgd = qgb[qgQ * 18 + 2] - qgb[qgQ * 18 + 0], qgv = qgb[qgQ * 18 + 3] - qgb[qgQ * 18 + 1];
      qgd < 0 || qgv < 0 || qgo["push"]({ "box": [[qgb[qgQ * 18 + 0], qgb[qgQ * 18 + 1]], [qgb[qgQ * 18 + 2], qgb[qgQ * 18 + 3]]], "points": [[qgb[qgQ * 18 + 4], qgb[qgQ * 18 + 5]], [qgb[qgQ * 18 + 6], qgb[qgQ * 18 + 7]], [qgb[qgQ * 18 + 8], qgb[qgQ * 18 + 9]], [qgb[qgQ * 18 + 10], qgb[qgQ * 18 + 11]], [qgb[qgQ * 18 + 12], qgb[qgQ * 18 + 13]], [qgb[qgQ * 18 + 14], qgb[qgQ * 18 + 15]], [qgb[qgQ * 18 + 16], qgb[qgQ * 18 + 17]]], "score": qgR[qgQ] });
    }
    if (qgL["dispose"](), qgI["dispose"](), qgo["length"] < 1) return [];
    if (qgo["length"] > 1) {
      const qgy = zX(qgo["map"]((qgT) => [qgT["box"][0][1], qgT["box"][0][0], qgT["box"][1][1], qgT["box"][1][0]])), qgl = zz(qgo["map"]((qgT) => qgT["score"])), qgH = await Gq["nonMaxSuppressionAsync"](qgy, qgl, this["handsMax"], this["iouThresh"], this["scoreThresh"]), qgA = await qgH["data"]();
      qgH["dispose"]();
      const qgh = [];
      for (let qgT = 0; qgT < qgA["length"]; qgT++) qgh["push"](qgo[qgA[qgT]]);
      qgo = qgh;
    }
    if (qgo["length"] < 1) return [];
    const qgr = { "width": 1 - 2 * qgj["x"], "height": 1 - 2 * qgj["y"] };
    return qgo["map"]((qgK) => ({ "points": qgK["points"]["map"]((qgB) => [(qgB[0] - qgj["x"]) / qgr["width"], (qgB[1] - qgj["y"]) / qgr["height"]]), "box": qgK["box"]["map"]((qgB) => [(qgB[0] - qgj["x"]) / qgr["width"], (qgB[1] - qgj["y"]) / qgr["height"]]), "score": qgK["score"] }));
  }
  ["decodeBoxes"](qgu, qgj, qgL) {
    let qgI = zq(DH(qgu, [0, 0], [-1, 1])), qgb = zq(DH(qgu, [0, 1], [-1, 1])), qgR = zq(DH(qgu, [0, 2], [-1, 1])), qgo = zq(DH(qgu, [0, 3], [-1, 1]));
    qgI = WY(iM(qgI, qgL["width"]), qgj[0]), qgb = WY(iM(qgb, qgL["height"]), qgj[1]), qgR = iM(qgR, qgL["width"] * 2), qgo = iM(qgo, qgL["height"] * 2);
    const qgr = DW(ZK(qgI, qgR), [2016, 1]), qgQ = DW(ZK(qgb, qgo), [2016, 1]), qgd = DW(WY(qgI, qgR), [2016, 1]), qgv = DW(WY(qgb, qgo), [2016, 1]);
    let qgy = ms([qgr, qgQ, qgd, qgv], 1);
    for (let qgl = 0; qgl < 7; qgl++) {
      let qgH = zq(DH(qgu, [0, 4 + qgl * 2], [-1, 1])), qgA = zq(DH(qgu, [0, 4 + qgl * 2 + 1], [-1, 1]));
      qgH = DW(WY(iM(qgH, qgL["width"]), qgj[0]), [2016, 1]), qgA = DW(WY(iM(qgA, qgL["height"]), qgj[1]), [2016, 1]), qgy = ms([qgy, qgH, qgA], 1);
    }
    return qgy;
  }
  ["buildAnchors"](qgu) {
    const qgj = [8, 16, 16, 16], qgL = [];
    let qgI = 0;
    for (; qgI < 4; ) {
      let qgb = 0, qgR = qgI;
      for (; qgR < qgj["length"] && qgj[qgR] === qgj[qgI]; ) qgb += 2, qgR++;
      const qgo = qgj[qgI], qgr = Math["ceil"](qgu["height"] / qgo), qgQ = Math["ceil"](qgu["width"] / qgo);
      for (let qgd = 0; qgd < qgr; ++qgd) for (let qgv = 0; qgv < qgQ; ++qgv) for (let qgy = 0; qgy < qgb; ++qgy) qgL["push"]({ "x": (qgv + 0.5) / qgQ, "y": (qgd + 0.5) / qgr });
      qgI = qgR;
    }
    return qgL;
  }
  async ["prepare"]() {
    const { width: qgu, height: qgj } = this["modelSize"], qgL = wF([1, qgj, qgu, 3]), qgI = this["model"]["execute"](qgL, "palm");
    await qgI["data"](), qgL["dispose"](), qgI["dispose"]();
  }
  ["dispose"]() {
    this["model"]["dispose"](), this["anchorsX"]["dispose"](), this["anchorsY"]["dispose"]();
  }
};
var q4T;
((qgu) => (qgu["add"] = (qgj, qgL) => [qgj[0] + qgL[0], qgj[1] + qgL[1], qgj[2] + qgL[2]], qgu["sub"] = (qgj, qgL) => [qgj[0] - qgL[0], qgj[1] - qgL[1], qgj[2] - qgL[2]], qgu["cross"] = (qgj, qgL) => [qgj[1] * qgL[2] - qgj[2] * qgL[1], qgj[2] * qgL[0] - qgj[0] * qgL[2], qgj[0] * qgL[1] - qgj[1] * qgL[0]], qgu["dot"] = (qgj, qgL) => qgj[0] * qgL[0] + qgj[1] * qgL[1] + qgj[2] * qgL[2], qgu["lerp"] = (qgj, qgL, qgI) => [qgj[0] + (qgL[0] - qgj[0]) * qgI, qgj[1] + (qgL[1] - qgj[1]) * qgI, qgj[2] + (qgL[2] - qgj[2]) * qgI], qgu["scale"] = (qgj, qgL) => [qgj[0] * qgL, qgj[1] * qgL, qgj[2] * qgL], qgu["scaleInPlace"] = (qgj, qgL) => (qgj[0] *= qgL, qgj[1] *= qgL, qgj[2] *= qgL, qgj), qgu["negate"] = (qgj) => [-qgj[0], -qgj[1], -qgj[2]], qgu["negateInPlace"] = (qgj) => (qgj[0] = -qgj[0], qgj[1] = -qgj[1], qgj[2] = -qgj[2], qgj), qgu["normalize"] = (qgj) => (0, qgu["scale"])(qgj, 1 / (0, qgu["length"])(qgj)), qgu["normalizeInPlace"] = (qgj) => (0, qgu["scaleInPlace"])(qgj, 1 / (0, qgu["length"])(qgj)), qgu["normalizeToLen"] = (qgj, qgL) => (0, qgu["scale"])(qgj, qgL / (0, qgu["length"])(qgj)), qgu["normalizeToLenInPlace"] = (qgj, qgL) => (0, qgu["scaleInPlace"])(qgj, qgL / (0, qgu["length"])(qgj)), qgu["lengthSqr"] = (qgj) => qgj[0] ** 2 + qgj[1] ** 2 + qgj[2] ** 2, qgu["length"] = (qgj) => Math["sqrt"](qgj[0] ** 2 + qgj[1] ** 2 + qgj[2] ** 2)))(q4T || (q4T = {}));
var q4K = Object["defineProperty"];
var q4B = Object["getOwnPropertySymbols"];
var q4V = Object["prototype"]["hasOwnProperty"];
var q4J = Object["prototype"]["propertyIsEnumerable"];
var q4Y = (qgu, qgj, qgL) => qgj in qgu ? q4K(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var q4P = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) q4V["call"](qgj, qgL) && q4Y(qgu, qgL, qgj[qgL]);
  if (q4B) {
    for (var qgL of q4B(qgj)) q4J["call"](qgj, qgL) && q4Y(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var q4U = class {
  constructor(qgu, qgj = false) {
    this["model"] = qgu, this["wrist"] = qgj, this["model"] = qgu, this["modelSize"] = qgu["inputs"][0]["shape"] ? { "width": qgu["inputs"][0]["shape"][2], "height": qgu["inputs"][0]["shape"][1] } : { "width": 224, "height": 224 }, this["modelRatio"] = this["modelSize"]["width"] / this["modelSize"]["height"];
  }
  ["process"](qgu, qgj) {
    const [qgL, qgI] = [qgu["shape"][1], qgu["shape"][2]], { modelSize: qgb, modelRatio: qgR } = this, qgo = [qgj["start"][0] * qgI, qgj["start"][1] * qgL], qgr = [qgj["end"][0] * qgI, qgj["end"][1] * qgL];
    let [qgQ, qgd] = [qgr[0] - qgo[0], qgo[1] - qgr[1]];
    const qgv = Math["sqrt"](qgQ ** 2 + qgd ** 2);
    qgQ /= qgv, qgd /= qgv;
    const qgy = Math["atan2"](qgQ, qgd), qgl = [0.5 * (qgj["box"][0][0] + qgj["box"][1][0]) * qgI, 0.5 * (qgj["box"][0][1] + qgj["box"][1][1]) * qgL];
    let qgH = 0.5 * (qgj["box"][1][0] - qgj["box"][0][0]) * qgI, qgA = 0.5 * (qgj["box"][1][1] - qgj["box"][0][1]) * qgL;
    const qgh = qgH / qgA / qgR;
    qgh > 1 ? qgH *= qgh : qgA /= qgh;
    const qgT = [qgl[1] - qgA, qgl[0] - qgH, qgl[1] + qgA, qgl[0] + qgH], qgK = Sq(() => this["rotatedRect"](qgu, qgT, qgy, qgb, "constant")), qgB = ["Identity_2:0", "Identity_1:0", "Identity:0", "Identity_3:0"], [qgV, qgJ, qgY, qgP] = this["model"]["execute"](qgK, qgB), qgU = qgV["dataSync"](), qx0 = qgP["dataSync"](), qx1 = qgJ["dataSync"]()[0], qx2 = 2 * qgY["dataSync"]()[0] - 1, qx3 = [], qx4 = [];
    for (let qxE = 0; qxE < 21; qxE++) qx3["push"]([qgU[3 * qxE + 0] / qgb["width"], qgU[3 * qxE + 1] / qgb["height"], qgU[3 * qxE + 2] / qgb["width"] / 0.4]), qx4["push"]([qx0[3 * qxE + 0], qx0[3 * qxE + 1], qx0[3 * qxE + 2]]);
    const { rings: qx5, edges: qx6 } = this["processPhalanxes"](qgK, qx3), qx7 = (qx3[0][0] - 0.5) * 2 * qgH, qx8 = (qx3[0][1] - 0.5) * 2 * qgA, qx9 = [qx7 * qgd - qx8 * qgQ + qgl[0], qx7 * qgQ + qx8 * qgd + qgl[1]], qxq = this["wrist"] ? this["processWrist"](qgu, qx9, qgH, qgA, qgy) : void 0;
    qgK["dispose"](), qgV["dispose"](), qgP["dispose"](), qgJ["dispose"](), qgY["dispose"]();
    const qxn = (qxM) => {
      const qxf = (qxM[0] - 0.5) * 2 * qgH, qxS = (qxM[1] - 0.5) * 2 * qgA;
      qxM[0] = (qxf * qgd - qxS * qgQ + qgl[0]) / qgI, qxM[1] = (qxf * qgQ + qxS * qgd + qgl[1]) / qgL, qxM[2] *= 2 * qgH / qgI;
    }, qxp = qx3["map"]((qxM, qxf) => ({ "pixel": qxM, "metric": qx4[qxf] }));
    qxp["forEach"]((qxM) => {
      qxn(qxM["pixel"]);
      const qxf = qxM["metric"][0], qxS = qxM["metric"][1];
      qxM["metric"][0] = qxf * qgd - qxS * qgQ, qxM["metric"][1] = qxf * qgQ + qxS * qgd;
    }), qx5["forEach"]((qxM) => {
      qxn(qxM[0]), qxn(qxM[1]), qxn(qxM[2]);
    });
    const qxs = qx5["map"]((qxM) => ({ "center": qxM[0], "edges": [qxM[1], qxM[2]] }));
    return qxq && qxq["lines"]["forEach"]((qxM) => {
      const qxf = (qxM["point"][0] - 0.5) * 2 * qgH, qxS = (qxM["point"][1] - 0.5) * 2 * qgA;
      qxM["point"][0] = (qxf * qgd - qxS * qgQ + qx9[0]) / qgI, qxM["point"][1] = (qxf * qgQ + qxS * qgd + qx9[1]) / qgL;
      const qxF = qxM["vector"][0], qxt = qxM["vector"][1];
      qxM["vector"][0] = qxF * qgd - qxt * qgQ, qxM["vector"][1] = qxF * qgQ + qxt * qgd;
    }), { "keypoints": qxp, "score": qx1, "handedness": qx2, "phalanxes": qxs, "wrist": qxq && { "lines": qxq["lines"] }, "debug": q4P({ "box": qgj, "edges": qx6 }, qxq == null ? void 0 : qxq["debug"]) };
  }
  ["processPhalanxes"](qgu, qgj) {
    if (!this["backend"] || !this["phalanxProg"]) return { "rings": [], "edges": [] };
    const qgL = [1, 0.97, 0.92, 0.83, 0.91, 0.93, 0.85, 0.75, 0.83, 0.85, 0.77, 0.65], qgI = [q4T["sub"](qgj[5], qgj[17]), q4T["sub"](qgj[0], qgj[5]), q4T["sub"](qgj[0], qgj[17])];
    qgI[0][2] *= 0, qgI[1][2] *= 0, qgI[2][2] *= 0;
    const qgb = 0.087 * Math["max"](q4T["length"](qgI[0]) / 0.26, q4T["length"](qgI[1]) / 0.41, q4T["length"](qgI[2]) / 0.38), qgR = [], qgo = [], qgr = (qx2, qx3, qx4) => {
      const qx5 = q4T["sub"](qx3, qx2);
      qx5[2] *= 0.1;
      const qx6 = q4T["length"](qx5), qx7 = q4T["scale"]([qx5[1], -qx5[0], qx5[2]], 1 / qx6), qx8 = q4T["dot"](qx7, qx4) > 0 ? qx4 : q4T["negate"](qx4), qx9 = q4T["lerp"](qx7, qx8, Math["abs"](qx7[2]) ** 2);
      qx9[2] = 0;
      const qxq = q4T["normalize"](qx9), qxn = q4T["negate"](qxq), qxp = 0.5 * qgb * qgL[qgR["length"]], qxs = qxp * 0.9;
      qgR["push"]({ "origin": qx2, "end": qx3, "center": q4T["lerp"](qx2, qx3, 0.5), "normal": qxq, "radius": qxp, "polygon": [q4T["add"](qx2, q4T["scale"](qxq, qxs)), q4T["add"](qx2, q4T["scale"](qxn, qxs)), q4T["add"](qx3, q4T["scale"](qxn, qxs)), q4T["add"](qx3, q4T["scale"](qxq, qxs)), 0.5 * (qx2[2] + qx3[2])] }), qgo["push"]([qx2[0], qx2[1], qx3[0], qx3[1], qxq[0], qxq[1], qxp, 0]), qgo["push"]([qx2[0], qx2[1], qx3[0], qx3[1], qxn[0], qxn[1], qxp, 0]);
    }, qgQ = (qx2, qx3, qx4) => Array["from"]({ "length": qx4 }, (qx5, qx6) => qx2 + qx6 * (qx3 - qx2) / (qx4 - 1)), qgd = [[5, 9], [9, 13], [13, 17]]["map"]((qx2) => q4T["normalize"](q4T["sub"](qgj[qx2[0]], qgj[qx2[1]]))), qgv = qgQ(0.75, 1.05, 8);
    qgr(qgj[5], qgj[6], qgd[0]), qgr(qgj[9], qgj[10], qgd[0]), qgr(qgj[13], qgj[14], qgd[1]), qgr(qgj[17], qgj[18], qgd[2]);
    const qgy = qgQ(0.4, 0.8, 8);
    qgr(qgj[6], qgj[7], qgd[0]), qgr(qgj[10], qgj[11], qgd[0]), qgr(qgj[14], qgj[15], qgd[1]), qgr(qgj[18], qgj[19], qgd[2]), qgr(qgj[7], qgj[8], qgd[0]), qgr(qgj[11], qgj[12], qgd[0]), qgr(qgj[15], qgj[16], qgd[1]), qgr(qgj[19], qgj[20], qgd[2]);
    const qgl = (qx2, qx3) => {
      const qx4 = ([qx6, qx7], [qx8, qx9], [qxq, qxn]) => qx7 > qxn != qx9 > qxn && qxq < (qx8 - qx6) * (qxn - qx7) / (qx9 - qx7) + qx6;
      let qx5 = false;
      return qx5 = qx4(qx3[0], qx3[1], qx2) ? !qx5 : qx5, qx5 = qx4(qx3[1], qx3[2], qx2) ? !qx5 : qx5, qx5 = qx4(qx3[2], qx3[3], qx2) ? !qx5 : qx5, qx5 = qx4(qx3[3], qx3[0], qx2) ? !qx5 : qx5, qx5;
    }, qgH = (qx2, qx3, qx4, qx5, qx6, qx7) => {
      const qx8 = [q4T["add"](q4T["lerp"](qx2, qx3, qx7[0]), qx4), q4T["add"](q4T["lerp"](qx2, qx3, qx7[1]), qx4)];
      let qx9 = false;
      for (let qxq = 0; qxq < qgR["length"] && !qx9; qxq++) {
        const qxn = qgR[qxq]["polygon"];
        qxq === qx6 || qxn[4] > qx5 || (qx9 = qgl(qx8[0], qxn), !qx9 && (qx9 = qgl(qx8[1], qxn)));
      }
      return qx9;
    }, qgA = qgR["map"]((qx2, qx3) => {
      const { origin: qx4, end: qx5, normal: qx6, radius: qx7, polygon: qx8 } = qx2, qx9 = qx3 > 0 ? qgy : qgv;
      return [qgH(qx4, qx5, q4T["scale"](qx6, 0.9 * qx7), qx8[4], qx3, [qx9[0], qx9[8]]), qgH(qx4, qx5, q4T["scale"](qx6, -0.9 * qx7), qx8[4], qx3, [qx9[0], qx9[8]])];
    }), qgh = zq(qgu), qgT = zX(qgo), qgK = zX([qgv, qgy]), qgB = this["backend"]["compileAndRun"](this["phalanxProg"], [qgh, qgT, qgK]), qgV = fU()["makeTensorFromTensorInfo"](qgB), qgJ = qgV["dataSync"](), qgY = [];
    qgR["forEach"]((qx2, qx3) => qgY["push"]([qgJ[qx3 * 8], qgJ[qx3 * 8 + 4]]));
    const qgP = [];
    qgY["forEach"]((qx2, qx3) => {
      const qx4 = qgR[qx3];
      qx2[0] = qx4["radius"] + qx2[0] / this["modelSize"]["width"], qx2[1] = qx4["radius"] + qx2[1] / this["modelSize"]["width"], !qgA[qx3][0] && !qgA[qx3][1] && qgP["push"]((qx2[0] + qx2[1]) / qgL[qx3]);
    });
    const qgU = qgP[Math["floor"](qgP["length"] / 2)] || qgb;
    qgY["forEach"]((qx2, qx3) => {
      const qx4 = qgU * qgL[qx3];
      if (qgA[qx3][0] && qgA[qx3][1]) {
        qx2[0] = qx2[1] = 0.5 * qx4;
        return;
      }
      if (qgA[qx3][1]) {
        qx2[1] = qx4 - qx2[0];
        return;
      }
      if (qgA[qx3][0]) {
        qx2[0] = qx4 - qx2[1];
        return;
      }
    });
    const qx0 = [];
    qgR["forEach"]((qx2, qx3) => qx0["push"]([qx2["center"], q4T["add"](qx2["center"], q4T["scale"](qx2["normal"], qgY[qx3][0] || 0)), q4T["add"](qx2["center"], q4T["scale"](qx2["normal"], -qgY[qx3][1] || 0))]));
    const qx1 = [];
    return qgR["forEach"]((qx2) => qx1["push"](q4T["add"](q4T["lerp"](qx2["origin"], qx2["end"], 0.2), q4T["scale"](qx2["normal"], qx2["radius"])), q4T["add"](q4T["lerp"](qx2["origin"], qx2["end"], 0.2), q4T["scale"](qx2["normal"], -qx2["radius"])), q4T["add"](q4T["lerp"](qx2["origin"], qx2["end"], 0.8), q4T["scale"](qx2["normal"], qx2["radius"])), q4T["add"](q4T["lerp"](qx2["origin"], qx2["end"], 0.8), q4T["scale"](qx2["normal"], -qx2["radius"])))), qgh["dispose"](), qgT["dispose"](), qgK["dispose"](), qgV["dispose"](), { "rings": qx0, "edges": qx1 };
  }
  ["processWrist"](qgu, qgj, qgL, qgI, qgb) {
    if (!this["backend"] || !this["wristDirProg"] || !this["wristEdgeProg"]) return;
    const qgR = [qgj[1] - qgI, qgj[0] - qgL, qgj[1] + qgI, qgj[0] + qgL], qgo = Sq(() => zq(this["rotatedRect"](qgu, qgR, qgb, { "width": 32, "height": 32 }, "reflect"), [0])), [qgr, qgQ] = Sq(() => {
      const qx2 = iM(qgo, ZU(aj(OW(qgo, [[0.897], [1.761], [0.342]]), 1.15), 0.01)), qx3 = eJ(qx2, [15, 15, 0], [3, 3, 3]);
      return [aG(aU(ZK(DW(qx2, [32, 32, 1, 3]), DW(qx3, [-1, 3])), 3, false), 2, true), {}];
    }), qgd = [], qgv = this["backend"]["compileAndRun"](this["wristDirProg"], [qgr]), qgy = fU()["makeTensorFromTensorInfo"](qgv), qgl = qgy["dataSync"]();
    let qgH = 0, qgA = qgl[0];
    for (let qx2 = 1; qx2 < 32; qx2++) {
      const qx3 = qgl[qx2];
      qx3 < qgA && (qgA = qx3, qgH = qx2);
    }
    let qgh = [qgH, qgH];
    for (let qx4 = 0; qx4 < 5; qx4++) {
      const qx5 = [qgh[0] - 1, qgh[1] + 1], qx6 = [qx5[0] >= 0 ? qgl[qx5[0]] : 1e4, qx5[1] < 32 ? qgl[qx5[1]] : 1e4], qx7 = qx6[0] < qx6[1] ? 0 : 1;
      qgh[qx7] = qx5[qx7];
    }
    const qgT = Math["PI"] / 31 * (qgh[0] + qgh[1]) * 0.5, qgK = [Math["cos"](qgT), Math["sin"](qgT), 0], qgB = [qgK[1], -qgK[0], 0], qgV = this["backend"]["compileAndRun"](this["wristEdgeProg"], [qgr], "float32", [[qgK[0], qgK[1]]]), qgJ = fU()["makeTensorFromTensorInfo"](qgV), [qgY, qgP] = [qgJ["shape"][0], qgJ["shape"][1] / 2], qgU = qgJ["dataSync"](), qx0 = new Float32Array(qgU["length"])["fill"](0), qx1 = [qgP + 0.5, -0.5]["map"]((qx8, qx9) => {
      const qxq = new Float32Array(qgP)["fill"](0);
      for (let qxE = 0; qxE < qgP; qxE++) {
        const qxM = (qxE * 2 + qx9) * qgP;
        for (let qxf = 1; qxf < qgP - 1; qxf++) qgU[qxM + qxf] > Math["max"](qgU[qxM + qxf + 1], qgU[qxM + qxf - 1], 0) && (qx0[qxM + qxf] = qgU[qxM + qxf], qxq[qxf] += qgU[qxM + qxf]);
      }
      let qxn = 1, qxp = 0;
      for (let qxS = 1; qxS < qgP - 1; qxS++) {
        const qxF = qxq[qxS] + 0.5 * (qxq[qxS - 1] + qxq[qxS + 1]);
        qxF > qxp && (qxp = qxF, qxn = qxS);
      }
      let qxs = [];
      for (let qxt = 0; qxt < qgY; qxt++) {
        const qxk = (qxt * 2 + qx9) * qgP;
        let qxO = qx0[qxk + qxn] > 0 ? qxn : void 0;
        if (qxO = qxO === void 0 ? qx0[qxk + qxn + 1] > 0 ? qxn + 1 : qxO : qx0[qxk + qxn + 1] > qx0[qxk + qxO] ? qxn + 1 : qxO, qxO = qxO === void 0 ? qx0[qxk + qxn - 1] > 0 ? qxn - 1 : qxO : qx0[qxk + qxn - 1] > qx0[qxk + qxO] ? qxn - 1 : qxO, qxO === void 0) continue;
        const qxW = qxO < 1 || qxO >= 7 ? 0 : 0.5 * (qgU[qxk + qxO + 1] - qgU[qxk + qxO - 1]) / (qgU[qxk + qxO + 1] - 2 * qgU[qxk + qxO] + qgU[qxk + qxO - 1]);
        qxO -= qxW;
        const qxi = q4T["add"](q4T["add"]([16, 16, 0], q4T["scale"](qgK, 4 + qxt)), q4T["scale"](qgB, qxO - qx8));
        qxs["push"]([qxi[0] / 32, qxi[1] / 32]);
      }
      return this["fitLineRobust"](qxs, [qgK[0], qgK[1]]);
    });
    return qgo["dispose"](), qgy["dispose"](), qgJ["dispose"](), qgr["dispose"](), { "lines": this["normalizeLines"](qx1[0], qx1[1], [0.5, 0.5]), "debug": q4P({ "anchors": qgd }, qgQ) };
  }
  ["fitLine"](qgu) {
    const qgj = qgu["reduce"]((qgo, qgr) => [qgo[0] + qgr[0], qgo[1] + qgr[1]], [0, 0]);
    qgj[0] /= qgu["length"], qgj[1] /= qgu["length"];
    const qgL = qgu["reduce"]((qgo, qgr) => {
      const qgQ = [qgr[0] - qgj[0], qgr[1] - qgj[1]];
      return [qgo[0] + qgQ[0] ** 2 - qgQ[1] ** 2, qgo[1] + 2 * qgQ[0] * qgQ[1]];
    }, [0, 0]), qgI = Math["sqrt"](qgL[0] ** 2 + qgL[1] ** 2), qgb = [Math["sqrt"](0.5 * (qgI + qgL[0])), Math["sqrt"](0.5 * (qgI - qgL[0]))], qgR = Math["sqrt"](qgb[0] ** 2 + qgb[1] ** 2);
    return qgb[0] /= qgR, qgb[1] /= qgR, qgL[1] < 0 && (qgb[0] = -qgb[0]), { "point": qgj, "vector": qgb };
  }
  ["fitLineRobust"](qgu, qgj) {
    const qgL = Math["abs"](qgj[1]) > Math["abs"](qgj[0]), qgI = qgL ? qgu["map"]((qgA) => [qgA[1], qgA[0]]) : qgu, qgb = [];
    for (let qgA = 0; qgA < qgI["length"]; qgA++) for (let qgh = qgA + 1; qgh < qgI["length"]; qgh++) qgb["push"]((qgI[qgh][1] - qgI[qgA][1]) / (qgI[qgh][0] - qgI[qgA][0]));
    const qgR = qgb["sort"]((qgT, qgK) => qgT - qgK)[Math["floor"](qgb["length"] / 2)], qgo = qgI["map"]((qgT) => qgT[1] - qgR * qgT[0])["sort"]((qgT, qgK) => qgT - qgK), qgr = qgo[Math["floor"](qgo["length"] / 2)], qgQ = Math["sqrt"](qgR * qgR + 1), qgd = [1 / qgQ, qgR / qgQ], qgv = qgI["reduce"]((qgT, qgK) => qgT + qgK[0], 0) / qgI["length"], qgy = [qgv, qgv * qgR + qgr], qgl = qgL ? [qgy[1], qgy[0]] : qgy;
    let qgH = qgL ? [qgd[1], qgd[0]] : qgd;
    return qgH[0] * qgj[0] + qgH[1] * qgj[1] < 0 && (qgH = [-qgH[0], -qgH[1]]), { "point": qgl, "vector": qgH };
  }
  ["normalizeLines"](qgu, qgj, qgL) {
    const qgI = (qgY) => [qgY[0] / qgY[2], qgY[1] / qgY[2], 1], qgb = [...qgu["point"], 1], qgR = [...qgj["point"], 1], qgo = [...qgu["vector"], 0], qgr = [...qgj["vector"], 0], qgQ = q4T["lerp"](qgo, qgr, 0.5), qgd = [qgQ[1], -qgQ[0], 0], qgv = q4T["cross"](qgb, q4T["add"](qgb, qgo)), qgy = q4T["cross"](qgR, q4T["add"](qgR, qgr)), qgl = q4T["cross"](qgb, q4T["add"](qgb, qgd)), qgH = qgI(q4T["cross"](qgl, qgy)), qgA = q4T["lerp"](qgb, qgH, 0.5), qgh = [...qgL, 1], qgT = q4T["add"](qgA, q4T["scale"](qgQ, q4T["dot"](qgQ, q4T["sub"](qgh, qgA)))), qgK = q4T["add"](qgT, q4T["scale"](qgQ, 0.15)), qgB = q4T["cross"](qgK, q4T["add"](qgK, qgd)), qgV = qgI(q4T["cross"](qgv, qgB)), qgJ = qgI(q4T["cross"](qgy, qgB));
    return [{ "point": [qgV[0], qgV[1]], "vector": qgu["vector"] }, { "point": [qgJ[0], qgJ[1]], "vector": qgj["vector"] }, { "point": qgK, "vector": qgQ }];
  }
  ["rotatedRect"](qgu, qgj, qgL, qgI, qgb = "constant") {
    let qgR = qgu, qgo = [...qgj];
    for (; (qgo[2] - qgo[0]) / qgI["width"] > 2; ) qgR = Gq["resizeBilinear"](qgR, [Math["round"](qgR["shape"][1] / 2), Math["round"](qgR["shape"][2] / 2)]), qgo[0] /= 2, qgo[1] /= 2, qgo[2] /= 2, qgo[3] /= 2;
    const [qgr, qgQ] = [qgo[2] - qgo[0], qgo[3] - qgo[1]], [qgd, qgv] = [(qgo[2] + qgo[0]) * 0.5, (qgo[3] + qgo[1]) * 0.5], [qgy, qgl] = [qgr / qgI["height"], qgQ / qgI["width"]], [qgH, qgA] = [Math["cos"](qgL), Math["sin"](qgL)], qgh = [qgH * qgl, -qgA * qgy, (-qgH * qgQ + qgA * qgr) * 0.5 + qgv, qgA * qgl, qgH * qgy, (-qgA * qgQ - qgH * qgr) * 0.5 + qgd, 0, 0];
    return Gq["transform"](qgR, [qgh], "bilinear", qgb, 0, [qgI["height"], qgI["width"]]);
  }
  async ["prepare"]() {
    const { width: qgu, height: qgj } = this["modelSize"], qgL = wF([1, qgj, qgu, 3]), qgI = this["model"]["execute"](qgL);
    if (await Promise["all"](qgI["map"](async (qgd) => {
      await qgd["data"](), qgd["dispose"]();
    })), qgL["dispose"](), St() !== "webgl") return;
    if (this["backend"] = SD(), this["wrist"]) {
      this["wristDirProg"] = { "variableNames": ["image"], "outputShape": [32], "userCode": "\n                    float getImage2x2(vec2 xy) {\n                        vec2 xyF = floor(xy);\n                        ivec2 xyI = ivec2(xyF);\n                        vec2 xyW = xy - xyF;\n                        return mix(mix(getImage(xyI.y,     xyI.x,     0),\n                                       getImage(xyI.y,     xyI.x + 1, 0), xyW.x),\n                                   mix(getImage(xyI.y + 1, xyI.x,     0),\n                                       getImage(xyI.y + 1, xyI.x + 1, 0), xyW.x), xyW.y);\n                    }\n                    #define M_PI 3.1415926535\n                    void main() {\n                        float angle = M_PI / 31.0 * float(getOutputCoords());\n                        vec2 axis = vec2(cos(angle), sin(angle));\n                        vec2 dxy = vec2(axis.y, -axis.x);\n                        vec2 xy0 = 16.0 + axis * 6.0;\n                        float sum = 0.0;\n                        for (int i = 0; i < 8; i++) {\n                            sum += getImage2x2(xy0);\n                            sum += getImage2x2(xy0 + dxy);\n                            sum += getImage2x2(xy0 - dxy);\n                            xy0 += axis;\n                        }\n                        setOutput(sum);\n                    }" }, this["wristEdgeProg"] = { "variableNames": ["diff"], "customUniforms": [{ "name": "axis", "type": "vec2" }], "outputShape": [8, 16], "userCode": "\n                    float getDiff2x2(vec2 xy) {\n                        vec2 xyF = floor(xy);\n                        ivec2 xyI = ivec2(xyF);\n                        vec2 xyW = xy - xyF;\n                        return mix(mix(getDiff(xyI.y,     xyI.x,     0),\n                                       getDiff(xyI.y,     xyI.x + 1, 0), xyW.x),\n                                   mix(getDiff(xyI.y + 1, xyI.x,     0),\n                                       getDiff(xyI.y + 1, xyI.x + 1, 0), xyW.x), xyW.y);\n                    }\n                    void main() {\n                        ivec2 c = getOutputCoords();\n                        vec2 n = vec2(axis.y, -axis.x);\n                        vec2 xy = 16.0 + axis * (4.0 + float(c.x)) +\n                            (float(c.y) - 8.0) * vec2(axis.y, -axis.x);\n                        vec2 n1 = c.y >= 8 ? n : -n;\n                        setOutput(getDiff2x2(xy + n1) - getDiff2x2(xy));\n                    }" };
      const qgd = wF([32, 32, 1]), qgv = this["backend"]["compileAndRun"](this["wristDirProg"], [qgd]), qgy = fU()["makeTensorFromTensorInfo"](qgv), qgl = this["backend"]["compileAndRun"](this["wristEdgeProg"], [qgd], "float32", [[0, 1]]), qgH = fU()["makeTensorFromTensorInfo"](qgl);
      await qgy["data"](), await qgH["data"](), qgd["dispose"](), qgy["dispose"](), qgH["dispose"]();
    }
    this["phalanxProg"] = { "variableNames": ["image", "edge", "offset"], "outputShape": [24 * 2, 2], "packedOutput": true, "userCode": "\n                float getImage2x2(vec2 xy, int c) {\n                    vec2 xyF = floor(xy);\n                    ivec2 xyI = ivec2(xyF);\n                    vec2 xyW = xy - xyF;\n                    return mix(mix(getImage(xyI.y,     xyI.x,     c),\n                                   getImage(xyI.y,     xyI.x + 1, c), xyW.x),\n                               mix(getImage(xyI.y + 1, xyI.x,     c),\n                                   getImage(xyI.y + 1, xyI.x + 1, c), xyW.x), xyW.y);\n                }\n                vec3 getImage2x2(vec2 xy) {\n                    return vec3(getImage2x2(xy, 0), getImage2x2(xy, 1), getImage2x2(xy, 2));\n                }\n                void main() {\n                    int c = getOutputCoords().x / 2;\n                    vec2 b0 = vec2(getEdge(c, 0), getEdge(c, 1));\n                    vec2 b1 = vec2(getEdge(c, 2), getEdge(c, 3));\n                    vec2 dxy = vec2(getEdge(c, 4), getEdge(c, 5));\n                    float r = getEdge(c, 6) * 224.0;\n                    int offsetsI = min(c, 1);\n                    vec3 res[7];\n                    for (int j = 0; j < 7; j++)\n                        res[j] = vec3(0.0);\n                    for (int i = 0; i < 8; i++) {\n                        vec3 d; vec3 v0; vec3 v1; vec3 v2;\n                        vec2 xy0 = mix(b0, b1, getOffset(offsetsI, i)) * 224.0;\n                        for (int j = 0; j <= 9; j++) {\n                            v0 = v1; v1 = v2;\n                            v2 = getImage2x2(xy0 + (r + float(j - 6)) * dxy);\n                            d.xy = d.yz;\n                            d.z = length((v2 - v0) * vec3(0.5, 1.0, 0.8));\n                            bool cond = d.y > max(d.x, d.z) && d.y > 0.02;\n                            if (cond && j >= 4) {\n                                float subpix = 0.5 * (d.x - d.z) /\n                                    (d.x - 2.0 * d.y + d.z);\n                                res[j - 4] += vec3(d.y, 1.0, subpix);\n                            }\n                        }\n                    }\n                    int jMax = 3;\n                    float measureMax = 0.0;\n                    for (int j = 1; j < 6; j++) {\n                        float m = res[j - 1].x + res[j].x + res[j + 1].x;\n                        if (m > measureMax) {\n                            measureMax = m;\n                            jMax = j;\n                        }\n                    }\n                    float subpix =\n                        0.50 * res[jMax    ].z / max(res[jMax    ].y, 1.0) +\n                        0.25 * res[jMax - 1].z / max(res[jMax - 1].y, 1.0) +\n                        0.25 * res[jMax + 1].z / max(res[jMax + 1].y, 1.0);\n                    setOutput(vec4(subpix + float(jMax - 4),\n                        measureMax, res[jMax].y + res[jMax - 1].y + res[jMax + 1].y, c));\n                }\n        " };
    const qgb = wF([this["modelSize"]["height"], this["modelSize"]["width"], 3]), qgR = wF([24, 8]), qgo = wF([2, 8]), qgr = this["backend"]["compileAndRun"](this["phalanxProg"], [qgb, qgR, qgo]), qgQ = fU()["makeTensorFromTensorInfo"](qgr);
    await qgQ["data"](), qgb["dispose"](), qgo["dispose"](), qgQ["dispose"]();
  }
  async ["dispose"]() {
    var qgu;
    (qgu = this["model"]) == null || qgu["dispose"]();
  }
};
var q50 = class {
  constructor() {
    this["freq"] = 30, this["pixelParams"] = { "minCutOff": 2, "minCutOffD": 2, "beta": 50 }, this["metricParams"] = { "minCutOff": 0.1, "minCutOffD": 1, "beta": 20 }, this["phalanxParams"] = { "minCutOff": 2, "minCutOffD": 1, "beta": 80 }, this["scoreCutOff"] = 1, this["handednessCutOff"] = 0.1, this["visibilityCutOff"] = 1, this["time"] = 0;
  }
  ["filter"](qgu, qgj, qgL = 1) {
    if (this["time"] >= qgj) return qgu;
    if (this["time"] !== 0 && (this["freq"] = 1 / (qgj - this["time"])), this["time"] = qgj, !this["raw"] || !this["smooth"] || !this["der"]) return this["raw"] = this["clonePose"](qgu), this["smooth"] = this["clonePose"](qgu), this["der"] = { "keypoints": qgu["keypoints"]["map"](() => ({ "pixel": [0, 0, 0], "metric": [0, 0, 0] })), "phalanxes": qgu["phalanxes"]["map"](() => ({ "center": [0, 0, 0], "edges": [[0, 0, 0], [0, 0, 0]] })), "score": 0, "handedness": 0.5, "wrist": qgu["wrist"] && { "lines": qgu["wrist"]["lines"]["map"](() => ({ "point": [0, 0], "vector": [0, 0] })) } }, this["clonePose"](this["smooth"]);
    const { raw: qgI, smooth: qgb, der: qgR } = this, qgo = [...qgb["keypoints"][0]["pixel"]];
    this["filterKeypoints"](qgu["keypoints"], qgI["keypoints"], qgR["keypoints"], qgb["keypoints"], qgL);
    const qgr = [...qgb["keypoints"][0]["pixel"]], qgQ = [qgr[0] - qgo[0], qgr[1] - qgo[1]], qgd = this["alpha"](this["scoreCutOff"]);
    qgb["score"] = qgb["score"] + qgd * (qgu["score"] - qgb["score"]);
    const qgv = this["alpha"](this["handednessCutOff"]);
    return qgb["handedness"] = this["smooth"]["handedness"] + qgv * (qgu["handedness"] - this["smooth"]["handedness"]), this["filterPhalanxes"](qgu["phalanxes"], qgI["phalanxes"], qgR["phalanxes"], qgb["phalanxes"], qgL), this["filterWrist"](qgu, qgI, qgR, qgb, qgQ, qgL), qgb["debug"] = qgu["debug"], this["clonePose"](this["smooth"]);
  }
  ["filterKeypoints"](qgu, qgj, qgL, qgI, qgb) {
    for (let qgR = 0; qgR < qgu["length"]; qgR++) this["filterCoord3D"](qgu[qgR]["pixel"], qgj[qgR]["pixel"], qgL[qgR]["pixel"], qgI[qgR]["pixel"], qgb, this["pixelParams"]), this["filterCoord3D"](qgu[qgR]["metric"], qgj[qgR]["metric"], qgL[qgR]["metric"], qgI[qgR]["metric"], qgb, this["metricParams"]);
  }
  ["filterPhalanxes"](qgu, qgj, qgL, qgI, qgb) {
    for (let qgR = 0; qgR < qgu["length"]; qgR++) this["filterCoord3D"](qgu[qgR]["center"], qgj[qgR]["center"], qgL[qgR]["center"], qgI[qgR]["center"], qgb, this["phalanxParams"]), this["filterCoord3D"](qgu[qgR]["edges"][0], qgj[qgR]["edges"][0], qgL[qgR]["edges"][0], qgI[qgR]["edges"][0], qgb, this["phalanxParams"]), this["filterCoord3D"](qgu[qgR]["edges"][1], qgj[qgR]["edges"][1], qgL[qgR]["edges"][1], qgI[qgR]["edges"][1], qgb, this["phalanxParams"]);
  }
  ["filterWrist"](qgu, qgj, qgL, qgI, qgb, qgR) {
    if (!(!qgu["wrist"] || !qgj["wrist"] || !qgL["wrist"] || !qgI["wrist"])) for (let qgo = 0; qgo < qgu["wrist"]["lines"]["length"]; qgo++) {
      const qgr = qgu["wrist"]["lines"][qgo], qgQ = qgj["wrist"]["lines"][qgo], qgd = qgL["wrist"]["lines"][qgo], qgv = qgI["wrist"]["lines"][qgo];
      if (isNaN(qgv["point"][0]) || isNaN(qgv["point"][0]) || isNaN(qgv["vector"][0]) || isNaN(qgv["vector"][0])) {
        qgv["point"] = [...qgr["point"]], qgv["vector"] = [...qgr["vector"]];
        continue;
      }
      if (isNaN(qgr["point"][0]) || isNaN(qgr["point"][0]) || isNaN(qgr["vector"][0]) || isNaN(qgr["vector"][0])) {
        qgv["point"][0] += qgb[0], qgv["point"][1] += qgb[1];
        continue;
      }
      this["filterCoord2D"](qgr["point"], qgQ["point"], qgd["point"], qgv["point"], qgR, { "minCutOff": 0.5, "minCutOffD": 4, "beta": 75 }), this["filterCoord2D"](qgr["vector"], qgQ["vector"], qgd["vector"], qgv["vector"], qgR, { "minCutOff": 0.1, "minCutOffD": 0.5, "beta": 10 });
      const qgy = Math["sqrt"](qgv["vector"][0] ** 2 + qgv["vector"][1] ** 2);
      qgv["vector"][0] /= qgy, qgv["vector"][1] /= qgy;
    }
  }
  ["filterCoord3D"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = [(qgu[0] - qgI[0]) * qgb * this["freq"], (qgu[1] - qgI[1]) * qgb * this["freq"], (qgu[2] - qgI[2]) * qgb * this["freq"]], qgr = this["alpha"](qgR["minCutOffD"]);
    qgL[0] = qgL[0] + qgr * (qgo[0] - qgL[0]), qgL[1] = qgL[1] + qgr * (qgo[1] - qgL[1]), qgL[2] = qgL[2] + qgr * (qgo[2] - qgL[2]);
    const qgQ = [this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[0])), this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[1])), this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[2]))];
    qgI[0] = qgI[0] + qgQ[0] * (qgu[0] - qgI[0]), qgI[1] = qgI[1] + qgQ[1] * (qgu[1] - qgI[1]), qgI[2] = qgI[2] + qgQ[2] * (qgu[2] - qgI[2]), qgj[0] = qgu[0], qgj[1] = qgu[1], qgj[2] = qgu[2];
  }
  ["filterCoord2D"](qgu, qgj, qgL, qgI, qgb, qgR) {
    const qgo = [(qgu[0] - qgI[0]) * qgb * this["freq"], (qgu[1] - qgI[1]) * qgb * this["freq"]], qgr = this["alpha"](qgR["minCutOffD"]);
    qgL[0] = qgL[0] + qgr * (qgo[0] - qgL[0]), qgL[1] = qgL[1] + qgr * (qgo[1] - qgL[1]);
    const qgQ = [this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[0])), this["alpha"](qgR["minCutOff"] + qgR["beta"] * Math["abs"](qgL[1]))];
    qgI[0] = qgI[0] + qgQ[0] * (qgu[0] - qgI[0]), qgI[1] = qgI[1] + qgQ[1] * (qgu[1] - qgI[1]), qgj[0] = qgu[0], qgj[1] = qgu[1];
  }
  ["reset"]() {
    delete this["raw"], delete this["smooth"], delete this["der"];
  }
  ["alpha"](qgu) {
    return 1 / (1 + this["freq"] / (2 * Math["PI"] * qgu));
  }
  ["clonePose"](qgu) {
    return { "keypoints": qgu["keypoints"]["map"]((qgj) => ({ "pixel": [...qgj["pixel"]], "metric": [...qgj["metric"]] })), "score": qgu["score"], "handedness": qgu["handedness"], "phalanxes": qgu["phalanxes"]["map"]((qgj) => ({ "center": [...qgj["center"]], "edges": [[...qgj["edges"][0]], [...qgj["edges"][1]]] })), "wrist": qgu["wrist"] && { "lines": qgu["wrist"]["lines"]["map"]((qgj) => ({ "point": [...qgj["point"]], "vector": [...qgj["vector"]] })) }, "debug": qgu["debug"] };
  }
};
var q51 = class {
  constructor() {
    this["handTracks"] = [], this["handFilters"] = [], this["angle"] = 10 / 180 * Math["PI"], this["ratio"] = 1920 / 1080, this["near"] = 1, this["handScore"] = 0.55;
  }
  async ["process"](qgu, qgj) {
    var qgL, qgI;
    const qgb = Sq(() => {
      const qgA = OM(OK(qgu, 3), "float32"), qgh = iM(qgA, 255);
      return ZM(qgh, 0);
    }), [qgR, qgo] = [qgb["shape"][1], qgb["shape"][2]], qgr = (qgA, qgh) => {
      const qgT = [qgA[0] * qgo, qgA[1] * qgR], qgK = [qgh[0] * qgo, qgh[1] * qgR];
      let [qgB, qgV] = [qgK[0] - qgT[0], qgT[1] - qgK[1]];
      const qgJ = Math["sqrt"](qgB ** 2 + qgV ** 2);
      return qgB /= qgJ, qgV /= qgJ, [qgB, qgV];
    }, qgQ = (qgA, qgh, qgT, qgK, qgB, qgV) => {
      const qgJ = [0.5 * (qgA[0][0] + qgA[1][0]) * qgo, 0.5 * (qgA[0][1] + qgA[1][1]) * qgR], qgY = { "width": (qgA[1][0] - qgA[0][0]) * qgo, "height": (qgA[1][1] - qgA[0][1]) * qgR }, [qgP, qgU] = qgr(qgh, qgT), qx0 = [qgB * qgY["width"], qgV * qgY["height"]];
      qgJ[0] += qx0[0] * qgU - qx0[1] * qgP, qgJ[1] += qx0[0] * qgP + qx0[1] * qgU, qgJ[0] /= qgo, qgJ[1] /= qgR;
      const qx1 = 0.5 * qgK * Math["max"](qgY["width"], qgY["height"]);
      let qx2 = qx1 / qgo, qx3 = qx1 / qgR;
      return [[qgJ[0] - qx2, qgJ[1] - qx3], [qgJ[0] + qx2, qgJ[1] + qx3]];
    };
    if (this["handTracks"]["length"] === 0) {
      const qgA = await ((qgL = this["palmDetector"]) == null ? void 0 : qgL["process"](qgb)) || [];
      this["handTracks"] = qgA["map"]((qgh) => ({ "box": qgQ(qgh["box"], qgh["points"][0], qgh["points"][2], 2.6, 0, -0.5), "points": qgh["points"], "start": qgh["points"][0], "end": qgh["points"][2] })), this["handTracks"]["forEach"](() => this["handFilters"]["push"](new q50()));
    }
    const { handDetector: qgd } = this, qgv = qgd ? this["handTracks"]["map"]((qgh) => qgd["process"](qgb, qgh)) : [];
    qgv["forEach"]((qgh, qgT) => {
      if (qgj === void 0) return;
      const qgK = qgo / qgR, qgB = this["handTracks"][qgT]["box"][1][0] - this["handTracks"][qgT]["box"][0][0], qgV = (this["handTracks"][qgT]["box"][1][1] - this["handTracks"][qgT]["box"][0][1]) / qgK, qgJ = Math["sqrt"](qgB * qgB + qgV * qgV) * (1 + qgK);
      qgv[qgT] = this["handFilters"][qgT]["filter"](qgh, qgj, 1 / qgJ);
    }), qgb["dispose"]();
    const qgy = [], qgl = [], qgH = [];
    for (let qgh = 0; qgh < qgv["length"]; qgh++) {
      const qgT = qgv[qgh], { keypoints: qgK, phalanxes: qgB, score: qgV } = qgT;
      if (qgV < this["handScore"]) continue;
      const qgJ = [qgK[0]["pixel"][0], qgK[0]["pixel"][1]], qgY = [qgK[5]["pixel"][0], qgK[5]["pixel"][1]], qgP = [qgK[10]["pixel"][0], qgK[10]["pixel"][1]], qgU = [qgK[14]["pixel"][0], qgK[14]["pixel"][1]], qx0 = [0.25 * qgY[0] + 0.5 * qgP[0] + 0.25 * qgU[0], 0.25 * qgY[1] + 0.5 * qgP[1] + 0.25 * qgU[1]], [qx1, qx2] = qgr(qgJ, qx0), [qx3, qx4] = [-qx1, qx2], qx5 = [...qgK["slice"](0, 4), ...qgK["slice"](5, 7), ...qgK["slice"](9, 11), ...qgK["slice"](13, 15), ...qgK["slice"](17, 19)]["map"]((qxF) => [qxF["pixel"][0], qxF["pixel"][1]]), qx6 = [[10, 10], [-10, -10]];
      for (let qxF = 0; qxF < qx5["length"]; qxF++) qx6[0][0] = Math["min"](qx6[0][0], qx5[qxF][0]), qx6[0][1] = Math["min"](qx6[0][1], qx5[qxF][1]), qx6[1][0] = Math["max"](qx6[1][0], qx5[qxF][0]), qx6[1][1] = Math["max"](qx6[1][1], qx5[qxF][1]);
      const qx7 = [(qx6[0][0] + qx6[1][0]) * 0.5, (qx6[0][1] + qx6[1][1]) * 0.5], qx8 = [[10, 10], [-10, -10]];
      for (let qxt = 0; qxt < qx5["length"]; qxt++) {
        const qxk = [(qx5[qxt][0] - qx7[0]) * qgo, (qx5[qxt][1] - qx7[1]) * qgR], qxO = [qx4 * qxk[0] - qx3 * qxk[1], qx3 * qxk[0] + qx4 * qxk[1]];
        qx8[0][0] = Math["min"](qx8[0][0], qxO[0]), qx8[0][1] = Math["min"](qx8[0][1], qxO[1]), qx8[1][0] = Math["max"](qx8[1][0], qxO[0]), qx8[1][1] = Math["max"](qx8[1][1], qxO[1]);
      }
      const qx9 = [(qx8[0][0] + qx8[1][0]) * 0.5, (qx8[0][1] + qx8[1][1]) * 0.5], qxq = [(qx2 * qx9[0] - qx1 * qx9[1]) / qgo + qx7[0], (qx1 * qx9[0] + qx2 * qx9[1]) / qgR + qx7[1]], qxn = 0.5 * (qx8[1][0] - qx8[0][0]) / qgo, qxp = 0.5 * (qx8[1][1] - qx8[0][1]) / qgR, qxs = qgQ([[qxq[0] - qxn, qx7[1] - qxp], [qxq[0] + qxn, qx7[1] + qxp]], qgJ, qx0, 2, 0, -0.1);
      if (jo(qxs, this["handTracks"][qgh]["box"]) < 0.5) continue;
      this["correct"](qgT["keypoints"]), this["align"](qgT["keypoints"]);
      const qxE = [[5, 6], [9, 10], [13, 14], [17, 18], [6, 7], [10, 11], [14, 15], [18, 19], [7, 8], [11, 12], [15, 16], [19, 20]], qxM = 2 * Math["tan"](0.5 * this["angle"]), qxf = this["ratio"] * qxM, qxS = (qxW, qxi) => {
        const qxD = [(qxW[0] - 0.5) * qxf, (qxW[1] - 0.5) * qxM];
        qxW[0] = qxD[0] * qxi, qxW[1] = qxD[1] * qxi, qxW[2] = qxi, qxW[1] = -qxW[1], qxW[2] = -qxW[2];
      };
      qgB["forEach"]((qxW, qxi) => {
        const qxD = -0.5 * (qgK[qxE[qxi][0]]["metric"][2] + qgK[qxE[qxi][1]]["metric"][2]);
        qxS(qxW["center"], qxD), qxS(qxW["edges"][0], qxD), qxS(qxW["edges"][1], qxD);
      }), (qgI = qgT["debug"]) == null || qgI["edges"]["forEach"]((qxW, qxi) => {
        const qxD = 2 * Math["tan"](0.5 * this["angle"]), qxm = this["ratio"] * qxD, qxa = Math["floor"](qxi / 16) + 2, qxZ = -0.5 * (qgK[qxE[qxa][0]]["metric"][2] + qgK[qxE[qxa][1]]["metric"][2]), qxw = qxW, qxe = [(qxw[0] - 0.5) * qxm, (qxw[1] - 0.5) * qxD];
        qxw[0] = qxe[0] * qxZ, qxw[1] = qxe[1] * qxZ, qxw[2] = qxZ, qxw[1] = -qxw[1], qxw[2] = -qxw[2];
      }), qgy["push"]({ "box": qxs, "start": qgJ, "end": qx0, "points": [] }), qgl["push"](this["handFilters"][qgh]), qgH["push"](qgT);
    }
    return this["handTracks"] = qgy, this["handFilters"] = qgl, qgH;
  }
  ["align"](qgu) {
    const qgj = 2 * Math["tan"](0.5 * this["angle"]), qgL = this["ratio"] * qgj, qgI = qgu["map"]((qgv) => ({ "pixel": [(qgv["pixel"][0] - 0.5) * qgL, (qgv["pixel"][1] - 0.5) * qgj], "world": [...qgv["metric"]] })), qgb = [];
    qgI["forEach"]((qgv) => {
      qgb["push"]([0, 1, -qgv["pixel"][1], qgv["world"][1] - qgv["pixel"][1] * qgv["world"][2]], [-1, 0, qgv["pixel"][0], qgv["pixel"][0] * qgv["world"][2] - qgv["world"][0]]);
    });
    const { v: qgR, q: qgo } = q4F(qgb), qgr = qgo["reduce"]((qgv, qgy, qgl, qgH) => qgy < qgH[qgv] ? qgl : qgv, 0), qgQ = qgR[3][qgr], qgd = [qgR[0][qgr] / qgQ, qgR[1][qgr] / qgQ, qgR[2][qgr] / qgQ];
    qgu["forEach"]((qgv) => {
      qgv["metric"][0] += qgd[0], qgv["metric"][1] += qgd[1], qgv["metric"][2] += qgd[2];
    }), qgu["forEach"]((qgv) => {
      const qgy = [(qgv["pixel"][0] - 0.5) * qgL, (qgv["pixel"][1] - 0.5) * qgj], qgl = qgv["metric"];
      qgl[0] = qgy[0] * qgl[2], qgl[1] = qgy[1] * qgl[2], qgv["metric"][1] = -qgv["metric"][1], qgv["metric"][2] = -qgv["metric"][2];
    });
  }
  ["correct"](qgu) {
    const qgj = (qgL, qgI) => {
      for (let qgb = 0; qgb < qgL["length"] - 1; qgb++) {
        const qgR = q4T["sub"](qgL[qgb + 1]["metric"], qgL[qgb]["metric"]), qgo = q4T["normalizeToLen"](qgR, qgI[qgb] - q4T["length"](qgR));
        for (let qgr = qgb + 1; qgr < qgL["length"]; qgr++) qgL[qgr]["metric"] = q4T["add"](qgL[qgr]["metric"], qgo);
      }
    };
    qgj([0, 1, 2, 3, 4]["map"]((qgL) => qgu[qgL]), [0.034, 0.028, 0.03, 0.026]), qgj([0, 5, 6, 7, 8]["map"]((qgL) => qgu[qgL]), [0.083, 0.034, 0.023, 0.021]), qgj([0, 9, 10, 11, 12]["map"]((qgL) => qgu[qgL]), [0.081, 0.038, 0.025, 0.024]), qgj([0, 13, 14, 15, 16]["map"]((qgL) => qgu[qgL]), [0.077, 0.035, 0.023, 0.023]), qgj([0, 17, 18, 19, 20]["map"]((qgL) => qgu[qgL]), [0.07, 0.028, 0.015, 0.015]);
  }
  ["setCamera"](qgu, qgj, qgL = 1) {
    this["angle"] = qgu, this["ratio"] = qgj, this["near"] = qgL;
  }
  async ["init"](qgu, qgj = "./", qgL = false, qgI = false, qgb = "webgl") {
    const qgR = await jB(qgu, qgj, qgL), qgo = new qgR["ParseLoader"](qgj);
    if (qgL || await qgo["remove"]("hand.wasm"), !await qgo["loadDict"](["hand.wasm"]) || !await qgo["load"]("hand.wasm") || !qgo["parse"]()) return;
    qM()["set"]("WEBGL_USE_SHAPES_UNIFORMS", true), fP(), await SF(qgb);
    const qgr = { "weightUrlConverter": async (qgv) => qgv, "fetchFunc": async (qgv) => {
      const qgy = new Blob([qgo["file"](qgv)]);
      return fetch(URL["createObjectURL"](qgy));
    } }, qgQ = await rq("palmmodel.def", qgr), qgd = await rq("handmodel.def", qgr);
    this["palmDetector"] = new q4h(qgQ), this["handDetector"] = new q4U(qgd, qgI);
  }
  ["reset"]() {
    this["handTracks"] = [], this["handFilters"] = [];
  }
  async ["prepare"]() {
    var qgu, qgj;
    qM()["set"]("ENGINE_COMPILE_ONLY", true), await ((qgu = this["palmDetector"]) == null ? void 0 : qgu["prepare"]()), await ((qgj = this["handDetector"]) == null ? void 0 : qgj["prepare"]());
    const qgL = SD();
    qgL instanceof JP && (qgL["checkCompileCompletion"](), qgL["getUniformLocations"]()), qM()["set"]("ENGINE_COMPILE_ONLY", false);
  }
  ["dispose"]() {
    var qgu;
    this["reset"](), (qgu = this["palmDetector"]) == null || qgu["dispose"]();
  }
};
var q52 = class {
  async ["process"](qgu, qgj) {
    var qgL;
    const qgI = Sq(() => {
      const qgR = OM(OK(qgu, 3), "float32"), qgo = it(qgR, 1 / 255);
      return ZM(qgo, 0);
    }), qgb = (qgL = this["segmenter"]) == null ? void 0 : qgL["process"](qgI, [[0, 0], [1, 1]]);
    return qgI["dispose"](), qgb ? [qgb] : [];
  }
  async ["init"](qgu, qgj = "./", qgL = false, qgI = false, qgb = false, qgR = "webgl") {
    const qgo = await jB(qgu, qgj, qgL), qgr = new qgo["ParseLoader"](qgj), [qgQ, qgd] = qgb ? ["masksm.wasm", "maskmodelsm.def"] : ["mask.wasm", "maskmodel.def"];
    if (qgL || await qgr["remove"](qgQ), !await qgr["loadDict"]([qgQ]) || !await qgr["load"](qgQ) || !qgr["parse"]()) return;
    qM()["set"]("WEBGL_USE_SHAPES_UNIFORMS", true), fP(), await SF(qgR);
    const qgv = await rq(qgd, { "weightUrlConverter": async (qgy) => qgy, "fetchFunc": async (qgy) => {
      const qgl = new Blob([qgr["file"](qgy)]);
      return fetch(URL["createObjectURL"](qgl));
    } });
    this["segmenter"] = new q4r(qgv, qgI);
  }
  ["reset"]() {
    var qgu;
    (qgu = this["segmenter"]) == null || qgu["reset"]();
  }
  async ["prepare"]() {
    var qgu;
    qM()["set"]("ENGINE_COMPILE_ONLY", true), await ((qgu = this["segmenter"]) == null ? void 0 : qgu["prepare"]());
    const qgj = SD();
    qgj instanceof JP && (qgj["checkCompileCompletion"](), qgj["getUniformLocations"]()), qM()["set"]("ENGINE_COMPILE_ONLY", false);
  }
  ["dispose"]() {
    var qgu;
    (qgu = this["segmenter"]) == null || qgu["dispose"](), delete this["segmenter"];
  }
};
var q53 = Object["defineProperty"];
var q54 = Object["getOwnPropertySymbols"];
var q55 = Object["prototype"]["hasOwnProperty"];
var q56 = Object["prototype"]["propertyIsEnumerable"];
var q57 = (qgu, qgj, qgL) => qgj in qgu ? q53(qgu, qgj, { "enumerable": true, "configurable": true, "writable": true, "value": qgL }) : qgu[qgj] = qgL;
var q58 = (qgu, qgj) => {
  for (var qgL in qgj || (qgj = {})) q55["call"](qgj, qgL) && q57(qgu, qgL, qgj[qgL]);
  if (q54) {
    for (var qgL of q54(qgj)) q56["call"](qgj, qgL) && q57(qgu, qgL, qgj[qgL]);
  }
  return qgu;
};
var q59 = class {
  constructor(qgu, qgj = false) {
    this["model"] = qgu, this["smooth"] = qgj, this["timestamp"] = 40, this["modelSize"] = { "width": 256, "height": 256 };
  }
  ["process"](qgu, qgj) {
    var qgL;
    const qgI = (qgL = (this["smooth"] ? this["model"]["segmentForVideo"](qgu, this["timestamp"] += 20) : this["model"]["segment"](qgu))["confidenceMasks"]) == null ? void 0 : qgL[1];
    if (!qgI) return;
    const qgb = { "buffer": qgI["getAsUint8Array"](), "size": { "width": qgI["width"], "height": qgI["height"] }, "box": [[0, 0], [1, 1]] };
    return this["modelSize"] = qgb != null && qgb["size"] ? q58({}, qgb["size"]) : this["modelSize"], qgb;
  }
  ["size"]() {
    return this["modelSize"];
  }
  ["reset"]() {
  }
  async ["prepare"]() {
    const { width: qgu, height: qgj } = this["modelSize"], qgL = new ImageData(qgu, qgj);
    (this["smooth"] ? this["model"]["segmentForVideo"](qgL, 1) : this["model"]["segment"](qgL))["close"]();
  }
  ["dispose"]() {
    this["model"]["close"]();
  }
};
var q5q = typeof self != "undefined" ? self : {};
function q5n() {
  throw Error("Invalid UTF8");
}
function q5p(qgu, qgj) {
  return qgj = String["fromCharCode"]["apply"](null, qgj), qgu == null ? qgj : qgu + qgj;
}
var q5g;
var q5x;
var q5s = typeof TextDecoder != "undefined";
var q5E;
var q5M = typeof TextEncoder != "undefined";
function q5f(qgu) {
  if (q5M) qgu = (q5E || (q5E = new TextEncoder()))["encode"](qgu);
  else {
    let qgL = 0;
    const qgI = new Uint8Array(3 * qgu["length"]);
    for (let qgb = 0; qgb < qgu["length"]; qgb++) {
      var qgj = qgu["charCodeAt"](qgb);
      if (qgj < 128) qgI[qgL++] = qgj;
      else {
        if (qgj < 2048) qgI[qgL++] = qgj >> 6 | 192;
        else {
          if (qgj >= 55296 && qgj <= 57343) {
            if (qgj <= 56319 && qgb < qgu["length"]) {
              const qgR = qgu["charCodeAt"](++qgb);
              if (qgR >= 56320 && qgR <= 57343) {
                qgj = 1024 * (qgj - 55296) + qgR - 56320 + 65536, qgI[qgL++] = qgj >> 18 | 240, qgI[qgL++] = qgj >> 12 & 63 | 128, qgI[qgL++] = qgj >> 6 & 63 | 128, qgI[qgL++] = 63 & qgj | 128;
                continue;
              }
              qgb--;
            }
            qgj = 65533;
          }
          qgI[qgL++] = qgj >> 12 | 224, qgI[qgL++] = qgj >> 6 & 63 | 128;
        }
        qgI[qgL++] = 63 & qgj | 128;
      }
    }
    qgu = qgL === qgI["length"] ? qgI : qgI["subarray"](0, qgL);
  }
  return qgu;
}
var q5S;
var q5F;
qgu: {
  for (q5t = ["CLOSURE_FLAGS"], q5k = q5q, q5O = 0; q5O < q5t["length"]; q5O++) if ((q5k = q5k[q5t[q5O]]) == null) {
    q5F = null;
    break qgu;
  }
  q5F = q5k;
}
var q5t;
var q5k;
var q5O;
var q5W;
var q5i = q5F && q5F[610401301];
q5S = q5i != null && q5i;
var q5D = q5q["navigator"];
function q5m(qgu) {
  return !!q5S && !!q5W && q5W["brands"]["some"](({ brand: qgj }) => qgj && qgj["indexOf"](qgu) != -1);
}
function q5a(qgu) {
  var qgj;
  return (qgj = q5q["navigator"]) && (qgj = qgj["userAgent"]) || (qgj = ""), qgj["indexOf"](qgu) != -1;
}
function q5Z() {
  return !!q5S && !!q5W && q5W["brands"]["length"] > 0;
}
function q5w() {
  return q5Z() ? q5m("Chromium") : (q5a("Chrome") || q5a("CriOS")) && !(!q5Z() && q5a("Edge")) || q5a("Silk");
}
function q5e(qgu) {
  return q5e[" "](qgu), qgu;
}
q5W = q5D && q5D["userAgentData"] || null, q5e[" "] = function() {
};
var q5z = !q5Z() && (q5a("Trident") || q5a("MSIE"));
!q5a("Android") || q5w(), q5w(), q5a("Safari") && (q5w() || !q5Z() && q5a("Coast") || !q5Z() && q5a("Opera") || !q5Z() && q5a("Edge") || (q5Z() ? q5m("Microsoft Edge") : q5a("Edg/")) || q5Z() && q5m("Opera"));
var q5c = {};
var q5X = null;
function q5G(qgu) {
  const qgj = qgu["length"];
  let qgL = 3 * qgj / 4;
  qgL % 3 ? qgL = Math["floor"](qgL) : "=."["indexOf"](qgu[qgj - 1]) != -1 && (qgL = "=."["indexOf"](qgu[qgj - 2]) != -1 ? qgL - 2 : qgL - 1);
  const qgI = new Uint8Array(qgL);
  let qgb = 0;
  return function(qgR, qgo) {
    function qgr(qgd) {
      for (; qgQ < qgR["length"]; ) {
        const qgv = qgR["charAt"](qgQ++), qgy = q5X[qgv];
        if (qgy != null) return qgy;
        if (!/^[\s\xa0]*$/["test"](qgv)) throw Error("Unknown base64 encoding at char: " + qgv);
      }
      return qgd;
    }
    q5N();
    let qgQ = 0;
    for (; ; ) {
      const qgd = qgr(-1), qgv = qgr(0), qgy = qgr(64), qgl = qgr(64);
      if (qgl === 64 && qgd === -1) break;
      qgo(qgd << 2 | qgv >> 4), qgy != 64 && (qgo(qgv << 4 & 240 | qgy >> 2), qgl != 64 && qgo(qgy << 6 & 192 | qgl));
    }
  }(qgu, function(qgR) {
    qgI[qgb++] = qgR;
  }), qgb !== qgL ? qgI["subarray"](0, qgb) : qgI;
}
function q5N() {
  if (!q5X) {
    q5X = {};
    var qgu = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"["split"](""), qgj = ["+/=", "+/", "-_=", "-_.", "-_"];
    for (let qgL = 0; qgL < 5; qgL++) {
      const qgI = qgu["concat"](qgj[qgL]["split"](""));
      q5c[qgL] = qgI;
      for (let qgb = 0; qgb < qgI["length"]; qgb++) {
        const qgR = qgI[qgb];
        q5X[qgR] === void 0 && (q5X[qgR] = qgb);
      }
    }
  }
}
var q5u = typeof Uint8Array != "undefined";
var q5j = !q5z && typeof btoa == "function";
function q5L(qgu) {
  if (!q5j) {
    var qgj;
    qgj === void 0 && (qgj = 0), q5N(), qgj = q5c[qgj];
    var qgL = Array(Math["floor"](qgu["length"] / 3)), qgI = qgj[64] || "";
    let qgQ = 0, qgd = 0;
    for (; qgQ < qgu["length"] - 2; qgQ += 3) {
      var qgb = qgu[qgQ], qgR = qgu[qgQ + 1], qgo = qgu[qgQ + 2], qgr = qgj[qgb >> 2];
      qgb = qgj[(3 & qgb) << 4 | qgR >> 4], qgR = qgj[(15 & qgR) << 2 | qgo >> 6], qgo = qgj[63 & qgo], qgL[qgd++] = qgr + qgb + qgR + qgo;
    }
    switch (qgr = 0, qgo = qgI, qgu["length"] - qgQ) {
      case 2:
        qgo = qgj[(15 & (qgr = qgu[qgQ + 1])) << 2] || qgI;
      case 1:
        qgu = qgu[qgQ], qgL[qgd] = qgj[qgu >> 2] + qgj[(3 & qgu) << 4 | qgr >> 4] + qgo + qgI;
    }
    return qgL["join"]("");
  }
  for (qgj = "", qgL = 0, qgI = qgu["length"] - 10240; qgL < qgI; ) qgj += String["fromCharCode"]["apply"](null, qgu["subarray"](qgL, qgL += 10240));
  return qgj += String["fromCharCode"]["apply"](null, qgL ? qgu["subarray"](qgL) : qgu), btoa(qgj);
}
var q5I = /[-_.]/g;
var q5b = { "-": "+", "_": "/", ".": "=" };
function q5R(qgu) {
  return q5b[qgu] || "";
}
function q5o(qgu) {
  if (!q5j) return q5G(qgu);
  q5I["test"](qgu) && (qgu = qgu["replace"](q5I, q5R)), qgu = atob(qgu);
  const qgj = new Uint8Array(qgu["length"]);
  for (let qgL = 0; qgL < qgu["length"]; qgL++) qgj[qgL] = qgu["charCodeAt"](qgL);
  return qgj;
}
function q5r(qgu) {
  return q5u && qgu != null && qgu instanceof Uint8Array;
}
var q5Q = {};
function q5d() {
  return q5C || (q5C = new q5y(null, q5Q));
}
function q5v(qgu) {
  q5H(q5Q);
  var qgj = qgu["g"];
  return (qgj = qgj == null || q5r(qgj) ? qgj : typeof qgj == "string" ? q5o(qgj) : null) == null ? qgj : qgu["g"] = qgj;
}
var q5y = class {
  ["h"]() {
    return new Uint8Array(q5v(this) || 0);
  }
  constructor(qgu, qgj) {
    if (q5H(qgj), this["g"] = qgu, qgu != null && qgu["length"] === 0) throw Error("ByteString should be constructed with non-empty values");
  }
};
var q5C;
var q5l;
function q5H(qgu) {
  if (qgu !== q5Q) throw Error("illegal external caller");
}
function q5A(qgu, qgj) {
  qgu["__closure__error__context__984382"] || (qgu["__closure__error__context__984382"] = {}), qgu["__closure__error__context__984382"]["severity"] = qgj;
}
function q5h(qgu) {
  return q5A(qgu = Error(qgu), "warning"), qgu;
}
var q5T = typeof Symbol == "function" && typeof Symbol() == "symbol";
var q5K = /* @__PURE__ */ new Set();
function q5B(qgu, qgj, qgL = false, qgI = false) {
  return qgu = typeof Symbol == "function" && typeof Symbol() == "symbol" ? qgI && Symbol["for"] && qgu ? Symbol["for"](qgu) : qgu != null ? Symbol(qgu) : Symbol() : qgj, qgL && q5K["add"](qgu), qgu;
}
var q5V = q5B("jas", void 0, true, true);
var q5J = q5B(void 0, "0di");
var q5Y = q5B(void 0, "2ex");
var q5P = q5B(void 0, "1oa", true);
var q5U = q5B(void 0, Symbol(), true);
var q60 = q5T ? q5V : "Ga";
var q61 = { "Ga": { "value": 0, "configurable": true, "writable": true, "enumerable": false } };
var q62 = Object["defineProperties"];
function q63(qgu, qgj) {
  q5T || q60 in qgu || q62(qgu, q61), qgu[q60] |= qgj;
}
function q64(qgu, qgj) {
  q5T || q60 in qgu || q62(qgu, q61), qgu[q60] = qgj;
}
function q65(qgu) {
  return q63(qgu, 34), qgu;
}
function q66(qgu, qgj) {
  q64(qgj, -30975 & (0 | qgu));
}
function q67(qgu, qgj) {
  q64(qgj, -30941 & (34 | qgu));
}
function q68() {
  return typeof BigInt == "function";
}
function q69(qgu) {
  return Array["prototype"]["slice"]["call"](qgu);
}
var q6q;
var q6n = {};
var q6p = {};
function q6g(qgu) {
  return !(!qgu || typeof qgu != "object" || qgu["Ia"] !== q6p);
}
function q6x(qgu) {
  return qgu !== null && typeof qgu == "object" && !Array["isArray"](qgu) && qgu["constructor"] === Object;
}
function q6s(qgu, qgj) {
  if (qgu != null) {
    if (typeof qgu == "string") qgu = qgu ? new q5y(qgu, q5Q) : q5d();
    else {
      if (qgu["constructor"] !== q5y) {
        if (q5r(qgu)) qgu = qgu["length"] ? new q5y(new Uint8Array(qgu), q5Q) : q5d();
        else {
          if (!qgj) throw Error();
          qgu = void 0;
        }
      }
    }
  }
  return qgu;
}
function q6E(qgu) {
  return !(!Array["isArray"](qgu) || qgu["length"]) && !!(1 & (0 | qgu[q60]));
}
var q6M = [];
function q6f(qgu) {
  if (2 & qgu) throw Error();
}
q64(q6M, 55), q6q = Object["freeze"](q6M);
var q6S = class _q6S {
  constructor(qgu, qgj, qgL) {
    this["l"] = 0, this["g"] = qgu, this["h"] = qgj, this["m"] = qgL;
  }
  ["next"]() {
    if (this["l"] < this["g"]["length"]) {
      const qgu = this["g"][this["l"]++];
      return { "done": false, "value": this["h"] ? this["h"]["call"](this["m"], qgu) : qgu };
    }
    return { "done": true, "value": void 0 };
  }
  [Symbol["iterator"]]() {
    return new _q6S(this["g"], this["h"], this["m"]);
  }
};
function q6F(qgu) {
  return q5U ? qgu[q5U] : void 0;
}
var q6t = Object["freeze"]({});
function q6k(qgu) {
  return qgu["Qa"] = true, qgu;
}
var q6O = q6k((qgu) => typeof qgu == "number");
var q6W = q6k((qgu) => typeof qgu == "string");
var q6i = q6k((qgu) => typeof qgu == "boolean");
var q6D = typeof q5q["BigInt"] == "function" && typeof q5q["BigInt"](0) == "bigint";
var q6m = q6k((qgu) => q6D ? qgu >= q6Z && qgu <= q6e : qgu[0] === "-" ? q6z(qgu, q6a) : q6z(qgu, q6w));
var q6a = Number["MIN_SAFE_INTEGER"]["toString"]();
var q6Z = q6D ? BigInt(Number["MIN_SAFE_INTEGER"]) : void 0;
var q6w = Number["MAX_SAFE_INTEGER"]["toString"]();
var q6e = q6D ? BigInt(Number["MAX_SAFE_INTEGER"]) : void 0;
function q6z(qgu, qgj) {
  if (qgu["length"] > qgj["length"]) return false;
  if (qgu["length"] < qgj["length"] || qgu === qgj) return true;
  for (let qgL = 0; qgL < qgu["length"]; qgL++) {
    const qgI = qgu[qgL], qgb = qgj[qgL];
    if (qgI > qgb) return false;
    if (qgI < qgb) return true;
  }
}
var q6c = typeof Uint8Array["prototype"]["slice"] == "function";
var q6X;
var q6G = 0;
var q6N = 0;
function q6u(qgu) {
  const qgj = qgu >>> 0;
  q6G = qgj, q6N = (qgu - qgj) / 4294967296 >>> 0;
}
function q6j(qgu) {
  if (qgu < 0) {
    q6u(-qgu);
    const [qgj, qgL] = q6Q(q6G, q6N);
    q6G = qgj >>> 0, q6N = qgL >>> 0;
  } else q6u(qgu);
}
function q6L(qgu) {
  const qgj = q6X || (q6X = new DataView(new ArrayBuffer(8)));
  qgj["setFloat32"](0, +qgu, true), q6N = 0, q6G = qgj["getUint32"](0, true);
}
function q6I(qgu, qgj) {
  const qgL = 4294967296 * qgj + (qgu >>> 0);
  return Number["isSafeInteger"](qgL) ? qgL : q6R(qgu, qgj);
}
function q6b(qgu, qgj) {
  const qgL = 2147483648 & qgj;
  return qgL && (qgj = ~qgj >>> 0, (qgu = 1 + ~qgu >>> 0) == 0 && (qgj = qgj + 1 >>> 0)), typeof (qgu = q6I(qgu, qgj)) == "number" ? qgL ? -qgu : qgu : qgL ? "-" + qgu : qgu;
}
function q6R(qgu, qgj) {
  if (qgu >>>= 0, (qgj >>>= 0) <= 2097151) var qgL = "" + (4294967296 * qgj + qgu);
  else q68() ? qgL = "" + (BigInt(qgj) << BigInt(32) | BigInt(qgu)) : (qgu = (16777215 & qgu) + 6777216 * (qgL = 16777215 & (qgu >>> 24 | qgj << 8)) + 6710656 * (qgj = qgj >> 16 & 65535), qgL += 8147497 * qgj, qgj *= 2, qgu >= 1e7 && (qgL += qgu / 1e7 >>> 0, qgu %= 1e7), qgL >= 1e7 && (qgj += qgL / 1e7 >>> 0, qgL %= 1e7), qgL = qgj + q6o(qgL) + q6o(qgu));
  return qgL;
}
function q6o(qgu) {
  return qgu = String(qgu), "0000000"["slice"](qgu["length"]) + qgu;
}
function q6r(qgu) {
  if (qgu["length"] < 16) q6j(Number(qgu));
  else {
    if (q68()) qgu = BigInt(qgu), q6G = Number(qgu & BigInt(4294967295)) >>> 0, q6N = Number(qgu >> BigInt(32) & BigInt(4294967295));
    else {
      const qgj = +(qgu[0] === "-");
      q6N = q6G = 0;
      const qgL = qgu["length"];
      for (let qgI = qgj, qgb = (qgL - qgj) % 6 + qgj; qgb <= qgL; qgI = qgb, qgb += 6) {
        const qgR = Number(qgu["slice"](qgI, qgb));
        q6N *= 1e6, q6G = 1e6 * q6G + qgR, q6G >= 4294967296 && (q6N += Math["trunc"](q6G / 4294967296), q6N >>>= 0, q6G >>>= 0);
      }
      if (qgj) {
        const [qgo, qgr] = q6Q(q6G, q6N);
        q6G = qgo, q6N = qgr;
      }
    }
  }
}
function q6Q(qgu, qgj) {
  return qgj = ~qgj, qgu ? qgu = 1 + ~qgu : qgj += 1, [qgu, qgj];
}
var q6d = typeof BigInt == "function" ? BigInt["asIntN"] : void 0;
var q6v = typeof BigInt == "function" ? BigInt["asUintN"] : void 0;
var q6y = Number["isSafeInteger"];
var q6C = Number["isFinite"];
var q6l = Math["trunc"];
function q6H(qgu) {
  return qgu == null || typeof qgu == "number" ? qgu : qgu === "NaN" || qgu === "Infinity" || qgu === "-Infinity" ? Number(qgu) : void 0;
}
function q6A(qgu) {
  return qgu == null || typeof qgu == "boolean" ? qgu : typeof qgu == "number" ? !!qgu : void 0;
}
var q6h = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
function q6T(qgu) {
  switch (typeof qgu) {
    case "bigint":
      return true;
    case "number":
      return q6C(qgu);
    case "string":
      return q6h["test"](qgu);
    default:
      return false;
  }
}
function q6K(qgu) {
  if (qgu == null) return qgu;
  if (typeof qgu == "string" && qgu) qgu = +qgu;
  else {
    if (typeof qgu != "number") return;
  }
  return q6C(qgu) ? 0 | qgu : void 0;
}
function q6B(qgu) {
  if (qgu == null) return qgu;
  if (typeof qgu == "string" && qgu) qgu = +qgu;
  else {
    if (typeof qgu != "number") return;
  }
  return q6C(qgu) ? qgu >>> 0 : void 0;
}
function q6V(qgu) {
  if (qgu[0] === "-") return false;
  const qgj = qgu["length"];
  return qgj < 20 || qgj === 20 && Number(qgu["substring"](0, 6)) < 184467;
}
function q6J(qgu) {
  return qgu = q6l(qgu), q6y(qgu) || (q6j(qgu), qgu = q6b(q6G, q6N)), qgu;
}
function q6Y(qgu) {
  var qgj = q6l(Number(qgu));
  if (q6y(qgj)) return String(qgj);
  if ((qgj = qgu["indexOf"](".")) !== -1 && (qgu = qgu["substring"](0, qgj)), qgj = qgu["length"], !(qgu[0] === "-" ? qgj < 20 || qgj === 20 && Number(qgu["substring"](0, 7)) > -922337 : qgj < 19 || qgj === 19 && Number(qgu["substring"](0, 6)) < 922337)) {
    if (q6r(qgu), qgu = q6G, 2147483648 & (qgj = q6N)) {
      if (q68()) qgu = "" + (BigInt(0 | qgj) << BigInt(32) | BigInt(qgu >>> 0));
      else {
        const [qgL, qgI] = q6Q(qgu, qgj);
        qgu = "-" + q6R(qgL, qgI);
      }
    } else qgu = q6R(qgu, qgj);
  }
  return qgu;
}
function q6P(qgu) {
  return qgu == null ? qgu : typeof qgu == "bigint" ? (q6m(qgu) ? qgu = Number(qgu) : (qgu = q6d(64, qgu), qgu = q6m(qgu) ? Number(qgu) : String(qgu)), qgu) : q6T(qgu) ? typeof qgu == "number" ? q6J(qgu) : q6Y(qgu) : void 0;
}
function q6U(qgu) {
  if (qgu == null) return qgu;
  var qgj = typeof qgu;
  if (qgj === "bigint") return String(q6v(64, qgu));
  if (q6T(qgu)) {
    if (qgj === "string") return qgj = q6l(Number(qgu)), q6y(qgj) && qgj >= 0 ? qgu = String(qgj) : ((qgj = qgu["indexOf"](".")) !== -1 && (qgu = qgu["substring"](0, qgj)), q6V(qgu) || (q6r(qgu), qgu = q6R(q6G, q6N))), qgu;
    if (qgj === "number") return (qgu = q6l(qgu)) >= 0 && q6y(qgu) ? qgu : function(qgL) {
      if (qgL < 0) {
        q6j(qgL);
        var qgI = q6R(q6G, q6N);
        return qgL = Number(qgI), q6y(qgL) ? qgL : qgI;
      }
      return q6V(qgI = String(qgL)) ? qgI : (q6j(qgL), q6I(q6G, q6N));
    }(qgu);
  }
}
function q70(qgu) {
  if (typeof qgu != "string") throw Error();
  return qgu;
}
function q71(qgu) {
  if (qgu != null && typeof qgu != "string") throw Error();
  return qgu;
}
function q72(qgu) {
  return qgu == null || typeof qgu == "string" ? qgu : void 0;
}
function q73(qgu, qgj, qgL, qgI) {
  if (qgu != null && typeof qgu == "object" && qgu["W"] === q6n) return qgu;
  if (!Array["isArray"](qgu)) return qgL ? 2 & qgI ? ((qgu = qgj[q5J]) || (q65((qgu = new qgj())["u"]), qgu = qgj[q5J] = qgu), qgj = qgu) : qgj = new qgj() : qgj = void 0, qgj;
  let qgb = qgL = 0 | qgu[q60];
  return qgb === 0 && (qgb |= 32 & qgI), qgb |= 2 & qgI, qgb !== qgL && q64(qgu, qgb), new qgj(qgu);
}
function q74(qgu, qgj, qgL) {
  if (qgj) qgI: {
    if (!q6T(qgj = qgu)) throw q5h("int64");
    switch (typeof qgj) {
      case "string":
        qgj = q6Y(qgj);
        break qgI;
      case "bigint":
        if (qgu = qgj = q6d(64, qgj), q6W(qgu)) {
          if (!/^\s*(?:-?[1-9]\d*|0)?\s*$/["test"](qgu)) throw Error(String(qgu));
        } else {
          if (q6O(qgu) && !Number["isSafeInteger"](qgu)) throw Error(String(qgu));
        }
        qgj = q6D ? BigInt(qgj) : q6i(qgj) ? qgj ? "1" : "0" : q6W(qgj) ? qgj["trim"]() || "0" : String(qgj);
        break qgI;
      default:
        qgj = q6J(qgj);
    }
  }
  else qgj = q6P(qgu);
  return typeof (qgL = (qgu = qgj) == null ? qgL ? 0 : void 0 : qgu) == "string" && q6y(qgj = +qgL) ? qgj : qgL;
}
var q75 = {};
var q76 = function() {
  try {
    return q5e(new class extends Map {
      constructor() {
        super();
      }
    }()), false;
  } catch (qgu) {
    return true;
  }
}();
var q77 = class {
  constructor() {
    this["g"] = /* @__PURE__ */ new Map();
  }
  ["get"](qgu) {
    return this["g"]["get"](qgu);
  }
  ["set"](qgu, qgj) {
    return this["g"]["set"](qgu, qgj), this["size"] = this["g"]["size"], this;
  }
  ["delete"](qgu) {
    return qgu = this["g"]["delete"](qgu), this["size"] = this["g"]["size"], qgu;
  }
  ["clear"]() {
    this["g"]["clear"](), this["size"] = this["g"]["size"];
  }
  ["has"](qgu) {
    return this["g"]["has"](qgu);
  }
  ["entries"]() {
    return this["g"]["entries"]();
  }
  ["keys"]() {
    return this["g"]["keys"]();
  }
  ["values"]() {
    return this["g"]["values"]();
  }
  ["forEach"](qgu, qgj) {
    return this["g"]["forEach"](qgu, qgj);
  }
  [Symbol["iterator"]]() {
    return this["entries"]();
  }
};
var q78 = q76 ? (Object["setPrototypeOf"](q77["prototype"], Map["prototype"]), Object["defineProperties"](q77["prototype"], { "size": { "value": 0, "configurable": true, "enumerable": true, "writable": true } }), q77) : class extends Map {
  constructor() {
    super();
  }
};
function q79(qgu) {
  return qgu;
}
function q7q(qgu) {
  if (2 & qgu["L"]) throw Error("Cannot mutate an immutable Map");
}
var q7n = class extends q78 {
  constructor(qgu, qgj, qgL = q79, qgI = q79) {
    super();
    let qgb = 0 | qgu[q60];
    qgb |= 64, q64(qgu, qgb), this["L"] = qgb, this["S"] = qgj, this["R"] = qgL, this["Y"] = this["S"] ? q7p : qgI;
    for (let qgR = 0; qgR < qgu["length"]; qgR++) {
      const qgo = qgu[qgR], qgr = qgL(qgo[0], false, true);
      let qgQ = qgo[1];
      qgj ? qgQ === void 0 && (qgQ = null) : qgQ = qgI(qgo[1], false, true, void 0, void 0, qgb), super["set"](qgr, qgQ);
    }
  }
  ["na"](qgu = q7g) {
    if (this["size"] !== 0) return this["X"](qgu);
  }
  ["X"](qgu = q7g) {
    const qgj = [], qgL = super["entries"]();
    for (var qgI; !(qgI = qgL["next"]())["done"]; ) (qgI = qgI["value"])[0] = qgu(qgI[0]), qgI[1] = qgu(qgI[1]), qgj["push"](qgI);
    return qgj;
  }
  ["clear"]() {
    q7q(this), super["clear"]();
  }
  ["delete"](qgu) {
    return q7q(this), super["delete"](this["R"](qgu, true, false));
  }
  ["entries"]() {
    var qgu = this["ma"]();
    return new q6S(qgu, q7x, this);
  }
  ["keys"]() {
    return this["Ha"]();
  }
  ["values"]() {
    var qgu = this["ma"]();
    return new q6S(qgu, q7n["prototype"]["get"], this);
  }
  ["forEach"](qgu, qgj) {
    super["forEach"]((qgL, qgI) => {
      qgu["call"](qgj, this["get"](qgI), qgI, this);
    });
  }
  ["set"](qgu, qgj) {
    return q7q(this), (qgu = this["R"](qgu, true, false)) == null ? this : qgj == null ? (super["delete"](qgu), this) : super["set"](qgu, this["Y"](qgj, true, true, this["S"], false, this["L"]));
  }
  ["Na"](qgu) {
    const qgj = this["R"](qgu[0], false, true);
    qgu = qgu[1], qgu = this["S"] ? qgu === void 0 ? null : qgu : this["Y"](qgu, false, true, void 0, false, this["L"]), super["set"](qgj, qgu);
  }
  ["has"](qgu) {
    return super["has"](this["R"](qgu, false, false));
  }
  ["get"](qgu) {
    qgu = this["R"](qgu, false, false);
    const qgj = super["get"](qgu);
    if (qgj !== void 0) {
      var qgL = this["S"];
      return qgL ? ((qgL = this["Y"](qgj, false, true, qgL, this["ra"], this["L"])) !== qgj && super["set"](qgu, qgL), qgL) : qgj;
    }
  }
  ["ma"]() {
    return Array["from"](super["keys"]());
  }
  ["Ha"]() {
    return super["keys"]();
  }
  [Symbol["iterator"]]() {
    return this["entries"]();
  }
};
function q7p(qgu, qgj, qgL, qgI, qgb, qgR) {
  return qgu = q73(qgu, qgI, qgL, qgR), qgb && (qgu = q7a(qgu)), qgu;
}
function q7g(qgu) {
  return qgu;
}
function q7x(qgu) {
  return [qgu, this["get"](qgu)];
}
var q7s;
var q7E;
var q7M;
function q7f() {
  return q7s || (q7s = new q7n(q65([]), void 0, void 0, void 0, q75));
}
function q7S(qgu, qgj, qgL, qgI, qgb) {
  if (qgu != null) {
    if (Array["isArray"](qgu)) qgu = q6E(qgu) ? void 0 : qgb && 2 & (0 | qgu[q60]) ? qgu : q7F(qgu, qgj, qgL, qgI !== void 0, qgb);
    else {
      if (q6x(qgu)) {
        const qgR = {};
        for (let qgo in qgu) qgR[qgo] = q7S(qgu[qgo], qgj, qgL, qgI, qgb);
        qgu = qgR;
      } else qgu = qgj(qgu, qgI);
    }
    return qgu;
  }
}
function q7F(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgI || qgL ? 0 | qgu[q60] : 0, qgo = qgI ? !!(32 & qgR) : void 0;
  qgI = q69(qgu);
  for (let qgr = 0; qgr < qgI["length"]; qgr++) qgI[qgr] = q7S(qgI[qgr], qgj, qgL, qgo, qgb);
  return qgL && ((qgu = q6F(qgu)) && (qgI[q5U] = q69(qgu)), qgL(qgR, qgI)), qgI;
}
function q7t(qgu) {
  return q7S(qgu, q7k, void 0, void 0, false);
}
function q7k(qgu) {
  return qgu["W"] === q6n ? qgu["toJSON"]() : qgu instanceof q7n ? qgu["na"](q7t) : function(qgj) {
    switch (typeof qgj) {
      case "number":
        return isFinite(qgj) ? qgj : String(qgj);
      case "bigint":
        return q6m(qgj) ? Number(qgj) : String(qgj);
      case "boolean":
        return qgj ? 1 : 0;
      case "object":
        if (qgj) {
          if (Array["isArray"](qgj)) {
            if (q6E(qgj)) return;
          } else {
            if (q5r(qgj)) return q5L(qgj);
            if (qgj instanceof q5y) {
              const qgL = qgj["g"];
              return qgL == null ? "" : typeof qgL == "string" ? qgL : qgj["g"] = q5L(qgL);
            }
            if (qgj instanceof q7n) return qgj["na"]();
          }
        }
    }
    return qgj;
  }(qgu);
}
function q7O(qgu) {
  return q7F(qgu, q7k, void 0, void 0, false);
}
function q7W(qgu, qgj, qgL) {
  return qgu = q7i(qgu, qgj[0], qgj[1], qgL ? 1 : 2), qgj !== q7E && qgL && q63(qgu, 16384), qgu;
}
function q7i(qgu, qgj, qgL, qgI) {
  if (qgu == null) {
    var qgb = 96;
    qgL ? (qgu = [qgL], qgb |= 512) : qgu = [], qgj && (qgb = -33521665 & qgb | (1023 & qgj) << 15);
  } else {
    if (!Array["isArray"](qgu)) throw Error("narr");
    if (2048 & (qgb = 0 | qgu[q60])) throw Error("farr");
    if (64 & qgb) return qgu;
    if (qgI === 1 || qgI === 2 || (qgb |= 64), qgL && (qgb |= 512, qgL !== qgu[0])) throw Error("mid");
    qgo: {
      if (qgI = (qgL = qgu)["length"]) {
        const qgR = qgI - 1;
        if (q6x(qgL[qgR])) {
          if ((qgj = qgR - (512 & (qgb |= 256) ? 0 : -1)) >= 1024) throw Error("pvtlmt");
          qgb = -33521665 & qgb | (1023 & qgj) << 15;
          break qgo;
        }
      }
      if (qgj) {
        if ((qgj = Math["max"](qgj, qgI - (512 & qgb ? 0 : -1))) > 1024) throw Error("spvt");
        qgb = -33521665 & qgb | (1023 & qgj) << 15;
      }
    }
  }
  return q64(qgu, qgb), qgu;
}
function q7D(qgu, qgj, qgL = q67) {
  if (qgu != null) {
    if (q5u && qgu instanceof Uint8Array) return qgj ? qgu : new Uint8Array(qgu);
    if (Array["isArray"](qgu)) {
      var qgI = 0 | qgu[q60];
      return 2 & qgI ? qgu : (qgj && (qgj = qgI === 0 || !!(32 & qgI) && !(64 & qgI || !(16 & qgI))), qgj ? (q64(qgu, -12293 & (34 | qgI)), qgu) : q7F(qgu, q7D, 4 & qgI ? q67 : qgL, true, true));
    }
    return qgu["W"] === q6n ? qgu = 2 & (qgI = 0 | (qgL = qgu["u"])[q60]) ? qgu : new qgu["constructor"](q7m(qgL, qgI, true)) : qgu instanceof q7n && !(2 & qgu["L"]) && (qgL = q65(qgu["X"](q7D)), qgu = new q7n(qgL, qgu["S"], qgu["R"], qgu["Y"])), qgu;
  }
}
function q7m(qgu, qgj, qgL) {
  const qgI = qgL || 2 & qgj ? q67 : q66, qgb = !!(32 & qgj);
  return qgu = function(qgR, qgo, qgr) {
    const qgQ = q69(qgR);
    var qgd = qgQ["length"];
    const qgv = 256 & qgo ? qgQ[qgd - 1] : void 0;
    for (qgd += qgv ? -1 : 0, qgo = 512 & qgo ? 1 : 0; qgo < qgd; qgo++) qgQ[qgo] = qgr(qgQ[qgo]);
    if (qgv) {
      qgo = qgQ[qgo] = {};
      for (const qgy in qgv) qgo[qgy] = qgr(qgv[qgy]);
    }
    return (qgR = q6F(qgR)) && (qgQ[q5U] = q69(qgR)), qgQ;
  }(qgu, qgj, (qgR) => q7D(qgR, qgb, qgI)), q63(qgu, 32 | (qgL ? 2 : 0)), qgu;
}
function q7a(qgu) {
  const qgj = qgu["u"], qgL = 0 | qgj[q60];
  return 2 & qgL ? new qgu["constructor"](q7m(qgj, qgL, false)) : qgu;
}
function q7Z(qgu, qgj) {
  return q7w(qgu = qgu["u"], 0 | qgu[q60], qgj);
}
function q7w(qgu, qgj, qgL, qgI) {
  if (qgL === -1) return null;
  var qgb = qgL + (512 & qgj ? 0 : -1);
  const qgR = qgu["length"] - 1;
  return qgb >= qgR && 256 & qgj ? qgu[qgR][qgL] : qgI && 256 & qgj && (qgj = qgu[qgR][qgL]) != null ? (qgu[qgb] != null && q5Y != null && ((qgb = (qgu = q5l != null ? q5l : q5l = {})[q5Y] || 0) >= 4 || (qgu[q5Y] = qgb + 1, q5A(qgu = Error(), "incident"), function(qgo) {
    q5q["setTimeout"](() => {
      throw qgo;
    }, 0);
  }(qgu))), qgj) : qgb <= qgR ? qgu[qgb] : void 0;
}
function q7e(qgu, qgj, qgL) {
  const qgI = qgu["u"];
  let qgb = 0 | qgI[q60];
  return q6f(qgb), q7z(qgI, qgb, qgj, qgL), qgu;
}
function q7z(qgu, qgj, qgL, qgI) {
  const qgb = 512 & qgj ? 0 : -1, qgR = qgL + qgb;
  var qgo = qgu["length"] - 1;
  return qgR >= qgo && 256 & qgj ? (qgu[qgo][qgL] = qgI, qgj) : qgR <= qgo ? (qgu[qgR] = qgI, 256 & qgj && qgL in (qgu = qgu[qgo]) && delete qgu[qgL], qgj) : (qgI !== void 0 && (qgL >= (qgo = qgj >> 15 & 1023 || 536870912) ? qgI != null && (qgu[qgo + qgb] = { [qgL]: qgI }, q64(qgu, qgj |= 256)) : qgu[qgR] = qgI), qgj);
}
function q7c(qgu, qgj) {
  let qgL = 0 | (qgu = qgu["u"])[q60];
  const qgI = q7w(qgu, qgL, qgj), qgb = q6H(qgI);
  return qgb != null && qgb !== qgI && q7z(qgu, qgL, qgj, qgb), qgb;
}
function q7X(qgu) {
  let qgj = 0 | (qgu = qgu["u"])[q60];
  const qgL = q7w(qgu, qgj, 1), qgI = q6s(qgL, true);
  return qgI != null && qgI !== qgL && q7z(qgu, qgj, 1, qgI), qgI;
}
function q7G() {
  return q6t === void 0 ? 2 : 4;
}
function q7N(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgu["u"], qgo = 2 & (qgu = 0 | qgR[q60]) ? 1 : qgI;
  qgb = !!qgb;
  let qgr = 0 | (qgI = q7u(qgR, qgu, qgj))[q60];
  if (!(4 & qgr)) {
    4 & qgr && (qgI = q69(qgI), qgr = q7T(qgr, qgu), qgu = q7z(qgR, qgu, qgj, qgI));
    let qgQ = 0, qgd = 0;
    for (; qgQ < qgI["length"]; qgQ++) {
      const qgv = qgL(qgI[qgQ]);
      qgv != null && (qgI[qgd++] = qgv);
    }
    qgd < qgQ && (qgI["length"] = qgd), qgr = q7j(qgr, qgu), qgL = -4097 & (20 | qgr), qgr = qgL &= -8193, q64(qgI, qgr), 2 & qgr && Object["freeze"](qgI);
  }
  return qgo === 1 || qgo === 4 && 32 & qgr ? q7L(qgr) || (qgb = qgr, qgr |= 2, qgr !== qgb && q64(qgI, qgr), Object["freeze"](qgI)) : (qgo === 2 && q7L(qgr) && (qgI = q69(qgI), qgr = q7T(qgr, qgu), qgr = q7K(qgr, qgu, qgb), q64(qgI, qgr), qgu = q7z(qgR, qgu, qgj, qgI)), q7L(qgr) || (qgj = qgr, qgr = q7K(qgr, qgu, qgb), qgr !== qgj && q64(qgI, qgr))), qgI;
}
function q7u(qgu, qgj, qgL, qgI) {
  return qgu = q7w(qgu, qgj, qgL, qgI), Array["isArray"](qgu) ? qgu : q6q;
}
function q7j(qgu, qgj) {
  return qgu === 0 && (qgu = q7T(qgu, qgj)), 1 | qgu;
}
function q7L(qgu) {
  return !!(2 & qgu) && !!(4 & qgu) || !!(2048 & qgu);
}
function q7I(qgu) {
  qgu = q69(qgu);
  for (let qgj = 0; qgj < qgu["length"]; qgj++) {
    const qgL = qgu[qgj] = q69(qgu[qgj]);
    Array["isArray"](qgL[1]) && (qgL[1] = q65(qgL[1]));
  }
  return qgu;
}
function q7b(qgu, qgj, qgL, qgI) {
  let qgb = 0 | (qgu = qgu["u"])[q60];
  q6f(qgb), q7z(qgu, qgb, qgj, (qgI === "0" ? Number(qgL) === 0 : qgL === qgI) ? void 0 : qgL);
}
function q7R(qgu, qgj, qgL, qgI, qgb) {
  q6f(qgj);
  var qgR = !(!(64 & qgj) && 16384 & qgj);
  const qgo = (qgb = q7u(qgu, qgj, qgL, qgb)) !== q6q;
  if (qgR || !qgo) {
    let qgr = qgR = qgo ? 0 | qgb[q60] : 0;
    (!qgo || 2 & qgr || q7L(qgr) || 4 & qgr && !(32 & qgr)) && (qgb = q69(qgb), qgr = q7T(qgr, qgj), qgj = q7z(qgu, qgj, qgL, qgb)), qgr = -13 & q7j(qgr, qgj), qgr = q7K(qgI ? -17 & qgr : 16 | qgr, qgj, true), qgr !== qgR && q64(qgb, qgr);
  }
  return qgb;
}
function q7o(qgu, qgj) {
  var qgL = qqR;
  return q7d(q7r(qgu = qgu["u"]), qgu, 0 | qgu[q60], qgL) === qgj ? qgj : -1;
}
function q7r(qgu) {
  var qgj;
  if (q5T) return (qgj = qgu[q5P]) != null ? qgj : qgu[q5P] = /* @__PURE__ */ new Map();
  if (q5P in qgu) return qgu[q5P];
  const qgL = /* @__PURE__ */ new Map();
  return Object["defineProperty"](qgu, q5P, { "value": qgL }), qgL;
}
function q7Q(qgu, qgj, qgL, qgI) {
  const qgb = q7r(qgu), qgR = q7d(qgb, qgu, qgj, qgL);
  return qgR !== qgI && (qgR && (qgj = q7z(qgu, qgj, qgR)), qgb["set"](qgL, qgI)), qgj;
}
function q7d(qgu, qgj, qgL, qgI) {
  let qgb = qgu["get"](qgI);
  if (qgb != null) return qgb;
  qgb = 0;
  for (let qgR = 0; qgR < qgI["length"]; qgR++) {
    const qgo = qgI[qgR];
    q7w(qgj, qgL, qgo) != null && (qgb !== 0 && (qgL = q7z(qgj, qgL, qgb)), qgb = qgo);
  }
  return qgu["set"](qgI, qgb), qgb;
}
function q7v(qgu, qgj, qgL, qgI) {
  let qgb, qgR = 0 | qgu[q60];
  if ((qgI = q7w(qgu, qgR, qgL, qgI)) != null && qgI["W"] === q6n) return (qgj = q7a(qgI)) !== qgI && q7z(qgu, qgR, qgL, qgj), qgj["u"];
  if (Array["isArray"](qgI)) {
    const qgo = 0 | qgI[q60];
    qgb = 2 & qgo ? q7W(q7m(qgI, qgo, false), qgj, true) : 64 & qgo ? qgI : q7W(qgb, qgj, true);
  } else qgb = q7W(void 0, qgj, true);
  return qgb !== qgI && q7z(qgu, qgR, qgL, qgb), qgb;
}
function q7y(qgu, qgj, qgL, qgI) {
  let qgb = 0 | (qgu = qgu["u"])[q60];
  return (qgj = q73(qgI = q7w(qgu, qgb, qgL, qgI), qgj, false, qgb)) !== qgI && qgj != null && q7z(qgu, qgb, qgL, qgj), qgj;
}
function q7C(qgu, qgj, qgL, qgI = false) {
  if ((qgj = q7y(qgu, qgj, qgL, qgI)) == null) return qgj;
  if (!(2 & (qgI = 0 | (qgu = qgu["u"])[q60]))) {
    const qgb = q7a(qgj);
    qgb !== qgj && q7z(qgu, qgI, qgL, qgj = qgb);
  }
  return qgj;
}
function q7l(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
  qgu = qgu["u"];
  var qgr = !!(2 & qgj);
  const qgQ = qgr ? 1 : qgb;
  qgR = !!qgR, qgo && (qgo = !qgr);
  var qgd = 0 | (qgb = q7u(qgu, qgj, qgI))[q60];
  if (!(qgr = !!(4 & qgd))) {
    var qgv = qgb, qgy = qgj;
    const qgl = !!(2 & (qgd = q7j(qgd, qgj)));
    qgl && (qgy |= 2);
    let qgH = !qgl, qgA = true, qgh = 0, qgT = 0;
    for (; qgh < qgv["length"]; qgh++) {
      const qgK = q73(qgv[qgh], qgL, false, qgy);
      if (qgK instanceof qgL) {
        if (!qgl) {
          const qgB = !!(2 & (0 | qgK["u"][q60]));
          qgH && (qgH = !qgB), qgA && (qgA = qgB);
        }
        qgv[qgT++] = qgK;
      }
    }
    qgT < qgh && (qgv["length"] = qgT), qgd |= 4, qgd = qgA ? 16 | qgd : -17 & qgd, q64(qgv, qgd = qgH ? 8 | qgd : -9 & qgd), qgl && Object["freeze"](qgv);
  }
  if (qgo && !(8 & qgd || !qgb["length"] && (qgQ === 1 || qgQ === 4 && 32 & qgd))) {
    for (q7L(qgd) && (qgb = q69(qgb), qgd = q7T(qgd, qgj), qgj = q7z(qgu, qgj, qgI, qgb)), qgL = qgb, qgo = qgd, qgv = 0; qgv < qgL["length"]; qgv++) (qgd = qgL[qgv]) !== (qgy = q7a(qgd)) && (qgL[qgv] = qgy);
    qgo |= 8, q64(qgL, qgo = qgL["length"] ? -17 & qgo : 16 | qgo), qgd = qgo;
  }
  return qgQ === 1 || qgQ === 4 && 32 & qgd ? q7L(qgd) || (qgj = qgd, (qgd |= !qgb["length"] || 16 & qgd && (!qgr || 32 & qgd) ? 2 : 2048) !== qgj && q64(qgb, qgd), Object["freeze"](qgb)) : (qgQ === 2 && q7L(qgd) && (q64(qgb = q69(qgb), qgd = q7K(qgd = q7T(qgd, qgj), qgj, qgR)), qgj = q7z(qgu, qgj, qgI, qgb)), q7L(qgd) || (qgI = qgd, (qgd = q7K(qgd, qgj, qgR)) !== qgI && q64(qgb, qgd))), qgb;
}
function q7H(qgu, qgj, qgL) {
  const qgI = 0 | qgu["u"][q60];
  return q7l(qgu, qgI, qgj, qgL, q7G(), false, !(2 & qgI));
}
function q7A(qgu, qgj, qgL, qgI) {
  return qgI == null && (qgI = void 0), q7e(qgu, qgL, qgI);
}
function q7h(qgu, qgj, qgL, qgI) {
  qgI == null && (qgI = void 0);
  qgo: {
    let qgb = 0 | (qgu = qgu["u"])[q60];
    if (q6f(qgb), qgI == null) {
      const qgR = q7r(qgu);
      if (q7d(qgR, qgu, qgb, qgL) !== qgj) break qgo;
      qgR["set"](qgL, 0);
    } else qgb = q7Q(qgu, qgb, qgL, qgj);
    q7z(qgu, qgb, qgj, qgI);
  }
}
function q7T(qgu, qgj) {
  return -2049 & (qgu = 32 | (2 & qgj ? 2 | qgu : -3 & qgu));
}
function q7K(qgu, qgj, qgL) {
  return 32 & qgj && qgL || (qgu &= -33), qgu;
}
function q7B(qgu, qgj, qgL, qgI) {
  const qgb = 0 | qgu["u"][q60];
  q6f(qgb), qgu = q7l(qgu, qgb, qgL, qgj, 2, true), qgI = qgI != null ? qgI : new qgL(), qgu["push"](qgI), qgu[q60] = 2 & (0 | qgI["u"][q60]) ? -9 & qgu[q60] : -17 & qgu[q60];
}
function q7V(qgu, qgj) {
  return q6K(q7Z(qgu, qgj));
}
function q7J(qgu, qgj) {
  return q72(q7Z(qgu, qgj));
}
function q7Y(qgu, qgj) {
  var qgL;
  return (qgL = q7c(qgu, qgj)) != null ? qgL : 0;
}
function q7P(qgu, qgj, qgL) {
  if (qgL != null && typeof qgL != "boolean") throw qgu = typeof qgL, Error("Expected boolean but got " + (qgu != "object" ? qgu : qgL ? Array["isArray"](qgL) ? "array" : qgu : "null") + ": " + qgL);
  q7e(qgu, qgj, qgL);
}
function q7U(qgu, qgj, qgL) {
  if (qgL != null) {
    if (typeof qgL != "number" || !q6C(qgL)) throw q5h("int32");
    qgL |= 0;
  }
  q7e(qgu, qgj, qgL);
}
function q80(qgu, qgj, qgL) {
  if (qgL != null && typeof qgL != "number") throw Error("Value of float/double field must be a number, found " + typeof qgL + ": " + qgL);
  q7e(qgu, qgj, qgL);
}
function q81(qgu, qgj, qgL) {
  {
    const qgo = qgu["u"];
    let qgr = 0 | qgo[q60];
    if (q6f(qgr), qgL == null) q7z(qgo, qgr, qgj);
    else {
      var qgI = qgu = 0 | qgL[q60], qgb = q7L(qgu), qgR = qgb || Object["isFrozen"](qgL);
      for (qgb || (qgu = 0), qgR || (qgL = q69(qgL), qgI = 0, qgu = q7K(qgu = q7T(qgu, qgr), qgr, true), qgR = false), qgu |= 21, qgb = 0; qgb < qgL["length"]; qgb++) {
        const qgQ = qgL[qgb], qgd = q70(qgQ);
        Object["is"](qgQ, qgd) || (qgR && (qgL = q69(qgL), qgI = 0, qgu = q7K(qgu = q7T(qgu, qgr), qgr, true), qgR = false), qgL[qgb] = qgd);
      }
      qgu !== qgI && (qgR && (qgL = q69(qgL), qgu = q7K(qgu = q7T(qgu, qgr), qgr, true)), q64(qgL, qgu)), q7z(qgo, qgr, qgj, qgL);
    }
  }
}
function q82(qgu, qgj, qgL) {
  q6f(0 | qgu["u"][q60]), q7N(qgu, qgj, q72, 2, true)["push"](q70(qgL));
}
function q83(qgu, qgj) {
  return Error("Invalid wire type: " + qgu + " (at position " + qgj + ")");
}
function q84() {
  return Error("Failed to read varint, encoding is invalid.");
}
function q85(qgu, qgj) {
  return Error("Tried to read past the end of the data " + qgj + " > " + qgu);
}
function q86(qgu) {
  if (typeof qgu == "string") return { "buffer": q5o(qgu), "N": false };
  if (Array["isArray"](qgu)) return { "buffer": new Uint8Array(qgu), "N": false };
  if (qgu["constructor"] === Uint8Array) return { "buffer": qgu, "N": false };
  if (qgu["constructor"] === ArrayBuffer) return { "buffer": new Uint8Array(qgu), "N": false };
  if (qgu["constructor"] === q5y) return { "buffer": q5v(qgu) || new Uint8Array(0), "N": true };
  if (qgu instanceof Uint8Array) return { "buffer": new Uint8Array(qgu["buffer"], qgu["byteOffset"], qgu["byteLength"]), "N": false };
  throw Error("Type not convertible to a Uint8Array, expected a Uint8Array, an ArrayBuffer, a base64 encoded string, a ByteString or an Array of numbers");
}
function q87(qgu, qgj) {
  let qgL, qgI = 0, qgb = 0, qgR = 0;
  const qgo = qgu["h"];
  let qgr = qgu["g"];
  do
    qgL = qgo[qgr++], qgI |= (127 & qgL) << qgR, qgR += 7;
  while (qgR < 32 && 128 & qgL);
  for (qgR > 32 && (qgb |= (127 & qgL) >> 4), qgR = 3; qgR < 32 && 128 & qgL; qgR += 7) qgL = qgo[qgr++], qgb |= (127 & qgL) << qgR;
  if (q8s(qgu, qgr), qgL < 128) return qgj(qgI >>> 0, qgb >>> 0);
  throw q84();
}
function q88(qgu) {
  let qgj = 0, qgL = qgu["g"];
  const qgI = qgL + 10, qgb = qgu["h"];
  for (; qgL < qgI; ) {
    const qgR = qgb[qgL++];
    if (qgj |= qgR, (128 & qgR) == 0) return q8s(qgu, qgL), !!(127 & qgj);
  }
  throw q84();
}
function q89(qgu) {
  const qgj = qgu["h"];
  let qgL = qgu["g"], qgI = qgj[qgL++], qgb = 127 & qgI;
  if (128 & qgI && (qgI = qgj[qgL++], qgb |= (127 & qgI) << 7, 128 & qgI && (qgI = qgj[qgL++], qgb |= (127 & qgI) << 14, 128 & qgI && (qgI = qgj[qgL++], qgb |= (127 & qgI) << 21, 128 & qgI && (qgI = qgj[qgL++], qgb |= qgI << 28, 128 & qgI && 128 & qgj[qgL++] && 128 & qgj[qgL++] && 128 & qgj[qgL++] && 128 & qgj[qgL++] && 128 & qgj[qgL++]))))) throw q84();
  return q8s(qgu, qgL), qgb;
}
function q8q(qgu) {
  return q89(qgu) >>> 0;
}
function q8n(qgu) {
  var qgj = qgu["h"];
  const qgL = qgu["g"], qgI = qgj[qgL], qgb = qgj[qgL + 1], qgR = qgj[qgL + 2];
  return qgj = qgj[qgL + 3], q8s(qgu, qgu["g"] + 4), (qgI << 0 | qgb << 8 | qgR << 16 | qgj << 24) >>> 0;
}
function q8p(qgu) {
  var qgj = q8n(qgu);
  qgu = 2 * (qgj >> 31) + 1;
  const qgL = qgj >>> 23 & 255;
  return qgj &= 8388607, qgL == 255 ? qgj ? NaN : qgu * (1 / 0) : qgL == 0 ? 1401298464324817e-60 * qgu * qgj : qgu * Math["pow"](2, qgL - 150) * (qgj + 8388608);
}
function q8g(qgu) {
  return q89(qgu);
}
function q8x(qgu, qgj, { ba: qgL = false } = {}) {
  qgu["ba"] = qgL, qgj && (qgj = q86(qgj), qgu["h"] = qgj["buffer"], qgu["m"] = qgj["N"], qgu["j"] = 0, qgu["l"] = qgu["h"]["length"], qgu["g"] = qgu["j"]);
}
function q8s(qgu, qgj) {
  if (qgu["g"] = qgj, qgj > qgu["l"]) throw q85(qgu["l"], qgj);
}
function q8E(qgu, qgj) {
  if (qgj < 0) throw Error("Tried to read a negative byte length: " + qgj);
  const qgL = qgu["g"], qgI = qgL + qgj;
  if (qgI > qgu["l"]) throw q85(qgj, qgu["l"] - qgL);
  return qgu["g"] = qgI, qgL;
}
function q8M(qgu, qgj) {
  if (qgj == 0) return q5d();
  var qgL = q8E(qgu, qgj);
  return qgu["ba"] && qgu["m"] ? qgL = qgu["h"]["subarray"](qgL, qgL + qgj) : (qgu = qgu["h"], qgL = qgL === (qgj = qgL + qgj) ? new Uint8Array(0) : q6c ? qgu["slice"](qgL, qgj) : new Uint8Array(qgu["subarray"](qgL, qgj))), qgL["length"] == 0 ? q5d() : new q5y(qgL, q5Q);
}
q7n["prototype"]["toJSON"] = void 0, q7n["prototype"]["Ia"] = q6p;
var q8f = [];
function q8S(qgu) {
  var qgj = qgu["g"];
  if (qgj["g"] == qgj["l"]) return false;
  qgu["l"] = qgu["g"]["g"];
  var qgL = q8q(qgu["g"]);
  if (qgj = qgL >>> 3, !((qgL &= 7) >= 0 && qgL <= 5)) throw q83(qgL, qgu["l"]);
  if (qgj < 1) throw Error("Invalid field number: " + qgj + " (at position " + qgu["l"] + ")");
  return qgu["m"] = qgj, qgu["h"] = qgL, true;
}
function q8F(qgu) {
  switch (qgu["h"]) {
    case 0:
      qgu["h"] != 0 ? q8F(qgu) : q88(qgu["g"]);
      break;
    case 1:
      q8s(qgu = qgu["g"], qgu["g"] + 8);
      break;
    case 2:
      if (qgu["h"] != 2) q8F(qgu);
      else {
        var qgj = q8q(qgu["g"]);
        q8s(qgu = qgu["g"], qgu["g"] + qgj);
      }
      break;
    case 5:
      q8s(qgu = qgu["g"], qgu["g"] + 4);
      break;
    case 3:
      for (qgj = qgu["m"]; ; ) {
        if (!q8S(qgu)) throw Error("Unmatched start-group tag: stream EOF");
        if (qgu["h"] == 4) {
          if (qgu["m"] != qgj) throw Error("Unmatched end-group tag");
          break;
        }
        q8F(qgu);
      }
      break;
    default:
      throw q83(qgu["h"], qgu["l"]);
  }
}
function q8t(qgu, qgj, qgL) {
  const qgI = qgu["g"]["l"], qgb = q8q(qgu["g"]), qgR = qgu["g"]["g"] + qgb;
  let qgo = qgR - qgI;
  if (qgo <= 0 && (qgu["g"]["l"] = qgR, qgL(qgj, qgu, void 0, void 0, void 0), qgo = qgR - qgu["g"]["g"]), qgo) throw Error("Message parsing ended unexpectedly. Expected to read " + qgb + " bytes, instead read " + (qgb - qgo) + " bytes, either the data ended unexpectedly or the message misreported its own length");
  return qgu["g"]["g"] = qgR, qgu["g"]["l"] = qgI, qgj;
}
function q8k(qgu) {
  var qgj = q8q(qgu["g"]), qgL = q8E(qgu = qgu["g"], qgj);
  if (qgu = qgu["h"], q5s) {
    var qgI, qgb = qgu;
    (qgI = q5x) || (qgI = q5x = new TextDecoder("utf-8", { "fatal": true })), qgj = qgL + qgj, qgb = qgL === 0 && qgj === qgb["length"] ? qgb : qgb["subarray"](qgL, qgj);
    try {
      var qgR = qgI["decode"](qgb);
    } catch (qgr) {
      if (q5g === void 0) {
        try {
          qgI["decode"](new Uint8Array([128]));
        } catch (qgQ) {
        }
        try {
          qgI["decode"](new Uint8Array([97])), q5g = true;
        } catch (qgd) {
          q5g = false;
        }
      }
      throw !q5g && (q5x = void 0), qgr;
    }
  } else {
    qgj = (qgR = qgL) + qgj, qgL = [];
    let qgv, qgy = null;
    for (; qgR < qgj; ) {
      var qgo = qgu[qgR++];
      qgo < 128 ? qgL["push"](qgo) : qgo < 224 ? qgR >= qgj ? q5n() : (qgv = qgu[qgR++], qgo < 194 || (192 & qgv) != 128 ? (qgR--, q5n()) : qgL["push"]((31 & qgo) << 6 | 63 & qgv)) : qgo < 240 ? qgR >= qgj - 1 ? q5n() : (qgv = qgu[qgR++], (192 & qgv) != 128 || qgo === 224 && qgv < 160 || qgo === 237 && qgv >= 160 || (192 & (qgI = qgu[qgR++])) != 128 ? (qgR--, q5n()) : qgL["push"]((15 & qgo) << 12 | (63 & qgv) << 6 | 63 & qgI)) : qgo <= 244 ? qgR >= qgj - 2 ? q5n() : (qgv = qgu[qgR++], (192 & qgv) != 128 || qgv - 144 + (qgo << 28) >> 30 != 0 || (192 & (qgI = qgu[qgR++])) != 128 || (192 & (qgb = qgu[qgR++])) != 128 ? (qgR--, q5n()) : (qgo = (7 & qgo) << 18 | (63 & qgv) << 12 | (63 & qgI) << 6 | 63 & qgb, qgo -= 65536, qgL["push"](55296 + (qgo >> 10 & 1023), 56320 + (1023 & qgo)))) : q5n(), qgL["length"] >= 8192 && (qgy = q5p(qgy, qgL), qgL["length"] = 0);
    }
    qgR = q5p(qgy, qgL);
  }
  return qgR;
}
function q8O(qgu) {
  const qgj = q8q(qgu["g"]);
  return q8M(qgu["g"], qgj);
}
function q8W(qgu, qgj, qgL) {
  var qgI = q8q(qgu["g"]);
  for (qgI = qgu["g"]["g"] + qgI; qgu["g"]["g"] < qgI; ) qgL["push"](qgj(qgu["g"]));
}
var q8i = [];
function q8D(qgu) {
  return qgu;
}
var q8m;
function q8a(qgu, qgj, qgL) {
  qgj["g"] ? qgj["m"](qgu, qgj["g"], qgj["h"], qgL) : qgj["m"](qgu, qgj["h"], qgL);
}
var q8Z = class {
  constructor(qgu, qgj) {
    this["u"] = q7i(qgu, qgj);
  }
  ["toJSON"]() {
    const qgu = !q8m;
    try {
      return qgu && (q8m = q7O), q8w(this);
    } finally {
      qgu && (q8m = void 0);
    }
  }
  ["l"]() {
    var qgu = qnZ;
    return qgu["g"] ? qgu["l"](this, qgu["g"], qgu["h"], true) : qgu["l"](this, qgu["h"], qgu["defaultValue"], true);
  }
  ["clone"]() {
    const qgu = this["u"];
    return new this["constructor"](q7m(qgu, 0 | qgu[q60], false));
  }
  ["N"]() {
    return !!(2 & (0 | this["u"][q60]));
  }
};
function q8w(qgu) {
  var qgj = qgu["u"];
  {
    qgj = (qgu = q8m(qgj)) !== qgj;
    let qgd = qgu["length"];
    if (qgd) {
      var qgL = qgu[qgd - 1], qgI = q6x(qgL);
      qgI ? qgd-- : qgL = void 0;
      var qgb = qgu;
      if (qgI) {
        qgl: {
          var qgR, qgo = qgL, qgr = false;
          if (qgo) {
            for (let qgv in qgo) isNaN(+qgv) ? (qgR != null ? qgR : qgR = {})[qgv] = qgo[qgv] : (qgI = qgo[qgv], Array["isArray"](qgI) && (q6E(qgI) || q6g(qgI) && qgI["size"] === 0) && (qgI = null), qgI == null && (qgr = true), qgI != null && ((qgR != null ? qgR : qgR = {})[qgv] = qgI));
          }
          if (qgr || (qgR = qgo), qgR) for (let qgy in qgR) {
            qgr = qgR;
            break qgl;
          }
          qgr = null;
        }
        qgo = qgr == null ? qgL != null : qgr !== qgL;
      }
      for (; qgd > 0 && ((qgR = qgb[qgd - 1]) == null || q6E(qgR) || q6g(qgR) && qgR["size"] === 0); qgd--) var qgQ = true;
      (qgb !== qgu || qgo || qgQ) && (qgj ? (qgQ || qgo || qgr) && (qgb["length"] = qgd) : qgb = Array["prototype"]["slice"]["call"](qgb, 0, qgd), qgr && qgb["push"](qgr)), qgQ = qgb;
    } else qgQ = qgu;
  }
  return qgQ;
}
function q8e(qgu) {
  return qgu ? /^\d+$/["test"](qgu) ? (q6r(qgu), new q8z(q6G, q6N)) : null : q8c || (q8c = new q8z(0, 0));
}
q8Z["prototype"]["W"] = q6n, q8Z["prototype"]["toString"] = function() {
  try {
    return q8m = q8D, q8w(this)["toString"]();
  } finally {
    q8m = void 0;
  }
};
var q8z = class {
  constructor(qgu, qgj) {
    this["h"] = qgu >>> 0, this["g"] = qgj >>> 0;
  }
};
var q8c;
function q8X(qgu) {
  return qgu ? /^-?\d+$/["test"](qgu) ? (q6r(qgu), new q8G(q6G, q6N)) : null : q8N || (q8N = new q8G(0, 0));
}
var q8G = class {
  constructor(qgu, qgj) {
    this["h"] = qgu >>> 0, this["g"] = qgj >>> 0;
  }
};
var q8N;
function q8u(qgu, qgj, qgL) {
  for (; qgL > 0 || qgj > 127; ) qgu["g"]["push"](127 & qgj | 128), qgj = (qgj >>> 7 | qgL << 25) >>> 0, qgL >>>= 7;
  qgu["g"]["push"](qgj);
}
function q8j(qgu, qgj) {
  for (; qgj > 127; ) qgu["g"]["push"](127 & qgj | 128), qgj >>>= 7;
  qgu["g"]["push"](qgj);
}
function q8L(qgu, qgj) {
  if (qgj >= 0) q8j(qgu, qgj);
  else {
    for (let qgL = 0; qgL < 9; qgL++) qgu["g"]["push"](127 & qgj | 128), qgj >>= 7;
    qgu["g"]["push"](1);
  }
}
function q8I(qgu, qgj) {
  qgu["g"]["push"](qgj >>> 0 & 255), qgu["g"]["push"](qgj >>> 8 & 255), qgu["g"]["push"](qgj >>> 16 & 255), qgu["g"]["push"](qgj >>> 24 & 255);
}
function q8b(qgu, qgj) {
  qgj["length"] !== 0 && (qgu["l"]["push"](qgj), qgu["h"] += qgj["length"]);
}
function q8R(qgu, qgj, qgL) {
  q8j(qgu["g"], 8 * qgj + qgL);
}
function q8o(qgu, qgj) {
  return q8R(qgu, qgj, 2), qgj = qgu["g"]["end"](), q8b(qgu, qgj), qgj["push"](qgu["h"]), qgj;
}
function q8r(qgu, qgj) {
  var qgL = qgj["pop"]();
  for (qgL = qgu["h"] + qgu["g"]["length"]() - qgL; qgL > 127; ) qgj["push"](127 & qgL | 128), qgL >>>= 7, qgu["h"]++;
  qgj["push"](qgL), qgu["h"]++;
}
function q8Q(qgu, qgj, qgL) {
  q8R(qgu, qgj, 2), q8j(qgu["g"], qgL["length"]), q8b(qgu, qgu["g"]["end"]()), q8b(qgu, qgL);
}
function q8d(qgu, qgj, qgL, qgI) {
  qgL != null && (qgj = q8o(qgu, qgj), qgI(qgL, qgu), q8r(qgu, qgj));
}
function q8v() {
  const qgu = class {
    constructor() {
      throw Error();
    }
  };
  return Object["setPrototypeOf"](qgu, qgu["prototype"]), qgu;
}
var q8y = q8v();
var q8C = q8v();
var q8l = q8v();
var q8H = q8v();
var q8A = q8v();
var q8h = q8v();
var q8T = q8v();
var q8K = q8v();
var q8B = q8v();
var q8V = class {
  constructor(qgu, qgj, qgL) {
    this["g"] = qgu, this["h"] = qgj, qgu = q8y, this["l"] = !!qgu && qgL === qgu || false;
  }
};
function q8J(qgu, qgj) {
  return new q8V(qgu, qgj, q8y);
}
function q8Y(qgu, qgj, qgL, qgI, qgb) {
  q8d(qgu, qgL, q98(qgj, qgI), qgb);
}
var q8P = q8J(function(qgu, qgj, qgL, qgI, qgb) {
  return qgu["h"] === 2 && (q8t(qgu, q7v(qgj, qgI, qgL), qgb), true);
}, q8Y);
var q8U = q8J(function(qgu, qgj, qgL, qgI, qgb) {
  return qgu["h"] === 2 && (q8t(qgu, q7v(qgj, qgI, qgL, true), qgb), true);
}, q8Y);
var q90 = Symbol();
var q91 = Symbol();
var q92 = Symbol();
var q93 = Symbol();
var q94;
var q95;
function q96(qgu, qgj, qgL, qgI) {
  var qgb = qgI[qgu];
  if (qgb) return qgb;
  (qgb = {})["Pa"] = qgI, qgb["V"] = function(qgy) {
    switch (typeof qgy) {
      case "boolean":
        return q7E || (q7E = [0, void 0, true]);
      case "number":
        return qgy > 0 ? void 0 : qgy === 0 ? q7M || (q7M = [0, void 0]) : [-qgy, void 0];
      case "string":
        return [0, qgy];
      case "object":
        return qgy;
    }
  }(qgI[0]);
  var qgR = qgI[1];
  let qgo = 1;
  qgR && qgR["constructor"] === Object && (qgb["ga"] = qgR, typeof (qgR = qgI[++qgo]) == "function" && (qgb["la"] = true, q94 != null || (q94 = qgR), q95 != null || (q95 = qgI[qgo + 1]), qgR = qgI[qgo += 2]));
  const qgr = {};
  for (; qgR && Array["isArray"](qgR) && qgR["length"] && typeof qgR[0] == "number" && qgR[0] > 0; ) {
    for (var qgQ = 0; qgQ < qgR["length"]; qgQ++) qgr[qgR[qgQ]] = qgR;
    qgR = qgI[++qgo];
  }
  for (qgQ = 1; qgR !== void 0; ) {
    let qgy;
    typeof qgR == "number" && (qgQ += qgR, qgR = qgI[++qgo]);
    var qgd = void 0;
    if (qgR instanceof q8V ? qgy = qgR : (qgy = q8P, qgo--), qgy == null ? void 0 : qgy["l"]) {
      qgR = qgI[++qgo], qgd = qgI;
      var qgv = qgo;
      typeof qgR == "function" && (qgR = qgR(), qgd[qgv] = qgR), qgd = qgR;
    }
    for (qgv = qgQ + 1, typeof (qgR = qgI[++qgo]) == "number" && qgR < 0 && (qgv -= qgR, qgR = qgI[++qgo]); qgQ < qgv; qgQ++) {
      const qgl = qgr[qgQ];
      qgd ? qgL(qgb, qgQ, qgy, qgd, qgl) : qgj(qgb, qgQ, qgy, qgl);
    }
  }
  return qgI[qgu] = qgb;
}
function q97(qgu) {
  return Array["isArray"](qgu) ? qgu[0] instanceof q8V ? qgu : [q8U, qgu] : [qgu, void 0];
}
function q98(qgu, qgj) {
  return qgu instanceof q8Z ? qgu["u"] : Array["isArray"](qgu) ? q7W(qgu, qgj, false) : void 0;
}
function q99(qgu, qgj, qgL, qgI) {
  const qgb = qgL["g"];
  qgu[qgj] = qgI ? (qgR, qgo, qgr) => qgb(qgR, qgo, qgr, qgI) : qgb;
}
function q9q(qgu, qgj, qgL, qgI, qgb) {
  const qgR = qgL["g"];
  let qgo, qgr;
  qgu[qgj] = (qgQ, qgd, qgv) => qgR(qgQ, qgd, qgv, qgr || (qgr = q96(q91, q99, q9q, qgI)["V"]), qgo || (qgo = q9n(qgI)), qgb);
}
function q9n(qgu) {
  let qgj = qgu[q92];
  if (qgj != null) return qgj;
  const qgL = q96(q91, q99, q9q, qgu);
  return qgj = qgL["la"] ? (qgI, qgb) => q94(qgI, qgb, qgL) : (qgI, qgb) => {
    const qgR = 0 | qgI[q60];
    for (; q8S(qgb) && qgb["h"] != 4; ) {
      var qgo = qgb["m"], qgr = qgL[qgo];
      if (qgr == null) {
        var qgQ = qgL["ga"];
        qgQ && (qgQ = qgQ[qgo]) && (qgQ = q9p(qgQ)) != null && (qgr = qgL[qgo] = qgQ);
      }
      qgr != null && qgr(qgb, qgI, qgo) || (qgo = (qgr = qgb)["l"], q8F(qgr), qgr["fa"] ? qgr = void 0 : (qgQ = qgr["g"]["g"] - qgo, qgr["g"]["g"] = qgo, qgr = q8M(qgr["g"], qgQ)), qgo = qgI, qgr && ((qgQ = qgo[q5U]) ? qgQ["push"](qgr) : qgo[q5U] = [qgr]));
    }
    return 16384 & qgR && q65(qgI), true;
  }, qgu[q92] = qgj;
}
function q9p(qgu) {
  const qgj = (qgu = q97(qgu))[0]["g"];
  if (qgu = qgu[1]) {
    const qgL = q9n(qgu), qgI = q96(q91, q99, q9q, qgu)["V"];
    return (qgb, qgR, qgo) => qgj(qgb, qgR, qgo, qgI, qgL);
  }
  return qgj;
}
function q9g(qgu, qgj, qgL) {
  qgu[qgj] = qgL["h"];
}
function q9x(qgu, qgj, qgL, qgI) {
  let qgb, qgR;
  const qgo = qgL["h"];
  qgu[qgj] = (qgr, qgQ, qgd) => qgo(qgr, qgQ, qgd, qgR || (qgR = q96(q90, q9g, q9x, qgI)["V"]), qgb || (qgb = q9s(qgI)));
}
function q9s(qgu) {
  let qgj = qgu[q93];
  if (!qgj) {
    const qgL = q96(q90, q9g, q9x, qgu);
    qgj = (qgI, qgb) => q9E(qgI, qgb, qgL), qgu[q93] = qgj;
  }
  return qgj;
}
function q9E(qgu, qgj, qgL) {
  for (var qgI = 0 | qgu[q60], qgb = 512 & qgI ? 0 : -1, qgR = qgu["length"], qgo = 512 & qgI ? 1 : 0, qgr = qgR + (256 & qgI ? -1 : 0); qgo < qgr; qgo++) {
    const qgQ = qgu[qgo];
    if (qgQ == null) continue;
    const qgd = qgo - qgb, qgv = q9M(qgL, qgd);
    qgv && qgv(qgj, qgQ, qgd);
  }
  if (256 & qgI) {
    qgI = qgu[qgR - 1];
    for (const qgy in qgI) qgb = +qgy, Number["isNaN"](qgb) || (qgR = qgI[qgb]) != null && (qgr = q9M(qgL, qgb)) && qgr(qgj, qgR, qgb);
  }
  if (qgu = q6F(qgu)) {
    for (q8b(qgj, qgj["g"]["end"]()), qgL = 0; qgL < qgu["length"]; qgL++) q8b(qgj, q5v(qgu[qgL]) || new Uint8Array(0));
  }
}
function q9M(qgu, qgj) {
  var qgL = qgu[qgj];
  if (qgL) return qgL;
  if ((qgL = qgu["ga"]) && (qgL = qgL[qgj])) {
    var qgI = (qgL = q97(qgL))[0]["h"];
    if (qgL = qgL[1]) {
      const qgb = q9s(qgL), qgR = q96(q90, q9g, q9x, qgL)["V"];
      qgL = qgu["la"] ? q95(qgR, qgb) : (qgo, qgr, qgQ) => qgI(qgo, qgr, qgQ, qgR, qgb);
    } else qgL = qgI;
    return qgu[qgj] = qgL;
  }
}
function q9f(qgu, qgj) {
  if (Array["isArray"](qgj)) {
    var qgL = 0 | qgj[q60];
    if (4 & qgL) return qgj;
    for (var qgI = 0, qgb = 0; qgI < qgj["length"]; qgI++) {
      const qgR = qgu(qgj[qgI]);
      qgR != null && (qgj[qgb++] = qgR);
    }
    return qgb < qgI && (qgj["length"] = qgb), q64(qgj, -12289 & (5 | qgL)), 2 & qgL && Object["freeze"](qgj), qgj;
  }
}
function q9S(qgu, qgj, qgL) {
  return new q8V(qgu, qgj, qgL);
}
function q9F(qgu, qgj, qgL) {
  return new q8V(qgu, qgj, qgL);
}
function q9t(qgu, qgj, qgL) {
  q7z(qgu, 0 | qgu[q60], qgj, qgL);
}
var q9k = q8J(function(qgu, qgj, qgL, qgI, qgb) {
  return qgu["h"] === 2 && (qgu = q8t(qgu, q7W([void 0, void 0], qgI, true), qgb), q6f(qgI = 0 | qgj[q60]), (qgb = q7w(qgj, qgI, qgL)) instanceof q7n ? (2 & qgb["L"]) != 0 ? ((qgb = qgb["X"]())["push"](qgu), q7z(qgj, qgI, qgL, qgb)) : qgb["Na"](qgu) : Array["isArray"](qgb) ? (2 & (0 | qgb[q60]) && q7z(qgj, qgI, qgL, qgb = q7I(qgb)), qgb["push"](qgu)) : q7z(qgj, qgI, qgL, [qgu]), true);
}, function(qgu, qgj, qgL, qgI, qgb) {
  if (qgj instanceof q7n) qgj["forEach"]((qgR, qgo) => {
    q8d(qgu, qgL, q7W([qgo, qgR], qgI, false), qgb);
  });
  else {
    if (Array["isArray"](qgj)) for (let qgR = 0; qgR < qgj["length"]; qgR++) {
      const qgo = qgj[qgR];
      Array["isArray"](qgo) && q8d(qgu, qgL, q7W(qgo, qgI, false), qgb);
    }
  }
});
function q9O(qgu, qgj, qgL) {
  if (qgj = function(qgI) {
    if (qgI == null) return qgI;
    const qgb = typeof qgI;
    if (qgb === "bigint") return String(q6d(64, qgI));
    if (q6T(qgI)) {
      if (qgb === "string") return q6Y(qgI);
      if (qgb === "number") return q6J(qgI);
    }
  }(qgj), qgj != null && (typeof qgj == "string" && q8X(qgj), qgj != null)) switch (q8R(qgu, qgL, 0), typeof qgj) {
    case "number":
      qgu = qgu["g"], q6j(qgj), q8u(qgu, q6G, q6N);
      break;
    case "bigint":
      qgL = BigInt["asUintN"](64, qgj), qgL = new q8G(Number(qgL & BigInt(4294967295)), Number(qgL >> BigInt(32))), q8u(qgu["g"], qgL["h"], qgL["g"]);
      break;
    default:
      qgL = q8X(qgj), q8u(qgu["g"], qgL["h"], qgL["g"]);
  }
}
function q9W(qgu, qgj, qgL) {
  (qgj = q6K(qgj)) != null && qgj != null && (q8R(qgu, qgL, 0), q8L(qgu["g"], qgj));
}
function q9i(qgu, qgj, qgL) {
  (qgj = q6A(qgj)) != null && (q8R(qgu, qgL, 0), qgu["g"]["g"]["push"](qgj ? 1 : 0));
}
function q9D(qgu, qgj, qgL) {
  (qgj = q72(qgj)) != null && q8Q(qgu, qgL, q5f(qgj));
}
function q9m(qgu, qgj, qgL, qgI, qgb) {
  q8d(qgu, qgL, q98(qgj, qgI), qgb);
}
function q9a(qgu, qgj, qgL) {
  (qgj = qgj == null || typeof qgj == "string" || q5r(qgj) || qgj instanceof q5y ? qgj : void 0) != null && q8Q(qgu, qgL, q86(qgj)["buffer"]);
}
function q9Z(qgu, qgj, qgL) {
  return (qgu["h"] === 5 || qgu["h"] === 2) && (qgj = q7R(qgj, 0 | qgj[q60], qgL, false, false), qgu["h"] == 2 ? q8W(qgu, q8p, qgj) : qgj["push"](q8p(qgu["g"])), true);
}
var q9w = q9S(function(qgu, qgj, qgL) {
  if (qgu["h"] !== 1) return false;
  var qgI = qgu["g"];
  qgu = q8n(qgI);
  const qgb = q8n(qgI);
  qgI = 2 * (qgb >> 31) + 1;
  const qgR = qgb >>> 20 & 2047;
  return qgu = 4294967296 * (1048575 & qgb) + qgu, q9t(qgj, qgL, qgR == 2047 ? qgu ? NaN : qgI * (1 / 0) : qgR == 0 ? 5e-324 * qgI * qgu : qgI * Math["pow"](2, qgR - 1075) * (qgu + 4503599627370496)), true;
}, function(qgu, qgj, qgL) {
  (qgj = q6H(qgj)) != null && (q8R(qgu, qgL, 1), qgu = qgu["g"], (qgL = q6X || (q6X = new DataView(new ArrayBuffer(8))))["setFloat64"](0, +qgj, true), q6G = qgL["getUint32"](0, true), q6N = qgL["getUint32"](4, true), q8I(qgu, q6G), q8I(qgu, q6N));
}, q8v());
var q9e = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 5 && (q9t(qgj, qgL, q8p(qgu["g"])), true);
}, function(qgu, qgj, qgL) {
  (qgj = q6H(qgj)) != null && (q8R(qgu, qgL, 5), qgu = qgu["g"], q6L(qgj), q8I(qgu, q6G));
}, q8T);
var q9z = q9F(q9Z, function(qgu, qgj, qgL) {
  if ((qgj = q9f(q6H, qgj)) != null) for (let qgo = 0; qgo < qgj["length"]; qgo++) {
    var qgI = qgu, qgb = qgL, qgR = qgj[qgo];
    qgR != null && (q8R(qgI, qgb, 5), qgI = qgI["g"], q6L(qgR), q8I(qgI, q6G));
  }
}, q8T);
var q9c = q9F(q9Z, function(qgu, qgj, qgL) {
  if ((qgj = q9f(q6H, qgj)) != null && qgj["length"]) {
    q8R(qgu, qgL, 2), q8j(qgu["g"], 4 * qgj["length"]);
    for (let qgI = 0; qgI < qgj["length"]; qgI++) qgL = qgu["g"], q6L(qgj[qgI]), q8I(qgL, q6G);
  }
}, q8T);
var q9X = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, q87(qgu["g"], q6b)), true);
}, q9O, q8h);
var q9G = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, (qgu = q87(qgu["g"], q6b)) === 0 ? void 0 : qgu), true);
}, q9O, q8h);
var q9N = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, q87(qgu["g"], q6I)), true);
}, function(qgu, qgj, qgL) {
  if ((qgj = q6U(qgj)) != null && (typeof qgj == "string" && q8e(qgj), qgj != null)) switch (q8R(qgu, qgL, 0), typeof qgj) {
    case "number":
      qgu = qgu["g"], q6j(qgj), q8u(qgu, q6G, q6N);
      break;
    case "bigint":
      qgL = BigInt["asUintN"](64, qgj), qgL = new q8z(Number(qgL & BigInt(4294967295)), Number(qgL >> BigInt(32))), q8u(qgu["g"], qgL["h"], qgL["g"]);
      break;
    default:
      qgL = q8e(qgj), q8u(qgu["g"], qgL["h"], qgL["g"]);
  }
}, q8v());
var q9u = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, q89(qgu["g"])), true);
}, q9W, q8H);
var q9j = q9F(function(qgu, qgj, qgL) {
  return (qgu["h"] === 0 || qgu["h"] === 2) && (qgj = q7R(qgj, 0 | qgj[q60], qgL, false, false), qgu["h"] == 2 ? q8W(qgu, q89, qgj) : qgj["push"](q89(qgu["g"])), true);
}, function(qgu, qgj, qgL) {
  if ((qgj = q9f(q6K, qgj)) != null && qgj["length"]) {
    qgL = q8o(qgu, qgL);
    for (let qgI = 0; qgI < qgj["length"]; qgI++) q8L(qgu["g"], qgj[qgI]);
    q8r(qgu, qgL);
  }
}, q8H);
var q9L = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, (qgu = q89(qgu["g"])) === 0 ? void 0 : qgu), true);
}, q9W, q8H);
var q9I = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, q88(qgu["g"])), true);
}, q9i, q8C);
var q9b = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, (qgu = q88(qgu["g"])) === false ? void 0 : qgu), true);
}, q9i, q8C);
var q9R = q9F(function(qgu, qgj, qgL) {
  return qgu["h"] === 2 && (qgu = q8k(qgu), q7R(qgj, 0 | qgj[q60], qgL, false)["push"](qgu), true);
}, function(qgu, qgj, qgL) {
  if ((qgj = q9f(q72, qgj)) != null) for (let qgo = 0; qgo < qgj["length"]; qgo++) {
    var qgI = qgu, qgb = qgL, qgR = qgj[qgo];
    qgR != null && q8Q(qgI, qgb, q5f(qgR));
  }
}, q8l);
var q9o = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 2 && (q9t(qgj, qgL, (qgu = q8k(qgu)) === "" ? void 0 : qgu), true);
}, q9D, q8l);
var q9r = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 2 && (q9t(qgj, qgL, q8k(qgu)), true);
}, q9D, q8l);
var q9Q = function(qgu, qgj, qgL = q8y) {
  return new q8V(qgu, qgj, qgL);
}(function(qgu, qgj, qgL, qgI, qgb) {
  return qgu["h"] === 2 && (qgI = q7W(void 0, qgI, true), q7R(qgj, 0 | qgj[q60], qgL, true)["push"](qgI), q8t(qgu, qgI, qgb), true);
}, function(qgu, qgj, qgL, qgI, qgb) {
  if (Array["isArray"](qgj)) {
    for (let qgR = 0; qgR < qgj["length"]; qgR++) q9m(qgu, qgj[qgR], qgL, qgI, qgb);
  }
});
var q9d = q8J(function(qgu, qgj, qgL, qgI, qgb, qgR) {
  return qgu["h"] === 2 && (q7Q(qgj, 0 | qgj[q60], qgR, qgL), q8t(qgu, qgj = q7v(qgj, qgI, qgL), qgb), true);
}, q9m);
var q9v = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 2 && (q9t(qgj, qgL, q8O(qgu)), true);
}, q9a, q8K);
var q9y = q9F(function(qgu, qgj, qgL) {
  return (qgu["h"] === 0 || qgu["h"] === 2) && (qgj = q7R(qgj, 0 | qgj[q60], qgL, false, false), qgu["h"] == 2 ? q8W(qgu, q8q, qgj) : qgj["push"](q8q(qgu["g"])), true);
}, function(qgu, qgj, qgL) {
  if ((qgj = q9f(q6B, qgj)) != null) for (let qgo = 0; qgo < qgj["length"]; qgo++) {
    var qgI = qgu, qgb = qgL, qgR = qgj[qgo];
    qgR != null && (q8R(qgI, qgb, 0), q8j(qgI["g"], qgR));
  }
}, q8A);
var q9C = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, (qgu = q8q(qgu["g"])) === 0 ? void 0 : qgu), true);
}, function(qgu, qgj, qgL) {
  (qgj = q6B(qgj)) != null && qgj != null && (q8R(qgu, qgL, 0), q8j(qgu["g"], qgj));
}, q8A);
var q9l = q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 0 && (q9t(qgj, qgL, q89(qgu["g"])), true);
}, function(qgu, qgj, qgL) {
  (qgj = q6K(qgj)) != null && (qgj = parseInt(qgj, 10), q8R(qgu, qgL, 0), q8L(qgu["g"], qgj));
}, q8B);
var q9H = class {
  constructor(qgu, qgj) {
    this["h"] = qgu, this["g"] = qgj, this["l"] = q7C, this["m"] = q7A, this["defaultValue"] = void 0;
  }
};
function q9A(qgu, qgj) {
  return new q9H(qgu, qgj);
}
function q9h(qgu, qgj) {
  return (qgL, qgI) => {
    if (q8i["length"]) {
      const qgR = q8i["pop"]();
      qgR["o"](qgI), q8x(qgR["g"], qgL, qgI), qgL = qgR;
    } else qgL = new class {
      constructor(qgo, qgr) {
        if (q8f["length"]) {
          const qgQ = q8f["pop"]();
          q8x(qgQ, qgo, qgr), qgo = qgQ;
        } else qgo = new class {
          constructor(qgd, qgv) {
            this["h"] = null, this["m"] = false, this["g"] = this["l"] = this["j"] = 0, q8x(this, qgd, qgv);
          }
          ["clear"]() {
            this["h"] = null, this["m"] = false, this["g"] = this["l"] = this["j"] = 0, this["ba"] = false;
          }
        }(qgo, qgr);
        this["g"] = qgo, this["l"] = this["g"]["g"], this["h"] = this["m"] = -1, this["o"](qgr);
      }
      ["o"]({ fa: qgo = false } = {}) {
        this["fa"] = qgo;
      }
    }(qgL, qgI);
    try {
      const qgo = new qgu(), qgr = qgo["u"];
      q9n(qgj)(qgr, qgL);
      var qgb = qgo;
    } finally {
      qgL["g"]["clear"](), qgL["m"] = -1, qgL["h"] = -1, q8i["length"] < 100 && q8i["push"](qgL);
    }
    return qgb;
  };
}
function q9T(qgu) {
  return function() {
    const qgj = new class {
      constructor() {
        this["l"] = [], this["h"] = 0, this["g"] = new class {
          constructor() {
            this["g"] = [];
          }
          ["length"]() {
            return this["g"]["length"];
          }
          ["end"]() {
            const qgo = this["g"];
            return this["g"] = [], qgo;
          }
        }();
      }
    }();
    q9E(this["u"], qgj, q96(q90, q9g, q9x, qgu)), q8b(qgj, qgj["g"]["end"]());
    const qgL = new Uint8Array(qgj["h"]), qgI = qgj["l"], qgb = qgI["length"];
    let qgR = 0;
    for (let qgo = 0; qgo < qgb; qgo++) {
      const qgr = qgI[qgo];
      qgL["set"](qgr, qgR), qgR += qgr["length"];
    }
    return qgj["l"] = [qgL], qgL;
  };
}
var q9K = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var q9B = [0, q9o, q9S(function(qgu, qgj, qgL) {
  return qgu["h"] === 2 && (q9t(qgj, qgL, (qgu = q8O(qgu)) === q5d() ? void 0 : qgu), true);
}, function(qgu, qgj, qgL) {
  if (qgj != null) {
    if (qgj instanceof q8Z) {
      const qgI = qgj["Ra"];
      return void (qgI && (qgj = qgI(qgj), qgj != null && q8Q(qgu, qgL, q86(qgj)["buffer"])));
    }
    if (Array["isArray"](qgj)) return;
  }
  q9a(qgu, qgj, qgL);
}, q8K)];
var q9V;
var q9J = globalThis["trustedTypes"];
function q9Y(qgu) {
  q9V === void 0 && (q9V = function() {
    let qgL = null;
    if (!q9J) return qgL;
    try {
      const qgI = (qgb) => qgb;
      qgL = q9J["createPolicy"]("goog#html", { "createHTML": qgI, "createScript": qgI, "createScriptURL": qgI });
    } catch (qgb) {
    }
    return qgL;
  }());
  var qgj = q9V;
  return new class {
    constructor(qgL) {
      this["g"] = qgL;
    }
    ["toString"]() {
      return this["g"] + "";
    }
  }(qgj ? qgj["createScriptURL"](qgu) : qgu);
}
function q9P(qgu, ...qgj) {
  if (qgj["length"] === 0) return q9Y(qgu[0]);
  let qgL = qgu[0];
  for (let qgI = 0; qgI < qgj["length"]; qgI++) qgL += encodeURIComponent(qgj[qgI]) + qgu[qgI + 1];
  return q9Y(qgL);
}
var q9U = [0, q9u, q9l, q9I, -1, q9j, q9l, -1];
var qq0 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qq1 = [0, q9I, q9r, q9I, q9l, -1, q9F(function(qgu, qgj, qgL) {
  return (qgu["h"] === 0 || qgu["h"] === 2) && (qgj = q7R(qgj, 0 | qgj[q60], qgL, false, false), qgu["h"] == 2 ? q8W(qgu, q8g, qgj) : qgj["push"](q89(qgu["g"])), true);
}, function(qgu, qgj, qgL) {
  if ((qgj = q9f(q6K, qgj)) != null && qgj["length"]) {
    qgL = q8o(qgu, qgL);
    for (let qgI = 0; qgI < qgj["length"]; qgI++) q8L(qgu["g"], qgj[qgI]);
    q8r(qgu, qgL);
  }
}, q8B), q9r, -1, [0, q9I, -1], q9l, q9I, -1];
var qq2 = [0, q9r, -2];
var qq3 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qq4 = [0];
var qq5 = [0, q9u, q9I, 1, q9I, -3];
var qq6 = class extends q8Z {
  constructor(qgu) {
    super(qgu, 2);
  }
};
var qq7 = {};
qq7[336783863] = [0, q9r, q9I, -1, q9u, [0, [1, 2, 3, 4, 5, 6, 7, 8], q9d, qq4, q9d, qq1, q9d, qq2, q9d, qq5, q9d, q9U, q9d, [0, q9r, -2], q9d, [0, q9r, q9l], q9d, [0, q9l, q9r]], [0, q9r], q9I, [0, [1, 3], [2, 4], q9d, [0, q9j], -1, q9d, [0, q9R], -1, q9Q, [0, q9r, -1]], q9r];
var qq8 = [0, q9G, -1, q9b, -3, q9G, q9j, q9o, q9L, q9G, -1, q9b, q9L, q9b, -2, q9o];
function qq9(qgu, qgj) {
  q7b(qgu, 2, q71(qgj), "");
}
function qqq(qgu, qgj) {
  q82(qgu, 3, qgj);
}
function qqn(qgu, qgj) {
  q82(qgu, 4, qgj);
}
var qqp = class extends q8Z {
  constructor(qgu) {
    super(qgu, 500);
  }
  ["o"](qgu) {
    return q7A(this, 0, 7, qgu);
  }
};
var qqg = [-1, {}];
var qqx = [0, q9r, 1, qqg];
var qqs = [0, q9r, q9R, qqg];
function qqE(qgu, qgj) {
  q7B(qgu, 1, qqp, qgj);
}
function qqM(qgu, qgj) {
  q82(qgu, 10, qgj);
}
function qqf(qgu, qgj) {
  q82(qgu, 15, qgj);
}
var qqS = class extends q8Z {
  constructor(qgu) {
    super(qgu, 500);
  }
  ["o"](qgu) {
    return q7A(this, 0, 1001, qgu);
  }
};
var qqF = [-500, q9Q, [-500, q9o, -1, q9R, -3, [-2, qq7, q9I], q9Q, q9B, q9L, -1, qqx, qqs, q9Q, [0, q9o, q9b], q9o, qq8, q9L, q9R, 987, q9R], 4, q9Q, [-500, q9r, -1, [-1, {}], 998, q9r], q9Q, [-500, q9r, q9R, -1, [-2, {}, q9I], 997, q9R, -1], q9L, q9Q, [-500, q9r, q9R, qqg, 998, q9R], q9R, q9L, qqx, qqs, q9Q, [0, q9o, -1, qqg], q9R, -2, qq8, q9o, -1, q9b, [0, q9b, q9C], 978, qqg, q9Q, q9B];
qqS["prototype"]["g"] = q9T(qqF);
var qqt = q9h(qqS, qqF);
var qqk = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqO = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["g"]() {
    return q7H(this, qqk, 1);
  }
};
var qqW = [0, q9Q, [0, q9u, q9e, q9r, -1]];
var qqi = q9h(qqO, qqW);
var qqD = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqm = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqa = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["h"]() {
    return q7C(this, qqD, 2);
  }
  ["g"]() {
    return q7H(this, qqm, 5);
  }
};
var qqZ = q9h(class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
}, [0, q9R, q9j, q9c, [0, q9l, [0, q9u, -3], [0, q9e, -3], [0, q9u, -1, [0, q9Q, [0, q9u, -2]]], q9Q, [0, q9e, -1, q9r, q9e]], q9r, -1, q9X, q9Q, [0, q9u, q9e], q9R, q9X]);
var qqw = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqe = q9h(class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
}, [0, q9Q, [0, q9e, -4]]);
var qqz = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqc = q9h(class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
}, [0, q9Q, [0, q9e, -4]]);
var qqX = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqG = [0, q9u, -1, q9c, q9l];
var qqN = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
qqN["prototype"]["g"] = q9T([0, q9e, -4, q9X]);
var qqu = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqj = q9h(class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
}, [0, q9Q, [0, 1, q9u, q9r, qqW], q9X]);
var qqL = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqI = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["oa"]() {
    const qgu = q7X(this);
    return qgu == null ? q5d() : qgu;
  }
};
var qqb = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqR = [1, 2];
var qqo = q9h(class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
}, [0, q9Q, [0, qqR, q9d, [0, q9c], q9d, [0, q9v], q9u, q9r], q9X]);
var qqr = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqQ = [0, q9r, q9u, q9e, q9R, -1];
var qqd = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqv = [0, q9I, -1];
var qqy = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqC = [1, 2, 3, 4, 5];
var qql = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["g"]() {
    return q7X(this) != null;
  }
  ["h"]() {
    return q7J(this, 2) != null;
  }
};
var qqH = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["g"]() {
    var qgu;
    return (qgu = q6A(q7Z(this, 2))) != null ? qgu : false;
  }
};
var qqA = [0, q9v, q9r, [0, q9u, q9X, -1], [0, q9N, q9X]];
var qqh = [0, qqA, q9I, [0, qqC, q9d, qq5, q9d, qq1, q9d, q9U, q9d, qq4, q9d, qq2], q9l];
var qqT = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqK = [0, qqh, q9e, -1, q9u];
var qqB = q9A(502141897, qqT);
qq7[502141897] = qqK;
var qqV = q9h(class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
}, [0, [0, q9l, -1, q9z, q9y], qqG]);
var qqJ = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqY = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qqP = [0, qqh, q9e, [0, qqh], q9I];
var qqU = [0, qqh, qqK, qqP, q9e, [0, [0, qqA]]];
var qn0 = q9A(508968150, qqY);
qq7[508968150] = qqU, qq7[508968149] = qqP;
var qn1 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qn2 = q9A(513916220, qn1);
qq7[513916220] = [0, qqh, qqU, q9u];
var qn3 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["h"]() {
    return q7C(this, qqr, 2);
  }
  ["g"]() {
    q7e(this, 2);
  }
};
var qn4 = [0, qqh, qqQ];
qq7[478825465] = qn4;
var qn5 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qn6 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qn7 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qn8 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qn9 = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnq = [0, qqh, [0, qqh], qn4, -1];
var qnn = [0, qqh, q9e, q9u];
var qnp = [0, qqh, q9e];
var qng = [0, qqh, qnn, qnp, q9e];
var qnx = q9A(479097054, qn9);
qq7[479097054] = [0, qqh, qng, qnq], qq7[463370452] = qnq, qq7[464864288] = qnn;
var qns = q9A(462713202, qn8);
qq7[462713202] = qng, qq7[474472470] = qnp;
var qnE = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnM = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnf = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnS = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnF = [0, qqh, q9e, -1, q9u];
var qnt = [0, qqh, q9e, q9I];
qnS["prototype"]["g"] = q9T([0, qqh, qnp, [0, qqh], qqK, qqP, qnF, qnt]);
var qnk = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnO = q9A(456383383, qnk);
qq7[456383383] = [0, qqh, qqQ];
var qnW = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qni = q9A(476348187, qnW);
qq7[476348187] = [0, qqh, qqv];
var qnD = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnm = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qna = [0, q9l, -1];
var qnZ = q9A(458105876, class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
  ["g"]() {
    var qgu = this["u"];
    const qgj = 0 | qgu[q60], qgL = 2 & qgj;
    return qgu = function(qgI, qgb, qgR) {
      var qgo = qnm;
      const qgr = 2 & qgb;
      let qgQ = false;
      if (qgR == null) {
        if (qgr) return q7f();
        qgR = [];
      } else {
        if (qgR["constructor"] === q7n) {
          if ((2 & qgR["L"]) == 0 || qgr) return qgR;
          qgR = qgR["X"]();
        } else Array["isArray"](qgR) ? qgQ = !!(2 & (0 | qgR[q60])) : qgR = [];
      }
      if (qgr) {
        if (!qgR["length"]) return q7f();
        qgQ || (qgQ = true, q65(qgR));
      } else qgQ && (qgQ = false, qgR = q7I(qgR));
      return qgQ || (64 & (0 | qgR[q60]) ? qgR[q60] &= -33 : 32 & qgb && q63(qgR, 32)), q7z(qgI, qgb, 2, qgo = new q7n(qgR, qgo, q74, void 0)), qgo;
    }(qgu, qgj, q7w(qgu, qgj, 2)), !qgL && qnm && (qgu["ra"] = true), qgu;
  }
});
qq7[458105876] = [0, qna, q9k, [true, q9X, [0, q9r, -1, q9R]]];
var qnw = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qne = q9A(458105758, qnw);
qq7[458105758] = [0, qqh, q9r, qna];
var qnz = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnc = q9A(443442058, qnz);
qq7[443442058] = [0, qqh, q9r, q9u, q9e, q9R, -1, q9I, q9e], qq7[514774813] = qnF;
var qnX = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qnG = q9A(516587230, qnX);
function qnN(qgu, qgj) {
  return qgj = qgj ? qgj["clone"]() : new qqr(), qgu["displayNamesLocale"] !== void 0 ? q7e(qgj, 1, q71(qgu["displayNamesLocale"])) : qgu["displayNamesLocale"] === void 0 && q7e(qgj, 1), qgu["maxResults"] !== void 0 ? q7U(qgj, 2, qgu["maxResults"]) : "maxResults" in qgu && q7e(qgj, 2), qgu["scoreThreshold"] !== void 0 ? q80(qgj, 3, qgu["scoreThreshold"]) : "scoreThreshold" in qgu && q7e(qgj, 3), qgu["categoryAllowlist"] !== void 0 ? q81(qgj, 4, qgu["categoryAllowlist"]) : "categoryAllowlist" in qgu && q7e(qgj, 4), qgu["categoryDenylist"] !== void 0 ? q81(qgj, 5, qgu["categoryDenylist"]) : "categoryDenylist" in qgu && q7e(qgj, 5), qgj;
}
function qnu(qgu, qgj = -1, qgL = "") {
  return { "categories": qgu["map"]((qgI) => {
    var qgb, qgR, qgo, qgr, qgQ, qgd, qgv;
    return { "index": (qgR = (qgb = q7V(qgI, 1)) != null ? qgb : 0) != null ? qgR : -1, "score": (qgo = q7Y(qgI, 2)) != null ? qgo : 0, "categoryName": (qgQ = (qgr = q7J(qgI, 3)) != null ? qgr : "") != null ? qgQ : "", "displayName": (qgv = (qgd = q7J(qgI, 4)) != null ? qgd : "") != null ? qgv : "" };
  }), "headIndex": qgj, "headName": qgL };
}
function qnj(qgu) {
  var qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ, qgd, qgv, qgy, qgl, qgH, qgA = q7N(qgu, 3, q6H, q7G()), qgh = q7N(qgu, 2, q6K, q7G()), qgT = q7N(qgu, 1, q72, q7G()), qgK = q7N(qgu, 9, q72, q7G());
  const qgB = { "categories": [], "keypoints": [] };
  for (let qgV = 0; qgV < qgA["length"]; qgV++) qgB["categories"]["push"]({ "score": qgA[qgV], "index": (qgj = qgh[qgV]) != null ? qgj : -1, "categoryName": (qgL = qgT[qgV]) != null ? qgL : "", "displayName": (qgI = qgK[qgV]) != null ? qgI : "" });
  if ((qgA = (qgb = q7C(qgu, qqa, 4)) == null ? void 0 : qgb["h"]()) && (qgB["boundingBox"] = { "originX": (qgR = q7V(qgA, 1)) != null ? qgR : 0, "originY": (qgo = q7V(qgA, 2)) != null ? qgo : 0, "width": (qgr = q7V(qgA, 3)) != null ? qgr : 0, "height": (qgQ = q7V(qgA, 4)) != null ? qgQ : 0, "angle": 0 }), (qgd = q7C(qgu, qqa, 4)) == null ? void 0 : qgd["g"]()["length"]) {
    for (const qgJ of q7C(qgu, qqa, 4)["g"]()) qgB["keypoints"]["push"]({ "x": (qgv = q7c(qgJ, 1)) != null ? qgv : 0, "y": (qgy = q7c(qgJ, 2)) != null ? qgy : 0, "score": (qgl = q7c(qgJ, 4)) != null ? qgl : 0, "label": (qgH = q7J(qgJ, 3)) != null ? qgH : "" });
  }
  return qgB;
}
function qnL(qgu) {
  var qgj, qgL, qgI, qgb;
  const qgR = [];
  for (const qgo of q7H(qgu, qqz, 1)) qgR["push"]({ "x": (qgj = q7Y(qgo, 1)) != null ? qgj : 0, "y": (qgL = q7Y(qgo, 2)) != null ? qgL : 0, "z": (qgI = q7Y(qgo, 3)) != null ? qgI : 0, "visibility": (qgb = q7Y(qgo, 4)) != null ? qgb : 0 });
  return qgR;
}
function qnI(qgu) {
  var qgj, qgL, qgI, qgb;
  const qgR = [];
  for (const qgo of q7H(qgu, qqw, 1)) qgR["push"]({ "x": (qgj = q7Y(qgo, 1)) != null ? qgj : 0, "y": (qgL = q7Y(qgo, 2)) != null ? qgL : 0, "z": (qgI = q7Y(qgo, 3)) != null ? qgI : 0, "visibility": (qgb = q7Y(qgo, 4)) != null ? qgb : 0 });
  return qgR;
}
function qnb(qgu) {
  return Array["from"](qgu, (qgj) => qgj > 127 ? qgj - 256 : qgj);
}
function qnR(qgu, qgj) {
  if (qgu["length"] !== qgj["length"]) throw Error("Cannot compute cosine similarity between embeddings of different sizes (" + qgu["length"] + " vs. " + qgj["length"] + ").");
  let qgL = 0, qgI = 0, qgb = 0;
  for (let qgR = 0; qgR < qgu["length"]; qgR++) qgL += qgu[qgR] * qgj[qgR], qgI += qgu[qgR] * qgu[qgR], qgb += qgj[qgR] * qgj[qgR];
  if (qgI <= 0 || qgb <= 0) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return qgL / Math["sqrt"](qgI * qgb);
}
var qno;
qq7[516587230] = [0, qqh, qnF, qnt, q9e], qq7[518928384] = qnt;
var qnr = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
async function qnQ() {
  if (qno === void 0) try {
    await WebAssembly["instantiate"](qnr), qno = true;
  } catch (qgu) {
    qno = false;
  }
  return qno;
}
async function qnd(qgu, qgj = q9P``) {
  const qgL = await qnQ() ? "wasm_internal" : "wasm_nosimd_internal";
  return { "wasmLoaderPath": qgj + "/" + qgu + "_" + qgL + ".js", "wasmBinaryPath": qgj + "/" + qgu + "_" + qgL + ".wasm" };
}
var qnv = class {
};
function qny() {
  var qgu = navigator;
  return typeof OffscreenCanvas != "undefined" && (!function(qgj = navigator) {
    return (qgj = qgj["userAgent"])["includes"]("Safari") && !qgj["includes"]("Chrome");
  }(qgu) || !!((qgu = qgu["userAgent"]["match"](/Version\/([\d]+).*Safari/)) && qgu["length"] >= 1 && Number(qgu[1]) >= 17));
}
async function qnC(qgu) {
  if (typeof importScripts != "function") {
    const qgj = document["createElement"]("script");
    return qgj["src"] = qgu["toString"](), qgj["crossOrigin"] = "anonymous", new Promise((qgL, qgI) => {
      qgj["addEventListener"]("load", () => {
        qgL();
      }, false), qgj["addEventListener"]("error", (qgb) => {
        qgI(qgb);
      }, false), document["body"]["appendChild"](qgj);
    });
  }
  importScripts(qgu["toString"]());
}
function qnl(qgu) {
  return qgu["videoWidth"] !== void 0 ? [qgu["videoWidth"], qgu["videoHeight"]] : qgu["naturalWidth"] !== void 0 ? [qgu["naturalWidth"], qgu["naturalHeight"]] : qgu["displayWidth"] !== void 0 ? [qgu["displayWidth"], qgu["displayHeight"]] : [qgu["width"], qgu["height"]];
}
function qnH(qgu, qgj, qgL) {
  qgu["m"] || console["error"]("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), qgL(qgj = qgu["i"]["stringToNewUTF8"](qgj)), qgu["i"]["_free"](qgj);
}
function qnA(qgu, qgj, qgL) {
  if (!qgu["i"]["canvas"]) throw Error("No OpenGL canvas configured.");
  if (qgL ? qgu["i"]["_bindTextureToStream"](qgL) : qgu["i"]["_bindTextureToCanvas"](), !(qgL = qgu["i"]["canvas"]["getContext"]("webgl2") || qgu["i"]["canvas"]["getContext"]("webgl"))) throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
  qgu["i"]["gpuOriginForWebTexturesIsBottomLeft"] && qgL["pixelStorei"](qgL["UNPACK_FLIP_Y_WEBGL"], true), qgL["texImage2D"](qgL["TEXTURE_2D"], 0, qgL["RGBA"], qgL["RGBA"], qgL["UNSIGNED_BYTE"], qgj), qgu["i"]["gpuOriginForWebTexturesIsBottomLeft"] && qgL["pixelStorei"](qgL["UNPACK_FLIP_Y_WEBGL"], false);
  const [qgI, qgb] = qnl(qgj);
  return !qgu["l"] || qgI === qgu["i"]["canvas"]["width"] && qgb === qgu["i"]["canvas"]["height"] || (qgu["i"]["canvas"]["width"] = qgI, qgu["i"]["canvas"]["height"] = qgb), [qgI, qgb];
}
function qnh(qgu, qgj, qgL) {
  qgu["m"] || console["error"]("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
  const qgI = new Uint32Array(qgj["length"]);
  for (let qgb = 0; qgb < qgj["length"]; qgb++) qgI[qgb] = qgu["i"]["stringToNewUTF8"](qgj[qgb]);
  qgj = qgu["i"]["_malloc"](4 * qgI["length"]), qgu["i"]["HEAPU32"]["set"](qgI, qgj >> 2), qgL(qgj);
  for (const qgR of qgI) qgu["i"]["_free"](qgR);
  qgu["i"]["_free"](qgj);
}
function qnT(qgu, qgj, qgL) {
  qgu["i"]["simpleListeners"] = qgu["i"]["simpleListeners"] || {}, qgu["i"]["simpleListeners"][qgj] = qgL;
}
function qnK(qgu, qgj, qgL) {
  let qgI = [];
  qgu["i"]["simpleListeners"] = qgu["i"]["simpleListeners"] || {}, qgu["i"]["simpleListeners"][qgj] = (qgb, qgR, qgo) => {
    qgR ? (qgL(qgI, qgo), qgI = []) : qgI["push"](qgb);
  };
}
qnv["forVisionTasks"] = function(qgu) {
  return qnd("vision", qgu);
}, qnv["forTextTasks"] = function(qgu) {
  return qnd("text", qgu);
}, qnv["forGenAiExperimentalTasks"] = function(qgu) {
  return qnd("genai_experimental", qgu);
}, qnv["forGenAiTasks"] = function(qgu) {
  return qnd("genai", qgu);
}, qnv["forAudioTasks"] = function(qgu) {
  return qnd("audio", qgu);
}, qnv["isSimdSupported"] = function() {
  return qnQ();
};
async function qnB(qgu, qgj, qgL, qgI) {
  return qgu = await (async (qgb, qgR, qgo, qgr, qgQ) => {
    if (qgR && await qnC(qgR), !self["ModuleFactory"] || qgo && (await qnC(qgo), !self["ModuleFactory"])) throw Error("ModuleFactory not set.");
    return self["Module"] && qgQ && ((qgR = self["Module"])["locateFile"] = qgQ["locateFile"], qgQ["mainScriptUrlOrBlob"] && (qgR["mainScriptUrlOrBlob"] = qgQ["mainScriptUrlOrBlob"])), qgQ = await self["ModuleFactory"](self["Module"] || qgQ), self["ModuleFactory"] = self["Module"] = void 0, new qgb(qgQ, qgr);
  })(qgu, qgL["wasmLoaderPath"], qgL["assetLoaderPath"], qgj, { "locateFile": (qgb) => qgb["endsWith"](".wasm") ? qgL["wasmBinaryPath"]["toString"]() : qgL["assetBinaryPath"] && qgb["endsWith"](".data") ? qgL["assetBinaryPath"]["toString"]() : qgb }), await qgu["o"](qgI), qgu;
}
function qnV(qgu, qgj) {
  const qgL = q7C(qgu["baseOptions"], qql, 1) || new qql();
  typeof qgj == "string" ? (q7e(qgL, 2, q71(qgj)), q7e(qgL, 1)) : qgj instanceof Uint8Array && (q7e(qgL, 1, q6s(qgj, false)), q7e(qgL, 2)), q7A(qgu["baseOptions"], 0, 1, qgL);
}
function qnJ(qgu) {
  try {
    const qgj = qgu["G"]["length"];
    if (qgj === 1) throw Error(qgu["G"][0]["message"]);
    if (qgj > 1) throw Error("Encountered multiple errors: " + qgu["G"]["map"]((qgL) => qgL["message"])["join"](", "));
  } finally {
    qgu["G"] = [];
  }
}
function qnY(qgu, qgj) {
  qgu["B"] = Math["max"](qgu["B"], qgj);
}
function qnP(qgu, qgj) {
  qgu["A"] = new qqp(), qq9(qgu["A"], "PassThroughCalculator"), qqq(qgu["A"], "free_memory"), qqn(qgu["A"], "free_memory_unused_out"), qqM(qgj, "free_memory"), qqE(qgj, qgu["A"]);
}
function qnU(qgu, qgj) {
  qqq(qgu["A"], qgj), qqn(qgu["A"], qgj + "_unused_out");
}
function qp0(qgu) {
  qgu["g"]["addBoolToStream"](true, "free_memory", qgu["B"]);
}
var qp1 = class {
  constructor(qgu) {
    this["g"] = qgu, this["G"] = [], this["B"] = 0, this["g"]["setAutoRenderToScreen"](false);
  }
  ["l"](qgu, qgj = true) {
    var qgL, qgI, qgb, qgR, qgo, qgr;
    if (qgj) {
      const qgQ = qgu["baseOptions"] || {};
      if ((qgL = qgu["baseOptions"]) != null && qgL["modelAssetBuffer"] && ((qgI = qgu["baseOptions"]) != null && qgI["modelAssetPath"])) throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
      if (!((qgb = q7C(this["baseOptions"], qql, 1)) != null && qgb["g"]() || (qgR = q7C(this["baseOptions"], qql, 1)) != null && qgR["h"]() || (qgo = qgu["baseOptions"]) != null && qgo["modelAssetBuffer"] || (qgr = qgu["baseOptions"]) != null && qgr["modelAssetPath"])) throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
      if (function(qgd, qgv) {
        let qgy = q7C(qgd["baseOptions"], qqy, 3);
        if (!qgy) {
          var qgl = qgy = new qqy(), qgH = new qq3();
          q7h(qgl, 4, qqC, qgH);
        }
        "delegate" in qgv && (qgv["delegate"] === "GPU" ? (qgv = qgy, qgl = new qq0(), q7h(qgv, 2, qqC, qgl)) : (qgv = qgy, qgl = new qq3(), q7h(qgv, 4, qqC, qgl))), q7A(qgd["baseOptions"], 0, 3, qgy);
      }(this, qgQ), qgQ["modelAssetPath"]) return fetch(qgQ["modelAssetPath"]["toString"]())["then"]((qgd) => {
        if (qgd["ok"]) return qgd["arrayBuffer"]();
        throw Error("Failed to fetch model: " + qgQ["modelAssetPath"] + " (" + qgd["status"] + ")");
      })["then"]((qgd) => {
        try {
          this["g"]["i"]["FS_unlink"]("/model.dat");
        } catch (qgv) {
        }
        this["g"]["i"]["FS_createDataFile"]("/", "model.dat", new Uint8Array(qgd), true, false, false), qnV(this, "/model.dat"), this["m"](), this["I"]();
      });
      if (qgQ["modelAssetBuffer"] instanceof Uint8Array) qnV(this, qgQ["modelAssetBuffer"]);
      else {
        if (qgQ["modelAssetBuffer"]) return async function(qgd) {
          const qgv = [];
          for (var qgy = 0; ; ) {
            const { done: qgl, value: qgH } = await qgd["read"]();
            if (qgl) break;
            qgv["push"](qgH), qgy += qgH["length"];
          }
          if (qgv["length"] === 0) return new Uint8Array(0);
          if (qgv["length"] === 1) return qgv[0];
          qgd = new Uint8Array(qgy), qgy = 0;
          for (const qgA of qgv) qgd["set"](qgA, qgy), qgy += qgA["length"];
          return qgd;
        }(qgQ["modelAssetBuffer"])["then"]((qgd) => {
          qnV(this, qgd), this["m"](), this["I"]();
        });
      }
    }
    return this["m"](), this["I"](), Promise["resolve"]();
  }
  ["I"]() {
  }
  ["da"]() {
    let qgu;
    if (this["g"]["da"]((qgj) => {
      qgu = qqt(qgj);
    }), !qgu) throw Error("Failed to retrieve CalculatorGraphConfig");
    return qgu;
  }
  ["setGraph"](qgu, qgj) {
    this["g"]["attachErrorListener"]((qgL, qgI) => {
      this["G"]["push"](Error(qgI));
    }), this["g"]["La"](), this["g"]["setGraph"](qgu, qgj), this["A"] = void 0, qnJ(this);
  }
  ["finishProcessing"]() {
    this["g"]["finishProcessing"](), qnJ(this);
  }
  ["close"]() {
    this["A"] = void 0, this["g"]["closeGraph"]();
  }
};
function qp2(qgu, qgj) {
  if (!qgu) throw Error("Unable to obtain required WebGL resource: " + qgj);
  return qgu;
}
qp1["prototype"]["close"] = qp1["prototype"]["close"], function(qgu, qgj) {
  qgu = qgu["split"](".");
  var qgL, qgI = q5q;
  for ((qgu[0] in qgI) || qgI["execScript"] === void 0 || qgI["execScript"]("var " + qgu[0]); qgu["length"] && (qgL = qgu["shift"]()); ) qgu["length"] || qgj === void 0 ? qgI = qgI[qgL] && qgI[qgL] !== Object["prototype"][qgL] ? qgI[qgL] : qgI[qgL] = {} : qgI[qgL] = qgj;
}("TaskRunner", qp1);
var qp3 = class {
  constructor(qgu, qgj, qgL, qgI) {
    this["g"] = qgu, this["h"] = qgj, this["m"] = qgL, this["l"] = qgI;
  }
  ["bind"]() {
    this["g"]["bindVertexArray"](this["h"]);
  }
  ["close"]() {
    this["g"]["deleteVertexArray"](this["h"]), this["g"]["deleteBuffer"](this["m"]), this["g"]["deleteBuffer"](this["l"]);
  }
};
function qp4(qgu, qgj, qgL) {
  const qgI = qgu["g"];
  if (qgL = qp2(qgI["createShader"](qgL), "Failed to create WebGL shader"), qgI["shaderSource"](qgL, qgj), qgI["compileShader"](qgL), !qgI["getShaderParameter"](qgL, qgI["COMPILE_STATUS"])) throw Error("Could not compile WebGL shader: " + qgI["getShaderInfoLog"](qgL));
  return qgI["attachShader"](qgu["h"], qgL), qgL;
}
function qp5(qgu, qgj) {
  const qgL = qgu["g"], qgI = qp2(qgL["createVertexArray"](), "Failed to create vertex array");
  qgL["bindVertexArray"](qgI);
  const qgb = qp2(qgL["createBuffer"](), "Failed to create buffer");
  qgL["bindBuffer"](qgL["ARRAY_BUFFER"], qgb), qgL["enableVertexAttribArray"](qgu["O"]), qgL["vertexAttribPointer"](qgu["O"], 2, qgL["FLOAT"], false, 0, 0), qgL["bufferData"](qgL["ARRAY_BUFFER"], new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), qgL["STATIC_DRAW"]);
  const qgR = qp2(qgL["createBuffer"](), "Failed to create buffer");
  return qgL["bindBuffer"](qgL["ARRAY_BUFFER"], qgR), qgL["enableVertexAttribArray"](qgu["I"]), qgL["vertexAttribPointer"](qgu["I"], 2, qgL["FLOAT"], false, 0, 0), qgL["bufferData"](qgL["ARRAY_BUFFER"], new Float32Array(qgj ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), qgL["STATIC_DRAW"]), qgL["bindBuffer"](qgL["ARRAY_BUFFER"], null), qgL["bindVertexArray"](null), new qp3(qgL, qgI, qgb, qgR);
}
function qp6(qgu, qgj) {
  if (qgu["g"]) {
    if (qgj !== qgu["g"]) throw Error("Cannot change GL context once initialized");
  } else qgu["g"] = qgj;
}
function qp7(qgu, qgj, qgL, qgI) {
  return qp6(qgu, qgj), qgu["h"] || (qgu["m"](), qgu["C"]()), qgL ? (qgu["s"] || (qgu["s"] = qp5(qgu, true)), qgL = qgu["s"]) : (qgu["v"] || (qgu["v"] = qp5(qgu, false)), qgL = qgu["v"]), qgj["useProgram"](qgu["h"]), qgL["bind"](), qgu["l"](), qgu = qgI(), qgL["g"]["bindVertexArray"](null), qgu;
}
function qp8(qgu, qgj, qgL) {
  return qp6(qgu, qgj), qgu = qp2(qgj["createTexture"](), "Failed to create texture"), qgj["bindTexture"](qgj["TEXTURE_2D"], qgu), qgj["texParameteri"](qgj["TEXTURE_2D"], qgj["TEXTURE_WRAP_S"], qgj["CLAMP_TO_EDGE"]), qgj["texParameteri"](qgj["TEXTURE_2D"], qgj["TEXTURE_WRAP_T"], qgj["CLAMP_TO_EDGE"]), qgj["texParameteri"](qgj["TEXTURE_2D"], qgj["TEXTURE_MIN_FILTER"], qgL != null ? qgL : qgj["LINEAR"]), qgj["texParameteri"](qgj["TEXTURE_2D"], qgj["TEXTURE_MAG_FILTER"], qgL != null ? qgL : qgj["LINEAR"]), qgj["bindTexture"](qgj["TEXTURE_2D"], null), qgu;
}
function qp9(qgu, qgj, qgL) {
  qp6(qgu, qgj), qgu["A"] || (qgu["A"] = qp2(qgj["createFramebuffer"](), "Failed to create framebuffe.")), qgj["bindFramebuffer"](qgj["FRAMEBUFFER"], qgu["A"]), qgj["framebufferTexture2D"](qgj["FRAMEBUFFER"], qgj["COLOR_ATTACHMENT0"], qgj["TEXTURE_2D"], qgL, 0);
}
function qpq(qgu) {
  var qgj;
  (qgj = qgu["g"]) == null || qgj["bindFramebuffer"](qgu["g"]["FRAMEBUFFER"], null);
}
var qpn = class {
  ["G"]() {
    return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n ";
  }
  ["m"]() {
    const qgu = this["g"];
    if (this["h"] = qp2(qgu["createProgram"](), "Failed to create WebGL program"), this["aa"] = qp4(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", qgu["VERTEX_SHADER"]), this["Z"] = qp4(this, this["G"](), qgu["FRAGMENT_SHADER"]), qgu["linkProgram"](this["h"]), !qgu["getProgramParameter"](this["h"], qgu["LINK_STATUS"])) throw Error("Error during program linking: " + qgu["getProgramInfoLog"](this["h"]));
    this["O"] = qgu["getAttribLocation"](this["h"], "aVertex"), this["I"] = qgu["getAttribLocation"](this["h"], "aTex");
  }
  ["C"]() {
  }
  ["l"]() {
  }
  ["close"]() {
    if (this["h"]) {
      const qgu = this["g"];
      qgu["deleteProgram"](this["h"]), qgu["deleteShader"](this["aa"]), qgu["deleteShader"](this["Z"]);
    }
    this["A"] && this["g"]["deleteFramebuffer"](this["A"]), this["v"] && this["v"]["close"](), this["s"] && this["s"]["close"]();
  }
};
function qpp(qgu, qgj) {
  switch (qgj) {
    case 0:
      return qgu["g"]["find"]((qgL) => qgL instanceof Uint8Array);
    case 1:
      return qgu["g"]["find"]((qgL) => qgL instanceof Float32Array);
    case 2:
      return qgu["g"]["find"]((qgL) => typeof WebGLTexture != "undefined" && qgL instanceof WebGLTexture);
    default:
      throw Error("Type is not supported: " + qgj);
  }
}
function qpg(qgu) {
  var qgj = qpp(qgu, 1);
  if (!qgj) {
    if (qgj = qpp(qgu, 0)) qgj = new Float32Array(qgj)["map"]((qgI) => qgI / 255);
    else {
      qgj = new Float32Array(qgu["width"] * qgu["height"]);
      const qgI = qps(qgu);
      var qgL = qpM(qgu);
      if (qp9(qgL, qgI, qpx(qgu)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod"["split"](";")["includes"](navigator["platform"]) || navigator["userAgent"]["includes"]("Mac") && "document" in self && "ontouchend" in self["document"]) {
        qgL = new Float32Array(qgu["width"] * qgu["height"] * 4), qgI["readPixels"](0, 0, qgu["width"], qgu["height"], qgI["RGBA"], qgI["FLOAT"], qgL);
        for (let qgb = 0, qgR = 0; qgb < qgj["length"]; ++qgb, qgR += 4) qgj[qgb] = qgL[qgR];
      } else qgI["readPixels"](0, 0, qgu["width"], qgu["height"], qgI["RED"], qgI["FLOAT"], qgj);
    }
    qgu["g"]["push"](qgj);
  }
  return qgj;
}
function qpx(qgu) {
  let qgj = qpp(qgu, 2);
  if (!qgj) {
    const qgL = qps(qgu);
    qgj = qpf(qgu);
    const qgI = qpg(qgu), qgb = qpE(qgu);
    qgL["texImage2D"](qgL["TEXTURE_2D"], 0, qgb, qgu["width"], qgu["height"], 0, qgL["RED"], qgL["FLOAT"], qgI), qpS(qgu);
  }
  return qgj;
}
function qps(qgu) {
  if (!qgu["canvas"]) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return qgu["h"] || (qgu["h"] = qp2(qgu["canvas"]["getContext"]("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), qgu["h"];
}
function qpE(qgu) {
  if (qgu = qps(qgu), !qpF) {
    if (qgu["getExtension"]("EXT_color_buffer_float") && qgu["getExtension"]("OES_texture_float_linear") && qgu["getExtension"]("EXT_float_blend")) qpF = qgu["R32F"];
    else {
      if (!qgu["getExtension"]("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
      qpF = qgu["R16F"];
    }
  }
  return qpF;
}
function qpM(qgu) {
  return qgu["l"] || (qgu["l"] = new qpn()), qgu["l"];
}
function qpf(qgu) {
  const qgj = qps(qgu);
  qgj["viewport"](0, 0, qgu["width"], qgu["height"]), qgj["activeTexture"](qgj["TEXTURE0"]);
  let qgL = qpp(qgu, 2);
  return qgL || (qgL = qp8(qpM(qgu), qgj, qgu["m"] ? qgj["LINEAR"] : qgj["NEAREST"]), qgu["g"]["push"](qgL), qgu["j"] = true), qgj["bindTexture"](qgj["TEXTURE_2D"], qgL), qgL;
}
function qpS(qgu) {
  qgu["h"]["bindTexture"](qgu["h"]["TEXTURE_2D"], null);
}
var qpF;
var qpt = class {
  constructor(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
    this["g"] = qgu, this["m"] = qgj, this["j"] = qgL, this["canvas"] = qgI, this["l"] = qgb, this["width"] = qgR, this["height"] = qgo, this["j"] && --qpk === 0 && console["error"]("You seem to be creating MPMask instances without invoking .close(). This leaks resources.");
  }
  ["Fa"]() {
    return !!qpp(this, 0);
  }
  ["ja"]() {
    return !!qpp(this, 1);
  }
  ["P"]() {
    return !!qpp(this, 2);
  }
  ["ia"]() {
    return (qgj = qpp(qgu = this, 0)) || (qgj = qpg(qgu), qgj = new Uint8Array(qgj["map"]((qgL) => 255 * qgL)), qgu["g"]["push"](qgj)), qgj;
    var qgu, qgj;
  }
  ["ha"]() {
    return qpg(this);
  }
  ["M"]() {
    return qpx(this);
  }
  ["clone"]() {
    const qgu = [];
    for (const qgj of this["g"]) {
      let qgL;
      if (qgj instanceof Uint8Array) qgL = new Uint8Array(qgj);
      else {
        if (qgj instanceof Float32Array) qgL = new Float32Array(qgj);
        else {
          if (!(qgj instanceof WebGLTexture)) throw Error("Type is not supported: " + qgj);
          {
            const qgI = qps(this), qgb = qpM(this);
            qgI["activeTexture"](qgI["TEXTURE1"]), qgL = qp8(qgb, qgI, this["m"] ? qgI["LINEAR"] : qgI["NEAREST"]), qgI["bindTexture"](qgI["TEXTURE_2D"], qgL);
            const qgR = qpE(this);
            qgI["texImage2D"](qgI["TEXTURE_2D"], 0, qgR, this["width"], this["height"], 0, qgI["RED"], qgI["FLOAT"], null), qgI["bindTexture"](qgI["TEXTURE_2D"], null), qp9(qgb, qgI, qgL), qp7(qgb, qgI, false, () => {
              qpf(this), qgI["clearColor"](0, 0, 0, 0), qgI["clear"](qgI["COLOR_BUFFER_BIT"]), qgI["drawArrays"](qgI["TRIANGLE_FAN"], 0, 4), qpS(this);
            }), qpq(qgb), qpS(this);
          }
        }
      }
      qgu["push"](qgL);
    }
    return new qpt(qgu, this["m"], this["P"](), this["canvas"], this["l"], this["width"], this["height"]);
  }
  ["close"]() {
    this["j"] && qps(this)["deleteTexture"](qpp(this, 2)), qpk = -1;
  }
};
qpt["prototype"]["close"] = qpt["prototype"]["close"], qpt["prototype"]["clone"] = qpt["prototype"]["clone"], qpt["prototype"]["getAsWebGLTexture"] = qpt["prototype"]["M"], qpt["prototype"]["getAsFloat32Array"] = qpt["prototype"]["ha"], qpt["prototype"]["getAsUint8Array"] = qpt["prototype"]["ia"], qpt["prototype"]["hasWebGLTexture"] = qpt["prototype"]["P"], qpt["prototype"]["hasFloat32Array"] = qpt["prototype"]["ja"], qpt["prototype"]["hasUint8Array"] = qpt["prototype"]["Fa"];
var qpk = 250;
function qpO(qgu, qgj) {
  switch (qgj) {
    case 0:
      return qgu["g"]["find"]((qgL) => qgL instanceof ImageData);
    case 1:
      return qgu["g"]["find"]((qgL) => typeof ImageBitmap != "undefined" && qgL instanceof ImageBitmap);
    case 2:
      return qgu["g"]["find"]((qgL) => typeof WebGLTexture != "undefined" && qgL instanceof WebGLTexture);
    default:
      throw Error("Type is not supported: " + qgj);
  }
}
function qpW(qgu) {
  var qgj = qpO(qgu, 0);
  if (!qgj) {
    qgj = qpD(qgu);
    const qgL = qpm(qgu), qgI = new Uint8Array(qgu["width"] * qgu["height"] * 4);
    qp9(qgL, qgj, qpi(qgu)), qgj["readPixels"](0, 0, qgu["width"], qgu["height"], qgj["RGBA"], qgj["UNSIGNED_BYTE"], qgI), qpq(qgL), qgj = new ImageData(new Uint8ClampedArray(qgI["buffer"]), qgu["width"], qgu["height"]), qgu["g"]["push"](qgj);
  }
  return qgj;
}
function qpi(qgu) {
  let qgj = qpO(qgu, 2);
  if (!qgj) {
    const qgL = qpD(qgu);
    qgj = qpa(qgu);
    const qgI = qpO(qgu, 1) || qpW(qgu);
    qgL["texImage2D"](qgL["TEXTURE_2D"], 0, qgL["RGBA"], qgL["RGBA"], qgL["UNSIGNED_BYTE"], qgI), qpZ(qgu);
  }
  return qgj;
}
function qpD(qgu) {
  if (!qgu["canvas"]) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return qgu["h"] || (qgu["h"] = qp2(qgu["canvas"]["getContext"]("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), qgu["h"];
}
function qpm(qgu) {
  return qgu["l"] || (qgu["l"] = new qpn()), qgu["l"];
}
function qpa(qgu) {
  const qgj = qpD(qgu);
  qgj["viewport"](0, 0, qgu["width"], qgu["height"]), qgj["activeTexture"](qgj["TEXTURE0"]);
  let qgL = qpO(qgu, 2);
  return qgL || (qgL = qp8(qpm(qgu), qgj), qgu["g"]["push"](qgL), qgu["m"] = true), qgj["bindTexture"](qgj["TEXTURE_2D"], qgL), qgL;
}
function qpZ(qgu) {
  qgu["h"]["bindTexture"](qgu["h"]["TEXTURE_2D"], null);
}
function qpw(qgu) {
  const qgj = qpD(qgu);
  return qp7(qpm(qgu), qgj, true, () => function(qgL, qgI) {
    const qgb = qgL["canvas"];
    if (qgb["width"] === qgL["width"] && qgb["height"] === qgL["height"]) return qgI();
    const qgR = qgb["width"], qgo = qgb["height"];
    return qgb["width"] = qgL["width"], qgb["height"] = qgL["height"], qgL = qgI(), qgb["width"] = qgR, qgb["height"] = qgo, qgL;
  }(qgu, () => {
    if (qgj["bindFramebuffer"](qgj["FRAMEBUFFER"], null), qgj["clearColor"](0, 0, 0, 0), qgj["clear"](qgj["COLOR_BUFFER_BIT"]), qgj["drawArrays"](qgj["TRIANGLE_FAN"], 0, 4), !(qgu["canvas"] instanceof OffscreenCanvas)) throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return qgu["canvas"]["transferToImageBitmap"]();
  }));
}
var qpe = class {
  constructor(qgu, qgj, qgL, qgI, qgb, qgR, qgo) {
    this["g"] = qgu, this["j"] = qgj, this["m"] = qgL, this["canvas"] = qgI, this["l"] = qgb, this["width"] = qgR, this["height"] = qgo, (this["j"] || this["m"]) && --qpz === 0 && console["error"]("You seem to be creating MPImage instances without invoking .close(). This leaks resources.");
  }
  ["Ea"]() {
    return !!qpO(this, 0);
  }
  ["ka"]() {
    return !!qpO(this, 1);
  }
  ["P"]() {
    return !!qpO(this, 2);
  }
  ["Ca"]() {
    return qpW(this);
  }
  ["Ba"]() {
    var qgu = qpO(this, 1);
    return qgu || (qpi(this), qpa(this), qgu = qpw(this), qpZ(this), this["g"]["push"](qgu), this["j"] = true), qgu;
  }
  ["M"]() {
    return qpi(this);
  }
  ["clone"]() {
    const qgu = [];
    for (const qgj of this["g"]) {
      let qgL;
      if (qgj instanceof ImageData) qgL = new ImageData(qgj["data"], this["width"], this["height"]);
      else {
        if (qgj instanceof WebGLTexture) {
          const qgI = qpD(this), qgb = qpm(this);
          qgI["activeTexture"](qgI["TEXTURE1"]), qgL = qp8(qgb, qgI), qgI["bindTexture"](qgI["TEXTURE_2D"], qgL), qgI["texImage2D"](qgI["TEXTURE_2D"], 0, qgI["RGBA"], this["width"], this["height"], 0, qgI["RGBA"], qgI["UNSIGNED_BYTE"], null), qgI["bindTexture"](qgI["TEXTURE_2D"], null), qp9(qgb, qgI, qgL), qp7(qgb, qgI, false, () => {
            qpa(this), qgI["clearColor"](0, 0, 0, 0), qgI["clear"](qgI["COLOR_BUFFER_BIT"]), qgI["drawArrays"](qgI["TRIANGLE_FAN"], 0, 4), qpZ(this);
          }), qpq(qgb), qpZ(this);
        } else {
          if (!(qgj instanceof ImageBitmap)) throw Error("Type is not supported: " + qgj);
          qpi(this), qpa(this), qgL = qpw(this), qpZ(this);
        }
      }
      qgu["push"](qgL);
    }
    return new qpe(qgu, this["ka"](), this["P"](), this["canvas"], this["l"], this["width"], this["height"]);
  }
  ["close"]() {
    this["j"] && qpO(this, 1)["close"](), this["m"] && qpD(this)["deleteTexture"](qpO(this, 2)), qpz = -1;
  }
};
qpe["prototype"]["close"] = qpe["prototype"]["close"], qpe["prototype"]["clone"] = qpe["prototype"]["clone"], qpe["prototype"]["getAsWebGLTexture"] = qpe["prototype"]["M"], qpe["prototype"]["getAsImageBitmap"] = qpe["prototype"]["Ba"], qpe["prototype"]["getAsImageData"] = qpe["prototype"]["Ca"], qpe["prototype"]["hasWebGLTexture"] = qpe["prototype"]["P"], qpe["prototype"]["hasImageBitmap"] = qpe["prototype"]["ka"], qpe["prototype"]["hasImageData"] = qpe["prototype"]["Ea"];
var qpz = 250;
function qpc(...qgu) {
  return qgu["map"](([qgj, qgL]) => ({ "start": qgj, "end": qgL }));
}
var qpX = /* @__PURE__ */ function(qgu) {
  return class extends qgu {
    ["La"]() {
      this["i"]["_registerModelResourcesGraphService"]();
    }
  };
}((qpG = class {
  constructor(qgu, qgj) {
    this["l"] = true, this["i"] = qgu, this["g"] = null, this["h"] = 0, this["m"] = typeof this["i"]["_addIntToInputStream"] == "function", qgj !== void 0 ? this["i"]["canvas"] = qgj : qny() ? this["i"]["canvas"] = new OffscreenCanvas(1, 1) : (console["warn"]("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this["i"]["canvas"] = document["createElement"]("canvas"));
  }
  async ["initializeGraph"](qgu) {
    const qgj = await (await fetch(qgu))["arrayBuffer"]();
    qgu = !(qgu["endsWith"](".pbtxt") || qgu["endsWith"](".textproto")), this["setGraph"](new Uint8Array(qgj), qgu);
  }
  ["setGraphFromString"](qgu) {
    this["setGraph"](new TextEncoder()["encode"](qgu), false);
  }
  ["setGraph"](qgu, qgj) {
    const qgL = qgu["length"], qgI = this["i"]["_malloc"](qgL);
    this["i"]["HEAPU8"]["set"](qgu, qgI), qgj ? this["i"]["_changeBinaryGraph"](qgL, qgI) : this["i"]["_changeTextGraph"](qgL, qgI), this["i"]["_free"](qgI);
  }
  ["configureAudio"](qgu, qgj, qgL, qgI, qgb) {
    this["i"]["_configureAudio"] || console["warn"]('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), qnH(this, qgI || "input_audio", (qgR) => {
      qnH(this, qgb = qgb || "audio_header", (qgo) => {
        this["i"]["_configureAudio"](qgR, qgo, qgu, qgj != null ? qgj : 0, qgL);
      });
    });
  }
  ["setAutoResizeCanvas"](qgu) {
    this["l"] = qgu;
  }
  ["setAutoRenderToScreen"](qgu) {
    this["i"]["_setAutoRenderToScreen"](qgu);
  }
  ["setGpuBufferVerticalFlip"](qgu) {
    this["i"]["gpuOriginForWebTexturesIsBottomLeft"] = qgu;
  }
  ["da"](qgu) {
    qnT(this, "__graph_config__", (qgj) => {
      qgu(qgj);
    }), qnH(this, "__graph_config__", (qgj) => {
      this["i"]["_getGraphConfig"](qgj, void 0);
    }), delete this["i"]["simpleListeners"]["__graph_config__"];
  }
  ["attachErrorListener"](qgu) {
    this["i"]["errorListener"] = qgu;
  }
  ["attachEmptyPacketListener"](qgu, qgj) {
    this["i"]["emptyPacketListeners"] = this["i"]["emptyPacketListeners"] || {}, this["i"]["emptyPacketListeners"][qgu] = qgj;
  }
  ["addAudioToStream"](qgu, qgj, qgL) {
    this["addAudioToStreamWithShape"](qgu, 0, 0, qgj, qgL);
  }
  ["addAudioToStreamWithShape"](qgu, qgj, qgL, qgI, qgb) {
    const qgR = 4 * qgu["length"];
    this["h"] !== qgR && (this["g"] && this["i"]["_free"](this["g"]), this["g"] = this["i"]["_malloc"](qgR), this["h"] = qgR), this["i"]["HEAPF32"]["set"](qgu, this["g"] / 4), qnH(this, qgI, (qgo) => {
      this["i"]["_addAudioToInputStream"](this["g"], qgj, qgL, qgo, qgb);
    });
  }
  ["addGpuBufferToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const [qgb, qgR] = qnA(this, qgu, qgI);
      this["i"]["_addBoundTextureToStream"](qgI, qgb, qgR, qgL);
    });
  }
  ["addBoolToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      this["i"]["_addBoolToInputStream"](qgu, qgI, qgL);
    });
  }
  ["addDoubleToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      this["i"]["_addDoubleToInputStream"](qgu, qgI, qgL);
    });
  }
  ["addFloatToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      this["i"]["_addFloatToInputStream"](qgu, qgI, qgL);
    });
  }
  ["addIntToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      this["i"]["_addIntToInputStream"](qgu, qgI, qgL);
    });
  }
  ["addUintToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      this["i"]["_addUintToInputStream"](qgu, qgI, qgL);
    });
  }
  ["addStringToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      qnH(this, qgu, (qgb) => {
        this["i"]["_addStringToInputStream"](qgb, qgI, qgL);
      });
    });
  }
  ["addStringRecordToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      qnh(this, Object["keys"](qgu), (qgb) => {
        qnh(this, Object["values"](qgu), (qgR) => {
          this["i"]["_addFlatHashMapToInputStream"](qgb, qgR, Object["keys"](qgu)["length"], qgI, qgL);
        });
      });
    });
  }
  ["addProtoToStream"](qgu, qgj, qgL, qgI) {
    qnH(this, qgL, (qgb) => {
      qnH(this, qgj, (qgR) => {
        const qgo = this["i"]["_malloc"](qgu["length"]);
        this["i"]["HEAPU8"]["set"](qgu, qgo), this["i"]["_addProtoToInputStream"](qgo, qgu["length"], qgR, qgb, qgI), this["i"]["_free"](qgo);
      });
    });
  }
  ["addEmptyPacketToStream"](qgu, qgj) {
    qnH(this, qgu, (qgL) => {
      this["i"]["_addEmptyPacketToInputStream"](qgL, qgj);
    });
  }
  ["addBoolVectorToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const qgb = this["i"]["_allocateBoolVector"](qgu["length"]);
      if (!qgb) throw Error("Unable to allocate new bool vector on heap.");
      for (const qgR of qgu) this["i"]["_addBoolVectorEntry"](qgb, qgR);
      this["i"]["_addBoolVectorToInputStream"](qgb, qgI, qgL);
    });
  }
  ["addDoubleVectorToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const qgb = this["i"]["_allocateDoubleVector"](qgu["length"]);
      if (!qgb) throw Error("Unable to allocate new double vector on heap.");
      for (const qgR of qgu) this["i"]["_addDoubleVectorEntry"](qgb, qgR);
      this["i"]["_addDoubleVectorToInputStream"](qgb, qgI, qgL);
    });
  }
  ["addFloatVectorToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const qgb = this["i"]["_allocateFloatVector"](qgu["length"]);
      if (!qgb) throw Error("Unable to allocate new float vector on heap.");
      for (const qgR of qgu) this["i"]["_addFloatVectorEntry"](qgb, qgR);
      this["i"]["_addFloatVectorToInputStream"](qgb, qgI, qgL);
    });
  }
  ["addIntVectorToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const qgb = this["i"]["_allocateIntVector"](qgu["length"]);
      if (!qgb) throw Error("Unable to allocate new int vector on heap.");
      for (const qgR of qgu) this["i"]["_addIntVectorEntry"](qgb, qgR);
      this["i"]["_addIntVectorToInputStream"](qgb, qgI, qgL);
    });
  }
  ["addUintVectorToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const qgb = this["i"]["_allocateUintVector"](qgu["length"]);
      if (!qgb) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const qgR of qgu) this["i"]["_addUintVectorEntry"](qgb, qgR);
      this["i"]["_addUintVectorToInputStream"](qgb, qgI, qgL);
    });
  }
  ["addStringVectorToStream"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const qgb = this["i"]["_allocateStringVector"](qgu["length"]);
      if (!qgb) throw Error("Unable to allocate new string vector on heap.");
      for (const qgR of qgu) qnH(this, qgR, (qgo) => {
        this["i"]["_addStringVectorEntry"](qgb, qgo);
      });
      this["i"]["_addStringVectorToInputStream"](qgb, qgI, qgL);
    });
  }
  ["addBoolToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      this["i"]["_addBoolToInputSidePacket"](qgu, qgL);
    });
  }
  ["addDoubleToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      this["i"]["_addDoubleToInputSidePacket"](qgu, qgL);
    });
  }
  ["addFloatToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      this["i"]["_addFloatToInputSidePacket"](qgu, qgL);
    });
  }
  ["addIntToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      this["i"]["_addIntToInputSidePacket"](qgu, qgL);
    });
  }
  ["addUintToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      this["i"]["_addUintToInputSidePacket"](qgu, qgL);
    });
  }
  ["addStringToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      qnH(this, qgu, (qgI) => {
        this["i"]["_addStringToInputSidePacket"](qgI, qgL);
      });
    });
  }
  ["addProtoToInputSidePacket"](qgu, qgj, qgL) {
    qnH(this, qgL, (qgI) => {
      qnH(this, qgj, (qgb) => {
        const qgR = this["i"]["_malloc"](qgu["length"]);
        this["i"]["HEAPU8"]["set"](qgu, qgR), this["i"]["_addProtoToInputSidePacket"](qgR, qgu["length"], qgb, qgI), this["i"]["_free"](qgR);
      });
    });
  }
  ["addBoolVectorToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      const qgI = this["i"]["_allocateBoolVector"](qgu["length"]);
      if (!qgI) throw Error("Unable to allocate new bool vector on heap.");
      for (const qgb of qgu) this["i"]["_addBoolVectorEntry"](qgI, qgb);
      this["i"]["_addBoolVectorToInputSidePacket"](qgI, qgL);
    });
  }
  ["addDoubleVectorToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      const qgI = this["i"]["_allocateDoubleVector"](qgu["length"]);
      if (!qgI) throw Error("Unable to allocate new double vector on heap.");
      for (const qgb of qgu) this["i"]["_addDoubleVectorEntry"](qgI, qgb);
      this["i"]["_addDoubleVectorToInputSidePacket"](qgI, qgL);
    });
  }
  ["addFloatVectorToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      const qgI = this["i"]["_allocateFloatVector"](qgu["length"]);
      if (!qgI) throw Error("Unable to allocate new float vector on heap.");
      for (const qgb of qgu) this["i"]["_addFloatVectorEntry"](qgI, qgb);
      this["i"]["_addFloatVectorToInputSidePacket"](qgI, qgL);
    });
  }
  ["addIntVectorToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      const qgI = this["i"]["_allocateIntVector"](qgu["length"]);
      if (!qgI) throw Error("Unable to allocate new int vector on heap.");
      for (const qgb of qgu) this["i"]["_addIntVectorEntry"](qgI, qgb);
      this["i"]["_addIntVectorToInputSidePacket"](qgI, qgL);
    });
  }
  ["addUintVectorToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      const qgI = this["i"]["_allocateUintVector"](qgu["length"]);
      if (!qgI) throw Error("Unable to allocate new unsigned int vector on heap.");
      for (const qgb of qgu) this["i"]["_addUintVectorEntry"](qgI, qgb);
      this["i"]["_addUintVectorToInputSidePacket"](qgI, qgL);
    });
  }
  ["addStringVectorToInputSidePacket"](qgu, qgj) {
    qnH(this, qgj, (qgL) => {
      const qgI = this["i"]["_allocateStringVector"](qgu["length"]);
      if (!qgI) throw Error("Unable to allocate new string vector on heap.");
      for (const qgb of qgu) qnH(this, qgb, (qgR) => {
        this["i"]["_addStringVectorEntry"](qgI, qgR);
      });
      this["i"]["_addStringVectorToInputSidePacket"](qgI, qgL);
    });
  }
  ["attachBoolListener"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachBoolListener"](qgL);
    });
  }
  ["attachBoolVectorListener"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachBoolVectorListener"](qgL);
    });
  }
  ["attachIntListener"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachIntListener"](qgL);
    });
  }
  ["attachIntVectorListener"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachIntVectorListener"](qgL);
    });
  }
  ["attachUintListener"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachUintListener"](qgL);
    });
  }
  ["attachUintVectorListener"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachUintVectorListener"](qgL);
    });
  }
  ["attachDoubleListener"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachDoubleListener"](qgL);
    });
  }
  ["attachDoubleVectorListener"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachDoubleVectorListener"](qgL);
    });
  }
  ["attachFloatListener"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachFloatListener"](qgL);
    });
  }
  ["attachFloatVectorListener"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachFloatVectorListener"](qgL);
    });
  }
  ["attachStringListener"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachStringListener"](qgL);
    });
  }
  ["attachStringVectorListener"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["i"]["_attachStringVectorListener"](qgL);
    });
  }
  ["attachProtoListener"](qgu, qgj, qgL) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgI) => {
      this["i"]["_attachProtoListener"](qgI, qgL || false);
    });
  }
  ["attachProtoVectorListener"](qgu, qgj, qgL) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgI) => {
      this["i"]["_attachProtoVectorListener"](qgI, qgL || false);
    });
  }
  ["attachAudioListener"](qgu, qgj, qgL) {
    this["i"]["_attachAudioListener"] || console["warn"]('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), qnT(this, qgu, (qgI, qgb) => {
      qgI = new Float32Array(qgI["buffer"], qgI["byteOffset"], qgI["length"] / 4), qgj(qgI, qgb);
    }), qnH(this, qgu, (qgI) => {
      this["i"]["_attachAudioListener"](qgI, qgL || false);
    });
  }
  ["finishProcessing"]() {
    this["i"]["_waitUntilIdle"]();
  }
  ["closeGraph"]() {
    this["i"]["_closeGraph"](), this["i"]["simpleListeners"] = void 0, this["i"]["emptyPacketListeners"] = void 0;
  }
}, class extends qpG {
  get ["ea"]() {
    return this["i"];
  }
  ["qa"](qgu, qgj, qgL) {
    qnH(this, qgj, (qgI) => {
      const [qgb, qgR] = qnA(this, qgu, qgI);
      this["ea"]["_addBoundTextureAsImageToStream"](qgI, qgb, qgR, qgL);
    });
  }
  ["U"](qgu, qgj) {
    qnT(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["ea"]["_attachImageListener"](qgL);
    });
  }
  ["ca"](qgu, qgj) {
    qnK(this, qgu, qgj), qnH(this, qgu, (qgL) => {
      this["ea"]["_attachImageVectorListener"](qgL);
    });
  }
}));
var qpG;
var qpN = class extends qpX {
};
async function qpu(qgu, qgj, qgL) {
  var qgI;
  return async function(qgb, qgR, qgo, qgr) {
    return qnB(qgb, qgR, qgo, qgr);
  }(qgu, (qgI = qgL["canvas"]) != null ? qgI : qny() ? void 0 : document["createElement"]("canvas"), qgj, qgL);
}
function qpj(qgu, qgj, qgL, qgI) {
  if (qgu["T"]) {
    const qgR = new qqN();
    if (qgL != null && qgL["regionOfInterest"]) {
      if (!qgu["pa"]) throw Error("This task doesn't support region-of-interest.");
      var qgb = qgL["regionOfInterest"];
      if (qgb["left"] >= qgb["right"] || qgb["top"] >= qgb["bottom"]) throw Error("Expected RectF with left < right and top < bottom.");
      if (qgb["left"] < 0 || qgb["top"] < 0 || qgb["right"] > 1 || qgb["bottom"] > 1) throw Error("Expected RectF values to be in [0,1].");
      q80(qgR, 1, (qgb["left"] + qgb["right"]) / 2), q80(qgR, 2, (qgb["top"] + qgb["bottom"]) / 2), q80(qgR, 4, qgb["right"] - qgb["left"]), q80(qgR, 3, qgb["bottom"] - qgb["top"]);
    } else q80(qgR, 1, 0.5), q80(qgR, 2, 0.5), q80(qgR, 4, 1), q80(qgR, 3, 1);
    if (qgL != null && qgL["rotationDegrees"]) {
      if ((qgL == null ? void 0 : qgL["rotationDegrees"]) % 90 != 0) throw Error("Expected rotation to be a multiple of 90°.");
      if (q80(qgR, 5, -Math["PI"] * qgL["rotationDegrees"] / 180), (qgL == null ? void 0 : qgL["rotationDegrees"]) % 180 != 0) {
        const [qgo, qgr] = qnl(qgj);
        qgL = q7Y(qgR, 3) * qgr / qgo, qgb = q7Y(qgR, 4) * qgo / qgr, q80(qgR, 4, qgL), q80(qgR, 3, qgb);
      }
    }
    qgu["g"]["addProtoToStream"](qgR["g"](), "mediapipe.NormalizedRect", qgu["T"], qgI);
  }
  qgu["g"]["qa"](qgj, qgu["aa"], qgI != null ? qgI : performance["now"]()), qgu["finishProcessing"]();
}
function qpL(qgu, qgj, qgL) {
  var qgI;
  if ((qgI = qgu["baseOptions"]) != null && qgI["g"]()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
  qpj(qgu, qgj, qgL, qgu["B"] + 1);
}
function qpI(qgu, qgj, qgL, qgI) {
  var qgb;
  if (!((qgb = qgu["baseOptions"]) != null && qgb["g"]())) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
  qpj(qgu, qgj, qgL, qgI);
}
function qpb(qgu, qgj, qgL, qgI) {
  var qgb = qgj["data"];
  const qgR = qgj["width"], qgo = qgR * (qgj = qgj["height"]);
  if ((qgb instanceof Uint8Array || qgb instanceof Float32Array) && qgb["length"] !== qgo) throw Error("Unsupported channel count: " + qgb["length"] / qgo);
  return qgu = new qpt([qgb], qgL, false, qgu["g"]["i"]["canvas"], qgu["O"], qgR, qgj), qgI ? qgu["clone"]() : qgu;
}
var qpR = class extends qp1 {
  constructor(qgu, qgj, qgL, qgI) {
    super(qgu), this["g"] = qgu, this["aa"] = qgj, this["T"] = qgL, this["pa"] = qgI, this["O"] = new qpn();
  }
  ["l"](qgu, qgj = true) {
    if ("runningMode" in qgu && q7P(this["baseOptions"], 2, !!qgu["runningMode"] && qgu["runningMode"] !== "IMAGE"), qgu["canvas"] !== void 0 && this["g"]["i"]["canvas"] !== qgu["canvas"]) throw Error("You must create a new task to reset the canvas.");
    return super["l"](qgu, qgj);
  }
  ["close"]() {
    this["O"]["close"](), super["close"]();
  }
};
qpR["prototype"]["close"] = qpR["prototype"]["close"];
var qpo = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect_in", false), this["j"] = { "detections": [] }, q7A(qgu = this["h"] = new qqT(), 0, 1, qgj = new qqH()), q80(this["h"], 2, 0.5), q80(this["h"], 3, 0.3);
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL;
    return "minDetectionConfidence" in qgu && q80(this["h"], 2, (qgj = qgu["minDetectionConfidence"]) != null ? qgj : 0.5), "minSuppressionThreshold" in qgu && q80(this["h"], 3, (qgL = qgu["minSuppressionThreshold"]) != null ? qgL : 0.3), this["l"](qgu);
  }
  ["D"](qgu, qgj) {
    return this["j"] = { "detections": [] }, qpL(this, qgu, qgj), this["j"];
  }
  ["F"](qgu, qgj, qgL) {
    return this["j"] = { "detections": [] }, qpI(this, qgu, qgL, qgj), this["j"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect_in"), qqf(qgu, "detections");
    const qgj = new qq6();
    q8a(qgj, qqB, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect_in"), qqn(qgL, "DETECTIONS:detections"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoVectorListener"]("detections", (qgI, qgb) => {
      for (const qgR of qgI) qgI = qqZ(qgR), this["j"]["detections"]["push"](qnj(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("detections", (qgI) => {
      qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qpo["prototype"]["detectForVideo"] = qpo["prototype"]["F"], qpo["prototype"]["detect"] = qpo["prototype"]["D"], qpo["prototype"]["setOptions"] = qpo["prototype"]["o"], qpo["createFromModelPath"] = async function(qgu, qgj) {
  return qpu(qpo, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qpo["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qpo, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qpo["createFromOptions"] = function(qgu, qgj) {
  return qpu(qpo, qgu, qgj);
};
var qpr = qpc([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]);
var qpQ = qpc([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]);
var qpd = qpc([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]);
var qpv = qpc([474, 475], [475, 476], [476, 477], [477, 474]);
var qpy = qpc([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]);
var qpC = qpc([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]);
var qpl = qpc([469, 470], [470, 471], [471, 472], [472, 469]);
var qpH = qpc([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]);
var qpA = [...qpr, ...qpQ, ...qpd, ...qpy, ...qpC, ...qpH];
var qph = qpc([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
function qpT(qgu) {
  qgu["j"] = { "faceLandmarks": [], "faceBlendshapes": [], "facialTransformationMatrixes": [] };
}
var qpK = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", false), this["j"] = { "faceLandmarks": [], "faceBlendshapes": [], "facialTransformationMatrixes": [] }, this["outputFacialTransformationMatrixes"] = this["outputFaceBlendshapes"] = false, q7A(qgu = this["h"] = new qqY(), 0, 1, qgj = new qqH()), this["v"] = new qqJ(), q7A(this["h"], 0, 3, this["v"]), this["s"] = new qqT(), q7A(this["h"], 0, 2, this["s"]), q7U(this["s"], 4, 1), q80(this["s"], 2, 0.5), q80(this["v"], 2, 0.5), q80(this["h"], 4, 0.5);
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL, qgI, qgb;
    return "numFaces" in qgu && q7U(this["s"], 4, (qgj = qgu["numFaces"]) != null ? qgj : 1), "minFaceDetectionConfidence" in qgu && q80(this["s"], 2, (qgL = qgu["minFaceDetectionConfidence"]) != null ? qgL : 0.5), "minTrackingConfidence" in qgu && q80(this["h"], 4, (qgI = qgu["minTrackingConfidence"]) != null ? qgI : 0.5), "minFacePresenceConfidence" in qgu && q80(this["v"], 2, (qgb = qgu["minFacePresenceConfidence"]) != null ? qgb : 0.5), "outputFaceBlendshapes" in qgu && (this["outputFaceBlendshapes"] = !!qgu["outputFaceBlendshapes"]), "outputFacialTransformationMatrixes" in qgu && (this["outputFacialTransformationMatrixes"] = !!qgu["outputFacialTransformationMatrixes"]), this["l"](qgu);
  }
  ["D"](qgu, qgj) {
    return qpT(this), qpL(this, qgu, qgj), this["j"];
  }
  ["F"](qgu, qgj, qgL) {
    return qpT(this), qpI(this, qgu, qgL, qgj), this["j"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect"), qqf(qgu, "face_landmarks");
    const qgj = new qq6();
    q8a(qgj, qn0, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "NORM_LANDMARKS:face_landmarks"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoVectorListener"]("face_landmarks", (qgI, qgb) => {
      for (const qgR of qgI) qgI = qqc(qgR), this["j"]["faceLandmarks"]["push"](qnL(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("face_landmarks", (qgI) => {
      qnY(this, qgI);
    }), this["outputFaceBlendshapes"] && (qqf(qgu, "blendshapes"), qqn(qgL, "BLENDSHAPES:blendshapes"), this["g"]["attachProtoVectorListener"]("blendshapes", (qgI, qgb) => {
      var qgR;
      if (this["outputFaceBlendshapes"]) {
        for (const qgo of qgI) qgI = qqi(qgo), this["j"]["faceBlendshapes"]["push"](qnu((qgR = qgI["g"]()) != null ? qgR : []));
      }
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("blendshapes", (qgI) => {
      qnY(this, qgI);
    })), this["outputFacialTransformationMatrixes"] && (qqf(qgu, "face_geometry"), qqn(qgL, "FACE_GEOMETRY:face_geometry"), this["g"]["attachProtoVectorListener"]("face_geometry", (qgI, qgb) => {
      var qgR, qgo, qgr, qgQ, qgd;
      if (this["outputFacialTransformationMatrixes"]) {
        for (const qgv of qgI) (qgI = q7C(qqV(qgv), qqX, 2)) && this["j"]["facialTransformationMatrixes"]["push"]({ "rows": (qgo = (qgR = q7V(qgI, 1)) != null ? qgR : 0) != null ? qgo : 0, "columns": (qgQ = (qgr = q7V(qgI, 2)) != null ? qgr : 0) != null ? qgQ : 0, "data": (qgd = q7N(qgI, 3, q6H, q7G())["slice"]()) != null ? qgd : [] });
      }
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("face_geometry", (qgI) => {
      qnY(this, qgI);
    })), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qpK["prototype"]["detectForVideo"] = qpK["prototype"]["F"], qpK["prototype"]["detect"] = qpK["prototype"]["D"], qpK["prototype"]["setOptions"] = qpK["prototype"]["o"], qpK["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qpK, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qpK["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qpK, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qpK["createFromOptions"] = function(qgu, qgj) {
  return qpu(qpK, qgu, qgj);
}, qpK["FACE_LANDMARKS_LIPS"] = qpr, qpK["FACE_LANDMARKS_LEFT_EYE"] = qpQ, qpK["FACE_LANDMARKS_LEFT_EYEBROW"] = qpd, qpK["FACE_LANDMARKS_LEFT_IRIS"] = qpv, qpK["FACE_LANDMARKS_RIGHT_EYE"] = qpy, qpK["FACE_LANDMARKS_RIGHT_EYEBROW"] = qpC, qpK["FACE_LANDMARKS_RIGHT_IRIS"] = qpl, qpK["FACE_LANDMARKS_FACE_OVAL"] = qpH, qpK["FACE_LANDMARKS_CONTOURS"] = qpA, qpK["FACE_LANDMARKS_TESSELATION"] = qph;
var qpB = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", true), q7A(qgu = this["j"] = new qn1(), 0, 1, qgj = new qqH());
  }
  get ["baseOptions"]() {
    return q7C(this["j"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["j"], 0, 1, qgu);
  }
  ["o"](qgu) {
    return super["l"](qgu);
  }
  ["Oa"](qgu, qgj, qgL) {
    const qgI = typeof qgj != "function" ? qgj : {};
    if (this["h"] = typeof qgj == "function" ? qgj : qgL, qpL(this, qgu, qgI != null ? qgI : {}), !this["h"]) return this["s"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect"), qqf(qgu, "stylized_image");
    const qgj = new qq6();
    q8a(qgj, qn2, this["j"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.face_stylizer.FaceStylizerGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "STYLIZED_IMAGE:stylized_image"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["U"]("stylized_image", (qgI, qgb) => {
      var qgR = !this["h"], qgo = qgI["data"], qgr = qgI["width"];
      const qgQ = qgr * (qgI = qgI["height"]);
      if (qgo instanceof Uint8Array) {
        if (qgo["length"] === 3 * qgQ) {
          const qgd = new Uint8ClampedArray(4 * qgQ);
          for (let qgv = 0; qgv < qgQ; ++qgv) qgd[4 * qgv] = qgo[3 * qgv], qgd[4 * qgv + 1] = qgo[3 * qgv + 1], qgd[4 * qgv + 2] = qgo[3 * qgv + 2], qgd[4 * qgv + 3] = 255;
          qgo = new ImageData(qgd, qgr, qgI);
        } else {
          if (qgo["length"] !== 4 * qgQ) throw Error("Unsupported channel count: " + qgo["length"] / qgQ);
          qgo = new ImageData(new Uint8ClampedArray(qgo["buffer"], qgo["byteOffset"], qgo["length"]), qgr, qgI);
        }
      } else {
        if (!(qgo instanceof WebGLTexture)) throw Error("Unsupported format: " + qgo["constructor"]["name"]);
      }
      qgr = new qpe([qgo], false, false, this["g"]["i"]["canvas"], this["O"], qgr, qgI), this["s"] = qgR = qgR ? qgr["clone"]() : qgr, this["h"] && this["h"](qgR), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("stylized_image", (qgI) => {
      this["s"] = null, this["h"] && this["h"](null), qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qpB["prototype"]["stylize"] = qpB["prototype"]["Oa"], qpB["prototype"]["setOptions"] = qpB["prototype"]["o"], qpB["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qpB, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qpB["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qpB, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qpB["createFromOptions"] = function(qgu, qgj) {
  return qpu(qpB, qgu, qgj);
};
var qpV = qpc([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
function qpJ(qgu) {
  qgu["gestures"] = [], qgu["landmarks"] = [], qgu["worldLandmarks"] = [], qgu["handedness"] = [];
}
function qpY(qgu) {
  return qgu["gestures"]["length"] === 0 ? { "gestures": [], "landmarks": [], "worldLandmarks": [], "handedness": [], "handednesses": [] } : { "gestures": qgu["gestures"], "landmarks": qgu["landmarks"], "worldLandmarks": qgu["worldLandmarks"], "handedness": qgu["handedness"], "handednesses": qgu["handedness"] };
}
function qpP(qgu, qgj = true) {
  var qgL, qgI, qgb, qgR, qgo, qgr;
  const qgQ = [];
  for (const qgv of qgu) {
    var qgd = qqi(qgv);
    qgu = [];
    for (const qgy of qgd["g"]()) qgd = qgj && q7V(qgy, 1) != null ? (qgL = q7V(qgy, 1)) != null ? qgL : 0 : -1, qgu["push"]({ "score": (qgI = q7Y(qgy, 2)) != null ? qgI : 0, "index": qgd, "categoryName": (qgR = (qgb = q7J(qgy, 3)) != null ? qgb : "") != null ? qgR : "", "displayName": (qgr = (qgo = q7J(qgy, 4)) != null ? qgo : "") != null ? qgr : "" });
    qgQ["push"](qgu);
  }
  return qgQ;
}
var qpU = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", false), this["gestures"] = [], this["landmarks"] = [], this["worldLandmarks"] = [], this["handedness"] = [], q7A(qgu = this["j"] = new qn9(), 0, 1, qgj = new qqH()), this["s"] = new qn8(), q7A(this["j"], 0, 2, this["s"]), this["C"] = new qn7(), q7A(this["s"], 0, 3, this["C"]), this["v"] = new qn6(), q7A(this["s"], 0, 2, this["v"]), this["h"] = new qn5(), q7A(this["j"], 0, 3, this["h"]), q80(this["v"], 2, 0.5), q80(this["s"], 4, 0.5), q80(this["C"], 2, 0.5);
  }
  get ["baseOptions"]() {
    return q7C(this["j"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["j"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL, qgI, qgb, qgR, qgo, qgr, qgQ;
    if (q7U(this["v"], 3, (qgj = qgu["numHands"]) != null ? qgj : 1), "minHandDetectionConfidence" in qgu && q80(this["v"], 2, (qgL = qgu["minHandDetectionConfidence"]) != null ? qgL : 0.5), "minTrackingConfidence" in qgu && q80(this["s"], 4, (qgI = qgu["minTrackingConfidence"]) != null ? qgI : 0.5), "minHandPresenceConfidence" in qgu && q80(this["C"], 2, (qgb = qgu["minHandPresenceConfidence"]) != null ? qgb : 0.5), qgu["cannedGesturesClassifierOptions"]) {
      var qgd = new qn3(), qgv = qgd, qgy = qnN(qgu["cannedGesturesClassifierOptions"], (qgR = q7C(this["h"], qn3, 3)) == null ? void 0 : qgR["h"]());
      q7A(qgv, 0, 2, qgy), q7A(this["h"], 0, 3, qgd);
    } else qgu["cannedGesturesClassifierOptions"] === void 0 && ((qgo = q7C(this["h"], qn3, 3)) == null || qgo["g"]());
    return qgu["customGesturesClassifierOptions"] ? (q7A(qgv = qgd = new qn3(), 0, 2, qgy = qnN(qgu["customGesturesClassifierOptions"], (qgr = q7C(this["h"], qn3, 4)) == null ? void 0 : qgr["h"]())), q7A(this["h"], 0, 4, qgd)) : qgu["customGesturesClassifierOptions"] === void 0 && ((qgQ = q7C(this["h"], qn3, 4)) == null || qgQ["g"]()), this["l"](qgu);
  }
  ["Ja"](qgu, qgj) {
    return qpJ(this), qpL(this, qgu, qgj), qpY(this);
  }
  ["Ka"](qgu, qgj, qgL) {
    return qpJ(this), qpI(this, qgu, qgL, qgj), qpY(this);
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect"), qqf(qgu, "hand_gestures"), qqf(qgu, "hand_landmarks"), qqf(qgu, "world_hand_landmarks"), qqf(qgu, "handedness");
    const qgj = new qq6();
    q8a(qgj, qnx, this["j"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "HAND_GESTURES:hand_gestures"), qqn(qgL, "LANDMARKS:hand_landmarks"), qqn(qgL, "WORLD_LANDMARKS:world_hand_landmarks"), qqn(qgL, "HANDEDNESS:handedness"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoVectorListener"]("hand_landmarks", (qgI, qgb) => {
      var qgR, qgo, qgr, qgQ;
      for (const qgd of qgI) {
        qgI = qqc(qgd);
        const qgv = [];
        for (const qgy of q7H(qgI, qqz, 1)) qgv["push"]({ "x": (qgR = q7Y(qgy, 1)) != null ? qgR : 0, "y": (qgo = q7Y(qgy, 2)) != null ? qgo : 0, "z": (qgr = q7Y(qgy, 3)) != null ? qgr : 0, "visibility": (qgQ = q7Y(qgy, 4)) != null ? qgQ : 0 });
        this["landmarks"]["push"](qgv);
      }
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("hand_landmarks", (qgI) => {
      qnY(this, qgI);
    }), this["g"]["attachProtoVectorListener"]("world_hand_landmarks", (qgI, qgb) => {
      var qgR, qgo, qgr, qgQ;
      for (const qgd of qgI) {
        qgI = qqe(qgd);
        const qgv = [];
        for (const qgy of q7H(qgI, qqw, 1)) qgv["push"]({ "x": (qgR = q7Y(qgy, 1)) != null ? qgR : 0, "y": (qgo = q7Y(qgy, 2)) != null ? qgo : 0, "z": (qgr = q7Y(qgy, 3)) != null ? qgr : 0, "visibility": (qgQ = q7Y(qgy, 4)) != null ? qgQ : 0 });
        this["worldLandmarks"]["push"](qgv);
      }
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("world_hand_landmarks", (qgI) => {
      qnY(this, qgI);
    }), this["g"]["attachProtoVectorListener"]("hand_gestures", (qgI, qgb) => {
      this["gestures"]["push"](...qpP(qgI, false)), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("hand_gestures", (qgI) => {
      qnY(this, qgI);
    }), this["g"]["attachProtoVectorListener"]("handedness", (qgI, qgb) => {
      this["handedness"]["push"](...qpP(qgI)), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("handedness", (qgI) => {
      qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
function qg0(qgu) {
  return { "landmarks": qgu["landmarks"], "worldLandmarks": qgu["worldLandmarks"], "handednesses": qgu["handedness"], "handedness": qgu["handedness"] };
}
qpU["prototype"]["recognizeForVideo"] = qpU["prototype"]["Ka"], qpU["prototype"]["recognize"] = qpU["prototype"]["Ja"], qpU["prototype"]["setOptions"] = qpU["prototype"]["o"], qpU["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qpU, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qpU["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qpU, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qpU["createFromOptions"] = function(qgu, qgj) {
  return qpu(qpU, qgu, qgj);
}, qpU["HAND_CONNECTIONS"] = qpV;
var qg1 = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", false), this["landmarks"] = [], this["worldLandmarks"] = [], this["handedness"] = [], q7A(qgu = this["h"] = new qn8(), 0, 1, qgj = new qqH()), this["s"] = new qn7(), q7A(this["h"], 0, 3, this["s"]), this["j"] = new qn6(), q7A(this["h"], 0, 2, this["j"]), q7U(this["j"], 3, 1), q80(this["j"], 2, 0.5), q80(this["s"], 2, 0.5), q80(this["h"], 4, 0.5);
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL, qgI, qgb;
    return "numHands" in qgu && q7U(this["j"], 3, (qgj = qgu["numHands"]) != null ? qgj : 1), "minHandDetectionConfidence" in qgu && q80(this["j"], 2, (qgL = qgu["minHandDetectionConfidence"]) != null ? qgL : 0.5), "minTrackingConfidence" in qgu && q80(this["h"], 4, (qgI = qgu["minTrackingConfidence"]) != null ? qgI : 0.5), "minHandPresenceConfidence" in qgu && q80(this["s"], 2, (qgb = qgu["minHandPresenceConfidence"]) != null ? qgb : 0.5), this["l"](qgu);
  }
  ["D"](qgu, qgj) {
    return this["landmarks"] = [], this["worldLandmarks"] = [], this["handedness"] = [], qpL(this, qgu, qgj), qg0(this);
  }
  ["F"](qgu, qgj, qgL) {
    return this["landmarks"] = [], this["worldLandmarks"] = [], this["handedness"] = [], qpI(this, qgu, qgL, qgj), qg0(this);
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect"), qqf(qgu, "hand_landmarks"), qqf(qgu, "world_hand_landmarks"), qqf(qgu, "handedness");
    const qgj = new qq6();
    q8a(qgj, qns, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "LANDMARKS:hand_landmarks"), qqn(qgL, "WORLD_LANDMARKS:world_hand_landmarks"), qqn(qgL, "HANDEDNESS:handedness"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoVectorListener"]("hand_landmarks", (qgI, qgb) => {
      for (const qgR of qgI) qgI = qqc(qgR), this["landmarks"]["push"](qnL(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("hand_landmarks", (qgI) => {
      qnY(this, qgI);
    }), this["g"]["attachProtoVectorListener"]("world_hand_landmarks", (qgI, qgb) => {
      for (const qgR of qgI) qgI = qqe(qgR), this["worldLandmarks"]["push"](qnI(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("world_hand_landmarks", (qgI) => {
      qnY(this, qgI);
    }), this["g"]["attachProtoVectorListener"]("handedness", (qgI, qgb) => {
      var qgR, qgo, qgr, qgQ, qgd, qgv, qgy, qgl = this["handedness"], qgH = qgl["push"];
      const qgA = [];
      for (const qgh of qgI) {
        qgI = qqi(qgh);
        const qgT = [];
        for (const qgK of qgI["g"]()) qgT["push"]({ "score": (qgR = q7Y(qgK, 2)) != null ? qgR : 0, "index": (qgr = (qgo = q7V(qgK, 1)) != null ? qgo : 0) != null ? qgr : -1, "categoryName": (qgd = (qgQ = q7J(qgK, 3)) != null ? qgQ : "") != null ? qgd : "", "displayName": (qgy = (qgv = q7J(qgK, 4)) != null ? qgv : "") != null ? qgy : "" });
        qgA["push"](qgT);
      }
      qgH["call"](qgl, ...qgA), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("handedness", (qgI) => {
      qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qg1["prototype"]["detectForVideo"] = qg1["prototype"]["F"], qg1["prototype"]["detect"] = qg1["prototype"]["D"], qg1["prototype"]["setOptions"] = qg1["prototype"]["o"], qg1["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qg1, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qg1["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qg1, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qg1["createFromOptions"] = function(qgu, qgj) {
  return qpu(qg1, qgu, qgj);
}, qg1["HAND_CONNECTIONS"] = qpV;
var qg2 = qpc([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
function qg3(qgu) {
  qgu["h"] = { "faceLandmarks": [], "faceBlendshapes": [], "poseLandmarks": [], "poseWorldLandmarks": [], "poseSegmentationMasks": [], "leftHandLandmarks": [], "leftHandWorldLandmarks": [], "rightHandLandmarks": [], "rightHandWorldLandmarks": [] };
}
function qg4(qgu) {
  try {
    if (!qgu["C"]) return qgu["h"];
    qgu["C"](qgu["h"]);
  } finally {
    qp0(qgu);
  }
}
function qg5(qgu, qgj) {
  qgu = qqc(qgu), qgj["push"](qnL(qgu));
}
var qg6 = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "input_frames_image", null, false), this["h"] = { "faceLandmarks": [], "faceBlendshapes": [], "poseLandmarks": [], "poseWorldLandmarks": [], "poseSegmentationMasks": [], "leftHandLandmarks": [], "leftHandWorldLandmarks": [], "rightHandLandmarks": [], "rightHandWorldLandmarks": [] }, this["outputPoseSegmentationMasks"] = this["outputFaceBlendshapes"] = false, q7A(qgu = this["j"] = new qnS(), 0, 1, qgj = new qqH()), this["J"] = new qn7(), q7A(this["j"], 0, 2, this["J"]), this["Z"] = new qnE(), q7A(this["j"], 0, 3, this["Z"]), this["s"] = new qqT(), q7A(this["j"], 0, 4, this["s"]), this["H"] = new qqJ(), q7A(this["j"], 0, 5, this["H"]), this["v"] = new qnM(), q7A(this["j"], 0, 6, this["v"]), this["K"] = new qnf(), q7A(this["j"], 0, 7, this["K"]), q80(this["s"], 2, 0.5), q80(this["s"], 3, 0.3), q80(this["H"], 2, 0.5), q80(this["v"], 2, 0.5), q80(this["v"], 3, 0.3), q80(this["K"], 2, 0.5), q80(this["J"], 2, 0.5);
  }
  get ["baseOptions"]() {
    return q7C(this["j"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["j"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL, qgI, qgb, qgR, qgo, qgr;
    return "minFaceDetectionConfidence" in qgu && q80(this["s"], 2, (qgj = qgu["minFaceDetectionConfidence"]) != null ? qgj : 0.5), "minFaceSuppressionThreshold" in qgu && q80(this["s"], 3, (qgL = qgu["minFaceSuppressionThreshold"]) != null ? qgL : 0.3), "minFacePresenceConfidence" in qgu && q80(this["H"], 2, (qgI = qgu["minFacePresenceConfidence"]) != null ? qgI : 0.5), "outputFaceBlendshapes" in qgu && (this["outputFaceBlendshapes"] = !!qgu["outputFaceBlendshapes"]), "minPoseDetectionConfidence" in qgu && q80(this["v"], 2, (qgb = qgu["minPoseDetectionConfidence"]) != null ? qgb : 0.5), "minPoseSuppressionThreshold" in qgu && q80(this["v"], 3, (qgR = qgu["minPoseSuppressionThreshold"]) != null ? qgR : 0.3), "minPosePresenceConfidence" in qgu && q80(this["K"], 2, (qgo = qgu["minPosePresenceConfidence"]) != null ? qgo : 0.5), "outputPoseSegmentationMasks" in qgu && (this["outputPoseSegmentationMasks"] = !!qgu["outputPoseSegmentationMasks"]), "minHandLandmarksConfidence" in qgu && q80(this["J"], 2, (qgr = qgu["minHandLandmarksConfidence"]) != null ? qgr : 0.5), this["l"](qgu);
  }
  ["D"](qgu, qgj, qgL) {
    const qgI = typeof qgj != "function" ? qgj : {};
    return this["C"] = typeof qgj == "function" ? qgj : qgL, qg3(this), qpL(this, qgu, qgI), qg4(this);
  }
  ["F"](qgu, qgj, qgL, qgI) {
    const qgb = typeof qgL != "function" ? qgL : {};
    return this["C"] = typeof qgL == "function" ? qgL : qgI, qg3(this), qpI(this, qgu, qgb, qgj), qg4(this);
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "input_frames_image"), qqf(qgu, "pose_landmarks"), qqf(qgu, "pose_world_landmarks"), qqf(qgu, "face_landmarks"), qqf(qgu, "left_hand_landmarks"), qqf(qgu, "left_hand_world_landmarks"), qqf(qgu, "right_hand_landmarks"), qqf(qgu, "right_hand_world_landmarks");
    const qgj = new qq6(), qgL = new q9K();
    q7b(qgL, 1, q71("type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), ""), function(qgb, qgR) {
      if (qgR != null) {
        if (Array["isArray"](qgR)) q7e(qgb, 2, q7O(qgR));
        else {
          if (!(typeof qgR == "string" || qgR instanceof q5y || q5r(qgR))) throw Error("invalid value in Any.value field: " + qgR + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
          q7b(qgb, 2, q6s(qgR, false), q5d());
        }
      }
    }(qgL, this["j"]["g"]());
    const qgI = new qqp();
    qq9(qgI, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), q7B(qgI, 8, q9K, qgL), qqq(qgI, "IMAGE:input_frames_image"), qqn(qgI, "POSE_LANDMARKS:pose_landmarks"), qqn(qgI, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), qqn(qgI, "FACE_LANDMARKS:face_landmarks"), qqn(qgI, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), qqn(qgI, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), qqn(qgI, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), qqn(qgI, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), qgI["o"](qgj), qqE(qgu, qgI), qnP(this, qgu), this["g"]["attachProtoListener"]("pose_landmarks", (qgb, qgR) => {
      qg5(qgb, this["h"]["poseLandmarks"]), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("pose_landmarks", (qgb) => {
      qnY(this, qgb);
    }), this["g"]["attachProtoListener"]("pose_world_landmarks", (qgb, qgR) => {
      var qgo = this["h"]["poseWorldLandmarks"];
      qgb = qqe(qgb), qgo["push"](qnI(qgb)), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("pose_world_landmarks", (qgb) => {
      qnY(this, qgb);
    }), this["outputPoseSegmentationMasks"] && (qqn(qgI, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), qnU(this, "pose_segmentation_mask"), this["g"]["U"]("pose_segmentation_mask", (qgb, qgR) => {
      this["h"]["poseSegmentationMasks"] = [qpb(this, qgb, true, !this["C"])], qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("pose_segmentation_mask", (qgb) => {
      this["h"]["poseSegmentationMasks"] = [], qnY(this, qgb);
    })), this["g"]["attachProtoListener"]("face_landmarks", (qgb, qgR) => {
      qg5(qgb, this["h"]["faceLandmarks"]), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("face_landmarks", (qgb) => {
      qnY(this, qgb);
    }), this["outputFaceBlendshapes"] && (qqf(qgu, "extra_blendshapes"), qqn(qgI, "FACE_BLENDSHAPES:extra_blendshapes"), this["g"]["attachProtoListener"]("extra_blendshapes", (qgb, qgR) => {
      var qgo, qgr = this["h"]["faceBlendshapes"];
      this["outputFaceBlendshapes"] && (qgb = qqi(qgb), qgr["push"](qnu((qgo = qgb["g"]()) != null ? qgo : []))), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("extra_blendshapes", (qgb) => {
      qnY(this, qgb);
    })), this["g"]["attachProtoListener"]("left_hand_landmarks", (qgb, qgR) => {
      qg5(qgb, this["h"]["leftHandLandmarks"]), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("left_hand_landmarks", (qgb) => {
      qnY(this, qgb);
    }), this["g"]["attachProtoListener"]("left_hand_world_landmarks", (qgb, qgR) => {
      var qgo = this["h"]["leftHandWorldLandmarks"];
      qgb = qqe(qgb), qgo["push"](qnI(qgb)), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("left_hand_world_landmarks", (qgb) => {
      qnY(this, qgb);
    }), this["g"]["attachProtoListener"]("right_hand_landmarks", (qgb, qgR) => {
      qg5(qgb, this["h"]["rightHandLandmarks"]), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("right_hand_landmarks", (qgb) => {
      qnY(this, qgb);
    }), this["g"]["attachProtoListener"]("right_hand_world_landmarks", (qgb, qgR) => {
      var qgo = this["h"]["rightHandWorldLandmarks"];
      qgb = qqe(qgb), qgo["push"](qnI(qgb)), qnY(this, qgR);
    }), this["g"]["attachEmptyPacketListener"]("right_hand_world_landmarks", (qgb) => {
      qnY(this, qgb);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qg6["prototype"]["detectForVideo"] = qg6["prototype"]["F"], qg6["prototype"]["detect"] = qg6["prototype"]["D"], qg6["prototype"]["setOptions"] = qg6["prototype"]["o"], qg6["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qg6, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qg6["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qg6, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qg6["createFromOptions"] = function(qgu, qgj) {
  return qpu(qg6, qgu, qgj);
}, qg6["HAND_CONNECTIONS"] = qpV, qg6["POSE_CONNECTIONS"] = qg2, qg6["FACE_LANDMARKS_LIPS"] = qpr, qg6["FACE_LANDMARKS_LEFT_EYE"] = qpQ, qg6["FACE_LANDMARKS_LEFT_EYEBROW"] = qpd, qg6["FACE_LANDMARKS_LEFT_IRIS"] = qpv, qg6["FACE_LANDMARKS_RIGHT_EYE"] = qpy, qg6["FACE_LANDMARKS_RIGHT_EYEBROW"] = qpC, qg6["FACE_LANDMARKS_RIGHT_IRIS"] = qpl, qg6["FACE_LANDMARKS_FACE_OVAL"] = qpH, qg6["FACE_LANDMARKS_CONTOURS"] = qpA, qg6["FACE_LANDMARKS_TESSELATION"] = qph;
var qg7 = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "input_image", "norm_rect", true), this["j"] = { "classifications": [] }, q7A(qgu = this["h"] = new qnk(), 0, 1, qgj = new qqH());
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    return q7A(this["h"], 0, 2, qnN(qgu, q7C(this["h"], qqr, 2))), this["l"](qgu);
  }
  ["sa"](qgu, qgj) {
    return this["j"] = { "classifications": [] }, qpL(this, qgu, qgj), this["j"];
  }
  ["ta"](qgu, qgj, qgL) {
    return this["j"] = { "classifications": [] }, qpI(this, qgu, qgL, qgj), this["j"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "input_image"), qqM(qgu, "norm_rect"), qqf(qgu, "classifications");
    const qgj = new qq6();
    q8a(qgj, qnO, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), qqq(qgL, "IMAGE:input_image"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "CLASSIFICATIONS:classifications"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoListener"]("classifications", (qgI, qgb) => {
      this["j"] = function(qgR) {
        var qgo;
        const qgr = { "classifications": q7H(qgR, qqu, 1)["map"]((qgQ) => {
          var qgd, qgv, qgy, qgl;
          return qnu((qgv = (qgd = q7C(qgQ, qqO, 4)) == null ? void 0 : qgd["g"]()) != null ? qgv : [], (qgy = q7V(qgQ, 2)) != null ? qgy : 0, (qgl = q7J(qgQ, 3)) != null ? qgl : "");
        }) };
        return q6P(q7Z(qgR, 2)) != null && (qgr["timestampMs"] = (qgo = q6P(q7Z(qgR, 2))) != null ? qgo : 0), qgr;
      }(qqj(qgI)), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("classifications", (qgI) => {
      qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qg7["prototype"]["classifyForVideo"] = qg7["prototype"]["ta"], qg7["prototype"]["classify"] = qg7["prototype"]["sa"], qg7["prototype"]["setOptions"] = qg7["prototype"]["o"], qg7["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qg7, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qg7["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qg7, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qg7["createFromOptions"] = function(qgu, qgj) {
  return qpu(qg7, qgu, qgj);
};
var qg8 = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", true), this["h"] = new qnW(), this["embeddings"] = { "embeddings": [] }, q7A(qgu = this["h"], 0, 1, qgj = new qqH());
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj = this["h"], qgL = q7C(this["h"], qqd, 2);
    return qgL = qgL ? qgL["clone"]() : new qqd(), qgu["l2Normalize"] !== void 0 ? q7P(qgL, 1, qgu["l2Normalize"]) : "l2Normalize" in qgu && q7e(qgL, 1), qgu["quantize"] !== void 0 ? q7P(qgL, 2, qgu["quantize"]) : "quantize" in qgu && q7e(qgL, 2), q7A(qgj, 0, 2, qgL), this["l"](qgu);
  }
  ["za"](qgu, qgj) {
    return qpL(this, qgu, qgj), this["embeddings"];
  }
  ["Aa"](qgu, qgj, qgL) {
    return qpI(this, qgu, qgL, qgj), this["embeddings"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect"), qqf(qgu, "embeddings_out");
    const qgj = new qq6();
    q8a(qgj, qni, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "EMBEDDINGS:embeddings_out"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoListener"]("embeddings_out", (qgI, qgb) => {
      qgI = qqo(qgI), this["embeddings"] = function(qgR) {
        var qgo;
        return { "embeddings": q7H(qgR, qqb, 1)["map"]((qgr) => {
          var qgQ, qgd, qgv, qgy, qgl, qgH, qgA;
          const qgh = { "headIndex": (qgd = (qgQ = q7V(qgr, 3)) != null ? qgQ : 0) != null ? qgd : -1, "headName": (qgy = (qgv = q7J(qgr, 4)) != null ? qgv : "") != null ? qgy : "" };
          if (q7y(qgr, qqL, q7o(qgr, 1)) !== void 0) qgr = q7N(qgr = q7C(qgr, qqL, q7o(qgr, 1)), 1, q6H, q7G()), qgh["floatEmbedding"] = qgr["slice"]();
          else {
            const qgT = new Uint8Array(0);
            qgh["quantizedEmbedding"] = (qgA = (qgH = (qgl = q7C(qgr, qqI, q7o(qgr, 2))) == null ? void 0 : qgl["oa"]()) == null ? void 0 : qgH["h"]()) != null ? qgA : qgT;
          }
          return qgh;
        }), "timestampMs": (qgo = q6P(q7Z(qgR, 2))) != null ? qgo : 0 };
      }(qgI), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("embeddings_out", (qgI) => {
      qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qg8["cosineSimilarity"] = function(qgu, qgj) {
  if (qgu["floatEmbedding"] && qgj["floatEmbedding"]) qgu = qnR(qgu["floatEmbedding"], qgj["floatEmbedding"]);
  else {
    if (!qgu["quantizedEmbedding"] || !qgj["quantizedEmbedding"]) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
    qgu = qnR(qnb(qgu["quantizedEmbedding"]), qnb(qgj["quantizedEmbedding"]));
  }
  return qgu;
}, qg8["prototype"]["embedForVideo"] = qg8["prototype"]["Aa"], qg8["prototype"]["embed"] = qg8["prototype"]["za"], qg8["prototype"]["setOptions"] = qg8["prototype"]["o"], qg8["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qg8, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qg8["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qg8, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qg8["createFromOptions"] = function(qgu, qgj) {
  return qpu(qg8, qgu, qgj);
};
var qg9 = class {
  constructor(qgu, qgj, qgL) {
    this["confidenceMasks"] = qgu, this["categoryMask"] = qgj, this["qualityScores"] = qgL;
  }
  ["close"]() {
    var qgu, qgj;
    (qgu = this["confidenceMasks"]) == null || qgu["forEach"]((qgL) => {
      qgL["close"]();
    }), (qgj = this["categoryMask"]) == null || qgj["close"]();
  }
};
function qgq(qgu) {
  qgu["categoryMask"] = void 0, qgu["confidenceMasks"] = void 0, qgu["qualityScores"] = void 0;
}
function qgn(qgu) {
  try {
    const qgj = new qg9(qgu["confidenceMasks"], qgu["categoryMask"], qgu["qualityScores"]);
    if (!qgu["j"]) return qgj;
    qgu["j"](qgj);
  } finally {
    qp0(qgu);
  }
}
qg9["prototype"]["close"] = qg9["prototype"]["close"];
var qgp = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", false), this["s"] = [], this["outputCategoryMask"] = false, this["outputConfidenceMasks"] = true, this["h"] = new qnw(), this["v"] = new qnD(), q7A(this["h"], 0, 3, this["v"]), q7A(qgu = this["h"], 0, 1, qgj = new qqH());
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL;
    return qgu["displayNamesLocale"] !== void 0 ? q7e(this["h"], 2, q71(qgu["displayNamesLocale"])) : "displayNamesLocale" in qgu && q7e(this["h"], 2), "outputCategoryMask" in qgu && (this["outputCategoryMask"] = (qgj = qgu["outputCategoryMask"]) != null ? qgj : false), "outputConfidenceMasks" in qgu && (this["outputConfidenceMasks"] = (qgL = qgu["outputConfidenceMasks"]) != null ? qgL : true), super["l"](qgu);
  }
  ["I"]() {
    (function(qgu) {
      var qgj, qgL, qgI;
      const qgb = q7H(qgu["da"](), qqp, 1)["filter"]((qgR) => {
        var qgo;
        return ((qgo = q7J(qgR, 1)) != null ? qgo : "")["includes"]("mediapipe.tasks.TensorsToSegmentationCalculator");
      });
      if (qgu["s"] = [], qgb["length"] > 1) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
      qgb["length"] === 1 && ((qgI = (qgL = (qgj = q7C(qgb[0], qq6, 7)) == null ? void 0 : qgj["l"]()) == null ? void 0 : qgL["g"]()) != null ? qgI : /* @__PURE__ */ new Map())["forEach"]((qgR, qgo) => {
        var qgr;
        qgu["s"][Number(qgo)] = (qgr = q7J(qgR, 1)) != null ? qgr : "";
      });
    })(this);
  }
  ["segment"](qgu, qgj, qgL) {
    const qgI = typeof qgj != "function" ? qgj : {};
    return this["j"] = typeof qgj == "function" ? qgj : qgL, qgq(this), qpL(this, qgu, qgI), qgn(this);
  }
  ["Ma"](qgu, qgj, qgL, qgI) {
    const qgb = typeof qgL != "function" ? qgL : {};
    return this["j"] = typeof qgL == "function" ? qgL : qgI, qgq(this), qpI(this, qgu, qgb, qgj), qgn(this);
  }
  ["Da"]() {
    return this["s"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect");
    const qgj = new qq6();
    q8a(qgj, qne, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qgL["o"](qgj), qqE(qgu, qgL), qnP(this, qgu), this["outputConfidenceMasks"] && (qqf(qgu, "confidence_masks"), qqn(qgL, "CONFIDENCE_MASKS:confidence_masks"), qnU(this, "confidence_masks"), this["g"]["ca"]("confidence_masks", (qgI, qgb) => {
      this["confidenceMasks"] = qgI["map"]((qgR) => qpb(this, qgR, true, !this["j"])), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("confidence_masks", (qgI) => {
      this["confidenceMasks"] = [], qnY(this, qgI);
    })), this["outputCategoryMask"] && (qqf(qgu, "category_mask"), qqn(qgL, "CATEGORY_MASK:category_mask"), qnU(this, "category_mask"), this["g"]["U"]("category_mask", (qgI, qgb) => {
      this["categoryMask"] = qpb(this, qgI, false, !this["j"]), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("category_mask", (qgI) => {
      this["categoryMask"] = void 0, qnY(this, qgI);
    })), qqf(qgu, "quality_scores"), qqn(qgL, "QUALITY_SCORES:quality_scores"), this["g"]["attachFloatVectorListener"]("quality_scores", (qgI, qgb) => {
      this["qualityScores"] = qgI, qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("quality_scores", (qgI) => {
      this["categoryMask"] = void 0, qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qgp["prototype"]["getLabels"] = qgp["prototype"]["Da"], qgp["prototype"]["segmentForVideo"] = qgp["prototype"]["Ma"], qgp["prototype"]["segment"] = qgp["prototype"]["segment"], qgp["prototype"]["setOptions"] = qgp["prototype"]["o"], qgp["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qgp, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qgp["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qgp, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qgp["createFromOptions"] = function(qgu, qgj) {
  return qpu(qgp, qgu, qgj);
};
var qgg = class {
  constructor(qgu, qgj, qgL) {
    this["confidenceMasks"] = qgu, this["categoryMask"] = qgj, this["qualityScores"] = qgL;
  }
  ["close"]() {
    var qgu, qgj;
    (qgu = this["confidenceMasks"]) == null || qgu["forEach"]((qgL) => {
      qgL["close"]();
    }), (qgj = this["categoryMask"]) == null || qgj["close"]();
  }
};
qgg["prototype"]["close"] = qgg["prototype"]["close"];
var qgx = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qgs = [0, q9u, -2];
var qgE = [0, q9w, -3, q9I, q9w, -1];
var qgM = [0, qgE];
var qgf = [0, qgE, q9u, -1];
var qgS = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qgF = [0, q9w, -1, q9I];
var qgt = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qgk = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
var qgO = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 14, 15];
var qgW = class extends q8Z {
  constructor(qgu) {
    super(qgu);
  }
};
qgW["prototype"]["g"] = q9T([0, q9Q, [0, qgO, q9d, qgE, q9d, [0, qgE, qgs], q9d, qgM, q9d, [0, qgM, qgs], q9d, qgF, q9d, [0, q9w, -3, q9I, q9l], q9d, [0, q9w, -3, q9I], q9d, [0, q9r, q9w, -2, q9I, q9u, q9I, -1, 2, q9w, qgs], q9d, qgf, q9d, [0, qgf, qgs], q9w, qgs, q9r, q9d, [0, q9w, -3, q9I, qgs, -1], q9d, [0, q9Q, qgF]], q9r, [0, q9r, q9u, -1, q9I]]);
var qgi = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect_in", false), this["outputCategoryMask"] = false, this["outputConfidenceMasks"] = true, this["h"] = new qnw(), this["s"] = new qnD(), q7A(this["h"], 0, 3, this["s"]), q7A(qgu = this["h"], 0, 1, qgj = new qqH());
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL;
    return "outputCategoryMask" in qgu && (this["outputCategoryMask"] = (qgj = qgu["outputCategoryMask"]) != null ? qgj : false), "outputConfidenceMasks" in qgu && (this["outputConfidenceMasks"] = (qgL = qgu["outputConfidenceMasks"]) != null ? qgL : true), super["l"](qgu);
  }
  ["segment"](qgu, qgj, qgL, qgI) {
    const qgb = typeof qgL != "function" ? qgL : {};
    this["j"] = typeof qgL == "function" ? qgL : qgI, this["qualityScores"] = this["categoryMask"] = this["confidenceMasks"] = void 0, qgL = this["B"] + 1, qgI = new qgW();
    const qgR = new qgk();
    var qgo = new qgx();
    if (q7U(qgo, 1, 255), q7A(qgR, 0, 12, qgo), qgj["keypoint"] && qgj["scribble"]) throw Error("Cannot provide both keypoint and scribble.");
    if (qgj["keypoint"]) {
      var qgr = new qgS();
      q7P(qgr, 3, true), q80(qgr, 1, qgj["keypoint"]["x"]), q80(qgr, 2, qgj["keypoint"]["y"]), q7h(qgR, 5, qgO, qgr);
    } else {
      if (!qgj["scribble"]) throw Error("Must provide either a keypoint or a scribble.");
      for (qgr of (qgo = new qgt(), qgj["scribble"])) q7P(qgj = new qgS(), 3, true), q80(qgj, 1, qgr["x"]), q80(qgj, 2, qgr["y"]), q7B(qgo, 1, qgS, qgj);
      q7h(qgR, 15, qgO, qgo);
    }
    q7B(qgI, 1, qgk, qgR), this["g"]["addProtoToStream"](qgI["g"](), "drishti.RenderData", "roi_in", qgL), qpL(this, qgu, qgb);
    qgv: {
      try {
        const qgd = new qgg(this["confidenceMasks"], this["categoryMask"], this["qualityScores"]);
        if (!this["j"]) {
          var qgQ = qgd;
          break qgv;
        }
        this["j"](qgd);
      } finally {
        qp0(this);
      }
      qgQ = void 0;
    }
    return qgQ;
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "roi_in"), qqM(qgu, "norm_rect_in");
    const qgj = new qq6();
    q8a(qgj, qne, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "ROI:roi_in"), qqq(qgL, "NORM_RECT:norm_rect_in"), qgL["o"](qgj), qqE(qgu, qgL), qnP(this, qgu), this["outputConfidenceMasks"] && (qqf(qgu, "confidence_masks"), qqn(qgL, "CONFIDENCE_MASKS:confidence_masks"), qnU(this, "confidence_masks"), this["g"]["ca"]("confidence_masks", (qgI, qgb) => {
      this["confidenceMasks"] = qgI["map"]((qgR) => qpb(this, qgR, true, !this["j"])), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("confidence_masks", (qgI) => {
      this["confidenceMasks"] = [], qnY(this, qgI);
    })), this["outputCategoryMask"] && (qqf(qgu, "category_mask"), qqn(qgL, "CATEGORY_MASK:category_mask"), qnU(this, "category_mask"), this["g"]["U"]("category_mask", (qgI, qgb) => {
      this["categoryMask"] = qpb(this, qgI, false, !this["j"]), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("category_mask", (qgI) => {
      this["categoryMask"] = void 0, qnY(this, qgI);
    })), qqf(qgu, "quality_scores"), qqn(qgL, "QUALITY_SCORES:quality_scores"), this["g"]["attachFloatVectorListener"]("quality_scores", (qgI, qgb) => {
      this["qualityScores"] = qgI, qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("quality_scores", (qgI) => {
      this["categoryMask"] = void 0, qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qgi["prototype"]["segment"] = qgi["prototype"]["segment"], qgi["prototype"]["setOptions"] = qgi["prototype"]["o"], qgi["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qgi, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qgi["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qgi, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qgi["createFromOptions"] = function(qgu, qgj) {
  return qpu(qgi, qgu, qgj);
};
var qgD = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "input_frame_gpu", "norm_rect", false), this["j"] = { "detections": [] }, q7A(qgu = this["h"] = new qnz(), 0, 1, qgj = new qqH());
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    return qgu["displayNamesLocale"] !== void 0 ? q7e(this["h"], 2, q71(qgu["displayNamesLocale"])) : "displayNamesLocale" in qgu && q7e(this["h"], 2), qgu["maxResults"] !== void 0 ? q7U(this["h"], 3, qgu["maxResults"]) : "maxResults" in qgu && q7e(this["h"], 3), qgu["scoreThreshold"] !== void 0 ? q80(this["h"], 4, qgu["scoreThreshold"]) : "scoreThreshold" in qgu && q7e(this["h"], 4), qgu["categoryAllowlist"] !== void 0 ? q81(this["h"], 5, qgu["categoryAllowlist"]) : "categoryAllowlist" in qgu && q7e(this["h"], 5), qgu["categoryDenylist"] !== void 0 ? q81(this["h"], 6, qgu["categoryDenylist"]) : "categoryDenylist" in qgu && q7e(this["h"], 6), this["l"](qgu);
  }
  ["D"](qgu, qgj) {
    return this["j"] = { "detections": [] }, qpL(this, qgu, qgj), this["j"];
  }
  ["F"](qgu, qgj, qgL) {
    return this["j"] = { "detections": [] }, qpI(this, qgu, qgL, qgj), this["j"];
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "input_frame_gpu"), qqM(qgu, "norm_rect"), qqf(qgu, "detections");
    const qgj = new qq6();
    q8a(qgj, qnc, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.ObjectDetectorGraph"), qqq(qgL, "IMAGE:input_frame_gpu"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "DETECTIONS:detections"), qgL["o"](qgj), qqE(qgu, qgL), this["g"]["attachProtoVectorListener"]("detections", (qgI, qgb) => {
      for (const qgR of qgI) qgI = qqZ(qgR), this["j"]["detections"]["push"](qnj(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("detections", (qgI) => {
      qnY(this, qgI);
    }), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qgD["prototype"]["detectForVideo"] = qgD["prototype"]["F"], qgD["prototype"]["detect"] = qgD["prototype"]["D"], qgD["prototype"]["setOptions"] = qgD["prototype"]["o"], qgD["createFromModelPath"] = async function(qgu, qgj) {
  return qpu(qgD, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qgD["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qgD, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qgD["createFromOptions"] = function(qgu, qgj) {
  return qpu(qgD, qgu, qgj);
};
var qgm = class {
  constructor(qgu, qgj, qgL) {
    this["landmarks"] = qgu, this["worldLandmarks"] = qgj, this["segmentationMasks"] = qgL;
  }
  ["close"]() {
    var qgu;
    (qgu = this["segmentationMasks"]) == null || qgu["forEach"]((qgj) => {
      qgj["close"]();
    });
  }
};
function qga(qgu) {
  qgu["landmarks"] = [], qgu["worldLandmarks"] = [], qgu["segmentationMasks"] = void 0;
}
function qgZ(qgu) {
  try {
    const qgj = new qgm(qgu["landmarks"], qgu["worldLandmarks"], qgu["segmentationMasks"]);
    if (!qgu["s"]) return qgj;
    qgu["s"](qgj);
  } finally {
    qp0(qgu);
  }
}
qgm["prototype"]["close"] = qgm["prototype"]["close"];
var qgw = class extends qpR {
  constructor(qgu, qgj) {
    super(new qpN(qgu, qgj), "image_in", "norm_rect", false), this["landmarks"] = [], this["worldLandmarks"] = [], this["outputSegmentationMasks"] = false, q7A(qgu = this["h"] = new qnX(), 0, 1, qgj = new qqH()), this["v"] = new qnf(), q7A(this["h"], 0, 3, this["v"]), this["j"] = new qnM(), q7A(this["h"], 0, 2, this["j"]), q7U(this["j"], 4, 1), q80(this["j"], 2, 0.5), q80(this["v"], 2, 0.5), q80(this["h"], 4, 0.5);
  }
  get ["baseOptions"]() {
    return q7C(this["h"], qqH, 1);
  }
  set ["baseOptions"](qgu) {
    q7A(this["h"], 0, 1, qgu);
  }
  ["o"](qgu) {
    var qgj, qgL, qgI, qgb, qgR;
    return "numPoses" in qgu && q7U(this["j"], 4, (qgj = qgu["numPoses"]) != null ? qgj : 1), "minPoseDetectionConfidence" in qgu && q80(this["j"], 2, (qgL = qgu["minPoseDetectionConfidence"]) != null ? qgL : 0.5), "minTrackingConfidence" in qgu && q80(this["h"], 4, (qgI = qgu["minTrackingConfidence"]) != null ? qgI : 0.5), "minPosePresenceConfidence" in qgu && q80(this["v"], 2, (qgb = qgu["minPosePresenceConfidence"]) != null ? qgb : 0.5), "outputSegmentationMasks" in qgu && (this["outputSegmentationMasks"] = (qgR = qgu["outputSegmentationMasks"]) != null ? qgR : false), this["l"](qgu);
  }
  ["D"](qgu, qgj, qgL) {
    const qgI = typeof qgj != "function" ? qgj : {};
    return this["s"] = typeof qgj == "function" ? qgj : qgL, qga(this), qpL(this, qgu, qgI), qgZ(this);
  }
  ["F"](qgu, qgj, qgL, qgI) {
    const qgb = typeof qgL != "function" ? qgL : {};
    return this["s"] = typeof qgL == "function" ? qgL : qgI, qga(this), qpI(this, qgu, qgb, qgj), qgZ(this);
  }
  ["m"]() {
    var qgu = new qqS();
    qqM(qgu, "image_in"), qqM(qgu, "norm_rect"), qqf(qgu, "normalized_landmarks"), qqf(qgu, "world_landmarks"), qqf(qgu, "segmentation_masks");
    const qgj = new qq6();
    q8a(qgj, qnG, this["h"]);
    const qgL = new qqp();
    qq9(qgL, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), qqq(qgL, "IMAGE:image_in"), qqq(qgL, "NORM_RECT:norm_rect"), qqn(qgL, "NORM_LANDMARKS:normalized_landmarks"), qqn(qgL, "WORLD_LANDMARKS:world_landmarks"), qgL["o"](qgj), qqE(qgu, qgL), qnP(this, qgu), this["g"]["attachProtoVectorListener"]("normalized_landmarks", (qgI, qgb) => {
      this["landmarks"] = [];
      for (const qgR of qgI) qgI = qqc(qgR), this["landmarks"]["push"](qnL(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("normalized_landmarks", (qgI) => {
      this["landmarks"] = [], qnY(this, qgI);
    }), this["g"]["attachProtoVectorListener"]("world_landmarks", (qgI, qgb) => {
      this["worldLandmarks"] = [];
      for (const qgR of qgI) qgI = qqe(qgR), this["worldLandmarks"]["push"](qnI(qgI));
      qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("world_landmarks", (qgI) => {
      this["worldLandmarks"] = [], qnY(this, qgI);
    }), this["outputSegmentationMasks"] && (qqn(qgL, "SEGMENTATION_MASK:segmentation_masks"), qnU(this, "segmentation_masks"), this["g"]["ca"]("segmentation_masks", (qgI, qgb) => {
      this["segmentationMasks"] = qgI["map"]((qgR) => qpb(this, qgR, true, !this["s"])), qnY(this, qgb);
    }), this["g"]["attachEmptyPacketListener"]("segmentation_masks", (qgI) => {
      this["segmentationMasks"] = [], qnY(this, qgI);
    })), qgu = qgu["g"](), this["setGraph"](new Uint8Array(qgu), true);
  }
};
qgw["prototype"]["detectForVideo"] = qgw["prototype"]["F"], qgw["prototype"]["detect"] = qgw["prototype"]["D"], qgw["prototype"]["setOptions"] = qgw["prototype"]["o"], qgw["createFromModelPath"] = function(qgu, qgj) {
  return qpu(qgw, qgu, { "baseOptions": { "modelAssetPath": qgj } });
}, qgw["createFromModelBuffer"] = function(qgu, qgj) {
  return qpu(qgw, qgu, { "baseOptions": { "modelAssetBuffer": qgj } });
}, qgw["createFromOptions"] = function(qgu, qgj) {
  return qpu(qgw, qgu, qgj);
}, qgw["POSE_CONNECTIONS"] = qg2;
var qge = class {
  async ["process"](qgu, qgj) {
    var qgL;
    const qgI = (qgL = this["segmenter"]) == null ? void 0 : qgL["process"](qgu, qgj);
    return qgI ? [qgI] : [];
  }
  async ["init"](qgu, qgj = "./", qgL = false, qgI = false) {
    const qgb = await jB(qgu, qgj, qgL), qgR = new qgb["ParseLoader"](qgj), qgo = await qnv["isSimdSupported"]() ? "" : "lp", qgr = "hair" + qgo + ".wasm";
    if (qgL || await qgR["remove"](qgr), !await qgR["loadDict"]([qgr]) || !await qgR["load"](qgr) || !qgR["parse"]()) return;
    window["dbg"] = () => {
    };
    const qgQ = "hairmodel" + qgo, qgd = URL["createObjectURL"](new Blob([qgR["file"](qgQ + ".wasm")], { "type": "application/wasm" })), qgv = URL["createObjectURL"](new Blob([qgR["file"](qgQ + ".js")])), qgy = URL["createObjectURL"](new Blob([qgR["file"]("hairmodel.tflite")])), qgl = await qgp["createFromOptions"]({ "wasmLoaderPath": qgv, "wasmBinaryPath": qgd }, { "baseOptions": { "modelAssetPath": qgy, "delegate": "GPU" }, "runningMode": qgI ? "VIDEO" : "IMAGE" });
    this["segmenter"] = new q59(qgl, qgI);
  }
  ["reset"]() {
    var qgu;
    (qgu = this["segmenter"]) == null || qgu["reset"]();
  }
  async ["prepare"]() {
    var qgu;
    await ((qgu = this["segmenter"]) == null ? void 0 : qgu["prepare"]());
  }
  ["dispose"]() {
    var qgu;
    (qgu = this["segmenter"]) == null || qgu["dispose"](), delete this["segmenter"];
  }
};
var qgc = [127, 34, 139, 11, 0, 37, 232, 231, 120, 72, 37, 39, 128, 121, 47, 232, 121, 128, 104, 69, 67, 175, 171, 148, 157, 154, 155, 118, 50, 101, 73, 39, 40, 9, 151, 108, 48, 115, 131, 194, 204, 211, 74, 40, 185, 80, 42, 183, 40, 92, 186, 230, 229, 118, 202, 212, 214, 83, 18, 17, 76, 61, 146, 160, 29, 30, 56, 157, 173, 106, 204, 194, 135, 214, 192, 203, 165, 98, 21, 71, 68, 51, 45, 4, 144, 24, 23, 77, 146, 91, 205, 50, 187, 201, 200, 18, 91, 106, 182, 90, 91, 181, 85, 84, 17, 206, 203, 36, 148, 171, 140, 92, 40, 39, 193, 189, 244, 159, 158, 28, 247, 246, 161, 236, 3, 196, 54, 68, 104, 193, 168, 8, 117, 228, 31, 189, 193, 55, 98, 97, 99, 126, 47, 100, 166, 79, 218, 155, 154, 26, 209, 49, 131, 135, 136, 150, 47, 126, 217, 223, 52, 53, 45, 51, 134, 211, 170, 140, 67, 69, 108, 43, 106, 91, 230, 119, 120, 226, 130, 247, 63, 53, 52, 238, 20, 242, 46, 70, 156, 78, 62, 96, 46, 53, 63, 143, 34, 227, 173, 155, 133, 123, 117, 111, 44, 125, 19, 236, 134, 51, 216, 206, 205, 154, 153, 22, 39, 37, 167, 200, 201, 208, 36, 142, 100, 57, 212, 202, 20, 60, 99, 28, 158, 157, 35, 226, 113, 160, 159, 27, 204, 202, 210, 113, 225, 46, 43, 202, 204, 62, 76, 77, 137, 123, 116, 41, 38, 72, 203, 129, 142, 64, 98, 240, 49, 102, 64, 41, 73, 74, 212, 216, 207, 42, 74, 184, 169, 170, 211, 170, 149, 176, 105, 66, 69, 122, 6, 168, 123, 147, 187, 96, 77, 90, 65, 55, 107, 89, 90, 180, 101, 100, 120, 63, 105, 104, 93, 137, 227, 15, 86, 85, 129, 102, 49, 14, 87, 86, 55, 8, 9, 100, 47, 121, 145, 23, 22, 88, 89, 179, 6, 122, 196, 88, 95, 96, 138, 172, 136, 215, 58, 172, 115, 48, 219, 42, 80, 81, 195, 3, 51, 43, 146, 61, 171, 175, 199, 81, 82, 38, 53, 46, 225, 144, 163, 110, 246, 33, 7, 52, 65, 66, 229, 228, 117, 34, 127, 234, 107, 108, 69, 109, 108, 151, 48, 64, 235, 62, 78, 191, 129, 209, 126, 111, 35, 143, 163, 161, 246, 117, 123, 50, 222, 65, 52, 19, 125, 141, 221, 55, 65, 3, 195, 197, 25, 7, 33, 220, 237, 44, 70, 71, 139, 122, 193, 245, 247, 130, 33, 71, 21, 162, 153, 158, 159, 170, 169, 150, 188, 174, 196, 216, 186, 92, 144, 160, 161, 2, 97, 167, 141, 125, 241, 164, 167, 37, 72, 38, 12, 145, 159, 160, 38, 82, 13, 63, 68, 71, 226, 35, 111, 158, 153, 154, 101, 50, 205, 206, 92, 165, 209, 198, 217, 165, 167, 97, 220, 115, 218, 133, 112, 243, 239, 238, 241, 214, 135, 169, 190, 173, 133, 171, 208, 32, 125, 44, 237, 86, 87, 178, 85, 86, 179, 84, 85, 180, 83, 84, 181, 201, 83, 182, 137, 93, 132, 76, 62, 183, 61, 76, 184, 57, 61, 185, 212, 57, 186, 214, 207, 187, 34, 143, 156, 79, 239, 237, 123, 137, 177, 44, 1, 4, 201, 194, 32, 64, 102, 129, 213, 215, 138, 59, 166, 219, 242, 99, 97, 2, 94, 141, 75, 59, 235, 24, 110, 228, 25, 130, 226, 23, 24, 229, 22, 23, 230, 26, 22, 231, 112, 26, 232, 189, 190, 243, 221, 56, 190, 28, 56, 221, 27, 28, 222, 29, 27, 223, 30, 29, 224, 247, 30, 225, 238, 79, 20, 166, 59, 75, 60, 75, 240, 147, 177, 215, 20, 79, 166, 187, 147, 213, 112, 233, 244, 233, 128, 245, 128, 114, 188, 114, 217, 174, 131, 115, 220, 217, 198, 236, 198, 131, 134, 177, 132, 58, 143, 35, 124, 110, 163, 7, 228, 110, 25, 356, 389, 368, 11, 302, 267, 452, 350, 349, 302, 303, 269, 357, 343, 277, 452, 453, 357, 333, 332, 297, 175, 152, 377, 384, 398, 382, 347, 348, 330, 303, 304, 270, 9, 336, 337, 278, 279, 360, 418, 262, 431, 304, 408, 409, 310, 415, 407, 270, 409, 410, 450, 348, 347, 422, 430, 434, 313, 314, 17, 306, 307, 375, 387, 388, 260, 286, 414, 398, 335, 406, 418, 364, 367, 416, 423, 358, 327, 251, 284, 298, 281, 5, 4, 373, 374, 253, 307, 320, 321, 425, 427, 411, 421, 313, 18, 321, 405, 406, 320, 404, 405, 315, 16, 17, 426, 425, 266, 377, 400, 369, 322, 391, 269, 417, 465, 464, 386, 257, 258, 466, 260, 388, 456, 399, 419, 284, 332, 333, 417, 285, 8, 346, 340, 261, 413, 441, 285, 327, 460, 328, 355, 371, 329, 392, 439, 438, 382, 341, 256, 429, 420, 360, 364, 394, 379, 277, 343, 437, 443, 444, 283, 275, 440, 363, 431, 262, 369, 297, 338, 337, 273, 375, 321, 450, 451, 349, 446, 342, 467, 293, 334, 282, 458, 461, 462, 276, 353, 383, 308, 324, 325, 276, 300, 293, 372, 345, 447, 382, 398, 362, 352, 345, 340, 274, 1, 19, 456, 248, 281, 436, 427, 425, 381, 256, 252, 269, 391, 393, 200, 199, 428, 266, 330, 329, 287, 273, 422, 250, 462, 328, 258, 286, 384, 265, 353, 342, 387, 259, 257, 424, 431, 430, 342, 353, 276, 273, 335, 424, 292, 325, 307, 366, 447, 345, 271, 303, 302, 423, 266, 371, 294, 455, 460, 279, 278, 294, 271, 272, 304, 432, 434, 427, 272, 407, 408, 394, 430, 431, 395, 369, 400, 334, 333, 299, 351, 417, 168, 352, 280, 411, 325, 319, 320, 295, 296, 336, 319, 403, 404, 330, 348, 349, 293, 298, 333, 323, 454, 447, 15, 16, 315, 358, 429, 279, 14, 15, 316, 285, 336, 9, 329, 349, 350, 374, 380, 252, 318, 402, 403, 6, 197, 419, 318, 319, 325, 367, 364, 365, 435, 367, 397, 344, 438, 439, 272, 271, 311, 195, 5, 281, 273, 287, 291, 396, 428, 199, 311, 271, 268, 283, 444, 445, 373, 254, 339, 263, 466, 249, 282, 334, 296, 449, 347, 346, 264, 447, 454, 336, 296, 299, 338, 10, 151, 278, 439, 455, 292, 407, 415, 358, 371, 355, 340, 345, 372, 390, 249, 466, 346, 347, 280, 442, 443, 282, 19, 94, 370, 441, 442, 295, 248, 419, 197, 263, 255, 359, 440, 275, 274, 300, 383, 368, 351, 412, 465, 263, 467, 466, 301, 368, 389, 380, 374, 386, 395, 378, 379, 412, 351, 419, 436, 426, 322, 373, 390, 388, 2, 164, 393, 370, 462, 461, 164, 0, 267, 302, 11, 12, 374, 373, 387, 268, 12, 13, 293, 300, 301, 446, 261, 340, 385, 384, 381, 330, 266, 425, 426, 423, 391, 429, 355, 437, 391, 327, 326, 440, 457, 438, 341, 382, 362, 459, 457, 461, 434, 430, 394, 414, 463, 362, 396, 369, 262, 354, 461, 457, 316, 403, 402, 315, 404, 403, 314, 405, 404, 313, 406, 405, 421, 418, 406, 366, 401, 361, 306, 408, 407, 291, 409, 408, 287, 410, 409, 432, 436, 410, 434, 416, 411, 264, 368, 383, 309, 438, 457, 352, 376, 401, 274, 275, 4, 421, 428, 262, 294, 327, 358, 433, 416, 367, 289, 455, 439, 462, 370, 326, 2, 326, 370, 305, 460, 455, 254, 449, 448, 255, 261, 446, 253, 450, 449, 252, 451, 450, 256, 452, 451, 341, 453, 452, 413, 464, 463, 441, 413, 414, 258, 442, 441, 257, 443, 442, 259, 444, 443, 260, 445, 444, 467, 342, 445, 459, 458, 250, 289, 392, 290, 290, 328, 460, 376, 433, 435, 250, 290, 392, 411, 416, 433, 341, 463, 464, 453, 464, 465, 357, 465, 412, 343, 412, 399, 360, 363, 440, 437, 399, 456, 420, 456, 363, 401, 435, 288, 372, 383, 353, 339, 255, 249, 448, 261, 255, 133, 243, 190, 133, 155, 112, 33, 246, 247, 33, 130, 25, 398, 384, 286, 362, 398, 414, 362, 463, 341, 263, 359, 467, 263, 249, 255, 466, 467, 260, 75, 60, 166, 238, 239, 79, 162, 127, 139, 72, 11, 37, 121, 232, 120, 73, 72, 39, 114, 128, 47, 233, 232, 128, 103, 104, 67, 152, 175, 148, 173, 157, 155, 119, 118, 101, 74, 73, 40, 107, 9, 108, 49, 48, 131, 32, 194, 211, 184, 74, 185, 191, 80, 183, 185, 40, 186, 119, 230, 118, 210, 202, 214, 84, 83, 17, 77, 76, 146, 161, 160, 30, 190, 56, 173, 182, 106, 194, 138, 135, 192, 129, 203, 98, 54, 21, 68, 5, 51, 4, 145, 144, 23, 90, 77, 91, 207, 205, 187, 83, 201, 18, 181, 91, 182, 180, 90, 181, 16, 85, 17, 205, 206, 36, 176, 148, 140, 165, 92, 39, 245, 193, 244, 27, 159, 28, 30, 247, 161, 174, 236, 196, 103, 54, 104, 55, 193, 8, 111, 117, 31, 221, 189, 55, 240, 98, 99, 142, 126, 100, 219, 166, 218, 112, 155, 26, 198, 209, 131, 169, 135, 150, 114, 47, 217, 224, 223, 53, 220, 45, 134, 32, 211, 140, 109, 67, 108, 146, 43, 91, 231, 230, 120, 113, 226, 247, 105, 63, 52, 241, 238, 242, 124, 46, 156, 95, 78, 96, 70, 46, 63, 116, 143, 227, 116, 123, 111, 1, 44, 19, 3, 236, 51, 207, 216, 205, 26, 154, 22, 165, 39, 167, 199, 200, 208, 101, 36, 100, 43, 57, 202, 242, 20, 99, 56, 28, 157, 124, 35, 113, 29, 160, 27, 211, 204, 210, 124, 113, 46, 106, 43, 204, 96, 62, 77, 227, 137, 116, 73, 41, 72, 36, 203, 142, 235, 64, 240, 48, 49, 64, 42, 41, 74, 214, 212, 207, 183, 42, 184, 210, 169, 211, 140, 170, 176, 104, 105, 69, 193, 122, 168, 50, 123, 187, 89, 96, 90, 66, 65, 107, 179, 89, 180, 119, 101, 120, 68, 63, 104, 234, 93, 227, 16, 15, 85, 209, 129, 49, 15, 14, 86, 107, 55, 9, 120, 100, 121, 153, 145, 22, 178, 88, 179, 197, 6, 196, 89, 88, 96, 135, 138, 136, 138, 215, 172, 218, 115, 219, 41, 42, 81, 5, 195, 51, 57, 43, 61, 208, 171, 199, 41, 81, 38, 224, 53, 225, 24, 144, 110, 105, 52, 66, 118, 229, 117, 227, 34, 234, 66, 107, 69, 10, 109, 151, 219, 48, 235, 183, 62, 191, 142, 129, 126, 116, 111, 143, 7, 163, 246, 118, 117, 50, 223, 222, 52, 94, 19, 141, 222, 221, 65, 196, 3, 197, 45, 220, 44, 156, 70, 139, 188, 122, 245, 139, 71, 162, 145, 153, 159, 149, 170, 150, 122, 188, 196, 206, 216, 92, 163, 144, 161, 164, 2, 167, 242, 141, 241, 0, 164, 37, 11, 72, 12, 144, 145, 160, 12, 38, 13, 70, 63, 71, 31, 226, 111, 157, 158, 154, 36, 101, 205, 203, 206, 165, 126, 209, 217, 98, 165, 97, 237, 220, 218, 237, 239, 241, 210, 214, 169, 140, 171, 32, 241, 125, 237, 179, 86, 178, 180, 85, 179, 181, 84, 180, 182, 83, 181, 194, 201, 182, 177, 137, 132, 184, 76, 183, 185, 61, 184, 186, 57, 185, 216, 212, 186, 192, 214, 187, 139, 34, 156, 218, 79, 237, 147, 123, 177, 45, 44, 4, 208, 201, 32, 98, 64, 129, 192, 213, 138, 235, 59, 219, 141, 242, 97, 97, 2, 141, 240, 75, 235, 229, 24, 228, 31, 25, 226, 230, 23, 229, 231, 22, 230, 232, 26, 231, 233, 112, 232, 244, 189, 243, 189, 221, 190, 222, 28, 221, 223, 27, 222, 224, 29, 223, 225, 30, 224, 113, 247, 225, 99, 60, 240, 213, 147, 215, 60, 20, 166, 192, 187, 213, 243, 112, 244, 244, 233, 245, 245, 128, 188, 188, 114, 174, 134, 131, 220, 174, 217, 236, 236, 198, 134, 215, 177, 58, 156, 143, 124, 25, 110, 7, 31, 228, 25, 264, 356, 368, 0, 11, 267, 451, 452, 349, 267, 302, 269, 350, 357, 277, 350, 452, 357, 299, 333, 297, 396, 175, 377, 381, 384, 382, 280, 347, 330, 269, 303, 270, 151, 9, 337, 344, 278, 360, 424, 418, 431, 270, 304, 409, 272, 310, 407, 322, 270, 410, 449, 450, 347, 432, 422, 434, 18, 313, 17, 291, 306, 375, 259, 387, 260, 424, 335, 418, 434, 364, 416, 391, 423, 327, 301, 251, 298, 275, 281, 4, 254, 373, 253, 375, 307, 321, 280, 425, 411, 200, 421, 18, 335, 321, 406, 321, 320, 405, 314, 315, 17, 423, 426, 266, 396, 377, 369, 270, 322, 269, 413, 417, 464, 385, 386, 258, 248, 456, 419, 298, 284, 333, 168, 417, 8, 448, 346, 261, 417, 413, 285, 326, 327, 328, 277, 355, 329, 309, 392, 438, 381, 382, 256, 279, 429, 360, 365, 364, 379, 355, 277, 437, 282, 443, 283, 281, 275, 363, 395, 431, 369, 299, 297, 337, 335, 273, 321, 348, 450, 349, 359, 446, 467, 283, 293, 282, 250, 458, 462, 300, 276, 383, 292, 308, 325, 283, 276, 293, 264, 372, 447, 346, 352, 340, 354, 274, 19, 363, 456, 281, 426, 436, 425, 380, 381, 252, 267, 269, 393, 421, 200, 428, 371, 266, 329, 432, 287, 422, 290, 250, 328, 385, 258, 384, 446, 265, 342, 386, 387, 257, 422, 424, 430, 445, 342, 276, 422, 273, 424, 306, 292, 307, 352, 366, 345, 268, 271, 302, 358, 423, 371, 327, 294, 460, 331, 279, 294, 303, 271, 304, 436, 432, 427, 304, 272, 408, 395, 394, 431, 378, 395, 400, 296, 334, 299, 6, 351, 168, 376, 352, 411, 307, 325, 320, 285, 295, 336, 320, 319, 404, 329, 330, 349, 334, 293, 333, 366, 323, 447, 316, 15, 315, 331, 358, 279, 317, 14, 316, 8, 285, 9, 277, 329, 350, 253, 374, 252, 319, 318, 403, 351, 6, 419, 324, 318, 325, 397, 367, 365, 288, 435, 397, 278, 344, 439, 310, 272, 311, 248, 195, 281, 375, 273, 291, 175, 396, 199, 312, 311, 268, 276, 283, 445, 390, 373, 339, 295, 282, 296, 448, 449, 346, 356, 264, 454, 337, 336, 299, 337, 338, 151, 294, 278, 455, 308, 292, 415, 429, 358, 355, 265, 340, 372, 388, 390, 466, 352, 346, 280, 295, 442, 282, 354, 19, 370, 285, 441, 295, 195, 248, 197, 457, 440, 274, 301, 300, 368, 417, 351, 465, 251, 301, 389, 385, 380, 386, 394, 395, 379, 399, 412, 419, 410, 436, 322, 387, 373, 388, 326, 2, 393, 354, 370, 461, 393, 164, 267, 268, 302, 12, 386, 374, 387, 312, 268, 13, 298, 293, 301, 265, 446, 340, 380, 385, 381, 280, 330, 425, 322, 426, 391, 420, 429, 437, 393, 391, 326, 344, 440, 438, 458, 459, 461, 364, 434, 394, 428, 396, 262, 274, 354, 457, 317, 316, 402, 316, 315, 403, 315, 314, 404, 314, 313, 405, 313, 421, 406, 323, 366, 361, 292, 306, 407, 306, 291, 408, 291, 287, 409, 287, 432, 410, 427, 434, 411, 372, 264, 383, 459, 309, 457, 366, 352, 401, 1, 274, 4, 418, 421, 262, 331, 294, 358, 435, 433, 367, 392, 289, 439, 328, 462, 326, 94, 2, 370, 289, 305, 455, 339, 254, 448, 359, 255, 446, 254, 253, 449, 253, 252, 450, 252, 256, 451, 256, 341, 452, 414, 413, 463, 286, 441, 414, 286, 258, 441, 258, 257, 442, 257, 259, 443, 259, 260, 444, 260, 467, 445, 309, 459, 250, 305, 289, 290, 305, 290, 460, 401, 376, 435, 309, 250, 392, 376, 411, 433, 453, 341, 464, 357, 453, 465, 343, 357, 412, 437, 343, 399, 344, 360, 440, 420, 437, 456, 360, 420, 363, 361, 401, 288, 265, 372, 353, 390, 339, 249, 339, 448, 255];
var qgX = [[0.499976992607117, 0.652534008026123], [0.500025987625122, 0.547487020492554], [0.499974012374878, 0.602371990680695], [0.482113003730774, 0.471979022026062], [0.500150978565216, 0.527155995368958], [0.499909996986389, 0.498252987861633], [0.499523013830185, 0.40106201171875], [0.289712011814117, 0.380764007568359], [0.499954998493195, 0.312398016452789], [0.499987006187439, 0.269918978214264], [0.500023007392883, 0.107050001621246], [0.500023007392883, 0.666234016418457], [0.5000159740448, 0.679224014282227], [0.500023007392883, 0.692348003387451], [0.499976992607117, 0.695277988910675], [0.499976992607117, 0.70593398809433], [0.499976992607117, 0.719385027885437], [0.499976992607117, 0.737019002437592], [0.499967992305756, 0.781370997428894], [0.499816000461578, 0.562981009483337], [0.473773002624512, 0.573909997940063], [0.104906998574734, 0.254140973091125], [0.365929991006851, 0.409575998783112], [0.338757991790771, 0.41302502155304], [0.311120003461838, 0.409460008144379], [0.274657994508743, 0.389131009578705], [0.393361985683441, 0.403706014156342], [0.345234006643295, 0.344011008739471], [0.370094001293182, 0.346076011657715], [0.319321990013123, 0.347265005111694], [0.297903001308441, 0.353591024875641], [0.24779200553894, 0.410809993743896], [0.396889001131058, 0.842755019664764], [0.280097991228104, 0.375599980354309], [0.106310002505779, 0.399955987930298], [0.2099249958992, 0.391353011131287], [0.355807989835739, 0.534406006336212], [0.471751004457474, 0.65040397644043], [0.474155008792877, 0.680191993713379], [0.439785003662109, 0.657229006290436], [0.414617002010345, 0.66654098033905], [0.450374007225037, 0.680860996246338], [0.428770989179611, 0.682690978050232], [0.374971002340317, 0.727805018424988], [0.486716985702515, 0.547628998756409], [0.485300987958908, 0.527395009994507], [0.257764995098114, 0.314490020275116], [0.401223003864288, 0.455172002315521], [0.429818987846375, 0.548614978790283], [0.421351999044418, 0.533740997314453], [0.276895999908447, 0.532056987285614], [0.483370006084442, 0.499586999416351], [0.33721199631691, 0.282882988452911], [0.296391993761063, 0.293242990970612], [0.169294998049736, 0.193813979625702], [0.447580009698868, 0.302609980106354], [0.392390012741089, 0.353887975215912], [0.354490011930466, 0.696784019470215], [0.067304998636246, 0.730105042457581], [0.442739009857178, 0.572826027870178], [0.457098007202148, 0.584792017936707], [0.381974011659622, 0.694710969924927], [0.392388999462128, 0.694203019142151], [0.277076005935669, 0.271932005882263], [0.422551989555359, 0.563233017921448], [0.385919004678726, 0.281364023685455], [0.383103013038635, 0.255840003490448], [0.331431001424789, 0.119714021682739], [0.229923993349075, 0.232002973556519], [0.364500999450684, 0.189113974571228], [0.229622006416321, 0.299540996551514], [0.173287004232407, 0.278747975826263], [0.472878992557526, 0.666198015213013], [0.446828007698059, 0.668527007102966], [0.422762006521225, 0.673889994621277], [0.445307999849319, 0.580065965652466], [0.388103008270264, 0.693961024284363], [0.403039008378983, 0.706539988517761], [0.403629004955292, 0.693953037261963], [0.460041999816895, 0.557139039039612], [0.431158006191254, 0.692366003990173], [0.452181994915009, 0.692366003990173], [0.475387006998062, 0.692366003990173], [0.465828001499176, 0.779190003871918], [0.472328990697861, 0.736225962638855], [0.473087012767792, 0.717857003211975], [0.473122000694275, 0.704625964164734], [0.473033010959625, 0.695277988910675], [0.427942007780075, 0.695277988910675], [0.426479011774063, 0.703539967536926], [0.423162013292313, 0.711845993995667], [0.4183090031147, 0.720062971115112], [0.390094995498657, 0.639572978019714], [0.013953999616206, 0.560034036636353], [0.499913990497589, 0.58014702796936], [0.413199990987778, 0.69539999961853], [0.409626007080078, 0.701822996139526], [0.468080013990402, 0.601534962654114], [0.422728985548019, 0.585985004901886], [0.463079988956451, 0.593783974647522], [0.37211999297142, 0.47341400384903], [0.334562003612518, 0.496073007583618], [0.411671012639999, 0.546965003013611], [0.242175996303558, 0.14767599105835], [0.290776997804642, 0.201445996761322], [0.327338010072708, 0.256527006626129], [0.399509996175766, 0.748921036720276], [0.441727995872498, 0.261676013469696], [0.429764986038208, 0.187834024429321], [0.412198007106781, 0.108901023864746], [0.288955003023148, 0.398952007293701], [0.218936994671822, 0.435410976409912], [0.41278201341629, 0.398970007896423], [0.257135003805161, 0.355440020561218], [0.427684992551804, 0.437960982322693], [0.448339998722076, 0.536936044692993], [0.178560003638268, 0.45755398273468], [0.247308000922203, 0.457193970680237], [0.286267012357712, 0.467674970626831], [0.332827985286713, 0.460712015628815], [0.368755996227264, 0.447206974029541], [0.398963987827301, 0.432654976844788], [0.476410001516342, 0.405806005001068], [0.189241006970406, 0.523923993110657], [0.228962004184723, 0.348950982093811], [0.490725994110107, 0.562400996685028], [0.404670000076294, 0.485132992267609], [0.019469000399113, 0.401564002037048], [0.426243007183075, 0.420431017875671], [0.396993011236191, 0.548797011375427], [0.266469985246658, 0.376977026462555], [0.439121007919312, 0.51895797252655], [0.032313998788595, 0.644356966018677], [0.419054001569748, 0.387154996395111], [0.462783008813858, 0.505746960639954], [0.238978996872902, 0.779744982719421], [0.198220998048782, 0.831938028335571], [0.107550002634525, 0.540755033493042], [0.183610007166862, 0.740257024765015], [0.134409993886948, 0.333683013916016], [0.385764002799988, 0.883153975009918], [0.490967005491257, 0.579378008842468], [0.382384985685349, 0.508572995662689], [0.174399003386497, 0.397670984268188], [0.318785011768341, 0.39623498916626], [0.343364000320435, 0.400596976280212], [0.396100014448166, 0.710216999053955], [0.187885001301765, 0.588537991046906], [0.430987000465393, 0.944064974784851], [0.318993002176285, 0.898285031318665], [0.266247987747192, 0.869701027870178], [0.500023007392883, 0.190576016902924], [0.499976992607117, 0.954452991485596], [0.366169989109039, 0.398822009563446], [0.393207013607025, 0.39553701877594], [0.410373002290726, 0.391080021858215], [0.194993004202843, 0.342101991176605], [0.388664990663528, 0.362284004688263], [0.365961998701096, 0.355970978736877], [0.343364000320435, 0.355356991291046], [0.318785011768341, 0.35834002494812], [0.301414996385574, 0.363156020641327], [0.058132998645306, 0.319076001644135], [0.301414996385574, 0.387449026107788], [0.499987989664078, 0.618434011936188], [0.415838003158569, 0.624195992946625], [0.445681989192963, 0.566076993942261], [0.465844005346298, 0.620640993118286], [0.49992299079895, 0.351523995399475], [0.288718998432159, 0.819945991039276], [0.335278987884521, 0.852819979190826], [0.440512001514435, 0.902418971061707], [0.128294005990028, 0.791940987110138], [0.408771991729736, 0.373893976211548], [0.455606997013092, 0.451801002025604], [0.499877005815506, 0.908990025520325], [0.375436991453171, 0.924192011356354], [0.11421000212431, 0.615022003650665], [0.448662012815475, 0.695277988910675], [0.4480200111866, 0.704632043838501], [0.447111994028091, 0.715808033943176], [0.444831997156143, 0.730794012546539], [0.430011987686157, 0.766808986663818], [0.406787008047104, 0.685672998428345], [0.400738000869751, 0.681069016456604], [0.392399996519089, 0.677703022956848], [0.367855995893478, 0.663918972015381], [0.247923001646996, 0.601333022117615], [0.452769994735718, 0.420849978923798], [0.43639200925827, 0.359887003898621], [0.416164010763168, 0.368713974952698], [0.413385987281799, 0.692366003990173], [0.228018000721931, 0.683571994304657], [0.468268007040024, 0.352671027183533], [0.411361992359161, 0.804327011108398], [0.499989002943039, 0.469825029373169], [0.479153990745544, 0.442654013633728], [0.499974012374878, 0.439637005329132], [0.432112008333206, 0.493588984012604], [0.499886006116867, 0.866917014122009], [0.49991300702095, 0.821729004383087], [0.456548988819122, 0.819200992584229], [0.344549000263214, 0.745438992977142], [0.37890899181366, 0.574010014533997], [0.374292999505997, 0.780184984207153], [0.319687992334366, 0.570737957954407], [0.357154995203018, 0.604269981384277], [0.295284003019333, 0.621580958366394], [0.447750002145767, 0.862477004528046], [0.410986006259918, 0.508723020553589], [0.31395098567009, 0.775308012962341], [0.354128003120422, 0.812552988529205], [0.324548006057739, 0.703992962837219], [0.189096003770828, 0.646299958229065], [0.279776990413666, 0.71465802192688], [0.1338230073452, 0.682700991630554], [0.336768001317978, 0.644733011722565], [0.429883986711502, 0.466521978378296], [0.455527991056442, 0.548622965812683], [0.437114000320435, 0.558896005153656], [0.467287987470627, 0.529924988746643], [0.414712011814117, 0.335219979286194], [0.37704598903656, 0.322777986526489], [0.344107985496521, 0.320150971412659], [0.312875986099243, 0.32233202457428], [0.283526003360748, 0.333190023899078], [0.241245999932289, 0.382785975933075], [0.102986000478268, 0.468762993812561], [0.267612010240555, 0.424560010433197], [0.297879010438919, 0.433175981044769], [0.333433985710144, 0.433878004550934], [0.366427004337311, 0.426115989685059], [0.396012008190155, 0.416696012020111], [0.420121014118195, 0.41022801399231], [0.007561000064015, 0.480777025222778], [0.432949006557465, 0.569517970085144], [0.458638995885849, 0.479089021682739], [0.473466008901596, 0.545744001865387], [0.476087987422943, 0.563830018043518], [0.468472003936768, 0.555056989192963], [0.433990985155106, 0.582361996173859], [0.483518004417419, 0.562983989715576], [0.482482999563217, 0.57784903049469], [0.42645001411438, 0.389798998832703], [0.438998997211456, 0.39649498462677], [0.450067013502121, 0.400434017181396], [0.289712011814117, 0.368252992630005], [0.276670008897781, 0.363372981548309], [0.517862021923065, 0.471948027610779], [0.710287988185883, 0.380764007568359], [0.526226997375488, 0.573909997940063], [0.895093023777008, 0.254140973091125], [0.634069979190826, 0.409575998783112], [0.661242008209229, 0.41302502155304], [0.688880026340485, 0.409460008144379], [0.725341975688934, 0.389131009578705], [0.606630027294159, 0.40370500087738], [0.654766023159027, 0.344011008739471], [0.629905998706818, 0.346076011657715], [0.680678009986877, 0.347265005111694], [0.702096998691559, 0.353591024875641], [0.75221198797226, 0.410804986953735], [0.602918028831482, 0.842862963676453], [0.719901978969574, 0.375599980354309], [0.893692970275879, 0.399959981441498], [0.790081977844238, 0.391354024410248], [0.643998026847839, 0.534487962722778], [0.528249025344849, 0.65040397644043], [0.525849997997284, 0.680191040039062], [0.560214996337891, 0.657229006290436], [0.585384011268616, 0.66654098033905], [0.549625992774963, 0.680860996246338], [0.57122802734375, 0.682691991329193], [0.624852001667023, 0.72809898853302], [0.513050019741058, 0.547281980514526], [0.51509702205658, 0.527251958847046], [0.742246985435486, 0.314507007598877], [0.598631024360657, 0.454979002475739], [0.570338010787964, 0.548575043678284], [0.578631997108459, 0.533622980117798], [0.723087012767792, 0.532054007053375], [0.516445994377136, 0.499638974666595], [0.662801027297974, 0.282917976379395], [0.70362401008606, 0.293271005153656], [0.830704987049103, 0.193813979625702], [0.552385985851288, 0.302568018436432], [0.607609987258911, 0.353887975215912], [0.645429015159607, 0.696707010269165], [0.932694971561432, 0.730105042457581], [0.557260990142822, 0.572826027870178], [0.542901992797852, 0.584792017936707], [0.6180260181427, 0.694710969924927], [0.607590973377228, 0.694203019142151], [0.722943007946014, 0.271963000297546], [0.577413976192474, 0.563166975975037], [0.614082992076874, 0.281386971473694], [0.616907000541687, 0.255886018276215], [0.668509006500244, 0.119913995265961], [0.770092010498047, 0.232020974159241], [0.635536015033722, 0.189248979091644], [0.77039098739624, 0.299556016921997], [0.826722025871277, 0.278755009174347], [0.527121007442474, 0.666198015213013], [0.553171992301941, 0.668527007102966], [0.577238023281097, 0.673889994621277], [0.554691970348358, 0.580065965652466], [0.611896991729736, 0.693961024284363], [0.59696102142334, 0.706539988517761], [0.596370995044708, 0.693953037261963], [0.539958000183105, 0.557139039039612], [0.568841993808746, 0.692366003990173], [0.547818005084991, 0.692366003990173], [0.52461302280426, 0.692366003990173], [0.534089982509613, 0.779141008853912], [0.527670979499817, 0.736225962638855], [0.526912987232208, 0.717857003211975], [0.526877999305725, 0.704625964164734], [0.526966989040375, 0.695277988910675], [0.572058022022247, 0.695277988910675], [0.573521018028259, 0.703539967536926], [0.57683801651001, 0.711845993995667], [0.581691026687622, 0.720062971115112], [0.609944999217987, 0.639909982681274], [0.986046016216278, 0.560034036636353], [0.5867999792099, 0.69539999961853], [0.590372025966644, 0.701822996139526], [0.531915009021759, 0.601536989212036], [0.577268004417419, 0.585934996604919], [0.536915004253387, 0.593786001205444], [0.627542972564697, 0.473352015018463], [0.665585994720459, 0.495950996875763], [0.588353991508484, 0.546862006187439], [0.757824003696442, 0.14767599105835], [0.709249973297119, 0.201507985591888], [0.672684013843536, 0.256581008434296], [0.600408971309662, 0.74900496006012], [0.55826598405838, 0.261672019958496], [0.570303976535797, 0.187870979309082], [0.588165998458862, 0.109044015407562], [0.711045026779175, 0.398952007293701], [0.781069993972778, 0.435405015945435], [0.587247014045715, 0.398931980133057], [0.742869973182678, 0.355445981025696], [0.572156012058258, 0.437651991844177], [0.55186802148819, 0.536570012569427], [0.821442008018494, 0.457556009292603], [0.752701997756958, 0.457181990146637], [0.71375697851181, 0.467626988887787], [0.66711300611496, 0.460672974586487], [0.631101012229919, 0.447153985500336], [0.6008620262146, 0.432473003864288], [0.523481011390686, 0.405627012252808], [0.810747981071472, 0.523926019668579], [0.771045982837677, 0.348959028720856], [0.509127020835876, 0.562718033790588], [0.595292985439301, 0.485023975372314], [0.980530977249146, 0.401564002037048], [0.573499977588654, 0.420000016689301], [0.602994978427887, 0.548687994480133], [0.733529984951019, 0.376977026462555], [0.560611009597778, 0.519016981124878], [0.967685997486115, 0.644356966018677], [0.580985009670258, 0.387160003185272], [0.537728011608124, 0.505385041236877], [0.760966002941132, 0.779752969741821], [0.801778972148895, 0.831938028335571], [0.892440974712372, 0.54076099395752], [0.816350996494293, 0.740260004997253], [0.865594983100891, 0.333687007427216], [0.614073991775513, 0.883246004581451], [0.508952975273132, 0.579437971115112], [0.617941975593567, 0.508316040039062], [0.825608015060425, 0.397674977779388], [0.681214988231659, 0.39623498916626], [0.656635999679565, 0.400596976280212], [0.603900015354156, 0.710216999053955], [0.81208598613739, 0.588539004325867], [0.56801301240921, 0.944564998149872], [0.681007981300354, 0.898285031318665], [0.733752012252808, 0.869701027870178], [0.633830010890961, 0.398822009563446], [0.606792986392975, 0.39553701877594], [0.589659988880157, 0.391062021255493], [0.805015981197357, 0.342108011245728], [0.611334979534149, 0.362284004688263], [0.634037971496582, 0.355970978736877], [0.656635999679565, 0.355356991291046], [0.681214988231659, 0.35834002494812], [0.698584973812103, 0.363156020641327], [0.941866993904114, 0.319076001644135], [0.698584973812103, 0.387449026107788], [0.584177017211914, 0.624107003211975], [0.554318010807037, 0.566076993942261], [0.534153997898102, 0.62064003944397], [0.711217999458313, 0.819975018501282], [0.664629995822906, 0.852871000766754], [0.559099972248077, 0.902631998062134], [0.871706008911133, 0.791940987110138], [0.591234028339386, 0.373893976211548], [0.544341027736664, 0.451583981513977], [0.624562978744507, 0.924192011356354], [0.88577002286911, 0.615028977394104], [0.551338016986847, 0.695277988910675], [0.551980018615723, 0.704632043838501], [0.552887976169586, 0.715808033943176], [0.555167973041534, 0.730794012546539], [0.569944024085999, 0.767035007476807], [0.593203008174896, 0.685675978660583], [0.599261999130249, 0.681069016456604], [0.607599973678589, 0.677703022956848], [0.631937980651855, 0.663500010967255], [0.752032995223999, 0.601315021514893], [0.547226011753082, 0.420395016670227], [0.563543975353241, 0.359827995300293], [0.583841025829315, 0.368713974952698], [0.586614012718201, 0.692366003990173], [0.771915018558502, 0.683578014373779], [0.531597018241882, 0.352482974529266], [0.588370978832245, 0.804440975189209], [0.52079701423645, 0.442565023899078], [0.567984998226166, 0.493479013442993], [0.543282985687256, 0.819254994392395], [0.655317008495331, 0.745514988899231], [0.621008992195129, 0.574018001556396], [0.625559985637665, 0.78031200170517], [0.680198013782501, 0.570719003677368], [0.64276397228241, 0.604337990283966], [0.704662978649139, 0.621529996395111], [0.552012026309967, 0.862591981887817], [0.589071989059448, 0.508637011051178], [0.685944974422455, 0.775357007980347], [0.645735025405884, 0.812640011310577], [0.675342977046967, 0.703978002071381], [0.810858011245728, 0.646304965019226], [0.72012197971344, 0.714666962623596], [0.866151988506317, 0.682704985141754], [0.663187026977539, 0.644596993923187], [0.570082008838654, 0.466325998306274], [0.544561982154846, 0.548375964164734], [0.562758982181549, 0.558784961700439], [0.531987011432648, 0.530140042304993], [0.585271000862122, 0.335177004337311], [0.622952997684479, 0.32277899980545], [0.655896008014679, 0.320163011550903], [0.687132000923157, 0.322345972061157], [0.716481983661652, 0.333200991153717], [0.758756995201111, 0.382786989212036], [0.897013008594513, 0.468769013881683], [0.732392013072968, 0.424547016620636], [0.70211398601532, 0.433162987232208], [0.66652500629425, 0.433866024017334], [0.633504986763, 0.426087975502014], [0.603875994682312, 0.416586995124817], [0.579657971858978, 0.409945011138916], [0.992439985275269, 0.480777025222778], [0.567192018032074, 0.569419980049133], [0.54136598110199, 0.478899002075195], [0.526564002037048, 0.546118021011353], [0.523913025856018, 0.563830018043518], [0.531529009342194, 0.555056989192963], [0.566035985946655, 0.582329034805298], [0.51631098985672, 0.563053965568542], [0.5174720287323, 0.577877044677734], [0.573594987392426, 0.389806985855103], [0.560697972774506, 0.395331978797913], [0.549755990505219, 0.399751007556915], [0.710287988185883, 0.368252992630005], [0.723330020904541, 0.363372981548309]];
var qgG = [[0, -0.03406405, 0.05979506], [0, -0.01126867, 0.07475604], [0, -0.02089025, 0.06058267], [-463928e-8, 955356e-8, 0.06633583], [0, -463172e-8, 0.0758658], [0, 365668e-8, 0.0724287], [0, 0.02473254, 0.05788627], [-0.04253081, 0.02577645, 0.03279702], [0, 0.04019041, 0.05284765], [0, 0.04885978, 0.05385259], [0, 0.08261777, 0.04481537], [0, -0.03706812, 0.05864923], [0, -0.03918302, 0.05569429], [0, -0.03994437, 0.05219482], [0, -0.04542401, 0.05404753], [0, -0.04745578, 0.05529456], [0, -0.05019568, 0.05601447], [0, -0.05365124, 0.0553544], [0, -0.06149625, 0.05071371], [0, -0.01501096, 0.07112196], [-416106e-8, -0.0146645, 0.06447657], [-0.0708796, 0.05434801, 99621e-8], [-0.02628638, 0.02035898, 0.03848121], [-0.03198363, 0.01985814, 0.03796952], [-0.03775151, 0.02039402, 0.03646194], [-0.04465819, 0.02422949, 0.03155169], [-0.02164288, 0.02189867, 0.03851822], [-0.03208229, 0.03223925, 0.04115823], [-0.02673803, 0.03205336, 0.04092203], [-0.03745193, 0.03165285, 0.03972409], [-0.04161018, 0.03059068, 0.03719554], [-0.05062005, 0.01934418, 0.02776093], [-0.02266659, -0.07425769, 0.04389811], [-0.04445859, 0.0266399, 0.03173422], [-0.0721453, 0.02263009, 7315e-7], [-0.05799793, 0.02349546, 0.02204059], [-0.02844939, -720869e-8, 0.0443313], [-711452e-8, -0.03329356, 0.05877044], [-606033e-8, -0.03924563, 0.05444922], [-0.01431615, -0.03500954, 0.05496188], [-0.0191491, -0.03803147, 0.05028929], [-0.01131043, -0.03973938, 0.05189647], [-0.01563548, -0.04082763, 0.04842262], [-0.02650112, -0.05003649, 0.04188482], [-427049e-8, -0.01094135, 0.07360528], [-496396e-8, -47566e-7, 0.07440358], [-0.05253307, 0.03881582, 0.0336316], [-0.01718698, 974608e-8, 0.04558359], [-0.01608635, -942517e-8, 0.05814193], [-0.01651267, -610869e-8, 0.05581319], [-0.04765501, -701555e-8, 0.03534632], [-478306e-8, 295764e-8, 0.07101013], [-0.03734964, 0.04508229, 0.04550455], [-0.04588603, 0.04302036, 0.04048485], [-0.06279331, 0.06615427, 0.01425851], [-0.01220941, 0.04142164, 0.05106035], [-0.02193489, 0.03100317, 0.04000575], [-0.03102642, -0.04352985, 0.04095904], [-0.06719682, -0.04788644, -0.01745402], [-0.01193824, -0.01306796, 0.05737746], [-729766e-8, -0.01593713, 0.05833207], [-0.02456206, -0.04342622, 0.04283883], [-0.02204823, -0.04304509, 0.04162498], [-0.04985894, 0.0480246, 0.03751978], [-0.01592294, -0.0125771, 0.05456949], [-0.02644548, 0.04524653, 0.0492156], [-0.02760292, 0.0510097, 0.05015991], [-0.03523964, 0.08005974, 0.03729165], [-0.05599763, 0.05715469, 0.0272426], [-0.03063932, 0.06566143, 0.04529982], [-0.05720968, 0.04254583, 0.02830853], [-0.06374393, 0.04785589, 0.01591692], [-672728e-8, -0.03688017, 0.05737803], [-0.0126256, -0.03787692, 0.05417778], [-0.01732553, -0.03952768, 0.05000578], [-0.01043625, -0.01464974, 0.05662455], [-0.02321234, -0.0432907, 0.04258155], [-0.02056846, -0.04477672, 0.04520882], [-0.02153084, -0.04276323, 0.04038092], [-946874e-8, -0.0103525, 0.06512274], [-0.01469132, -0.04036351, 0.04604907], [-0.0102434, -0.03989852, 0.04926693], [-533422e-8, -0.03993222, 0.05138201], [-76972e-7, -0.06095395, 0.04985882], [-699606e-8, -0.05291851, 0.05448303], [-669687e-8, -0.0494977, 0.05509611], [-630947e-8, -0.04695102, 0.0544937], [-583218e-8, -0.04517983, 0.05339869], [-0.0153717, -0.04423207, 0.04745469], [-0.016156, -0.04475943, 0.04813631], [-0.01729053, -0.0461868, 0.04854462], [-0.01838624, -0.04828747, 0.04823736], [-0.0236825, -0.03106238, 0.04868095], [-0.07542244, -0.01049282, -0.02431321], [0, -0.01724004, 0.0660139], [-0.01826614, -0.04399532, 0.0439902], [-0.01929558, -0.04411831, 0.04497051], [-597442e-8, -0.02013687, 0.05866456], [-0.01405627, -0.01714197, 0.05241086], [-662449e-8, -0.01819322, 0.05863759], [-0.02342339, 572221e-8, 0.04294303], [-0.03327324, 104862e-8, 0.0411386], [-0.01726175, -919166e-8, 0.05273354], [-0.05133204, 0.07485601, 0.02660443], [-0.04538641, 0.06319907, 0.03683425], [-0.03986562, 0.05109486, 0.04466315], [-0.02169681, -0.05440434, 0.04455873], [-0.01395634, 0.05011962, 0.05316032], [-0.016195, 0.06599216, 0.04921107], [-0.01891399, 0.08236376, 0.04274999], [-0.04195832, 0.02235205, 0.03375099], [-0.05733342, 0.01411738, 0.02431726], [-0.01859888, 0.02355756, 0.03843182], [-0.04988612, 0.03074653, 0.03083858], [-0.01303263, 0.01416452, 0.04831091], [-0.01305757, -67278e-7, 0.06415959], [-0.0646517, 937119e-8, 0.01689873], [-0.05258659, 945811e-8, 0.02974312], [-0.04432338, 722095e-8, 0.03522615], [-0.03300681, 86164e-7, 0.03872784], [-0.02430178, 0.01131491, 0.04039035], [-0.01820731, 0.01467953, 0.04224124], [-563221e-8, 0.02307693, 0.05566789], [-0.06338145, -529279e-8, 0.01881175], [-0.05587698, 0.03208071, 0.0268784], [-242624e-8, -0.01462858, 0.07071491], [-0.01611251, 339325e-8, 0.0489542], [-0.07743095, 0.02364999, -0.02005167], [-0.01391142, 0.01851047, 0.04448999], [-0.01785794, -978285e-8, 0.0485047], [-0.04670959, 0.0266446, 0.03084075], [-0.0133397, -283762e-8, 0.06097047], [-0.07270896, -0.02890916, -0.02252455], [-0.01856432, 0.02585245, 0.03757904], [-923388e-8, 73075e-8, 0.06671944], [-0.05000589, -0.06135128, 0.01892522], [-0.05085276, -0.0717859, 71471e-7], [-0.07159291, -81182e-7, -72044e-8], [-0.05843051, -0.05248023, 92409e-7], [-0.06847258, 0.03662916, 724696e-8], [-0.02412942, -0.08258854, 0.04119211], [-179909e-8, -0.01689865, 0.06573301], [-0.02103655, -163946e-8, 0.04566119], [-0.06407571, 0.02236021, 0.01560843], [-0.03670075, 0.02360153, 0.0363523], [-0.03177186, 0.02294264, 0.03775705], [-0.02196121, -0.04598323, 0.04479785], [-0.06234883, -0.0194443, 0.01663542], [-0.01292924, -0.09295921, 0.04094062], [-0.03210651, -0.08533278, 0.02802], [-0.04068926, -0.07993109, 0.01925118], [0, 0.06545389, 0.05027312], [0, -0.09403378, 0.0426449], [-0.02724032, 0.02315802, 0.03777151], [-0.0228846, 0.0239889, 0.03697603], [-0.01998311, 0.02496546, 0.03689148], [-0.0613004, 0.03399261, 0.02038516], [-0.0228846, 0.02886503, 0.03775031], [-0.02724032, 0.02961809, 0.03871767], [-0.03177186, 0.02964135, 0.03876973], [-0.03670075, 0.02927713, 0.03724325], [-0.04018389, 0.02857356, 0.03482983], [-0.07555811, 0.04106811, -991916e-8], [-0.04018389, 0.02483694, 0.03440898], [0, -0.02521946, 0.05932265], [-0.01776217, -0.02683947, 0.05213116], [-0.01222237, -0.01182445, 0.05952464], [-731493e-8, -0.02536684, 0.05815343], [0, 0.03271026, 0.05236015], [-0.04135272, -0.06996639, 0.02671969], [-0.03311811, -0.07660816, 0.03382962], [-0.01313701, -0.08639995, 0.04702454], [-0.05940524, -0.06223629, -631469e-8], [-0.01998311, 0.02743837, 0.0374403], [-901447e-8, 0.01236991, 0.05754256], [0, -0.08765243, 0.04891439], [-0.02308977, -0.08974197, 0.03609069], [-0.06954154, -0.02439843, -131163e-8], [-0.01098819, -0.04458788, 0.05120726], [-0.01181124, -0.04579997, 0.05189563], [-0.01255818, -0.04787901, 0.0523705], [-0.01325085, -0.05106508, 0.05205009], [-0.01546388, -0.05819392, 0.04757892], [-0.01953754, -0.04183893, 0.04431712], [-0.02117802, -0.04137093, 0.04555095], [-0.02285339, -0.04051196, 0.04582437], [-0.0285016, -0.03665721, 0.04484993], [-0.05278538, -0.02238942, 0.02861224], [-946709e-8, 0.01907627, 0.0519678], [-0.01314173, 0.03104912, 0.04231405], [-0.0178, 0.02859999, 0.03881555], [-0.0184511, -0.0409888, 0.04247263], [-0.05436186, -0.04030482, 0.02109851], [-766444e-8, 0.0318213, 0.04861453], [-0.01938616, -0.06614411, 0.04521083], [0, 0.01059412, 0.06774605], [-516573e-8, 0.01583571, 0.06148363], [0, 0.01728368, 0.0631675], [-0.01246815, 230296e-8, 0.05681035], [0, -0.07942194, 0.05181172], [0, -0.069915, 0.05153477], [-997827e-8, -0.06930922, 0.04979575], [-0.03288807, -0.05382515, 0.03795751], [-0.02311631, -0.01566238, 0.04590084], [-0.0268025, -0.06111567, 0.04096151], [-0.03832928, -0.01537327, 0.04137731], [-0.0296186, -0.02274216, 0.04440943], [-0.04386901, -0.02683286, 0.03643886], [-0.01217295, -0.07834466, 0.04969285], [-0.01542374, -136843e-8, 0.05201008], [-0.03878377, -0.06041764, 0.03311078], [-0.03084037, -0.06809843, 0.03814194], [-0.03747321, -0.04503546, 0.03726452], [-0.06094129, -0.03205992, 0.01473481], [-0.04588995, -0.04728726, 0.0298322], [-0.06583231, -0.03941269, 70267e-8], [-0.0349258, -0.03195821, 0.04130198], [-0.01255543, 80234e-7, 0.05307551], [-0.01126122, -933603e-8, 0.06538785], [-0.01443109, -0.01142775, 0.05905127], [-923043e-8, -529043e-8, 0.07003423], [-0.01755386, 0.03529116, 0.04327697], [-0.02632589, 0.03713828, 0.0436463], [-0.03388062, 0.03721975, 0.04309029], [-0.04075766, 0.03675412, 0.04076063], [-0.0462291, 0.0347469, 0.03646322], [-0.05171755, 0.02535752, 0.02670867], [-0.0729733, 763172e-8, -48769e-8], [-0.04706828, 0.01651, 0.03109532], [-0.04071712, 0.01476821, 0.03476944], [-0.03269817, 0.01470658, 0.03731945], [-0.02527572, 0.0161731, 0.03865444], [-0.01970894, 0.01858504, 0.03961782], [-0.01579543, 0.0209794, 0.04084997], [-0.07664182, 673132e-8, -0.02435867], [-0.01397041, -0.0134014, 0.05630378], [-884838e-8, 658739e-8, 0.06233231], [-767097e-8, -968036e-8, 0.07077932], [-460213e-8, -0.01334107, 0.06787448], [-748618e-8, -0.01067995, 0.06798303], [-0.01236408, -0.01585569, 0.05480489], [-387306e-8, -0.01409991, 0.06957705], [-319925e-8, -0.01607932, 0.06508676], [-0.01639633, 0.02556297, 0.03863737], [-0.01255645, 0.02467143, 0.042038], [-0.01031362, 0.02382662, 0.04615849], [-0.04253081, 0.02772296, 0.03315305], [-0.0453, 0.0291, 0.03339685], [463928e-8, 955356e-8, 0.06633583], [0.04253081, 0.02577645, 0.03279702], [416106e-8, -0.0146645, 0.06447657], [0.0708796, 0.05434801, 99621e-8], [0.02628638, 0.02035898, 0.03848121], [0.03198363, 0.01985814, 0.03796952], [0.03775151, 0.02039402, 0.03646194], [0.04465819, 0.02422949, 0.03155169], [0.02164288, 0.02189867, 0.03851822], [0.03208229, 0.03223925, 0.04115823], [0.02673803, 0.03205336, 0.04092203], [0.03745193, 0.03165285, 0.03972409], [0.04161018, 0.03059068, 0.03719554], [0.05062005, 0.01934418, 0.02776093], [0.02266659, -0.07425769, 0.04389811], [0.04445859, 0.0266399, 0.03173422], [0.0721453, 0.02263009, 7315e-7], [0.05799793, 0.02349546, 0.02204059], [0.02844939, -720869e-8, 0.0443313], [711452e-8, -0.03329356, 0.05877044], [606033e-8, -0.03924563, 0.05444922], [0.01431615, -0.03500954, 0.05496188], [0.0191491, -0.03803147, 0.05028929], [0.01131043, -0.03973938, 0.05189647], [0.01563548, -0.04082763, 0.04842262], [0.02650112, -0.05003649, 0.04188482], [427049e-8, -0.01094135, 0.07360528], [496396e-8, -47566e-7, 0.07440358], [0.05253307, 0.03881582, 0.0336316], [0.01718698, 974608e-8, 0.04558359], [0.01608635, -942517e-8, 0.05814193], [0.01651267, -610869e-8, 0.05581319], [0.04765501, -701555e-8, 0.03534632], [478306e-8, 295764e-8, 0.07101013], [0.03734964, 0.04508229, 0.04550455], [0.04588603, 0.04302036, 0.04048485], [0.06279331, 0.06615427, 0.01425851], [0.01220941, 0.04142164, 0.05106035], [0.02193489, 0.03100317, 0.04000575], [0.03102642, -0.04352985, 0.04095904], [0.06719682, -0.04788644, -0.01745402], [0.01193824, -0.01306796, 0.05737746], [729766e-8, -0.01593713, 0.05833207], [0.02456206, -0.04342622, 0.04283883], [0.02204823, -0.04304509, 0.04162498], [0.04985894, 0.0480246, 0.03751978], [0.01592294, -0.0125771, 0.05456949], [0.02644548, 0.04524653, 0.0492156], [0.02760292, 0.0510097, 0.05015991], [0.03523964, 0.08005974, 0.03729165], [0.05599763, 0.05715469, 0.0272426], [0.03063932, 0.06566143, 0.04529982], [0.05720968, 0.04254583, 0.02830853], [0.06374393, 0.04785589, 0.01591692], [672728e-8, -0.03688017, 0.05737803], [0.0126256, -0.03787692, 0.05417778], [0.01732553, -0.03952768, 0.05000578], [0.01043625, -0.01464974, 0.05662455], [0.02321234, -0.0432907, 0.04258155], [0.02056846, -0.04477672, 0.04520882], [0.02153084, -0.04276323, 0.04038092], [946874e-8, -0.0103525, 0.06512274], [0.01469132, -0.04036351, 0.04604907], [0.0102434, -0.03989852, 0.04926693], [533422e-8, -0.03993222, 0.05138201], [76972e-7, -0.06095395, 0.04985882], [699606e-8, -0.05291851, 0.05448303], [669687e-8, -0.0494977, 0.05509611], [630947e-8, -0.04695102, 0.0544937], [583218e-8, -0.04517983, 0.05339869], [0.0153717, -0.04423207, 0.04745469], [0.016156, -0.04475943, 0.04813631], [0.01729053, -0.0461868, 0.04854462], [0.01838624, -0.04828747, 0.04823736], [0.0236825, -0.03106238, 0.04868095], [0.07542244, -0.01049282, -0.02431321], [0.01826614, -0.04399532, 0.0439902], [0.01929558, -0.04411831, 0.04497051], [597442e-8, -0.02013687, 0.05866456], [0.01405627, -0.01714197, 0.05241086], [662449e-8, -0.01819322, 0.05863759], [0.02342339, 572221e-8, 0.04294303], [0.03327324, 104862e-8, 0.0411386], [0.01726175, -919166e-8, 0.05273354], [0.05133204, 0.07485601, 0.02660443], [0.04538641, 0.06319907, 0.03683425], [0.03986562, 0.05109486, 0.04466315], [0.02169681, -0.05440434, 0.04455873], [0.01395634, 0.05011962, 0.05316032], [0.016195, 0.06599216, 0.04921107], [0.01891399, 0.08236376, 0.04274999], [0.04195832, 0.02235205, 0.03375099], [0.05733342, 0.01411738, 0.02431726], [0.01859888, 0.02355756, 0.03843182], [0.04988612, 0.03074653, 0.03083858], [0.01303263, 0.01416452, 0.04831091], [0.01305757, -67278e-7, 0.06415959], [0.0646517, 937119e-8, 0.01689873], [0.05258659, 945811e-8, 0.02974312], [0.04432338, 722095e-8, 0.03522615], [0.03300681, 86164e-7, 0.03872784], [0.02430178, 0.01131491, 0.04039035], [0.01820731, 0.01467953, 0.04224124], [563221e-8, 0.02307693, 0.05566789], [0.06338145, -529279e-8, 0.01881175], [0.05587698, 0.03208071, 0.0268784], [242624e-8, -0.01462858, 0.07071491], [0.01611251, 339325e-8, 0.0489542], [0.07743095, 0.02364999, -0.02005167], [0.01391142, 0.01851047, 0.04448999], [0.01785794, -978285e-8, 0.0485047], [0.04670959, 0.0266446, 0.03084075], [0.0133397, -283762e-8, 0.06097047], [0.07270896, -0.02890916, -0.02252455], [0.01856432, 0.02585245, 0.03757904], [923388e-8, 73075e-8, 0.06671944], [0.05000589, -0.06135128, 0.01892522], [0.05085276, -0.0717859, 71471e-7], [0.07159291, -81182e-7, -72044e-8], [0.05843051, -0.05248023, 92409e-7], [0.06847258, 0.03662916, 724696e-8], [0.02412942, -0.08258854, 0.04119211], [179909e-8, -0.01689865, 0.06573301], [0.02103655, -163946e-8, 0.04566119], [0.06407571, 0.02236021, 0.01560843], [0.03670075, 0.02360153, 0.0363523], [0.03177186, 0.02294264, 0.03775705], [0.02196121, -0.04598323, 0.04479785], [0.06234883, -0.0194443, 0.01663542], [0.01292924, -0.09295921, 0.04094062], [0.03210651, -0.08533278, 0.02802], [0.04068926, -0.07993109, 0.01925118], [0.02724032, 0.02315802, 0.03777151], [0.0228846, 0.0239889, 0.03697603], [0.01998311, 0.02496546, 0.03689148], [0.0613004, 0.03399261, 0.02038516], [0.0228846, 0.02886503, 0.03775031], [0.02724032, 0.02961809, 0.03871767], [0.03177186, 0.02964135, 0.03876973], [0.03670075, 0.02927713, 0.03724325], [0.04018389, 0.02857356, 0.03482983], [0.07555811, 0.04106811, -991916e-8], [0.04018389, 0.02483694, 0.03440898], [0.01776217, -0.02683947, 0.05213116], [0.01222237, -0.01182445, 0.05952464], [731493e-8, -0.02536684, 0.05815343], [0.04135272, -0.06996639, 0.02671969], [0.03311811, -0.07660816, 0.03382962], [0.01313701, -0.08639995, 0.04702454], [0.05940524, -0.06223629, -631469e-8], [0.01998311, 0.02743837, 0.0374403], [901447e-8, 0.01236991, 0.05754256], [0.02308977, -0.08974197, 0.03609069], [0.06954154, -0.02439843, -131163e-8], [0.01098819, -0.04458788, 0.05120726], [0.01181124, -0.04579997, 0.05189563], [0.01255818, -0.04787901, 0.0523705], [0.01325085, -0.05106508, 0.05205009], [0.01546388, -0.05819392, 0.04757892], [0.01953754, -0.04183893, 0.04431712], [0.02117802, -0.04137093, 0.04555095], [0.02285339, -0.04051196, 0.04582437], [0.0285016, -0.03665721, 0.04484993], [0.05278538, -0.02238942, 0.02861224], [946709e-8, 0.01907627, 0.0519678], [0.01314173, 0.03104912, 0.04231405], [0.0178, 0.02859999, 0.03881555], [0.0184511, -0.0409888, 0.04247263], [0.05436186, -0.04030482, 0.02109851], [766444e-8, 0.0318213, 0.04861453], [0.01938616, -0.06614411, 0.04521083], [516573e-8, 0.01583571, 0.06148363], [0.01246815, 230296e-8, 0.05681035], [997827e-8, -0.06930922, 0.04979575], [0.03288807, -0.05382515, 0.03795751], [0.02311631, -0.01566238, 0.04590084], [0.0268025, -0.06111567, 0.04096151], [0.03832928, -0.01537327, 0.04137731], [0.0296186, -0.02274216, 0.04440943], [0.04386901, -0.02683286, 0.03643886], [0.01217295, -0.07834466, 0.04969285], [0.01542374, -136843e-8, 0.05201008], [0.03878377, -0.06041764, 0.03311078], [0.03084037, -0.06809843, 0.03814194], [0.03747321, -0.04503546, 0.03726452], [0.06094129, -0.03205992, 0.01473481], [0.04588995, -0.04728726, 0.0298322], [0.06583231, -0.03941269, 70267e-8], [0.0349258, -0.03195821, 0.04130198], [0.01255543, 80234e-7, 0.05307551], [0.01126122, -933603e-8, 0.06538785], [0.01443109, -0.01142775, 0.05905127], [923043e-8, -529043e-8, 0.07003423], [0.01755386, 0.03529116, 0.04327697], [0.02632589, 0.03713828, 0.0436463], [0.03388062, 0.03721975, 0.04309029], [0.04075766, 0.03675412, 0.04076063], [0.0462291, 0.0347469, 0.03646322], [0.05171755, 0.02535752, 0.02670867], [0.0729733, 763172e-8, -48769e-8], [0.04706828, 0.01651, 0.03109532], [0.04071712, 0.01476821, 0.03476944], [0.03269817, 0.01470658, 0.03731945], [0.02527572, 0.0161731, 0.03865444], [0.01970894, 0.01858504, 0.03961782], [0.01579543, 0.0209794, 0.04084997], [0.07664182, 673132e-8, -0.02435867], [0.01397041, -0.0134014, 0.05630378], [884838e-8, 658739e-8, 0.06233231], [767097e-8, -968036e-8, 0.07077932], [460213e-8, -0.01334107, 0.06787448], [748618e-8, -0.01067995, 0.06798303], [0.01236408, -0.01585569, 0.05480489], [387306e-8, -0.01409991, 0.06957705], [319925e-8, -0.01607932, 0.06508676], [0.01639633, 0.02556297, 0.03863737], [0.01255645, 0.02467143, 0.042038], [0.01031362, 0.02382662, 0.04615849], [0.04253081, 0.02772296, 0.03315305], [0.0453, 0.0291, 0.03339685]];

// node_modules/@geenee/bodyprocessors/dist/bodyprocessors.js
var s2 = class extends b0 {
  constructor() {
    super(...arguments), this["faceTracker"] = new q4d(), this["cameraAngleBase"] = 10 / 180 * Math["PI"];
  }
  async ["init"](F2, j2, K2) {
    return await this["faceTracker"]["init"](F2["token"], F2["root"], F2["cache"], F2["highP"], F2["mask"], F2["maskExt"], F2["maskSize"]), await this["faceTracker"]["prepare"](), super["init"](F2, j2, K2);
  }
  ["reset"]() {
    this["faceTracker"]["reset"](), super["reset"]();
  }
  ["dispose"]() {
    this["faceTracker"]["dispose"]();
  }
  async ["process"](F2, j2) {
    return { "faces": (await this["faceTracker"]["process"](F2, j2))["map"]((K2) => {
      const { keypoints: J2, mask: y0, score: y1 } = K2, y2 = K2 && this["params"]["transform"] ? this["faceTracker"]["align"](K2["keypoints"]) : void 0, y3 = y2 && this["params"]["metric"] ? this["faceTracker"]["metricPoints"]() : void 0, y4 = y2 && this["params"]["backproj"] ? this["faceTracker"]["backprojPoints"]() : void 0;
      return { "pixel": J2, "metric": y3, "backproj": y4, "transform": y2, "mask": y0, "score": y1 };
    }) };
  }
  ["setupVideo"](F2, j2) {
    super["setupVideo"](F2, j2), this["cameraAngle"] = this["cameraRatio"] >= 1 ? this["cameraAngleBase"] : 2 * Math["atan"](Math["tan"](0.5 * this["cameraAngleBase"]) / this["cameraRatio"]), this["faceTracker"]["setCamera"](this["cameraAngle"], this["cameraRatio"], 1), this["faceTracker"]["reset"]();
  }
};
var Z2 = class extends i {
  constructor(F2, j2 = x) {
    super(s2, F2, j2);
  }
};
var o2 = class extends b0 {
  constructor() {
    super(), this["poseTracker"] = new q4t(), this["cameraAngleBase"] = 15 / 180 * Math["PI"];
    const F2 = /iPhone|iPad|iPod/i["test"](navigator["userAgent"]);
    this["optimalSize"] = F2 ? 512 : 1024;
  }
  async ["init"](F2, j2, K2) {
    return await this["poseTracker"]["init"](F2["token"], F2["root"], F2["cache"], F2["mask"]), await this["poseTracker"]["prepare"](), super["init"](F2, j2, K2);
  }
  ["reset"]() {
    return this["poseTracker"]["reset"](), super["reset"]();
  }
  ["dispose"]() {
    this["poseTracker"]["dispose"]();
  }
  async ["process"](F2, j2) {
    return { "poses": (await this["poseTracker"]["process"](F2, j2))["map"]((K2) => ({ "points": S2((J2) => K2["keypoints"][N2[J2]]), "score": K2["score"], "mask": K2["mask"], "timestamp": j2, "debug": K2["debug"] })) };
  }
  ["setupVideo"](F2, j2) {
    super["setupVideo"](F2, j2), this["cameraAngle"] = this["cameraRatio"] >= 1 ? this["cameraAngleBase"] : 2 * Math["atan"](Math["tan"](0.5 * this["cameraAngleBase"]) / this["cameraRatio"]), this["poseTracker"]["setCamera"](this["cameraAngle"], this["cameraRatio"], 1), this["poseTracker"]["reset"]();
  }
};
var z2 = class extends i {
  constructor(F2, j2 = x) {
    super(o2, F2, j2);
  }
};
var r2 = ["nose", "eyeInnerL", "eyeL", "eyeOutterL", "eyeInnerR", "eyeR", "eyeOutterR", "earL", "earR", "mouthL", "mouthR", "shoulderL", "shoulderR", "elbowL", "elbowR", "wristL", "wristR", "pinkyL", "pinkyR", "indexL", "indexR", "thumbL", "thumbR", "hipL", "hipR", "kneeL", "kneeR", "ankleL", "ankleR", "heelL", "heelR", "footIndexL", "footIndexR"];
function q2(F2, j2) {
  return Object["fromEntries"](j2["map"]((K2) => [K2, F2(K2)]));
}
var C2 = (F2, j2) => q2(F2, j2);
var S2 = (F2) => q2(F2, r2);
var N2 = S2((F2) => r2["indexOf"](F2));
var R2 = class extends b0 {
  constructor() {
    super(...arguments), this["handTracker"] = new q51(), this["cameraAngleBase"] = 10 / 180 * Math["PI"];
  }
  async ["init"](F2, j2, K2) {
    return await this["handTracker"]["init"](F2["token"], F2["root"], F2["cache"], F2["wrist"]), await this["handTracker"]["prepare"](), super["init"](F2, j2, K2);
  }
  ["reset"]() {
    this["handTracker"]["reset"](), super["reset"]();
  }
  ["dispose"]() {
    this["handTracker"]["dispose"]();
  }
  async ["process"](F2, j2) {
    return { "hands": (await this["handTracker"]["process"](F2, j2))["map"]((K2) => ({ "points": K2["keypoints"], "score": K2["score"], "handedness": K2["handedness"], "phalanxes": K2["phalanxes"], "wrist": K2["wrist"], "debug": K2["debug"] })) };
  }
  ["setupVideo"](F2, j2) {
    super["setupVideo"](F2, j2), this["cameraAngle"] = this["cameraRatio"] >= 1 ? this["cameraAngleBase"] : 2 * Math["atan"](Math["tan"](0.5 * this["cameraAngleBase"]) / this["cameraRatio"]), this["handTracker"]["setCamera"](this["cameraAngle"], this["cameraRatio"], 1), this["handTracker"]["reset"]();
  }
};
var Y2 = class extends i {
  constructor(F2, j2 = x) {
    super(R2, F2, j2);
  }
};
var O2 = class extends b0 {
  constructor() {
    super(...arguments), this["maskTracker"] = new q52();
  }
  async ["init"](F2, j2, K2) {
    return await this["maskTracker"]["init"](F2["token"], F2["root"], F2["cache"], F2["smooth"], F2["masksm"]), await this["maskTracker"]["prepare"](), super["init"](F2, j2, K2);
  }
  ["reset"]() {
    this["maskTracker"]["reset"](), super["reset"]();
  }
  ["dispose"]() {
    this["maskTracker"]["dispose"]();
  }
  async ["process"](F2, j2) {
    return { "masks": (await this["maskTracker"]["process"](F2, j2))["map"]((K2) => ({ "mask": K2 })) };
  }
};
var U2 = class extends i {
  constructor(F2, j2 = x) {
    super(O2, F2, j2);
  }
};
var Q2 = class extends b0 {
  constructor() {
    super(...arguments), this["hairTracker"] = new qge();
  }
  async ["init"](F2, j2, K2) {
    return await this["hairTracker"]["init"](F2["token"], F2["root"], F2["cache"], F2["smooth"]), await this["hairTracker"]["prepare"](), super["init"](F2, j2, K2);
  }
  ["reset"]() {
    this["hairTracker"]["reset"](), super["reset"]();
  }
  ["dispose"]() {
    this["hairTracker"]["dispose"]();
  }
  async ["process"](F2, j2) {
    return { "masks": (await this["hairTracker"]["process"](F2, j2))["map"]((K2) => ({ "mask": K2 })) };
  }
};
var w2 = class extends i {
  constructor(F2, j2 = x) {
    super(Q2, F2, j2);
  }
};

export {
  qgc,
  qgX,
  qgG,
  s2 as s,
  Z2 as Z,
  o2 as o,
  z2 as z,
  r2 as r,
  q2 as q,
  C2 as C,
  S2 as S,
  N2 as N,
  R2 as R,
  Y2 as Y,
  O2 as O,
  U2 as U,
  Q2 as Q,
  w2 as w
};
//# sourceMappingURL=chunk-5JAPNPRW.js.map
