var A=Object['defineProperty'],R=Object['defineProperties'],e=Object['getOwnPropertyDescriptors'],I=Object['getOwnPropertySymbols'],a=Object['prototype']['hasOwnProperty'],S=Object['prototype']['propertyIsEnumerable'],D=(ZI,ZZ,ZU)=>ZZ in ZI?A(ZI,ZZ,{'enumerable':!0x0,'configurable':!0x0,'writable':!0x0,'value':ZU}):ZI[ZZ]=ZU,h=(ZI,ZZ)=>{for(var ZU in ZZ||(ZZ={}))a['call'](ZZ,ZU)&&D(ZI,ZU,ZZ[ZU]);if(I){for(var ZU of I(ZZ))S['call'](ZZ,ZU)&&D(ZI,ZU,ZZ[ZU]);}return ZI;},i=(ZI,ZZ)=>R(ZI,e(ZZ));import{SceneRenderer as l,ScenePlugin as m}from'@geenee/armature';import{WebGLRenderer as d}from'three/src/renderers/WebGLRenderer';import{Scene as u}from'three/src/scenes/Scene';import{PerspectiveCamera as w}from'three/src/cameras/PerspectiveCamera';import{OrthographicCamera as t}from'three/src/cameras/OrthographicCamera';import{Mesh as T}from'three/src/objects/Mesh';import{BufferGeometry as P}from'three/src/core/BufferGeometry';import{Texture as M}from'three/src/textures/Texture';import{Material as g}from'three/src/materials/Material';import{SRGBColorSpace as p,REVISION as b}from'three/src/constants';import*as r from'three';import{BufferAttribute as o,Vector3 as n,Vector2 as s,Plane as y,Line3 as c,Triangle as B,Sphere as x,Matrix4 as z,Box3 as Y,BackSide as v,DoubleSide as f,FrontSide as A0,Mesh as A1,UnsignedIntType as A2,FloatType as A3,DataTexture as A4,NearestFilter as A5,IntType as A6,UnsignedByteType as A7,UnsignedShortType as A8,ByteType as A9,ShortType as AA,RGBAFormat as AR,RGBAIntegerFormat as Ae,RGFormat as AI,RedFormat as AZ,RGIntegerFormat as AU,RedIntegerFormat as AW}from'three';import{meshReference as Aa,meshTriangles as AJ,meshUV as AS}from'@geenee/bodytracking';import{mapKeys as AD}from'@geenee/bodyprocessors';import{Quaternion as AG}from'three/src/math/Quaternion';import{Matrix4 as Ah}from'three/src/math/Matrix4';import{Vector3 as Ai}from'three/src/math/Vector3';import{Box3 as Al}from'three/src/math/Box3';import{CylinderGeometry as Am}from'three/src/geometries/CylinderGeometry';import{SphereGeometry as Ad}from'three/src/geometries/SphereGeometry';import{MeshBasicMaterial as Aq}from'three/src/materials/MeshBasicMaterial';import{ShaderMaterial as Aj}from'three/src/materials/ShaderMaterial';import{Vector2 as Au}from'three/src/math/Vector2';import{Color as Aw}from'three/src/math/Color';var Ak=Object['defineProperty'],AT=Object['getOwnPropertySymbols'],AP=Object['prototype']['hasOwnProperty'],AE=Object['prototype']['propertyIsEnumerable'],AM=(ZI,ZZ,ZU)=>ZZ in ZI?Ak(ZI,ZZ,{'enumerable':!0x0,'configurable':!0x0,'writable':!0x0,'value':ZU}):ZI[ZZ]=ZU,Ag=(ZI,ZZ)=>{for(var ZU in ZZ||(ZZ={}))AP['call'](ZZ,ZU)&&AM(ZI,ZU,ZZ[ZU]);if(AT){for(var ZU of AT(ZZ))AE['call'](ZZ,ZU)&&AM(ZI,ZU,ZZ[ZU]);}return ZI;};class AQ extends l{constructor(ZI,ZZ,ZU,ZW){super({'container':ZI,'mode':ZZ,'layerCount':0x2,'mirror':ZU});const Za=this['canvas']['layers'][0x1];this['renderer']=new d(Ag({'alpha':!0x0,'preserveDrawingBuffer':!0x0,'canvas':Za},ZW)),this['renderer']['setClearColor'](0x0,0x0),this['renderer']['setPixelRatio'](window['devicePixelRatio']),this['renderer']['setSize'](Za['clientWidth'],Za['clientHeight']),this['renderer']['outputColorSpace']=p,this['canvas']['on']('resize',()=>{this['renderer']['setSize'](Za['clientWidth'],Za['clientHeight']);}),this['scene']=new u(),this['scene']['background']=null,this['camera']=new w(this['cameraAngle'],0x1,0.02,0x14);}['updateScene'](){this['scene']&&this['renderer']['render'](this['scene'],this['camera']);}['setupCamera'](ZI,ZZ){super['setupCamera'](ZI,ZZ),this['camera']instanceof w&&(this['camera']['aspect']=this['cameraRatio'],this['camera']['fov']=this['cameraAngle']/Math['PI']*0xb4,this['camera']['updateProjectionMatrix']());}['setupVideo'](ZI,ZZ){super['setupVideo'](ZI,ZZ),this['camera']instanceof t&&(this['camera']['right']=this['videoSize']['width'],this['camera']['bottom']=this['videoSize']['height'],this['camera']['updateProjectionMatrix']());}['disposeObject'](ZI){const ZZ=(ZU,ZW)=>Array['isArray'](ZU)&&ZU['every'](Za=>Za instanceof ZW);ZI['removeFromParent'](),ZI['traverse'](ZU=>{ZU instanceof T&&(ZU['geometry']instanceof P&&ZU['geometry']['dispose'](),ZU['material']instanceof g&&ZU['material']['dispose'](),ZZ(ZU['material'],g)&&ZU['material']['forEach'](ZW=>{ZW['dispose']();for(const Za in ZW){const ZJ=ZW[Za];ZJ instanceof M&&ZJ['dispose']();}}));});}}class AX extends m{}class Ap extends AQ{}class Ab extends AX{}class Ao extends AQ{}class AO extends AX{}class AF extends AQ{}class AV extends AX{}class Ay extends AX{constructor(ZI,ZZ=!0x1){super(),this['node']=ZI,this['shapeScale']=ZZ;}async['update'](ZI,ZZ){var ZU;if(!this['loaded'])return;const ZW=(ZU=ZI['faces'][0x0])==null?void 0x0:ZU['transform'];if(!ZW)return this['node']['visible']=!0x1,super['update'](ZI,ZZ);const Za=new r['Vector3'](...ZW['translation']),ZJ=new r['Vector3']()['setScalar'](ZW['scale']),ZS=new r['Vector3'](...ZW['shapeScale'])['multiplyScalar'](ZW['scale']),ZD=new r['Quaternion'](...ZW['rotation']);return this['node']['visible']=!0x0,this['node']['setRotationFromQuaternion'](ZD),this['node']['position']['copy'](Za),this['node']['scale']['copy'](this['shapeScale']?ZS:ZJ),super['update'](ZI,ZZ);}}class Ac extends AX{constructor(ZI,ZZ=0x0,ZU=!0x1){super(),this['node']=ZI,this['facePoint']=ZZ,this['shapeScale']=ZU;}async['update'](ZI,ZZ){if(!this['loaded'])return;if(!this['node'])return super['update'](ZI,ZZ);const {transform:ZU=void 0x0,metric:ZW=void 0x0}=ZI['faces'][0x0]||{};if(!ZU||!ZW)return this['node']['visible']=!0x1,super['update'](ZI,ZZ);const Za=new r['Vector3'](...ZW[this['facePoint']]),ZJ=new r['Vector3']()['setScalar'](ZU['scale']),ZS=new r['Vector3'](...ZU['shapeScale'])['multiplyScalar'](ZU['scale']),ZD=new r['Quaternion'](...ZU['rotation']);return this['node']['visible']=!0x0,this['node']['setRotationFromQuaternion'](ZD),this['node']['position']['copy'](Za),this['node']['scale']['copy'](this['shapeScale']?ZS:ZJ),super['update'](ZI,ZZ);}}class AC extends AX{constructor(ZI){super(),this['mesh']=ZI,this['pointCont']=Aa['length'];}async['load'](ZI){this['loaded']||(await super['load'](ZI),await this['setMesh'](this['mesh']));}async['update'](ZI,ZZ){var ZU;if(!this['loaded'])return;if(!this['mesh'])return super['update'](ZI,ZZ);const ZW=(ZU=ZI['faces'][0x0])==null?void 0x0:ZU['metric'];if(!ZW)return this['mesh']['visible']=!0x1,super['update'](ZI,ZZ);this['mesh']['visible']=!0x0;let Za=this['mesh']['geometry']['getAttribute']('position');return ZW['slice'](0x0,this['pointCont'])['forEach']((ZJ,ZS)=>Za['setXYZ'](ZS,ZJ[0x0],ZJ[0x1],ZJ[0x2])),this['mesh']['geometry']['computeVertexNormals'](),Za['needsUpdate']=!0x0,super['update'](ZI,ZZ);}async['setMesh'](ZI){if(delete this['mesh'],this['mesh']=ZI,!this['loaded']||!ZI)return;const ZZ=new r['BufferGeometry']();ZZ['setIndex'](AJ),ZZ['setAttribute']('position',new r['Float32BufferAttribute'](Aa['flat'](),0x3)),ZZ['setAttribute']('uv',new r['Float32BufferAttribute'](AS['flat'](),0x2)),ZZ['computeVertexNormals'](),ZI['geometry']=ZZ;}}const AK=['hips','spine','spine1','spine2','neck','head','headEnd','shoulderL','shoulderR','armL','armR','forearmL','forearmR','handL','handR','uplegL','uplegR','legL','legR','footL','footR','toeL','toeR'];class AB extends Ab{constructor(ZI,ZZ={'spineCurve':0.5,'neckAdjust':0.01,'headRatio':0.32,'shouldersD':[0x0,-0.01,0.005]}){super(),this['node']=ZI,this['tune']=ZZ,this['avatarLength']=0x1,this['alignScore']=0.9,this['alignVisibility']=0.9;}async['load'](ZI){this['loaded']||(await super['load'](ZI),this['setNode'](this['node']));}['unload'](){this['loaded']&&(delete this['node'],delete this['skeletonNodes'],delete this['skeleton'],delete this['spineCurve'],super['unload']());}['setNode'](ZI){var ZZ;if(delete this['skeletonNodes'],delete this['skeleton'],delete this['spineCurve'],this['node']=ZI,!this['loaded']||!ZI)return;ZI['traverse'](Zg=>{!this['skeleton']&&Zg instanceof r['SkinnedMesh']&&(this['skeleton']=Zg['skeleton']);});const ZU=(ZZ=this['skeleton'])==null?void 0x0:ZZ['bones'];if(!ZU)return;const ZW=Zg=>ZU['find'](ZQ=>ZQ['name']['toLowerCase']()['endsWith'](Zg)),Za={'hips':ZW('hips'),'spine':ZW('spine'),'spine1':ZW('spine1'),'spine2':ZW('spine2'),'neck':ZW('neck'),'head':ZW('head'),'headEnd':ZW('headtop_end'),'shoulderL':ZW('leftshoulder'),'shoulderR':ZW('rightshoulder'),'armL':ZW('leftarm'),'armR':ZW('rightarm'),'forearmL':ZW('leftforearm'),'forearmR':ZW('rightforearm'),'handL':ZW('lefthand'),'handR':ZW('righthand'),'uplegL':ZW('leftupleg'),'uplegR':ZW('rightupleg'),'legL':ZW('leftleg'),'legR':ZW('rightleg'),'footL':ZW('leftfoot'),'footR':ZW('rightfoot'),'toeL':ZW('lefttoebase'),'toeR':ZW('righttoebase')};this['skeletonNodes']=Za;const ZJ=Za['hips']['getWorldPosition'](new r['Vector3']()),ZS=Za['armL']['getWorldPosition'](new r['Vector3']()),ZD=Za['armR']['getWorldPosition'](new r['Vector3']()),ZG=ZS['clone']()['lerp'](ZD,0.5)['sub'](ZJ)['length'](),Zh=ZS['clone']()['sub'](ZJ),Zl=ZD['clone']()['sub'](ZJ)['clone']()['cross'](Zh)['normalize'](),Zm=Za['spine']['getWorldPosition'](new r['Vector3']())['sub'](ZJ),Zd=Zm['dot'](Zl),Zq=Zm['clone']()['sub'](Zl['clone']()['multiplyScalar'](Zd))['length'](),Zj=Za['spine1']['getWorldPosition'](new r['Vector3']())['sub'](ZJ),Zu=Zj['dot'](Zl),Zw=Zj['clone']()['sub'](Zl['clone']()['multiplyScalar'](Zu))['length'](),Zk=Za['spine2']['getWorldPosition'](new r['Vector3']())['sub'](ZJ),ZT=Zk['dot'](Zl),ZP=Zk['clone']()['sub'](Zl['clone']()['multiplyScalar'](ZT))['length'](),ZE=Za['head']['getWorldPosition'](new r['Vector3']()),ZM=Za['headEnd']['getWorldPosition'](new r['Vector3']())['clone']()['sub'](ZE)['length']();this['avatarLength']=ZG,this['spineCurve']={'hips':[ZJ['x'],ZJ['y']],'spine':[Zq/ZG,Zd/ZG],'spine1':[Zw/ZG,Zu/ZG],'spine2':[ZP/ZG,ZT/ZG],'head':[ZM/ZG,0x0]},ZI['traverse'](Zg=>{Zg['frustumCulled']=!0x1;});}async['update'](ZI,ZZ){var ZU,ZW;const Za=(ZU=ZI['poses'][0x0])==null?void 0x0:ZU['points'],{node:ZJ,skeletonNodes:ZS,spineCurve:ZD}=this;if(!ZJ)return super['update'](ZI,ZZ);if(!ZS||!ZD||!Za)return ZJ['visible']=!0x1,super['update'](ZI,ZZ);const ZG=this['estimateBones'](Za,ZD);return ZJ['visible']=!0x0,(ZW=this['skeleton'])==null||ZW['pose'](),this['updateSpine'](ZG),this['updateHandL'](ZG,Za),this['updateHandR'](ZG,Za),this['updateLegL'](ZG,Za),this['updateLegR'](ZG,Za),super['update'](ZI,ZZ);}['updateSpine'](ZI){var ZZ;const {skeletonNodes:ZU}=this;if(!ZU)return;this['alignBone'](ZI['hips'],ZU['hips'],!0x1),this['alignBone'](ZI['spine'],ZU['spine']),this['alignBone'](ZI['spine1'],ZU['spine1']),this['alignBone'](ZI['spine2'],ZU['spine2']),this['alignBone'](ZI['neck'],ZU['neck'],!0x1),this['alignBone'](ZI['head'],ZU['head'],!0x1);const ZW=(ZZ=this['skeleton'])==null?void 0x0:ZZ['bones']['find'](Za=>Za['name']['endsWith']('HeadEnd'));if(ZW){const {head:Za,headEnd:ZJ}=ZI,ZS=ZJ['position']['clone']()['sub'](Za['position'])['length']();ZU['head']['scale']['setScalar'](1.05*ZS/ZW['position']['length']());}this['alignBone'](ZI['shoulderL'],ZU['shoulderL'],!0x1),this['alignBone'](ZI['shoulderR'],ZU['shoulderR'],!0x1);}['updateHandL'](ZI,ZZ){const {skeletonNodes:ZU}=this;if(!ZU)return;const {alignScore:ZW,alignVisibility:Za}=this;this['alignBone'](ZI['armL'],ZU['armL']),!(ZZ['elbowL']['score']<ZW&&ZZ['elbowL']['visibility']<Za)&&(this['alignBone'](ZI['forearmL'],ZU['forearmL']),this['alignBone'](ZI['handL'],ZU['handL']),ZU['handL']['scale']['setScalar'](0.95));}['updateHandR'](ZI,ZZ){const {skeletonNodes:ZU}=this;if(!ZU)return;const {alignScore:ZW,alignVisibility:Za}=this;this['alignBone'](ZI['armR'],ZU['armR']),!(ZZ['elbowR']['score']<ZW&&ZZ['elbowR']['visibility']<Za)&&(this['alignBone'](ZI['forearmR'],ZU['forearmR']),this['alignBone'](ZI['handR'],ZU['handR']),ZU['handR']['scale']['setScalar'](0.95));}['updateLegL'](ZI,ZZ){const {skeletonNodes:ZU}=this;if(!ZU)return;const {alignScore:ZW,alignVisibility:Za}=this;ZZ['hipL']['score']<ZW&&ZZ['hipL']['visibility']<Za||(this['alignBone'](ZI['uplegL'],ZU['uplegL'],!0x1),!(ZZ['kneeL']['score']<ZW&&ZZ['kneeL']['visibility']<Za)&&(this['alignBone'](ZI['legL'],ZU['legL']),!(ZZ['ankleL']['score']<ZW&&ZZ['ankleL']['visibility']<Za)&&(this['alignBone'](ZI['footL'],ZU['footL']),this['alignBone'](ZI['toeL'],ZU['toeL']))));}['updateLegR'](ZI,ZZ){const {skeletonNodes:ZU}=this;if(!ZU)return;const {alignScore:ZW,alignVisibility:Za}=this;ZZ['hipR']['score']<ZW&&ZZ['hipR']['visibility']<Za||(this['alignBone'](ZI['uplegR'],ZU['uplegR'],!0x1),!(ZZ['kneeR']['score']<ZW&&ZZ['kneeR']['visibility']<Za)&&(this['alignBone'](ZI['legR'],ZU['legR']),!(ZZ['ankleR']['score']<ZW&&ZZ['ankleR']['visibility']<Za)&&(this['alignBone'](ZI['footR'],ZU['footR']),this['alignBone'](ZI['toeR'],ZU['toeR']))));}['estimateBones'](ZI,ZZ){var ZU;const ZW=new r['Vector3'](...ZI['hipL']['metric']),Za=new r['Vector3'](...ZI['hipR']['metric']),ZJ=ZW['clone']()['lerp'](Za,0.5),ZS=ZW['clone']()['sub'](Za)['normalize'](),ZD=ZS['clone']()['negate'](),ZG=new r['Vector3'](...ZI['shoulderL']['metric']),Zh=new r['Vector3'](...ZI['shoulderR']['metric']),Zl=new r['Vector3'](...ZI['elbowL']['metric']),Zm=new r['Vector3'](...ZI['elbowR']['metric']),Zd=ZG['clone']()['lerp'](Zh,0.5),Zq=ZG['clone']()['sub'](Zh)['normalize'](),Zj=ZG['clone']()['sub'](ZJ),Zu=Zh['clone']()['sub'](ZJ)['clone']()['cross'](Zj)['normalize']();if(this['tune']['shouldersD']){const Uc=Zq['clone']()['multiplyScalar'](this['tune']['shouldersD'][0x0]),UC=Zd['clone']()['sub'](ZJ)['normalize']()['multiplyScalar'](this['tune']['shouldersD'][0x1])['add'](Zu['clone']()['multiplyScalar']((ZU=this['tune'])==null?void 0x0:ZU['shouldersD'][0x2]));ZG['add'](UC)['add'](Uc),Zh['add'](UC)['add'](Uc['clone']()['negate']());}const Zw=ZG['clone']()['lerp'](Zh,0.5),Zk=Zw['clone']()['sub'](ZJ)['normalize'](),ZT=Zl['clone']()['sub'](ZG)['normalize'](),ZP=Zm['clone']()['sub'](Zh)['normalize']();let ZE;if(this['tune']['neckAdjust']){const UK=Math['abs'](Zq['x']);ZE=Zk['clone']()['multiplyScalar'](UK*(Zk['dot'](ZT)*-this['tune']['neckAdjust']+Zk['dot'](ZP)*-this['tune']['neckAdjust'])),Zw['add'](ZE);}const ZM=Zw['clone']()['sub'](ZJ)['length'](),Zg=this['tune']['shoulderOffset']||0.2,ZQ=Zw['clone']()['lerp'](ZG,Zg),ZX=Zw['clone']()['lerp'](Zh,Zg),Zp=new r['Vector3'](...ZI['earL']['metric']),Zb=new r['Vector3'](...ZI['earR']['metric']),Zr=Zp['clone']()['lerp'](Zb,0.5),Zo=new r['Vector3'](...ZI['nose']['metric']),ZO=Zr['clone']()['sub'](Zo)['normalize'](),ZF=Zp['clone']()['sub'](Zb)['normalize'](),ZV=ZF['clone']()['cross'](ZO)['add'](ZO['clone']()['multiplyScalar'](0.05))['normalize'](),Zy=this['tune']['headRatio']||0.32,Zc=ZZ['head'][0x0]*ZM,ZC=Zr['clone']()['add'](ZV['clone']()['cross'](ZF)['multiplyScalar'](0.025)),ZK=ZC['clone']()['add'](ZV['clone']()['multiplyScalar'](-Zy*Zc)),ZB=ZC['clone']()['add'](ZV['clone']()['multiplyScalar']((0x1-Zy)*Zc)),Zx=ZK['clone']()['lerp'](ZB,0x2),Zz=Zq['clone']()['lerp'](ZF,0.5),ZY=ZE?ZG['clone']()['add'](ZE):ZG['clone'](),Zv=ZE?Zh['clone']()['add'](ZE):Zh['clone'](),Zf=ZW['clone']()['lerp'](ZY,ZZ['spine'][0x0]),ZH=Za['clone']()['lerp'](Zv,ZZ['spine'][0x0]),ZN=Zf['clone']()['lerp'](ZH,0.5),ZL=Zf['clone']()['sub'](ZH),U0=ZW['clone']()['lerp'](ZY,ZZ['spine1'][0x0]),U1=Za['clone']()['lerp'](Zv,ZZ['spine1'][0x0]),U2=U0['clone']()['lerp'](U1,0.5),U3=U0['clone']()['sub'](U1),U4=ZW['clone']()['lerp'](ZY,ZZ['spine2'][0x0]),U5=Za['clone']()['lerp'](Zv,ZZ['spine2'][0x0]),U6=U4['clone']()['lerp'](U5,0.5),U7=U0['clone']()['sub'](U5);if(this['tune']['spineCurve']){const UB=ZG['clone']()['sub'](ZJ),Ux=Zh['clone']()['sub'](ZJ)['clone']()['cross'](UB)['normalize'](),Uz=this['tune']['spineCurve']*ZM;ZN['add'](Ux['clone']()['multiplyScalar'](ZZ['spine'][0x1]*Uz)),U2['add'](Ux['clone']()['multiplyScalar'](ZZ['spine1'][0x1]*Uz)),U6['add'](Ux['clone']()['multiplyScalar'](ZZ['spine2'][0x1]*Uz));}const U8=new r['Vector3'](...ZI['wristL']['metric']),U9=U8['clone']()['sub'](Zl)['normalize']()['clone']()['sub'](ZT)['negate'](),UA=Zu['clone'](),UR=U9['clone']()['lerp'](UA,0.5),UI=new r['Vector3'](...ZI['indexL']['metric']),UZ=new r['Vector3'](...ZI['pinkyL']['metric']),UU=UI['clone']()['lerp'](UZ,0.5),UW=UZ['clone']()['sub'](UI),Ua=new r['Vector3'](...ZI['wristR']['metric']),UJ=Ua['clone']()['sub'](Zm)['normalize']()['clone']()['sub'](ZP),US=Zu['clone']()['negate'](),UD=UJ['clone']()['lerp'](US,0.5),UG=new r['Vector3'](...ZI['indexR']['metric']),Uh=new r['Vector3'](...ZI['pinkyR']['metric']),Ul=UG['clone']()['lerp'](Uh,0.5),Um=UG['clone']()['sub'](Uh),Ud=new r['Vector3'](...ZI['kneeL']['metric']),Uq=new r['Vector3'](...ZI['ankleL']['metric']),Uj=new r['Vector3'](...ZI['footIndexL']['metric']),Uu=new r['Vector3'](...ZI['heelL']['metric']),Uw=Uq['clone']()['sub'](Ud)['normalize'](),Uk=Uj['clone']()['sub'](Uu)['normalize'](),UT=Uw['clone']()['cross'](Uk)['normalize'](),UP=Uu['clone']()['lerp'](Uj,0.8),UE=ZD['clone']()['lerp'](UT,0.2),UM=ZD['clone']()['lerp'](UT,0.6),Ug=new r['Vector3'](...ZI['kneeR']['metric']),UQ=new r['Vector3'](...ZI['ankleR']['metric']),UX=new r['Vector3'](...ZI['footIndexR']['metric']),Up=new r['Vector3'](...ZI['heelR']['metric']),Ub=UQ['clone']()['sub'](Ug)['normalize'](),Uo=UX['clone']()['sub'](Up)['normalize'](),UO=Ub['clone']()['cross'](Uo)['normalize'](),UF=Up['clone']()['lerp'](UX,0.8),UV=ZD['clone']()['lerp'](UO,0.2),Uy=ZD['clone']()['lerp'](UO,0.6);return{'hips':this['estimateBone'](ZJ,ZN,ZS),'spine':this['estimateBone'](ZN,U2,ZL),'spine1':this['estimateBone'](U2,U6,U3),'spine2':this['estimateBone'](U6,Zw,U7),'neck':this['estimateBone'](Zw,ZK,Zz),'head':this['estimateBone'](ZK,ZB,ZF),'headEnd':this['estimateBone'](ZB,Zx,ZF),'shoulderL':this['estimateBone'](ZQ,ZG,UA),'armL':this['estimateBone'](ZG,Zl,UR),'forearmL':this['estimateBone'](Zl,U8,U9),'handL':this['estimateBone'](U8,UU,UW),'shoulderR':this['estimateBone'](ZX,Zh,US),'armR':this['estimateBone'](Zh,Zm,UD),'forearmR':this['estimateBone'](Zm,Ua,UJ),'handR':this['estimateBone'](Ua,Ul,Um),'uplegL':this['estimateBone'](ZW,Ud,UE),'legL':this['estimateBone'](Ud,Uq,UM),'footL':this['estimateBone'](Uq,UP,UT),'toeL':this['estimateBone'](UP,Uj,UT),'uplegR':this['estimateBone'](Za,Ug,UV),'legR':this['estimateBone'](Ug,UQ,Uy),'footR':this['estimateBone'](UQ,UF,UO),'toeR':this['estimateBone'](UF,UX,UO)};}['estimateBone'](ZI,ZZ,ZU){const ZW=ZZ['clone']()['sub'](ZI)['normalize'](),Za=ZU['clone']()['normalize']()['cross'](ZW)['normalize'](),ZJ=ZW['clone']()['cross'](Za);return{'position':ZI['clone'](),'rotation':new r['Quaternion']()['setFromRotationMatrix'](new r['Matrix4']()['makeBasis'](ZJ,ZW,Za))};}['alignBone'](ZI,ZZ,ZU=!0x0){let ZW=ZI['rotation']['clone'](),Za=ZI['position']['clone']();ZZ['parent']&&(ZW=ZZ['parent']['getWorldQuaternion'](new r['Quaternion']())['invert']()['multiply'](ZW),Za['applyMatrix4'](ZZ['parent']['matrixWorld']['clone']()['invert']()),ZU&&ZZ['parent']instanceof r['Bone']&&(ZZ['parent']['scale']['setScalar'](Za['length']()/ZZ['position']['length']()),ZZ['parent']['updateWorldMatrix'](!0x0,!0x0),Za=ZI['position']['clone']()['applyMatrix4'](ZZ['parent']['matrixWorld']['clone']()['invert']()))),ZZ['setRotationFromQuaternion'](ZW),ZZ['position']['copy'](Za),ZZ['updateWorldMatrix'](!0x0,!0x0);}}class Ax extends AB{constructor(ZI,ZZ,ZU={'spineCurve':0.5,'neckAdjust':0.01,'headRatio':0.32,'shouldersD':[0x0,-0.01,0.005]}){super(ZI,ZU),this['outfit']=ZZ;}['setNode'](ZI){super['setNode'](ZI);const {outfit:ZZ,node:ZU}=this;!ZZ||!ZU||ZU['traverse'](ZW=>{if(!(ZW instanceof r['Mesh']))return;const Za=ZJ=>ZJ==null?void 0x0:ZJ['some'](ZS=>typeof ZS=='string'?ZW['name']===ZS:ZS['test'](ZW['name']));if(Za(ZZ['occluders'])){ZW['material']['colorWrite']=!0x1,ZW['renderOrder']=-0x1;return;}if(Za(ZZ['hidden'])){ZW['visible']=!0x1;return;}});}['setOutfit'](ZI,ZZ){this['outfit']=ZZ,this['setNode'](ZI);}}class Az extends AB{constructor(ZI,ZZ,ZU,ZW,Za={'spineCurve':0.5,'neckAdjust':0.01,'headRatio':0.32,'shouldersD':[0x0,-0.01,0.005]}){super(ZI,Za),this['translation']=ZZ,this['rotation']=ZU,this['scale']=ZW;}async['update'](ZI,ZZ){var ZU;await super['update'](ZI,ZZ);const ZW=(ZU=ZI['poses'][0x0])==null?void 0x0:ZU['points'],{node:Za,translation:ZJ,rotation:ZS,scale:ZD}=this;!Za||!ZW||(ZJ&&Za['position']['add'](ZJ),ZS&&Za['setRotationFromQuaternion'](ZS),ZD&&Za['scale']['setScalar'](ZD));}['updateSpine'](ZI){const {skeletonNodes:ZZ}=this;ZZ&&(this['alignBone'](ZI['hips'],ZZ['hips']),this['alignBone'](ZI['spine'],ZZ['spine']),this['alignBone'](ZI['spine1'],ZZ['spine1']),this['alignBone'](ZI['spine2'],ZZ['spine2']),this['alignBone'](ZI['neck'],ZZ['neck']),this['alignBone'](ZI['head'],ZZ['head']),this['alignBone'](ZI['shoulderL'],ZZ['shoulderL']),this['alignBone'](ZI['shoulderR'],ZZ['shoulderR']));}['alignBone'](ZI,ZZ){let ZU=ZI['rotation']['clone']();ZZ['parent']&&(ZU=ZZ['parent']['getWorldQuaternion'](new r['Quaternion']())['invert']()['multiply'](ZU)),ZZ['setRotationFromQuaternion'](ZU),ZZ['updateWorldMatrix'](!0x0,!0x0);}}var AY;(ZI=>{function ZZ(Zh,Zl,Zm){return{'position':Zh['clone'](),'rotation':ZW(Zl['clone']()['sub'](Zh),Zm)};}ZI['estimateBoneYZ']=ZZ;function ZU(Zh,Zl,Zm){return{'position':Zh['clone'](),'rotation':Za(Zl['clone']()['sub'](Zh),Zm)};}ZI['estimateBoneYX']=ZU;function ZW(Zh,Zl){const Zm=Zh['clone']()['normalize'](),Zd=Zm['clone']()['cross'](Zl)['normalize'](),Zq=Zd['clone']()['cross'](Zm)['normalize']();return new AG()['setFromRotationMatrix'](new Ah()['makeBasis'](Zd,Zm,Zq));}ZI['estimateRotationYZ']=ZW;function Za(Zh,Zl){const Zm=Zh['clone']()['normalize'](),Zd=Zl['clone']()['cross'](Zm)['normalize'](),Zq=Zm['clone']()['cross'](Zd)['normalize']();return new AG()['setFromRotationMatrix'](new Ah()['makeBasis'](Zq,Zm,Zd));}ZI['estimateRotationYX']=Za;function ZJ(Zh,Zl){const Zm=Zh['clone']()['cross'](Zl);return new AG(Zm['x'],Zm['y'],Zm['z'],Math['sqrt'](0x1+Zh['dot'](Zl)))['normalize']();}ZI['rotationBetween']=ZJ;function ZS(Zh,Zl,Zm=!0x0){let Zd=Zh['position']['clone'](),Zq=Zh['rotation']['clone']();Zl['parent']&&(Zq=Zl['parent']['getWorldQuaternion'](new AG())['invert']()['multiply'](Zq),Zd['applyMatrix4'](Zl['parent']['matrixWorld']['clone']()['invert']()),Zm&&(Zl['parent']['scale']['setScalar'](Zd['length']()/Zl['position']['length']()),Zl['parent']['updateWorldMatrix'](!0x0,!0x0),Zd=Zh['position']['clone']()['applyMatrix4'](Zl['parent']['matrixWorld']['clone']()['invert']()))),Zl['setRotationFromQuaternion'](Zq),Zl['position']['copy'](Zd),Zl['updateWorldMatrix'](!0x0,!0x0);}ZI['alignBone']=ZS;function ZD(Zh,Zl,Zm=!0x0){let Zd=Zh['clone']();Zl['parent']&&(Zd['applyMatrix4'](Zl['parent']['matrixWorld']['clone']()['invert']()),Zm&&(Zl['parent']['scale']['setScalar'](Zd['length']()/Zl['position']['length']()),Zl['parent']['updateWorldMatrix'](!0x0,!0x0),Zd=Zh['clone']()['applyMatrix4'](Zl['parent']['matrixWorld']['clone']()['invert']()))),Zl['position']['copy'](Zd),Zl['updateWorldMatrix'](!0x0,!0x0);}ZI['positionBone']=ZD;function ZG(Zh,Zl){let Zm=Zh['clone']();Zl['parent']&&(Zm=Zl['parent']['getWorldQuaternion'](new AG())['invert']()['multiply'](Zm)),Zl['setRotationFromQuaternion'](Zm),Zl['updateWorldMatrix'](!0x0,!0x0);}ZI['rotateBone']=ZG;})(AY||(AY={}));function Av(ZI){return ZI['isMesh'];}function Af(ZI){return ZI['isSkinnedMesh'];}function AH(ZI){return ZI['isBone'];}function AN(ZI){return ZI['isCubeTexture'];}function AL(ZI){return ZI['isMeshStandardMaterial'];}function R0(ZI){return ZI['isMeshPhysicalMaterial'];}const R1=['hand','thumb0','thumb1','thumb2','thumb3','thumbEnd','index0','index1','index2','index3','indexEnd','middle0','middle1','middle2','middle3','middleEnd','ring0','ring1','ring2','ring3','ringEnd','pinky0','pinky1','pinky2','pinky3','pinkyEnd'],R2=(ZI,ZZ)=>AD(ZI,ZZ),R3=ZI=>R2(ZI,R1);class R4 extends AV{constructor(ZI){super(),this['node']=ZI,this['nodeOrigin']={'position':new Ai(0x0,0x0,-0x1),'rotation':new AG()};}async['load'](ZI){this['loaded']||(await super['load'](ZI),this['setNode'](this['node']));}['unload'](){this['loaded']&&(delete this['node'],delete this['skeletonNodes'],delete this['skeleton'],super['unload']());}['setNode'](ZI){var ZZ;if(delete this['skeletonNodes'],delete this['skeleton'],this['node']=ZI,!this['loaded']||!ZI)return;ZI['traverse'](Zd=>{!this['skeleton']&&Af(Zd)&&(this['skeleton']=Zd['skeleton']);});const ZU=(ZZ=this['skeleton'])==null?void 0x0:ZZ['bones'];if(!ZU)return;const ZW={'hand':'hand','thumb0':'thumb1','thumb1':'thumb2','thumb2':'thumb3','thumb3':'thumb4','thumbEnd':'thumb_tip','index0':'index1','index1':'index2','index2':'index3','index3':'index4','indexEnd':'index_tip','middle0':'middle1','middle1':'middle2','middle2':'middle3','middle3':'middle4','middleEnd':'middle_tip','ring0':'ring1','ring1':'ring2','ring2':'ring3','ring3':'ring4','ringEnd':'ring_tip','pinky0':'pinky1','pinky1':'pinky2','pinky2':'pinky3','pinky3':'pinky4','pinkyEnd':'pinky_tip'},Za=Zd=>ZU['find'](Zq=>Zq['name']['toLowerCase']()['endsWith'](ZW[Zd])),ZJ=R3(Zd=>Za(Zd));function ZS(Zd){return R1['every'](Zq=>Zd[Zq]!==void 0x0);}if(!ZS(ZJ))return;this['skeletonNodes']=ZJ,this['nodeOrigin']={'position':ZI['getWorldPosition'](new Ai())['sub'](ZJ['hand']['getWorldPosition'](new Ai()))['applyQuaternion'](ZJ['hand']['getWorldQuaternion'](new AG())['conjugate']()),'rotation':ZI['getWorldQuaternion'](new AG())['multiply'](ZJ['hand']['getWorldQuaternion'](new AG()['conjugate']()))};let ZD=new Al()['setFromObject'](ZI);const ZG=ZD['getCenter'](new Ai()),Zh=ZD['getSize'](new Ai()),Zl=Math['max'](Zh['x'],Zh['y'],Zh['z'])*1.1*0.5,Zm=new Al(ZG['clone']()['sub'](new Ai()['setScalar'](Zl)),ZG['clone']()['sub'](new Ai()['setScalar'](Zl)));ZI['traverse'](Zd=>{Av(Zd)&&(Zd['geometry']['boundingBox']=Zm);});}async['update'](ZI,ZZ){var ZU,ZW;if(!this['loaded']||!this['node'])return;const {points:Za=void 0x0,handedness:ZJ=0x0}=(ZU=ZI['hands'][0x0])!=null?ZU:{},{node:ZS,skeletonNodes:ZD}=this;if(!ZD||!Za)return ZS['visible']=!0x1,super['update'](ZI,ZZ);const ZG=this['estimateBones'](Za,ZJ),Zh={'position':ZG['hand']['position']['clone']()['add'](this['nodeOrigin']['position']['clone']()['applyQuaternion'](ZG['hand']['rotation'])),'rotation':ZG['hand']['rotation']['clone']()['multiply'](this['nodeOrigin']['rotation'])};return(ZW=this['skeleton'])==null||ZW['pose'](),AY['alignBone'](Zh,ZS,!0x1),this['updateFinger'](ZG['index'],[ZD['index0'],ZD['index1'],ZD['index2'],ZD['index3'],ZD['indexEnd']]),this['updateFinger'](ZG['ring'],[ZD['ring0'],ZD['ring1'],ZD['ring2'],ZD['ring3'],ZD['ringEnd']]),this['updateFinger'](ZG['middle'],[ZD['middle0'],ZD['middle1'],ZD['middle2'],ZD['middle3'],ZD['middleEnd']]),this['updateFinger'](ZG['pinky'],[ZD['pinky0'],ZD['pinky1'],ZD['pinky2'],ZD['pinky3'],ZD['pinkyEnd']]),this['updateFinger'](ZG['thumb'],[ZD['thumb0'],ZD['thumb1'],ZD['thumb2'],ZD['thumb3'],ZD['thumbEnd']]),ZS['visible']=!0x0,super['update'](ZI,ZZ);}['updateFinger'](ZI,ZZ){for(let ZU=0x0;ZU<ZI['length'];ZU++)AY['alignBone'](ZI[ZU],ZZ[ZU],ZU!==0x0);}['estimateBones'](ZI,ZZ){const ZU=ZI['map'](Zj=>new Ai(...Zj['metric'])),ZW=ZU[0x0],Za=new Ai()['lerpVectors'](ZU[0x5],ZU[0x11],0.5),ZJ=Za['clone']()['sub'](ZW)['normalize'](),ZS=ZU[0x11]['clone']()['sub'](ZU[0x5])['normalize']();ZZ<0x0&&ZS['negate']();const ZD=new Ai()['crossVectors'](ZJ,ZS),ZG=AY['estimateBoneYZ'](ZW,Za,ZD),Zh=this['estimateFinger']([ZU[0x5],ZU[0x6],ZU[0x7],ZU[0x8]],ZW,ZJ,ZS),Zl=this['estimateFinger']([ZU[0x9],ZU[0xa],ZU[0xb],ZU[0xc]],ZW,ZJ,ZS),Zm=this['estimateFinger']([ZU[0xd],ZU[0xe],ZU[0xf],ZU[0x10]],ZW,ZJ,ZS),Zd=this['estimateFinger']([ZU[0x11],ZU[0x12],ZU[0x13],ZU[0x14]],ZW,ZJ,ZS),Zq=this['estimateFinger']([ZU[0x1],ZU[0x2],ZU[0x3],ZU[0x4]],ZW,ZJ,ZD);return{'hand':ZG,'index':Zh,'middle':Zl,'ring':Zm,'pinky':Zd,'thumb':Zq};}['estimateFinger'](ZI,ZZ,ZU,ZW){let Za=ZZ,ZJ=ZU['clone'](),ZS=ZW['clone'](),ZD=[];for(let ZG=0x0;ZG<ZI['length'];ZG++){const Zh=ZI[ZG]['clone']()['sub'](Za)['normalize']();ZS['applyQuaternion'](AY['rotationBetween'](ZJ,Zh))['normalize'](),ZD['push'](AY['estimateBoneYZ'](Za,ZI[ZG],ZS)),ZJ=Zh,Za=ZI[ZG];}return ZD['push']({'position':Za,'rotation':ZD[ZD['length']-0x1]['rotation']}),ZD;}}class R5 extends AV{constructor(ZI){super(),this['geometry']=ZI;}['setGeometry'](ZI){this['geometry']=ZI;}static['buildGeometry'](ZI,ZZ){const ZU={'fingers':[]};for(let ZW=0x0;ZW<0x4;ZW++){const Za={'phalanxes':[],'joints':[]};for(let ZJ=0x0;ZJ<0x3;ZJ++){const ZS=new Am(0.5,0.5,0x1,0x80),ZD=new T(ZS,ZZ);ZD['renderOrder']=-0x1,ZD['name']='phalanx'+ZJ,ZI['add'](ZD),Za['phalanxes']['push'](ZD);}for(let ZG=0x0;ZG<0x4;ZG++){const Zh=new Ad(0.5,0x80,0x80),Zl=new T(Zh,ZZ);Zl['renderOrder']=-0x1,Zl['name']='joint'+ZG,ZI['add'](Zl),Za['joints']['push'](Zl);}ZU['fingers']['push'](Za);}return ZU;}async['update'](ZI,ZZ){var ZU;if(!this['loaded']||!this['geometry'])return;const {points:ZW=void 0x0,phalanxes:Za=void 0x0,handedness:ZJ=0x0}=(ZU=ZI['hands'][0x0])!=null?ZU:{};if(!ZW||!Za)return this['geometry']['fingers']['forEach'](ZD=>{ZD['phalanxes']['forEach'](ZG=>ZG['visible']=!0x1),ZD['joints']['forEach'](ZG=>ZG['visible']=!0x1);}),super['update'](ZI,ZZ);const ZS=this['estimateBones'](ZW,ZJ);return[ZS['index'],ZS['middle'],ZS['ring'],ZS['pinky']]['forEach']((ZD,ZG)=>{var Zh;const Zl=(Zh=this['geometry'])==null?void 0x0:Zh['fingers'][ZG];if(Zl){for(let Zm=0x0;Zm<0x3;Zm++){const Zd=ZD[Zm+0x1]['position']['distanceTo'](ZD[Zm+0x2]['position']),Zq=new Ai(...Za[Zm*0x4+ZG]['edges'][0x0])['distanceTo'](new Ai(...Za[Zm*0x4+ZG]['edges'][0x1]));Zl['phalanxes'][Zm]['position']['set'](...Za[Zm*0x4+ZG]['center']),Zl['phalanxes'][Zm]['setRotationFromQuaternion'](ZD[Zm+0x1]['rotation']),Zl['phalanxes'][Zm]['scale']['set'](Zq,Zd,Zq),Zl['phalanxes'][Zm]['visible']=!0x0,Zl['joints'][Zm]['position']['copy'](ZD[Zm+0x2]['position']),Zl['joints'][Zm]['scale']['setScalar'](Zq),Zl['joints'][Zm]['visible']=!0x0;}Zl['joints'][0x3]['position']['copy'](ZD[0x1]['position']),Zl['joints'][0x3]['scale']['setScalar'](Zl['joints'][0x0]['scale']['x']*1.05),Zl['joints'][0x3]['visible']=!0x0;}}),super['update'](ZI,ZZ);}['estimateBones'](ZI,ZZ){const ZU=ZI['map'](Zj=>new Ai(...Zj['metric'])),ZW=ZU[0x0],Za=new Ai()['lerpVectors'](ZU[0x5],ZU[0x11],0.5),ZJ=Za['clone']()['sub'](ZW)['normalize'](),ZS=ZU[0x11]['clone']()['sub'](ZU[0x5])['normalize']();ZZ<0x0&&ZS['negate']();const ZD=new Ai()['crossVectors'](ZJ,ZS),ZG=AY['estimateBoneYZ'](ZW,Za,ZD),Zh=this['estimateFinger']([ZU[0x5],ZU[0x6],ZU[0x7],ZU[0x8]],ZW,ZJ,ZS),Zl=this['estimateFinger']([ZU[0x9],ZU[0xa],ZU[0xb],ZU[0xc]],ZW,ZJ,ZS),Zm=this['estimateFinger']([ZU[0xd],ZU[0xe],ZU[0xf],ZU[0x10]],ZW,ZJ,ZS),Zd=this['estimateFinger']([ZU[0x11],ZU[0x12],ZU[0x13],ZU[0x14]],ZW,ZJ,ZS),Zq=this['estimateFinger']([ZU[0x1],ZU[0x2],ZU[0x3],ZU[0x4]],ZW,ZJ,ZD);return{'hand':ZG,'index':Zh,'middle':Zl,'ring':Zm,'pinky':Zd,'thumb':Zq};}['estimateFinger'](ZI,ZZ,ZU,ZW){let Za=ZZ,ZJ=ZU['clone'](),ZS=ZW['clone'](),ZD=[];for(let ZG=0x0;ZG<ZI['length'];ZG++){const Zh=ZI[ZG]['clone']()['sub'](Za)['normalize']();ZS['applyQuaternion'](AY['rotationBetween'](ZJ,Zh))['normalize'](),ZD['push'](AY['estimateBoneYZ'](Za,ZI[ZG],ZS)),ZJ=Zh,Za=ZI[ZG];}return ZD['push']({'position':Za,'rotation':ZD[ZD['length']-0x1]['rotation']}),ZD;}}class R6 extends AV{constructor(ZI,ZZ='ring'){super(),this['node']=ZI,this['finger']=ZZ;}['setNode'](ZI){this['node']=ZI;}async['update'](ZI,ZZ){var ZU;if(!this['loaded']||!this['node'])return;const {points:ZW=void 0x0,phalanxes:Za=void 0x0,handedness:ZJ=0x0}=(ZU=ZI['hands'][0x0])!=null?ZU:{};if(!ZW||!Za)return this['node']['visible']=!0x1,super['update'](ZI,ZZ);const ZS=this['estimateBones'](ZW,ZJ),ZD=Za[['index','middle','ring','pinky']['indexOf'](this['finger'])];return this['node']['position']['set'](...ZD['center']),this['node']['setRotationFromQuaternion'](ZS[0x1]['rotation']),this['node']['scale']['setScalar'](new Ai(...ZD['edges'][0x0])['distanceTo'](new Ai(...ZD['edges'][0x1]))),this['node']['visible']=!0x0,super['update'](ZI,ZZ);}['estimateBones'](ZI,ZZ){const ZU=ZI['map'](ZD=>new Ai(...ZD['metric'])),ZW=ZU[0x0],Za=new Ai()['lerpVectors'](ZU[0x5],ZU[0x11],0.5)['clone']()['sub'](ZW)['normalize'](),ZJ=ZU[0x11]['clone']()['sub'](ZU[0x5])['normalize']();ZZ<0x0&&ZJ['negate']();let ZS;switch(this['finger']){case'index':ZS=this['estimateFinger']([ZU[0x5],ZU[0x6],ZU[0x7],ZU[0x8]],ZW,Za,ZJ);break;case'middle':ZS=this['estimateFinger']([ZU[0x9],ZU[0xa],ZU[0xb],ZU[0xc]],ZW,Za,ZJ);break;case'ring':ZS=this['estimateFinger']([ZU[0xd],ZU[0xe],ZU[0xf],ZU[0x10]],ZW,Za,ZJ);break;case'pinky':ZS=this['estimateFinger']([ZU[0x11],ZU[0x12],ZU[0x13],ZU[0x14]],ZW,Za,ZJ);break;}return ZS;}['estimateFinger'](ZI,ZZ,ZU,ZW){let Za=ZZ,ZJ=ZU['clone'](),ZS=ZW['clone'](),ZD=[];for(let ZG=0x0;ZG<ZI['length'];ZG++){const Zh=ZI[ZG]['clone']()['sub'](Za)['normalize']();ZS['applyQuaternion'](AY['rotationBetween'](ZJ,Zh))['normalize'](),ZD['push'](AY['estimateBoneYZ'](Za,ZI[ZG],ZS)),ZJ=Zh,Za=ZI[ZG];}return ZD['push']({'position':Za,'rotation':ZD[ZD['length']-0x1]['rotation']}),ZD;}}class R7 extends AX{constructor(ZI,ZZ=-0x1){super(),this['node']=ZI,this['renderOrder']=ZZ;}async['load'](ZI){if(!this['loaded'])return this['node']['traverse'](ZZ=>{ZZ instanceof r['Mesh']&&(ZZ['material']['colorWrite']=!0x1),ZZ['renderOrder']=this['renderOrder'];}),super['load'](ZI);}}class R8 extends Aq{constructor(ZI='OccluderMaterial'){super({'colorWrite':!0x1,'name':ZI});}}const R9=0x0,RA=0x1,RR=0x2,RI=0x2,RZ=1.25,RU=0x1,RW=0x6*0x4+0x4+0x4,Ra=0xffff,RJ=Math['pow'](0x2,-0x18),RS=Symbol('SKIP_GENERATION');function RD(ZI){return ZI['index']?ZI['index']['count']:ZI['attributes']['position']['count'];}function RG(ZI){return RD(ZI)/0x3;}function Rh(ZI,ZZ=ArrayBuffer){return ZI>0xffff?new Uint32Array(new ZZ(0x4*ZI)):new Uint16Array(new ZZ(0x2*ZI));}function Rl(ZI,ZZ){if(!ZI['index']){const ZU=ZI['attributes']['position']['count'],ZW=ZZ['useSharedArrayBuffer']?SharedArrayBuffer:ArrayBuffer,Za=Rh(ZU,ZW);ZI['setIndex'](new o(Za,0x1));for(let ZJ=0x0;ZJ<ZU;ZJ++)Za[ZJ]=ZJ;}}function Rm(ZI){const ZZ=RG(ZI),ZU=ZI['drawRange'],ZW=ZU['start']/0x3,Za=(ZU['start']+ZU['count'])/0x3,ZJ=Math['max'](0x0,ZW),ZS=Math['min'](ZZ,Za)-ZJ;return[{'offset':Math['floor'](ZJ),'count':Math['floor'](ZS)}];}function Rd(ZI){if(!ZI['groups']||!ZI['groups']['length'])return Rm(ZI);const ZZ=[],ZU=new Set(),ZW=ZI['drawRange'],Za=ZW['start']/0x3,ZJ=(ZW['start']+ZW['count'])/0x3;for(const ZD of ZI['groups']){const ZG=ZD['start']/0x3,Zh=(ZD['start']+ZD['count'])/0x3;ZU['add'](Math['max'](Za,ZG)),ZU['add'](Math['min'](ZJ,Zh));}const ZS=Array['from'](ZU['values']())['sort']((Zl,Zm)=>Zl-Zm);for(let Zl=0x0;Zl<ZS['length']-0x1;Zl++){const Zm=ZS[Zl],Zd=ZS[Zl+0x1];ZZ['push']({'offset':Math['floor'](Zm),'count':Math['floor'](Zd-Zm)});}return ZZ;}function Rq(ZI){if(ZI['groups']['length']===0x0)return!0x1;const ZZ=RG(ZI),ZU=Rd(ZI)['sort']((ZJ,ZS)=>ZJ['offset']-ZS['offset']),ZW=ZU[ZU['length']-0x1];ZW['count']=Math['min'](ZZ-ZW['offset'],ZW['count']);let Za=0x0;return ZU['forEach'](({count:ZJ})=>Za+=ZJ),ZZ!==Za;}function Rj(ZI,ZZ,ZU,ZW,Za){let ZJ=0x1/0x0,ZS=0x1/0x0,ZD=0x1/0x0,ZG=-0x1/0x0,Zh=-0x1/0x0,Zl=-0x1/0x0,Zm=0x1/0x0,Zd=0x1/0x0,Zq=0x1/0x0,Zj=-0x1/0x0,Zu=-0x1/0x0,Zw=-0x1/0x0;for(let Zk=ZZ*0x6,ZT=(ZZ+ZU)*0x6;Zk<ZT;Zk+=0x6){const ZP=ZI[Zk+0x0],ZE=ZI[Zk+0x1],ZM=ZP-ZE,Zg=ZP+ZE;ZM<ZJ&&(ZJ=ZM),Zg>ZG&&(ZG=Zg),ZP<Zm&&(Zm=ZP),ZP>Zj&&(Zj=ZP);const ZQ=ZI[Zk+0x2],ZX=ZI[Zk+0x3],Zp=ZQ-ZX,Zb=ZQ+ZX;Zp<ZS&&(ZS=Zp),Zb>Zh&&(Zh=Zb),ZQ<Zd&&(Zd=ZQ),ZQ>Zu&&(Zu=ZQ);const Zr=ZI[Zk+0x4],Zo=ZI[Zk+0x5],ZO=Zr-Zo,ZF=Zr+Zo;ZO<ZD&&(ZD=ZO),ZF>Zl&&(Zl=ZF),Zr<Zq&&(Zq=Zr),Zr>Zw&&(Zw=Zr);}ZW[0x0]=ZJ,ZW[0x1]=ZS,ZW[0x2]=ZD,ZW[0x3]=ZG,ZW[0x4]=Zh,ZW[0x5]=Zl,Za[0x0]=Zm,Za[0x1]=Zd,Za[0x2]=Zq,Za[0x3]=Zj,Za[0x4]=Zu,Za[0x5]=Zw;}function Ru(ZI,ZZ=null,ZU=null,ZW=null){const Za=ZI['attributes']['position'],ZJ=ZI['index']?ZI['index']['array']:null,ZS=RG(ZI),ZD=Za['normalized'];let ZG;ZZ===null?(ZG=new Float32Array(ZS*0x6*0x4),ZU=0x0,ZW=ZS):(ZG=ZZ,ZU=ZU||0x0,ZW=ZW||ZS);const Zh=Za['array'],Zl=Za['offset']||0x0;let Zm=0x3;Za['isInterleavedBufferAttribute']&&(Zm=Za['data']['stride']);const Zd=['getX','getY','getZ'];for(let Zq=ZU;Zq<ZU+ZW;Zq++){const Zj=Zq*0x3,Zu=Zq*0x6;let Zw=Zj+0x0,Zk=Zj+0x1,ZT=Zj+0x2;ZJ&&(Zw=ZJ[Zw],Zk=ZJ[Zk],ZT=ZJ[ZT]),ZD||(Zw=Zw*Zm+Zl,Zk=Zk*Zm+Zl,ZT=ZT*Zm+Zl);for(let ZP=0x0;ZP<0x3;ZP++){let ZE,ZM,Zg;ZD?(ZE=Za[Zd[ZP]](Zw),ZM=Za[Zd[ZP]](Zk),Zg=Za[Zd[ZP]](ZT)):(ZE=Zh[Zw+ZP],ZM=Zh[Zk+ZP],Zg=Zh[ZT+ZP]);let ZQ=ZE;ZM<ZQ&&(ZQ=ZM),Zg<ZQ&&(ZQ=Zg);let ZX=ZE;ZM>ZX&&(ZX=ZM),Zg>ZX&&(ZX=Zg);const Zp=(ZX-ZQ)/0x2,Zb=ZP*0x2;ZG[Zu+Zb+0x0]=ZQ+Zp,ZG[Zu+Zb+0x1]=Zp+(Math['abs'](ZQ)+Zp)*RJ;}}return ZG;}function Rw(ZI,ZZ,ZU){return ZU['min']['x']=ZZ[ZI],ZU['min']['y']=ZZ[ZI+0x1],ZU['min']['z']=ZZ[ZI+0x2],ZU['max']['x']=ZZ[ZI+0x3],ZU['max']['y']=ZZ[ZI+0x4],ZU['max']['z']=ZZ[ZI+0x5],ZU;}function Rk(ZI){let ZZ=-0x1,ZU=-0x1/0x0;for(let ZW=0x0;ZW<0x3;ZW++){const Za=ZI[ZW+0x3]-ZI[ZW];Za>ZU&&(ZU=Za,ZZ=ZW);}return ZZ;}function RT(ZI,ZZ){ZZ['set'](ZI);}function RP(ZI,ZZ,ZU){let ZW,Za;for(let ZJ=0x0;ZJ<0x3;ZJ++){const ZS=ZJ+0x3;ZW=ZI[ZJ],Za=ZZ[ZJ],ZU[ZJ]=ZW<Za?ZW:Za,ZW=ZI[ZS],Za=ZZ[ZS],ZU[ZS]=ZW>Za?ZW:Za;}}function RE(ZI,ZZ,ZU){for(let ZW=0x0;ZW<0x3;ZW++){const Za=ZZ[ZI+0x2*ZW],ZJ=ZZ[ZI+0x2*ZW+0x1],ZS=Za-ZJ,ZD=Za+ZJ;ZS<ZU[ZW]&&(ZU[ZW]=ZS),ZD>ZU[ZW+0x3]&&(ZU[ZW+0x3]=ZD);}}function RM(ZI){const ZZ=ZI[0x3]-ZI[0x0],ZU=ZI[0x4]-ZI[0x1],ZW=ZI[0x5]-ZI[0x2];return 0x2*(ZZ*ZU+ZU*ZW+ZW*ZZ);}const Rg=0x20,RQ=(ZI,ZZ)=>ZI['candidate']-ZZ['candidate'],RX=new Array(Rg)['fill']()['map'](()=>({'count':0x0,'bounds':new Float32Array(0x6),'rightCacheBounds':new Float32Array(0x6),'leftCacheBounds':new Float32Array(0x6),'candidate':0x0})),Rp=new Float32Array(0x6);function Rb(ZI,ZZ,ZU,ZW,Za,ZJ){let ZS=-0x1,ZD=0x0;if(ZJ===R9)ZS=Rk(ZZ),ZS!==-0x1&&(ZD=(ZZ[ZS]+ZZ[ZS+0x3])/0x2);else{if(ZJ===RA)ZS=Rk(ZI),ZS!==-0x1&&(ZD=Ro(ZU,ZW,Za,ZS));else{if(ZJ===RR){const ZG=RM(ZI);let Zh=RZ*Za;const Zl=ZW*0x6,Zm=(ZW+Za)*0x6;for(let Zd=0x0;Zd<0x3;Zd++){const Zq=ZZ[Zd],Zj=(ZZ[Zd+0x3]-Zq)/Rg;if(Za<Rg/0x4){const Zu=[...RX];Zu['length']=Za;let Zw=0x0;for(let ZT=Zl;ZT<Zm;ZT+=0x6,Zw++){const ZP=Zu[Zw];ZP['candidate']=ZU[ZT+0x2*Zd],ZP['count']=0x0;const {bounds:ZE,leftCacheBounds:ZM,rightCacheBounds:Zg}=ZP;for(let ZQ=0x0;ZQ<0x3;ZQ++)Zg[ZQ]=0x1/0x0,Zg[ZQ+0x3]=-0x1/0x0,ZM[ZQ]=0x1/0x0,ZM[ZQ+0x3]=-0x1/0x0,ZE[ZQ]=0x1/0x0,ZE[ZQ+0x3]=-0x1/0x0;RE(ZT,ZU,ZE);}Zu['sort'](RQ);let Zk=Za;for(let ZX=0x0;ZX<Zk;ZX++){const Zp=Zu[ZX];for(;ZX+0x1<Zk&&Zu[ZX+0x1]['candidate']===Zp['candidate'];)Zu['splice'](ZX+0x1,0x1),Zk--;}for(let Zb=Zl;Zb<Zm;Zb+=0x6){const Zr=ZU[Zb+0x2*Zd];for(let Zo=0x0;Zo<Zk;Zo++){const ZO=Zu[Zo];Zr>=ZO['candidate']?RE(Zb,ZU,ZO['rightCacheBounds']):(RE(Zb,ZU,ZO['leftCacheBounds']),ZO['count']++);}}for(let ZF=0x0;ZF<Zk;ZF++){const ZV=Zu[ZF],Zy=ZV['count'],Zc=Za-ZV['count'],ZC=ZV['leftCacheBounds'],ZK=ZV['rightCacheBounds'];let ZB=0x0;Zy!==0x0&&(ZB=RM(ZC)/ZG);let Zx=0x0;Zc!==0x0&&(Zx=RM(ZK)/ZG);const Zz=RU+RZ*(ZB*Zy+Zx*Zc);Zz<Zh&&(ZS=Zd,Zh=Zz,ZD=ZV['candidate']);}}else{for(let Zf=0x0;Zf<Rg;Zf++){const ZH=RX[Zf];ZH['count']=0x0,ZH['candidate']=Zq+Zj+Zf*Zj;const ZN=ZH['bounds'];for(let ZL=0x0;ZL<0x3;ZL++)ZN[ZL]=0x1/0x0,ZN[ZL+0x3]=-0x1/0x0;}for(let U0=Zl;U0<Zm;U0+=0x6){let U1=~~((ZU[U0+0x2*Zd]-Zq)/Zj);U1>=Rg&&(U1=Rg-0x1);const U2=RX[U1];U2['count']++,RE(U0,ZU,U2['bounds']);}const ZY=RX[Rg-0x1];RT(ZY['bounds'],ZY['rightCacheBounds']);for(let U3=Rg-0x2;U3>=0x0;U3--){const U4=RX[U3],U5=RX[U3+0x1];RP(U4['bounds'],U5['rightCacheBounds'],U4['rightCacheBounds']);}let Zv=0x0;for(let U6=0x0;U6<Rg-0x1;U6++){const U7=RX[U6],U8=U7['count'],U9=U7['bounds'],UA=RX[U6+0x1]['rightCacheBounds'];U8!==0x0&&(Zv===0x0?RT(U9,Rp):RP(U9,Rp,Rp)),Zv+=U8;let UR=0x0,UI=0x0;Zv!==0x0&&(UR=RM(Rp)/ZG);const UZ=Za-Zv;UZ!==0x0&&(UI=RM(UA)/ZG);const UU=RU+RZ*(UR*Zv+UI*UZ);UU<Zh&&(ZS=Zd,Zh=UU,ZD=U7['candidate']);}}}}else console['warn']('MeshBVH:\x20Invalid\x20build\x20strategy\x20value\x20'+ZJ+'\x20used.');}}return{'axis':ZS,'pos':ZD};}function Ro(ZI,ZZ,ZU,ZW){let Za=0x0;for(let ZJ=ZZ,ZS=ZZ+ZU;ZJ<ZS;ZJ++)Za+=ZI[ZJ*0x6+ZW*0x2];return Za/ZU;}class RO{constructor(){this['boundingData']=new Float32Array(0x6);}}function RF(ZI,ZZ,ZU,ZW,Za,ZJ){let ZS=ZW,ZD=ZW+Za-0x1;const ZG=ZJ['pos'],Zh=ZJ['axis']*0x2;for(;;){for(;ZS<=ZD&&ZU[ZS*0x6+Zh]<ZG;)ZS++;for(;ZS<=ZD&&ZU[ZD*0x6+Zh]>=ZG;)ZD--;if(ZS<ZD){for(let Zl=0x0;Zl<0x3;Zl++){let Zm=ZZ[ZS*0x3+Zl];ZZ[ZS*0x3+Zl]=ZZ[ZD*0x3+Zl],ZZ[ZD*0x3+Zl]=Zm;}for(let Zd=0x0;Zd<0x6;Zd++){let Zq=ZU[ZS*0x6+Zd];ZU[ZS*0x6+Zd]=ZU[ZD*0x6+Zd],ZU[ZD*0x6+Zd]=Zq;}ZS++,ZD--;}else return ZS;}}function RV(ZI,ZZ,ZU,ZW,Za,ZJ){let ZS=ZW,ZD=ZW+Za-0x1;const ZG=ZJ['pos'],Zh=ZJ['axis']*0x2;for(;;){for(;ZS<=ZD&&ZU[ZS*0x6+Zh]<ZG;)ZS++;for(;ZS<=ZD&&ZU[ZD*0x6+Zh]>=ZG;)ZD--;if(ZS<ZD){let Zl=ZI[ZS];ZI[ZS]=ZI[ZD],ZI[ZD]=Zl;for(let Zm=0x0;Zm<0x6;Zm++){let Zd=ZU[ZS*0x6+Zm];ZU[ZS*0x6+Zm]=ZU[ZD*0x6+Zm],ZU[ZD*0x6+Zm]=Zd;}ZS++,ZD--;}else return ZS;}}function Ry(ZI,ZZ){return ZZ[ZI+0xf]===0xffff;}function Rc(ZI,ZZ){return ZZ[ZI+0x6];}function RC(ZI,ZZ){return ZZ[ZI+0xe];}function RK(ZI){return ZI+0x8;}function RB(ZI,ZZ){return ZZ[ZI+0x6];}function Rx(ZI,ZZ){return ZZ[ZI+0x7];}function Rz(ZI){return ZI;}let RY,Rv,Rf,RH;const RN=Math['pow'](0x2,0x20);function RL(ZI){return'count'in ZI?0x1:0x1+RL(ZI['left'])+RL(ZI['right']);}function e0(ZI,ZZ,ZU){return RY=new Float32Array(ZU),Rv=new Uint32Array(ZU),Rf=new Uint16Array(ZU),RH=new Uint8Array(ZU),e1(ZI,ZZ);}function e1(ZI,ZZ){const ZU=ZI/0x4,ZW=ZI/0x2,Za='count'in ZZ,ZJ=ZZ['boundingData'];for(let ZS=0x0;ZS<0x6;ZS++)RY[ZU+ZS]=ZJ[ZS];if(Za){if(ZZ['buffer']){const ZD=ZZ['buffer'];RH['set'](new Uint8Array(ZD),ZI);for(let ZG=ZI,Zh=ZI+ZD['byteLength'];ZG<Zh;ZG+=RW){const Zl=ZG/0x2;Ry(Zl,Rf)||(Rv[ZG/0x4+0x6]+=ZU);}return ZI+ZD['byteLength'];}else{const Zm=ZZ['offset'],Zd=ZZ['count'];return Rv[ZU+0x6]=Zm,Rf[ZW+0xe]=Zd,Rf[ZW+0xf]=Ra,ZI+RW;}}else{const Zq=ZZ['left'],Zj=ZZ['right'],Zu=ZZ['splitAxis'];let Zw;if(Zw=e1(ZI+RW,Zq),Zw/0x4>RN)throw new Error('MeshBVH:\x20Cannot\x20store\x20child\x20pointer\x20greater\x20than\x2032\x20bits.');return Rv[ZU+0x6]=Zw/0x4,Zw=e1(Zw,Zj),Rv[ZU+0x7]=Zu,Zw;}}function e2(ZI,ZZ){const ZU=(ZI['index']?ZI['index']['count']:ZI['attributes']['position']['count'])/0x3,ZW=ZU>0x2**0x10,Za=ZW?0x4:0x2,ZJ=ZZ?new SharedArrayBuffer(ZU*Za):new ArrayBuffer(ZU*Za),ZS=ZW?new Uint32Array(ZJ):new Uint16Array(ZJ);for(let ZD=0x0,ZG=ZS['length'];ZD<ZG;ZD++)ZS[ZD]=ZD;return ZS;}function e3(ZI,ZZ,ZU,ZW,Za){const {maxDepth:ZJ,verbose:ZS,maxLeafTris:ZD,strategy:ZG,onProgress:Zh,indirect:Zl}=Za,Zm=ZI['_indirectBuffer'],Zd=ZI['geometry'],Zq=Zd['index']?Zd['index']['array']:null,Zj=Zl?RV:RF,Zu=RG(Zd),Zw=new Float32Array(0x6);let Zk=!0x1;const ZT=new RO();return Rj(ZZ,ZU,ZW,ZT['boundingData'],Zw),ZE(ZT,ZU,ZW,Zw),ZT;function ZP(ZM){Zh&&Zh(ZM/Zu);}function ZE(ZM,Zg,ZQ,ZX=null,Zp=0x0){if(!Zk&&Zp>=ZJ&&(Zk=!0x0,ZS&&(console['warn']('MeshBVH:\x20Max\x20depth\x20of\x20'+ZJ+'\x20reached\x20when\x20generating\x20BVH.\x20Consider\x20increasing\x20maxDepth.'),console['warn'](Zd))),ZQ<=ZD||Zp>=ZJ)return ZP(Zg+ZQ),ZM['offset']=Zg,ZM['count']=ZQ,ZM;const Zb=Rb(ZM['boundingData'],ZX,ZZ,Zg,ZQ,ZG);if(Zb['axis']===-0x1)return ZP(Zg+ZQ),ZM['offset']=Zg,ZM['count']=ZQ,ZM;const Zr=Zj(Zm,Zq,ZZ,Zg,ZQ,Zb);if(Zr===Zg||Zr===Zg+ZQ)ZP(Zg+ZQ),ZM['offset']=Zg,ZM['count']=ZQ;else{ZM['splitAxis']=Zb['axis'];const Zo=new RO(),ZO=Zg,ZF=Zr-Zg;ZM['left']=Zo,Rj(ZZ,ZO,ZF,Zo['boundingData'],Zw),ZE(Zo,ZO,ZF,Zw,Zp+0x1);const ZV=new RO(),Zy=Zr,Zc=ZQ-ZF;ZM['right']=ZV,Rj(ZZ,Zy,Zc,ZV['boundingData'],Zw),ZE(ZV,Zy,Zc,Zw,Zp+0x1);}return ZM;}}function e4(ZI,ZZ){const ZU=ZI['geometry'];ZZ['indirect']&&(ZI['_indirectBuffer']=e2(ZU,ZZ['useSharedArrayBuffer']),Rq(ZU)&&!ZZ['verbose']&&console['warn']('MeshBVH:\x20Provided\x20geometry\x20contains\x20groups\x20that\x20do\x20not\x20fully\x20span\x20the\x20vertex\x20contents\x20while\x20using\x20the\x20\x22indirect\x22\x20option.\x20BVH\x20may\x20incorrectly\x20report\x20intersections\x20on\x20unrendered\x20portions\x20of\x20the\x20geometry.')),ZI['_indirectBuffer']||Rl(ZU,ZZ);const ZW=ZZ['useSharedArrayBuffer']?SharedArrayBuffer:ArrayBuffer,Za=Ru(ZU),ZJ=ZZ['indirect']?Rm(ZU):Rd(ZU);ZI['_roots']=ZJ['map'](ZS=>{const ZD=e3(ZI,Za,ZS['offset'],ZS['count'],ZZ),ZG=RL(ZD),Zh=new ZW(RW*ZG);return e0(0x0,ZD,Zh),Zh;});}class e5{constructor(){this['min']=0x1/0x0,this['max']=-0x1/0x0;}['setFromPointsField'](ZI,ZZ){let ZU=0x1/0x0,ZW=-0x1/0x0;for(let Za=0x0,ZJ=ZI['length'];Za<ZJ;Za++){const ZS=ZI[Za][ZZ];ZU=ZS<ZU?ZS:ZU,ZW=ZS>ZW?ZS:ZW;}this['min']=ZU,this['max']=ZW;}['setFromPoints'](ZI,ZZ){let ZU=0x1/0x0,ZW=-0x1/0x0;for(let Za=0x0,ZJ=ZZ['length'];Za<ZJ;Za++){const ZS=ZZ[Za],ZD=ZI['dot'](ZS);ZU=ZD<ZU?ZD:ZU,ZW=ZD>ZW?ZD:ZW;}this['min']=ZU,this['max']=ZW;}['isSeparated'](ZI){return this['min']>ZI['max']||ZI['min']>this['max'];}}e5['prototype']['setFromBox']=(function(){const ZI=new n();return function(ZZ,ZU){const ZW=ZU['min'],Za=ZU['max'];let ZJ=0x1/0x0,ZS=-0x1/0x0;for(let ZD=0x0;ZD<=0x1;ZD++)for(let ZG=0x0;ZG<=0x1;ZG++)for(let Zh=0x0;Zh<=0x1;Zh++){ZI['x']=ZW['x']*ZD+Za['x']*(0x1-ZD),ZI['y']=ZW['y']*ZG+Za['y']*(0x1-ZG),ZI['z']=ZW['z']*Zh+Za['z']*(0x1-Zh);const Zl=ZZ['dot'](ZI);ZJ=Math['min'](Zl,ZJ),ZS=Math['max'](Zl,ZS);}this['min']=ZJ,this['max']=ZS;};}());const e6=(function(){const ZI=new n(),ZZ=new n(),ZU=new n();return function(ZW,Za,ZJ){const ZS=ZW['start'],ZD=ZI,ZG=Za['start'],Zh=ZZ;ZU['subVectors'](ZS,ZG),ZI['subVectors'](ZW['end'],ZW['start']),ZZ['subVectors'](Za['end'],Za['start']);const Zl=ZU['dot'](Zh),Zm=Zh['dot'](ZD),Zd=Zh['dot'](Zh),Zq=ZU['dot'](ZD),Zj=ZD['dot'](ZD)*Zd-Zm*Zm;let Zu,Zw;Zj!==0x0?Zu=(Zl*Zm-Zq*Zd)/Zj:Zu=0x0,Zw=(Zl+Zu*Zm)/Zd,ZJ['x']=Zu,ZJ['y']=Zw;};}()),e7=(function(){const ZI=new s(),ZZ=new n(),ZU=new n();return function(ZW,Za,ZJ,ZS){e6(ZW,Za,ZI);let ZD=ZI['x'],ZG=ZI['y'];if(ZD>=0x0&&ZD<=0x1&&ZG>=0x0&&ZG<=0x1){ZW['at'](ZD,ZJ),Za['at'](ZG,ZS);return;}else{if(ZD>=0x0&&ZD<=0x1){ZG<0x0?Za['at'](0x0,ZS):Za['at'](0x1,ZS),ZW['closestPointToPoint'](ZS,!0x0,ZJ);return;}else{if(ZG>=0x0&&ZG<=0x1){ZD<0x0?ZW['at'](0x0,ZJ):ZW['at'](0x1,ZJ),Za['closestPointToPoint'](ZJ,!0x0,ZS);return;}else{let Zh;ZD<0x0?Zh=ZW['start']:Zh=ZW['end'];let Zl;ZG<0x0?Zl=Za['start']:Zl=Za['end'];const Zm=ZZ,Zd=ZU;if(ZW['closestPointToPoint'](Zl,!0x0,ZZ),Za['closestPointToPoint'](Zh,!0x0,ZU),Zm['distanceToSquared'](Zl)<=Zd['distanceToSquared'](Zh)){ZJ['copy'](Zm),ZS['copy'](Zl);return;}else{ZJ['copy'](Zh),ZS['copy'](Zd);return;}}}}};}()),e8=(function(){const ZI=new n(),ZZ=new n(),ZU=new y(),ZW=new c();return function(Za,ZJ){const {radius:ZS,center:ZD}=Za,{a:ZG,b:Zh,c:Zl}=ZJ;if(ZW['start']=ZG,ZW['end']=Zh,ZW['closestPointToPoint'](ZD,!0x0,ZI)['distanceTo'](ZD)<=ZS||(ZW['start']=ZG,ZW['end']=Zl,ZW['closestPointToPoint'](ZD,!0x0,ZI)['distanceTo'](ZD)<=ZS)||(ZW['start']=Zh,ZW['end']=Zl,ZW['closestPointToPoint'](ZD,!0x0,ZI)['distanceTo'](ZD)<=ZS))return!0x0;const Zm=ZJ['getPlane'](ZU);if(Math['abs'](Zm['distanceToPoint'](ZD))<=ZS){const Zd=Zm['projectPoint'](ZD,ZZ);if(ZJ['containsPoint'](Zd))return!0x0;}return!0x1;};}()),e9=1e-15;function eA(ZI){return Math['abs'](ZI)<e9;}class eR extends B{constructor(...ZI){super(...ZI),this['isExtendedTriangle']=!0x0,this['satAxes']=new Array(0x4)['fill']()['map'](()=>new n()),this['satBounds']=new Array(0x4)['fill']()['map'](()=>new e5()),this['points']=[this['a'],this['b'],this['c']],this['sphere']=new x(),this['plane']=new y(),this['needsUpdate']=!0x0;}['intersectsSphere'](ZI){return e8(ZI,this);}['update'](){const ZI=this['a'],ZZ=this['b'],ZU=this['c'],ZW=this['points'],Za=this['satAxes'],ZJ=this['satBounds'],ZS=Za[0x0],ZD=ZJ[0x0];this['getNormal'](ZS),ZD['setFromPoints'](ZS,ZW);const ZG=Za[0x1],Zh=ZJ[0x1];ZG['subVectors'](ZI,ZZ),Zh['setFromPoints'](ZG,ZW);const Zl=Za[0x2],Zm=ZJ[0x2];Zl['subVectors'](ZZ,ZU),Zm['setFromPoints'](Zl,ZW);const Zd=Za[0x3],Zq=ZJ[0x3];Zd['subVectors'](ZU,ZI),Zq['setFromPoints'](Zd,ZW),this['sphere']['setFromPoints'](this['points']),this['plane']['setFromNormalAndCoplanarPoint'](ZS,ZI),this['needsUpdate']=!0x1;}}eR['prototype']['closestPointToSegment']=(function(){const ZI=new n(),ZZ=new n(),ZU=new c();return function(ZW,Za=null,ZJ=null){const {start:ZS,end:ZD}=ZW,ZG=this['points'];let Zh,Zl=0x1/0x0;for(let Zm=0x0;Zm<0x3;Zm++){const Zd=(Zm+0x1)%0x3;ZU['start']['copy'](ZG[Zm]),ZU['end']['copy'](ZG[Zd]),e7(ZU,ZW,ZI,ZZ),Zh=ZI['distanceToSquared'](ZZ),Zh<Zl&&(Zl=Zh,Za&&Za['copy'](ZI),ZJ&&ZJ['copy'](ZZ));}return this['closestPointToPoint'](ZS,ZI),Zh=ZS['distanceToSquared'](ZI),Zh<Zl&&(Zl=Zh,Za&&Za['copy'](ZI),ZJ&&ZJ['copy'](ZS)),this['closestPointToPoint'](ZD,ZI),Zh=ZD['distanceToSquared'](ZI),Zh<Zl&&(Zl=Zh,Za&&Za['copy'](ZI),ZJ&&ZJ['copy'](ZD)),Math['sqrt'](Zl);};}()),eR['prototype']['intersectsTriangle']=(function(){const ZI=new eR(),ZZ=new Array(0x3),ZU=new Array(0x3),ZW=new e5(),Za=new e5(),ZJ=new n(),ZS=new n(),ZD=new n(),ZG=new n(),Zh=new n(),Zl=new c(),Zm=new c(),Zd=new c(),Zq=new n();function Zj(Zu,Zw,Zk){const ZT=Zu['points'];let ZP=0x0,ZE=-0x1;for(let ZM=0x0;ZM<0x3;ZM++){const {start:Zg,end:ZQ}=Zl;Zg['copy'](ZT[ZM]),ZQ['copy'](ZT[(ZM+0x1)%0x3]),Zl['delta'](ZS);const ZX=eA(Zw['distanceToPoint'](Zg));if(eA(Zw['normal']['dot'](ZS))&&ZX){Zk['copy'](Zl),ZP=0x2;break;}const Zp=Zw['intersectLine'](Zl,Zq);if(!Zp&&ZX&&Zq['copy'](Zg),(Zp||ZX)&&!eA(Zq['distanceTo'](ZQ))){if(ZP<=0x1)(ZP===0x1?Zk['start']:Zk['end'])['copy'](Zq),ZX&&(ZE=ZP);else{if(ZP>=0x2){(ZE===0x1?Zk['start']:Zk['end'])['copy'](Zq),ZP=0x2;break;}}if(ZP++,ZP===0x2&&ZE===-0x1)break;}}return ZP;}return function(Zu,Zw=null,Zk=!0x1){this['needsUpdate']&&this['update'](),Zu['isExtendedTriangle']?Zu['needsUpdate']&&Zu['update']():(ZI['copy'](Zu),ZI['update'](),Zu=ZI);const ZT=this['plane'],ZP=Zu['plane'];if(Math['abs'](ZT['normal']['dot'](ZP['normal']))>0x1-1e-10){const ZE=this['satBounds'],ZM=this['satAxes'];ZU[0x0]=Zu['a'],ZU[0x1]=Zu['b'],ZU[0x2]=Zu['c'];for(let ZX=0x0;ZX<0x4;ZX++){const Zp=ZE[ZX],Zb=ZM[ZX];if(ZW['setFromPoints'](Zb,ZU),Zp['isSeparated'](ZW))return!0x1;}const Zg=Zu['satBounds'],ZQ=Zu['satAxes'];ZZ[0x0]=this['a'],ZZ[0x1]=this['b'],ZZ[0x2]=this['c'];for(let Zr=0x0;Zr<0x4;Zr++){const Zo=Zg[Zr],ZO=ZQ[Zr];if(ZW['setFromPoints'](ZO,ZZ),Zo['isSeparated'](ZW))return!0x1;}for(let ZF=0x0;ZF<0x4;ZF++){const ZV=ZM[ZF];for(let Zy=0x0;Zy<0x4;Zy++){const Zc=ZQ[Zy];if(ZJ['crossVectors'](ZV,Zc),ZW['setFromPoints'](ZJ,ZZ),Za['setFromPoints'](ZJ,ZU),ZW['isSeparated'](Za))return!0x1;}}return Zw&&(Zk||console['warn']('ExtendedTriangle.intersectsTriangle:\x20Triangles\x20are\x20coplanar\x20which\x20does\x20not\x20support\x20an\x20output\x20edge.\x20Setting\x20edge\x20to\x200,\x200,\x200.'),Zw['start']['set'](0x0,0x0,0x0),Zw['end']['set'](0x0,0x0,0x0)),!0x0;}else{const ZC=Zj(this,ZP,Zm);if(ZC===0x1&&Zu['containsPoint'](Zm['end']))return Zw&&(Zw['start']['copy'](Zm['end']),Zw['end']['copy'](Zm['end'])),!0x0;if(ZC!==0x2)return!0x1;const ZK=Zj(Zu,ZT,Zd);if(ZK===0x1&&this['containsPoint'](Zd['end']))return Zw&&(Zw['start']['copy'](Zd['end']),Zw['end']['copy'](Zd['end'])),!0x0;if(ZK!==0x2)return!0x1;if(Zm['delta'](ZD),Zd['delta'](ZG),ZD['dot'](ZG)<0x0){let ZH=Zd['start'];Zd['start']=Zd['end'],Zd['end']=ZH;}const ZB=Zm['start']['dot'](ZD),Zx=Zm['end']['dot'](ZD),Zz=Zd['start']['dot'](ZD),ZY=Zd['end']['dot'](ZD),Zv=Zx<Zz,Zf=ZB<ZY;return ZB!==ZY&&Zz!==Zx&&Zv===Zf?!0x1:(Zw&&(Zh['subVectors'](Zm['start'],Zd['start']),Zh['dot'](ZD)>0x0?Zw['start']['copy'](Zm['start']):Zw['start']['copy'](Zd['start']),Zh['subVectors'](Zm['end'],Zd['end']),Zh['dot'](ZD)<0x0?Zw['end']['copy'](Zm['end']):Zw['end']['copy'](Zd['end'])),!0x0);}};}()),eR['prototype']['distanceToPoint']=(function(){const ZI=new n();return function(ZZ){return this['closestPointToPoint'](ZZ,ZI),ZZ['distanceTo'](ZI);};}()),eR['prototype']['distanceToTriangle']=(function(){const ZI=new n(),ZZ=new n(),ZU=['a','b','c'],ZW=new c(),Za=new c();return function(ZJ,ZS=null,ZD=null){const ZG=ZS||ZD?ZW:null;if(this['intersectsTriangle'](ZJ,ZG))return(ZS||ZD)&&(ZS&&ZG['getCenter'](ZS),ZD&&ZG['getCenter'](ZD)),0x0;let Zh=0x1/0x0;for(let Zl=0x0;Zl<0x3;Zl++){let Zm;const Zd=ZU[Zl],Zq=ZJ[Zd];this['closestPointToPoint'](Zq,ZI),Zm=Zq['distanceToSquared'](ZI),Zm<Zh&&(Zh=Zm,ZS&&ZS['copy'](ZI),ZD&&ZD['copy'](Zq));const Zj=this[Zd];ZJ['closestPointToPoint'](Zj,ZI),Zm=Zj['distanceToSquared'](ZI),Zm<Zh&&(Zh=Zm,ZS&&ZS['copy'](Zj),ZD&&ZD['copy'](ZI));}for(let Zu=0x0;Zu<0x3;Zu++){const Zw=ZU[Zu],Zk=ZU[(Zu+0x1)%0x3];ZW['set'](this[Zw],this[Zk]);for(let ZT=0x0;ZT<0x3;ZT++){const ZP=ZU[ZT],ZE=ZU[(ZT+0x1)%0x3];Za['set'](ZJ[ZP],ZJ[ZE]),e7(ZW,Za,ZI,ZZ);const ZM=ZI['distanceToSquared'](ZZ);ZM<Zh&&(Zh=ZM,ZS&&ZS['copy'](ZI),ZD&&ZD['copy'](ZZ));}}return Math['sqrt'](Zh);};}());class eI{constructor(ZI,ZZ,ZU){this['isOrientedBox']=!0x0,this['min']=new n(),this['max']=new n(),this['matrix']=new z(),this['invMatrix']=new z(),this['points']=new Array(0x8)['fill']()['map'](()=>new n()),this['satAxes']=new Array(0x3)['fill']()['map'](()=>new n()),this['satBounds']=new Array(0x3)['fill']()['map'](()=>new e5()),this['alignedSatBounds']=new Array(0x3)['fill']()['map'](()=>new e5()),this['needsUpdate']=!0x1,ZI&&this['min']['copy'](ZI),ZZ&&this['max']['copy'](ZZ),ZU&&this['matrix']['copy'](ZU);}['set'](ZI,ZZ,ZU){this['min']['copy'](ZI),this['max']['copy'](ZZ),this['matrix']['copy'](ZU),this['needsUpdate']=!0x0;}['copy'](ZI){this['min']['copy'](ZI['min']),this['max']['copy'](ZI['max']),this['matrix']['copy'](ZI['matrix']),this['needsUpdate']=!0x0;}}eI['prototype']['update']=(function(){return function(){const ZI=this['matrix'],ZZ=this['min'],ZU=this['max'],ZW=this['points'];for(let ZG=0x0;ZG<=0x1;ZG++)for(let Zh=0x0;Zh<=0x1;Zh++)for(let Zl=0x0;Zl<=0x1;Zl++){const Zm=0x1*ZG|0x2*Zh|0x4*Zl,Zd=ZW[Zm];Zd['x']=ZG?ZU['x']:ZZ['x'],Zd['y']=Zh?ZU['y']:ZZ['y'],Zd['z']=Zl?ZU['z']:ZZ['z'],Zd['applyMatrix4'](ZI);}const Za=this['satBounds'],ZJ=this['satAxes'],ZS=ZW[0x0];for(let Zq=0x0;Zq<0x3;Zq++){const Zj=ZJ[Zq],Zu=Za[Zq],Zw=0x1<<Zq,Zk=ZW[Zw];Zj['subVectors'](ZS,Zk),Zu['setFromPoints'](Zj,ZW);}const ZD=this['alignedSatBounds'];ZD[0x0]['setFromPointsField'](ZW,'x'),ZD[0x1]['setFromPointsField'](ZW,'y'),ZD[0x2]['setFromPointsField'](ZW,'z'),this['invMatrix']['copy'](this['matrix'])['invert'](),this['needsUpdate']=!0x1;};}()),eI['prototype']['intersectsBox']=(function(){const ZI=new e5();return function(ZZ){this['needsUpdate']&&this['update']();const ZU=ZZ['min'],ZW=ZZ['max'],Za=this['satBounds'],ZJ=this['satAxes'],ZS=this['alignedSatBounds'];if(ZI['min']=ZU['x'],ZI['max']=ZW['x'],ZS[0x0]['isSeparated'](ZI)||(ZI['min']=ZU['y'],ZI['max']=ZW['y'],ZS[0x1]['isSeparated'](ZI))||(ZI['min']=ZU['z'],ZI['max']=ZW['z'],ZS[0x2]['isSeparated'](ZI)))return!0x1;for(let ZD=0x0;ZD<0x3;ZD++){const ZG=ZJ[ZD],Zh=Za[ZD];if(ZI['setFromBox'](ZG,ZZ),Zh['isSeparated'](ZI))return!0x1;}return!0x0;};}()),eI['prototype']['intersectsTriangle']=(function(){const ZI=new eR(),ZZ=new Array(0x3),ZU=new e5(),ZW=new e5(),Za=new n();return function(ZJ){this['needsUpdate']&&this['update'](),ZJ['isExtendedTriangle']?ZJ['needsUpdate']&&ZJ['update']():(ZI['copy'](ZJ),ZI['update'](),ZJ=ZI);const ZS=this['satBounds'],ZD=this['satAxes'];ZZ[0x0]=ZJ['a'],ZZ[0x1]=ZJ['b'],ZZ[0x2]=ZJ['c'];for(let Zm=0x0;Zm<0x3;Zm++){const Zd=ZS[Zm],Zq=ZD[Zm];if(ZU['setFromPoints'](Zq,ZZ),Zd['isSeparated'](ZU))return!0x1;}const ZG=ZJ['satBounds'],Zh=ZJ['satAxes'],Zl=this['points'];for(let Zj=0x0;Zj<0x3;Zj++){const Zu=ZG[Zj],Zw=Zh[Zj];if(ZU['setFromPoints'](Zw,Zl),Zu['isSeparated'](ZU))return!0x1;}for(let Zk=0x0;Zk<0x3;Zk++){const ZT=ZD[Zk];for(let ZP=0x0;ZP<0x4;ZP++){const ZE=Zh[ZP];if(Za['crossVectors'](ZT,ZE),ZU['setFromPoints'](Za,ZZ),ZW['setFromPoints'](Za,Zl),ZU['isSeparated'](ZW))return!0x1;}}return!0x0;};}()),eI['prototype']['closestPointToPoint']=(function(){return function(ZI,ZZ){return this['needsUpdate']&&this['update'](),ZZ['copy'](ZI)['applyMatrix4'](this['invMatrix'])['clamp'](this['min'],this['max'])['applyMatrix4'](this['matrix']),ZZ;};}()),eI['prototype']['distanceToPoint']=(function(){const ZI=new n();return function(ZZ){return this['closestPointToPoint'](ZZ,ZI),ZZ['distanceTo'](ZI);};}()),eI['prototype']['distanceToBox']=(function(){const ZI=['x','y','z'],ZZ=new Array(0xc)['fill']()['map'](()=>new c()),ZU=new Array(0xc)['fill']()['map'](()=>new c()),ZW=new n(),Za=new n();return function(ZJ,ZS=0x0,ZD=null,ZG=null){if(this['needsUpdate']&&this['update'](),this['intersectsBox'](ZJ))return(ZD||ZG)&&(ZJ['getCenter'](Za),this['closestPointToPoint'](Za,ZW),ZJ['closestPointToPoint'](ZW,Za),ZD&&ZD['copy'](ZW),ZG&&ZG['copy'](Za)),0x0;const Zh=ZS*ZS,Zl=ZJ['min'],Zm=ZJ['max'],Zd=this['points'];let Zq=0x1/0x0;for(let Zu=0x0;Zu<0x8;Zu++){const Zw=Zd[Zu];Za['copy'](Zw)['clamp'](Zl,Zm);const Zk=Zw['distanceToSquared'](Za);if(Zk<Zq&&(Zq=Zk,ZD&&ZD['copy'](Zw),ZG&&ZG['copy'](Za),Zk<Zh))return Math['sqrt'](Zk);}let Zj=0x0;for(let ZT=0x0;ZT<0x3;ZT++)for(let ZP=0x0;ZP<=0x1;ZP++)for(let ZE=0x0;ZE<=0x1;ZE++){const ZM=(ZT+0x1)%0x3,Zg=(ZT+0x2)%0x3,ZQ=ZP<<ZM|ZE<<Zg,ZX=0x1<<ZT|ZP<<ZM|ZE<<Zg,Zp=Zd[ZQ],Zb=Zd[ZX];ZZ[Zj]['set'](Zp,Zb);const Zr=ZI[ZT],Zo=ZI[ZM],ZO=ZI[Zg],ZF=ZU[Zj],ZV=ZF['start'],Zy=ZF['end'];ZV[Zr]=Zl[Zr],ZV[Zo]=ZP?Zl[Zo]:Zm[Zo],ZV[ZO]=ZE?Zl[ZO]:Zm[Zo],Zy[Zr]=Zm[Zr],Zy[Zo]=ZP?Zl[Zo]:Zm[Zo],Zy[ZO]=ZE?Zl[ZO]:Zm[Zo],Zj++;}for(let Zc=0x0;Zc<=0x1;Zc++)for(let ZC=0x0;ZC<=0x1;ZC++)for(let ZK=0x0;ZK<=0x1;ZK++){Za['x']=Zc?Zm['x']:Zl['x'],Za['y']=ZC?Zm['y']:Zl['y'],Za['z']=ZK?Zm['z']:Zl['z'],this['closestPointToPoint'](Za,ZW);const ZB=Za['distanceToSquared'](ZW);if(ZB<Zq&&(Zq=ZB,ZD&&ZD['copy'](ZW),ZG&&ZG['copy'](Za),ZB<Zh))return Math['sqrt'](ZB);}for(let Zx=0x0;Zx<0xc;Zx++){const Zz=ZZ[Zx];for(let ZY=0x0;ZY<0xc;ZY++){const Zv=ZU[ZY];e7(Zz,Zv,ZW,Za);const Zf=ZW['distanceToSquared'](Za);if(Zf<Zq&&(Zq=Zf,ZD&&ZD['copy'](ZW),ZG&&ZG['copy'](Za),Zf<Zh))return Math['sqrt'](Zf);}}return Math['sqrt'](Zq);};}());class eZ{constructor(ZI){this['_getNewPrimitive']=ZI,this['_primitives']=[];}['getPrimitive'](){const ZI=this['_primitives'];return ZI['length']===0x0?this['_getNewPrimitive']():ZI['pop']();}['releasePrimitive'](ZI){this['_primitives']['push'](ZI);}}class eU extends eZ{constructor(){super(()=>new eR());}}const eW=new eU();class ea{constructor(){this['float32Array']=null,this['uint16Array']=null,this['uint32Array']=null;const ZI=[];let ZZ=null;this['setBuffer']=ZU=>{ZZ&&ZI['push'](ZZ),ZZ=ZU,this['float32Array']=new Float32Array(ZU),this['uint16Array']=new Uint16Array(ZU),this['uint32Array']=new Uint32Array(ZU);},this['clearBuffer']=()=>{ZZ=null,this['float32Array']=null,this['uint16Array']=null,this['uint32Array']=null,ZI['length']!==0x0&&this['setBuffer'](ZI['pop']());};}}const eJ=new ea();let eS,eD;const eG=[],eh=new eZ(()=>new Y());function el(ZI,ZZ,ZU,ZW,Za,ZJ){eS=eh['getPrimitive'](),eD=eh['getPrimitive'](),eG['push'](eS,eD),eJ['setBuffer'](ZI['_roots'][ZZ]);const ZS=em(0x0,ZI['geometry'],ZU,ZW,Za,ZJ);eJ['clearBuffer'](),eh['releasePrimitive'](eS),eh['releasePrimitive'](eD),eG['pop'](),eG['pop']();const ZD=eG['length'];return ZD>0x0&&(eD=eG[ZD-0x1],eS=eG[ZD-0x2]),ZS;}function em(ZI,ZZ,ZU,ZW,Za=null,ZJ=0x0,ZS=0x0){const {float32Array:ZD,uint16Array:ZG,uint32Array:Zh}=eJ;let Zl=ZI*0x2;if(Ry(Zl,ZG)){const Zm=Rc(ZI,Zh),Zd=RC(Zl,ZG);return Rw(ZI,ZD,eS),ZW(Zm,Zd,!0x1,ZS,ZJ+ZI,eS);}else{let Zq=function(ZO){const {uint16Array:ZF,uint32Array:ZV}=eJ;let Zy=ZO*0x2;for(;!Ry(Zy,ZF);)ZO=RK(ZO),Zy=ZO*0x2;return Rc(ZO,ZV);},Zj=function(ZO){const {uint16Array:ZF,uint32Array:ZV}=eJ;let Zy=ZO*0x2;for(;!Ry(Zy,ZF);)ZO=RB(ZO,ZV),Zy=ZO*0x2;return Rc(ZO,ZV)+RC(Zy,ZF);};const Zu=RK(ZI),Zw=RB(ZI,Zh);let Zk=Zu,ZT=Zw,ZP,ZE,ZM,Zg;if(Za&&(ZM=eS,Zg=eD,Rw(Zk,ZD,ZM),Rw(ZT,ZD,Zg),ZP=Za(ZM),ZE=Za(Zg),ZE<ZP)){Zk=Zw,ZT=Zu;const ZO=ZP;ZP=ZE,ZE=ZO,ZM=Zg;}ZM||(ZM=eS,Rw(Zk,ZD,ZM));const ZQ=Ry(Zk*0x2,ZG),ZX=ZU(ZM,ZQ,ZP,ZS+0x1,ZJ+Zk);let Zp;if(ZX===RI){const ZF=Zq(Zk),ZV=Zj(Zk)-ZF;Zp=ZW(ZF,ZV,!0x0,ZS+0x1,ZJ+Zk,ZM);}else Zp=ZX&&em(Zk,ZZ,ZU,ZW,Za,ZJ,ZS+0x1);if(Zp)return!0x0;Zg=eD,Rw(ZT,ZD,Zg);const Zb=Ry(ZT*0x2,ZG),Zr=ZU(Zg,Zb,ZE,ZS+0x1,ZJ+ZT);let Zo;if(Zr===RI){const Zy=Zq(ZT),Zc=Zj(ZT)-Zy;Zo=ZW(Zy,Zc,!0x0,ZS+0x1,ZJ+ZT,Zg);}else Zo=Zr&&em(ZT,ZZ,ZU,ZW,Za,ZJ,ZS+0x1);return!!Zo;}}const ed=new n(),eq=new n();function ej(ZI,ZZ,ZU={},ZW=0x0,Za=0x1/0x0){const ZJ=ZW*ZW,ZS=Za*Za;let ZD=0x1/0x0,ZG=null;if(ZI['shapecast']({'boundsTraverseOrder':Zl=>(ed['copy'](ZZ)['clamp'](Zl['min'],Zl['max']),ed['distanceToSquared'](ZZ)),'intersectsBounds':(Zl,Zm,Zd)=>Zd<ZD&&Zd<ZS,'intersectsTriangle':(Zl,Zm)=>{Zl['closestPointToPoint'](ZZ,ed);const Zd=ZZ['distanceToSquared'](ed);return Zd<ZD&&(eq['copy'](ed),ZD=Zd,ZG=Zm),Zd<ZJ;}}),ZD===0x1/0x0)return null;const Zh=Math['sqrt'](ZD);return ZU['point']?ZU['point']['copy'](eq):ZU['point']=eq['clone'](),ZU['distance']=Zh,ZU['faceIndex']=ZG,ZU;}const eu=new n(),ew=new n(),ek=new n(),et=new s(),eT=new s(),eP=new s(),eE=new n(),eM=new n(),eg=new n(),eQ=new n();function eX(ZI,ZZ,ZU,ZW,Za,ZJ,ZS,ZD){let ZG;if(ZJ===v?ZG=ZI['intersectTriangle'](ZW,ZU,ZZ,!0x0,Za):ZG=ZI['intersectTriangle'](ZZ,ZU,ZW,ZJ!==f,Za),ZG===null)return null;const Zh=ZI['origin']['distanceTo'](Za);return Zh<ZS||Zh>ZD?null:{'distance':Zh,'point':Za['clone']()};}function ep(ZI,ZZ,ZU,ZW,Za,ZJ,ZS,ZD,ZG,Zh,Zl){eu['fromBufferAttribute'](ZZ,ZJ),ew['fromBufferAttribute'](ZZ,ZS),ek['fromBufferAttribute'](ZZ,ZD);const Zm=eX(ZI,eu,ew,ek,eQ,ZG,Zh,Zl);if(Zm){ZW&&(et['fromBufferAttribute'](ZW,ZJ),eT['fromBufferAttribute'](ZW,ZS),eP['fromBufferAttribute'](ZW,ZD),Zm['uv']=B['getInterpolation'](eQ,eu,ew,ek,et,eT,eP,new s())),Za&&(et['fromBufferAttribute'](Za,ZJ),eT['fromBufferAttribute'](Za,ZS),eP['fromBufferAttribute'](Za,ZD),Zm['uv1']=B['getInterpolation'](eQ,eu,ew,ek,et,eT,eP,new s())),ZU&&(eE['fromBufferAttribute'](ZU,ZJ),eM['fromBufferAttribute'](ZU,ZS),eg['fromBufferAttribute'](ZU,ZD),Zm['normal']=B['getInterpolation'](eQ,eu,ew,ek,eE,eM,eg,new n()),Zm['normal']['dot'](ZI['direction'])>0x0&&Zm['normal']['multiplyScalar'](-0x1));const Zd={'a':ZJ,'b':ZS,'c':ZD,'normal':new n(),'materialIndex':0x0};B['getNormal'](eu,ew,ek,Zd['normal']),Zm['face']=Zd,Zm['faceIndex']=ZJ;}return Zm;}function eb(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const ZD=ZW*0x3;let ZG=ZD+0x0,Zh=ZD+0x1,Zl=ZD+0x2;const Zm=ZI['index'];ZI['index']&&(ZG=Zm['getX'](ZG),Zh=Zm['getX'](Zh),Zl=Zm['getX'](Zl));const {position:Zd,normal:Zq,uv:Zj,uv1:Zu}=ZI['attributes'],Zw=ep(ZU,Zd,Zq,Zj,Zu,ZG,Zh,Zl,ZZ,ZJ,ZS);return Zw?(Zw['faceIndex']=ZW,Za&&Za['push'](Zw),Zw):null;}function eo(ZI,ZZ,ZU,ZW){const Za=ZI['a'],ZJ=ZI['b'],ZS=ZI['c'];let ZD=ZZ,ZG=ZZ+0x1,Zh=ZZ+0x2;ZU&&(ZD=ZU['getX'](ZD),ZG=ZU['getX'](ZG),Zh=ZU['getX'](Zh)),Za['x']=ZW['getX'](ZD),Za['y']=ZW['getY'](ZD),Za['z']=ZW['getZ'](ZD),ZJ['x']=ZW['getX'](ZG),ZJ['y']=ZW['getY'](ZG),ZJ['z']=ZW['getZ'](ZG),ZS['x']=ZW['getX'](Zh),ZS['y']=ZW['getY'](Zh),ZS['z']=ZW['getZ'](Zh);}function eO(ZI,ZZ,ZU,ZW,Za,ZJ,ZS,ZD){const {geometry:ZG,_indirectBuffer:Zh}=ZI;for(let Zl=ZW,Zm=ZW+Za;Zl<Zm;Zl++)eb(ZG,ZZ,ZU,Zl,ZJ,ZS,ZD);}function eF(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const {geometry:ZD,_indirectBuffer:ZG}=ZI;let Zh=0x1/0x0,Zl=null;for(let Zm=ZW,Zd=ZW+Za;Zm<Zd;Zm++){let Zq;Zq=eb(ZD,ZZ,ZU,Zm,null,ZJ,ZS),Zq&&Zq['distance']<Zh&&(Zl=Zq,Zh=Zq['distance']);}return Zl;}function eV(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const {geometry:ZD}=ZU,{index:ZG}=ZD,Zh=ZD['attributes']['position'];for(let Zl=ZI,Zm=ZZ+ZI;Zl<Zm;Zl++){let Zd;if(Zd=Zl,eo(ZS,Zd*0x3,ZG,Zh),ZS['needsUpdate']=!0x0,ZW(ZS,Zd,Za,ZJ))return!0x0;}return!0x1;}function ey(ZI,ZZ=null){ZZ&&Array['isArray'](ZZ)&&(ZZ=new Set(ZZ));const ZU=ZI['geometry'],ZW=ZU['index']?ZU['index']['array']:null,Za=ZU['attributes']['position'];let ZJ,ZS,ZD,ZG,Zh=0x0;const Zl=ZI['_roots'];for(let Zd=0x0,Zq=Zl['length'];Zd<Zq;Zd++)ZJ=Zl[Zd],ZS=new Uint32Array(ZJ),ZD=new Uint16Array(ZJ),ZG=new Float32Array(ZJ),Zm(0x0,Zh),Zh+=ZJ['byteLength'];function Zm(Zj,Zu,Zw=!0x1){const Zk=Zj*0x2;if(ZD[Zk+0xf]===Ra){const ZT=ZS[Zj+0x6],ZP=ZD[Zk+0xe];let ZE=0x1/0x0,ZM=0x1/0x0,Zg=0x1/0x0,ZQ=-0x1/0x0,ZX=-0x1/0x0,Zp=-0x1/0x0;for(let Zb=0x3*ZT,Zr=0x3*(ZT+ZP);Zb<Zr;Zb++){let Zo=ZW[Zb];const ZO=Za['getX'](Zo),ZF=Za['getY'](Zo),ZV=Za['getZ'](Zo);ZO<ZE&&(ZE=ZO),ZO>ZQ&&(ZQ=ZO),ZF<ZM&&(ZM=ZF),ZF>ZX&&(ZX=ZF),ZV<Zg&&(Zg=ZV),ZV>Zp&&(Zp=ZV);}return ZG[Zj+0x0]!==ZE||ZG[Zj+0x1]!==ZM||ZG[Zj+0x2]!==Zg||ZG[Zj+0x3]!==ZQ||ZG[Zj+0x4]!==ZX||ZG[Zj+0x5]!==Zp?(ZG[Zj+0x0]=ZE,ZG[Zj+0x1]=ZM,ZG[Zj+0x2]=Zg,ZG[Zj+0x3]=ZQ,ZG[Zj+0x4]=ZX,ZG[Zj+0x5]=Zp,!0x0):!0x1;}else{const Zy=Zj+0x8,Zc=ZS[Zj+0x6],ZC=Zy+Zu,ZK=Zc+Zu;let ZB=Zw,Zx=!0x1,Zz=!0x1;ZZ?ZB||(Zx=ZZ['has'](ZC),Zz=ZZ['has'](ZK),ZB=!Zx&&!Zz):(Zx=!0x0,Zz=!0x0);const ZY=ZB||Zx,Zv=ZB||Zz;let Zf=!0x1;ZY&&(Zf=Zm(Zy,Zu,ZB));let ZH=!0x1;Zv&&(ZH=Zm(Zc,Zu,ZB));const ZN=Zf||ZH;if(ZN)for(let ZL=0x0;ZL<0x3;ZL++){const U0=Zy+ZL,U1=Zc+ZL,U2=ZG[U0],U3=ZG[U0+0x3],U4=ZG[U1],U5=ZG[U1+0x3];ZG[Zj+ZL]=U2<U4?U2:U4,ZG[Zj+ZL+0x3]=U3>U5?U3:U5;}return ZN;}}}function ec(ZI,ZZ,ZU,ZW,Za){let ZJ,ZS,ZD,ZG,Zh,Zl;const Zm=0x1/ZU['direction']['x'],Zd=0x1/ZU['direction']['y'],Zq=0x1/ZU['direction']['z'],Zj=ZU['origin']['x'],Zu=ZU['origin']['y'],Zw=ZU['origin']['z'];let Zk=ZZ[ZI],ZT=ZZ[ZI+0x3],ZP=ZZ[ZI+0x1],ZE=ZZ[ZI+0x3+0x1],ZM=ZZ[ZI+0x2],Zg=ZZ[ZI+0x3+0x2];return Zm>=0x0?(ZJ=(Zk-Zj)*Zm,ZS=(ZT-Zj)*Zm):(ZJ=(ZT-Zj)*Zm,ZS=(Zk-Zj)*Zm),Zd>=0x0?(ZD=(ZP-Zu)*Zd,ZG=(ZE-Zu)*Zd):(ZD=(ZE-Zu)*Zd,ZG=(ZP-Zu)*Zd),ZJ>ZG||ZD>ZS||((ZD>ZJ||isNaN(ZJ))&&(ZJ=ZD),(ZG<ZS||isNaN(ZS))&&(ZS=ZG),Zq>=0x0?(Zh=(ZM-Zw)*Zq,Zl=(Zg-Zw)*Zq):(Zh=(Zg-Zw)*Zq,Zl=(ZM-Zw)*Zq),ZJ>Zl||Zh>ZS)?!0x1:((Zh>ZJ||ZJ!==ZJ)&&(ZJ=Zh),(Zl<ZS||ZS!==ZS)&&(ZS=Zl),ZJ<=Za&&ZS>=ZW);}function eC(ZI,ZZ,ZU,ZW,Za,ZJ,ZS,ZD){const {geometry:ZG,_indirectBuffer:Zh}=ZI;for(let Zl=ZW,Zm=ZW+Za;Zl<Zm;Zl++){let Zd=Zh?Zh[Zl]:Zl;eb(ZG,ZZ,ZU,Zd,ZJ,ZS,ZD);}}function eK(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const {geometry:ZD,_indirectBuffer:ZG}=ZI;let Zh=0x1/0x0,Zl=null;for(let Zm=ZW,Zd=ZW+Za;Zm<Zd;Zm++){let Zq;Zq=eb(ZD,ZZ,ZU,ZG?ZG[Zm]:Zm,null,ZJ,ZS),Zq&&Zq['distance']<Zh&&(Zl=Zq,Zh=Zq['distance']);}return Zl;}function eB(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const {geometry:ZD}=ZU,{index:ZG}=ZD,Zh=ZD['attributes']['position'];for(let Zl=ZI,Zm=ZZ+ZI;Zl<Zm;Zl++){let Zd;if(Zd=ZU['resolveTriangleIndex'](Zl),eo(ZS,Zd*0x3,ZG,Zh),ZS['needsUpdate']=!0x0,ZW(ZS,Zd,Za,ZJ))return!0x0;}return!0x1;}function ex(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){eJ['setBuffer'](ZI['_roots'][ZZ]),ez(0x0,ZI,ZU,ZW,Za,ZJ,ZS),eJ['clearBuffer']();}function ez(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const {float32Array:ZD,uint16Array:ZG,uint32Array:Zh}=eJ,Zl=ZI*0x2;if(Ry(Zl,ZG)){const Zm=Rc(ZI,Zh),Zd=RC(Zl,ZG);eO(ZZ,ZU,ZW,Zm,Zd,Za,ZJ,ZS);}else{const Zq=RK(ZI);ec(Zq,ZD,ZW,ZJ,ZS)&&ez(Zq,ZZ,ZU,ZW,Za,ZJ,ZS);const Zj=RB(ZI,Zh);ec(Zj,ZD,ZW,ZJ,ZS)&&ez(Zj,ZZ,ZU,ZW,Za,ZJ,ZS);}}const eY=['x','y','z'];function ev(ZI,ZZ,ZU,ZW,Za,ZJ){eJ['setBuffer'](ZI['_roots'][ZZ]);const ZS=ef(0x0,ZI,ZU,ZW,Za,ZJ);return eJ['clearBuffer'](),ZS;}function ef(ZI,ZZ,ZU,ZW,Za,ZJ){const {float32Array:ZS,uint16Array:ZD,uint32Array:ZG}=eJ;let Zh=ZI*0x2;if(Ry(Zh,ZD)){const Zl=Rc(ZI,ZG),Zm=RC(Zh,ZD);return eF(ZZ,ZU,ZW,Zl,Zm,Za,ZJ);}else{const Zd=Rx(ZI,ZG),Zq=eY[Zd],Zj=ZW['direction'][Zq]>=0x0;let Zu,Zw;Zj?(Zu=RK(ZI),Zw=RB(ZI,ZG)):(Zu=RB(ZI,ZG),Zw=RK(ZI));const Zk=ec(Zu,ZS,ZW,Za,ZJ)?ef(Zu,ZZ,ZU,ZW,Za,ZJ):null;if(Zk){const ZP=Zk['point'][Zq];if(Zj?ZP<=ZS[Zw+Zd]:ZP>=ZS[Zw+Zd+0x3])return Zk;}const ZT=ec(Zw,ZS,ZW,Za,ZJ)?ef(Zw,ZZ,ZU,ZW,Za,ZJ):null;return Zk&&ZT?Zk['distance']<=ZT['distance']?Zk:ZT:Zk||ZT||null;}}const eH=new Y(),eN=new eR(),eL=new eR(),I0=new z(),I1=new eI(),I2=new eI();function I3(ZI,ZZ,ZU,ZW){eJ['setBuffer'](ZI['_roots'][ZZ]);const Za=I4(0x0,ZI,ZU,ZW);return eJ['clearBuffer'](),Za;}function I4(ZI,ZZ,ZU,ZW,Za=null){const {float32Array:ZJ,uint16Array:ZS,uint32Array:ZD}=eJ;let ZG=ZI*0x2;if(Za===null&&(ZU['boundingBox']||ZU['computeBoundingBox'](),I1['set'](ZU['boundingBox']['min'],ZU['boundingBox']['max'],ZW),Za=I1),Ry(ZG,ZS)){const Zh=ZZ['geometry'],Zl=Zh['index'],Zm=Zh['attributes']['position'],Zd=ZU['index'],Zq=ZU['attributes']['position'],Zj=Rc(ZI,ZD),Zu=RC(ZG,ZS);if(I0['copy'](ZW)['invert'](),ZU['boundsTree'])return Rw(ZI,ZJ,I2),I2['matrix']['copy'](I0),I2['needsUpdate']=!0x0,ZU['boundsTree']['shapecast']({'intersectsBounds':Zw=>I2['intersectsBox'](Zw),'intersectsTriangle':Zw=>{Zw['a']['applyMatrix4'](ZW),Zw['b']['applyMatrix4'](ZW),Zw['c']['applyMatrix4'](ZW),Zw['needsUpdate']=!0x0;for(let Zk=Zj*0x3,ZT=(Zu+Zj)*0x3;Zk<ZT;Zk+=0x3)if(eo(eL,Zk,Zl,Zm),eL['needsUpdate']=!0x0,Zw['intersectsTriangle'](eL))return!0x0;return!0x1;}});for(let Zw=Zj*0x3,Zk=(Zu+Zj)*0x3;Zw<Zk;Zw+=0x3){eo(eN,Zw,Zl,Zm),eN['a']['applyMatrix4'](I0),eN['b']['applyMatrix4'](I0),eN['c']['applyMatrix4'](I0),eN['needsUpdate']=!0x0;for(let ZT=0x0,ZP=Zd['count'];ZT<ZP;ZT+=0x3)if(eo(eL,ZT,Zd,Zq),eL['needsUpdate']=!0x0,eN['intersectsTriangle'](eL))return!0x0;}}else{const ZE=ZI+0x8,ZM=ZD[ZI+0x6];return Rw(ZE,ZJ,eH),!!(Za['intersectsBox'](eH)&&I4(ZE,ZZ,ZU,ZW,Za)||(Rw(ZM,ZJ,eH),Za['intersectsBox'](eH)&&I4(ZM,ZZ,ZU,ZW,Za)));}}const I5=new z(),I6=new eI(),I7=new eI(),I8=new n(),I9=new n(),IA=new n(),IR=new n();function II(ZI,ZZ,ZU,ZW={},Za={},ZJ=0x0,ZS=0x1/0x0){ZZ['boundingBox']||ZZ['computeBoundingBox'](),I6['set'](ZZ['boundingBox']['min'],ZZ['boundingBox']['max'],ZU),I6['needsUpdate']=!0x0;const ZD=ZI['geometry'],ZG=ZD['attributes']['position'],Zh=ZD['index'],Zl=ZZ['attributes']['position'],Zm=ZZ['index'],Zd=eW['getPrimitive'](),Zq=eW['getPrimitive']();let Zj=I8,Zu=I9,Zw=null,Zk=null;Za&&(Zw=IA,Zk=IR);let ZT=0x1/0x0,ZP=null,ZE=null;return I5['copy'](ZU)['invert'](),I7['matrix']['copy'](I5),ZI['shapecast']({'boundsTraverseOrder':ZM=>I6['distanceToBox'](ZM),'intersectsBounds':(ZM,Zg,ZQ)=>ZQ<ZT&&ZQ<ZS?(Zg&&(I7['min']['copy'](ZM['min']),I7['max']['copy'](ZM['max']),I7['needsUpdate']=!0x0),!0x0):!0x1,'intersectsRange':(ZM,Zg)=>{if(ZZ['boundsTree'])return ZZ['boundsTree']['shapecast']({'boundsTraverseOrder':ZQ=>I7['distanceToBox'](ZQ),'intersectsBounds':(ZQ,ZX,Zp)=>Zp<ZT&&Zp<ZS,'intersectsRange':(ZQ,ZX)=>{for(let Zp=ZQ,Zb=ZQ+ZX;Zp<Zb;Zp++){eo(Zq,0x3*Zp,Zm,Zl),Zq['a']['applyMatrix4'](ZU),Zq['b']['applyMatrix4'](ZU),Zq['c']['applyMatrix4'](ZU),Zq['needsUpdate']=!0x0;for(let Zr=ZM,Zo=ZM+Zg;Zr<Zo;Zr++){eo(Zd,0x3*Zr,Zh,ZG),Zd['needsUpdate']=!0x0;const ZO=Zd['distanceToTriangle'](Zq,Zj,Zw);if(ZO<ZT&&(Zu['copy'](Zj),Zk&&Zk['copy'](Zw),ZT=ZO,ZP=Zr,ZE=Zp),ZO<ZJ)return!0x0;}}}});{const ZQ=RG(ZZ);for(let ZX=0x0,Zp=ZQ;ZX<Zp;ZX++){eo(Zq,0x3*ZX,Zm,Zl),Zq['a']['applyMatrix4'](ZU),Zq['b']['applyMatrix4'](ZU),Zq['c']['applyMatrix4'](ZU),Zq['needsUpdate']=!0x0;for(let Zb=ZM,Zr=ZM+Zg;Zb<Zr;Zb++){eo(Zd,0x3*Zb,Zh,ZG),Zd['needsUpdate']=!0x0;const Zo=Zd['distanceToTriangle'](Zq,Zj,Zw);if(Zo<ZT&&(Zu['copy'](Zj),Zk&&Zk['copy'](Zw),ZT=Zo,ZP=Zb,ZE=ZX),Zo<ZJ)return!0x0;}}}}}),eW['releasePrimitive'](Zd),eW['releasePrimitive'](Zq),ZT===0x1/0x0?null:(ZW['point']?ZW['point']['copy'](Zu):ZW['point']=Zu['clone'](),ZW['distance']=ZT,ZW['faceIndex']=ZP,Za&&(Za['point']?Za['point']['copy'](Zk):Za['point']=Zk['clone'](),Za['point']['applyMatrix4'](I5),Zu['applyMatrix4'](I5),Za['distance']=Zu['sub'](Za['point'])['length'](),Za['faceIndex']=ZE),ZW);}function IZ(ZI,ZZ=null){ZZ&&Array['isArray'](ZZ)&&(ZZ=new Set(ZZ));const ZU=ZI['geometry'],ZW=ZU['index']?ZU['index']['array']:null,Za=ZU['attributes']['position'];let ZJ,ZS,ZD,ZG,Zh=0x0;const Zl=ZI['_roots'];for(let Zd=0x0,Zq=Zl['length'];Zd<Zq;Zd++)ZJ=Zl[Zd],ZS=new Uint32Array(ZJ),ZD=new Uint16Array(ZJ),ZG=new Float32Array(ZJ),Zm(0x0,Zh),Zh+=ZJ['byteLength'];function Zm(Zj,Zu,Zw=!0x1){const Zk=Zj*0x2;if(ZD[Zk+0xf]===Ra){const ZT=ZS[Zj+0x6],ZP=ZD[Zk+0xe];let ZE=0x1/0x0,ZM=0x1/0x0,Zg=0x1/0x0,ZQ=-0x1/0x0,ZX=-0x1/0x0,Zp=-0x1/0x0;for(let Zb=ZT,Zr=ZT+ZP;Zb<Zr;Zb++){const Zo=0x3*ZI['resolveTriangleIndex'](Zb);for(let ZO=0x0;ZO<0x3;ZO++){let ZF=Zo+ZO;ZF=ZW?ZW[ZF]:ZF;const ZV=Za['getX'](ZF),Zy=Za['getY'](ZF),Zc=Za['getZ'](ZF);ZV<ZE&&(ZE=ZV),ZV>ZQ&&(ZQ=ZV),Zy<ZM&&(ZM=Zy),Zy>ZX&&(ZX=Zy),Zc<Zg&&(Zg=Zc),Zc>Zp&&(Zp=Zc);}}return ZG[Zj+0x0]!==ZE||ZG[Zj+0x1]!==ZM||ZG[Zj+0x2]!==Zg||ZG[Zj+0x3]!==ZQ||ZG[Zj+0x4]!==ZX||ZG[Zj+0x5]!==Zp?(ZG[Zj+0x0]=ZE,ZG[Zj+0x1]=ZM,ZG[Zj+0x2]=Zg,ZG[Zj+0x3]=ZQ,ZG[Zj+0x4]=ZX,ZG[Zj+0x5]=Zp,!0x0):!0x1;}else{const ZC=Zj+0x8,ZK=ZS[Zj+0x6],ZB=ZC+Zu,Zx=ZK+Zu;let Zz=Zw,ZY=!0x1,Zv=!0x1;ZZ?Zz||(ZY=ZZ['has'](ZB),Zv=ZZ['has'](Zx),Zz=!ZY&&!Zv):(ZY=!0x0,Zv=!0x0);const Zf=Zz||ZY,ZH=Zz||Zv;let ZN=!0x1;Zf&&(ZN=Zm(ZC,Zu,Zz));let ZL=!0x1;ZH&&(ZL=Zm(ZK,Zu,Zz));const U0=ZN||ZL;if(U0)for(let U1=0x0;U1<0x3;U1++){const U2=ZC+U1,U3=ZK+U1,U4=ZG[U2],U5=ZG[U2+0x3],U6=ZG[U3],U7=ZG[U3+0x3];ZG[Zj+U1]=U4<U6?U4:U6,ZG[Zj+U1+0x3]=U5>U7?U5:U7;}return U0;}}}function IU(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){eJ['setBuffer'](ZI['_roots'][ZZ]),IW(0x0,ZI,ZU,ZW,Za,ZJ,ZS),eJ['clearBuffer']();}function IW(ZI,ZZ,ZU,ZW,Za,ZJ,ZS){const {float32Array:ZD,uint16Array:ZG,uint32Array:Zh}=eJ,Zl=ZI*0x2;if(Ry(Zl,ZG)){const Zm=Rc(ZI,Zh),Zd=RC(Zl,ZG);eC(ZZ,ZU,ZW,Zm,Zd,Za,ZJ,ZS);}else{const Zq=RK(ZI);ec(Zq,ZD,ZW,ZJ,ZS)&&IW(Zq,ZZ,ZU,ZW,Za,ZJ,ZS);const Zj=RB(ZI,Zh);ec(Zj,ZD,ZW,ZJ,ZS)&&IW(Zj,ZZ,ZU,ZW,Za,ZJ,ZS);}}const Ia=['x','y','z'];function IJ(ZI,ZZ,ZU,ZW,Za,ZJ){eJ['setBuffer'](ZI['_roots'][ZZ]);const ZS=IS(0x0,ZI,ZU,ZW,Za,ZJ);return eJ['clearBuffer'](),ZS;}function IS(ZI,ZZ,ZU,ZW,Za,ZJ){const {float32Array:ZS,uint16Array:ZD,uint32Array:ZG}=eJ;let Zh=ZI*0x2;if(Ry(Zh,ZD)){const Zl=Rc(ZI,ZG),Zm=RC(Zh,ZD);return eK(ZZ,ZU,ZW,Zl,Zm,Za,ZJ);}else{const Zd=Rx(ZI,ZG),Zq=Ia[Zd],Zj=ZW['direction'][Zq]>=0x0;let Zu,Zw;Zj?(Zu=RK(ZI),Zw=RB(ZI,ZG)):(Zu=RB(ZI,ZG),Zw=RK(ZI));const Zk=ec(Zu,ZS,ZW,Za,ZJ)?IS(Zu,ZZ,ZU,ZW,Za,ZJ):null;if(Zk){const ZP=Zk['point'][Zq];if(Zj?ZP<=ZS[Zw+Zd]:ZP>=ZS[Zw+Zd+0x3])return Zk;}const ZT=ec(Zw,ZS,ZW,Za,ZJ)?IS(Zw,ZZ,ZU,ZW,Za,ZJ):null;return Zk&&ZT?Zk['distance']<=ZT['distance']?Zk:ZT:Zk||ZT||null;}}const ID=new Y(),IG=new eR(),Ih=new eR(),Il=new z(),Im=new eI(),Id=new eI();function Iq(ZI,ZZ,ZU,ZW){eJ['setBuffer'](ZI['_roots'][ZZ]);const Za=Ij(0x0,ZI,ZU,ZW);return eJ['clearBuffer'](),Za;}function Ij(ZI,ZZ,ZU,ZW,Za=null){const {float32Array:ZJ,uint16Array:ZS,uint32Array:ZD}=eJ;let ZG=ZI*0x2;if(Za===null&&(ZU['boundingBox']||ZU['computeBoundingBox'](),Im['set'](ZU['boundingBox']['min'],ZU['boundingBox']['max'],ZW),Za=Im),Ry(ZG,ZS)){const Zh=ZZ['geometry'],Zl=Zh['index'],Zm=Zh['attributes']['position'],Zd=ZU['index'],Zq=ZU['attributes']['position'],Zj=Rc(ZI,ZD),Zu=RC(ZG,ZS);if(Il['copy'](ZW)['invert'](),ZU['boundsTree'])return Rw(ZI,ZJ,Id),Id['matrix']['copy'](Il),Id['needsUpdate']=!0x0,ZU['boundsTree']['shapecast']({'intersectsBounds':Zw=>Id['intersectsBox'](Zw),'intersectsTriangle':Zw=>{Zw['a']['applyMatrix4'](ZW),Zw['b']['applyMatrix4'](ZW),Zw['c']['applyMatrix4'](ZW),Zw['needsUpdate']=!0x0;for(let Zk=Zj,ZT=Zu+Zj;Zk<ZT;Zk++)if(eo(Ih,0x3*ZZ['resolveTriangleIndex'](Zk),Zl,Zm),Ih['needsUpdate']=!0x0,Zw['intersectsTriangle'](Ih))return!0x0;return!0x1;}});for(let Zw=Zj,Zk=Zu+Zj;Zw<Zk;Zw++){const ZT=ZZ['resolveTriangleIndex'](Zw);eo(IG,0x3*ZT,Zl,Zm),IG['a']['applyMatrix4'](Il),IG['b']['applyMatrix4'](Il),IG['c']['applyMatrix4'](Il),IG['needsUpdate']=!0x0;for(let ZP=0x0,ZE=Zd['count'];ZP<ZE;ZP+=0x3)if(eo(Ih,ZP,Zd,Zq),Ih['needsUpdate']=!0x0,IG['intersectsTriangle'](Ih))return!0x0;}}else{const ZM=ZI+0x8,Zg=ZD[ZI+0x6];return Rw(ZM,ZJ,ID),!!(Za['intersectsBox'](ID)&&Ij(ZM,ZZ,ZU,ZW,Za)||(Rw(Zg,ZJ,ID),Za['intersectsBox'](ID)&&Ij(Zg,ZZ,ZU,ZW,Za)));}}const Iu=new z(),Iw=new eI(),Ik=new eI(),IT=new n(),IP=new n(),IE=new n(),IM=new n();function Ig(ZI,ZZ,ZU,ZW={},Za={},ZJ=0x0,ZS=0x1/0x0){ZZ['boundingBox']||ZZ['computeBoundingBox'](),Iw['set'](ZZ['boundingBox']['min'],ZZ['boundingBox']['max'],ZU),Iw['needsUpdate']=!0x0;const ZD=ZI['geometry'],ZG=ZD['attributes']['position'],Zh=ZD['index'],Zl=ZZ['attributes']['position'],Zm=ZZ['index'],Zd=eW['getPrimitive'](),Zq=eW['getPrimitive']();let Zj=IT,Zu=IP,Zw=null,Zk=null;Za&&(Zw=IE,Zk=IM);let ZT=0x1/0x0,ZP=null,ZE=null;return Iu['copy'](ZU)['invert'](),Ik['matrix']['copy'](Iu),ZI['shapecast']({'boundsTraverseOrder':ZM=>Iw['distanceToBox'](ZM),'intersectsBounds':(ZM,Zg,ZQ)=>ZQ<ZT&&ZQ<ZS?(Zg&&(Ik['min']['copy'](ZM['min']),Ik['max']['copy'](ZM['max']),Ik['needsUpdate']=!0x0),!0x0):!0x1,'intersectsRange':(ZM,Zg)=>{if(ZZ['boundsTree']){const ZQ=ZZ['boundsTree'];return ZQ['shapecast']({'boundsTraverseOrder':ZX=>Ik['distanceToBox'](ZX),'intersectsBounds':(ZX,Zp,Zb)=>Zb<ZT&&Zb<ZS,'intersectsRange':(ZX,Zp)=>{for(let Zb=ZX,Zr=ZX+Zp;Zb<Zr;Zb++){const Zo=ZQ['resolveTriangleIndex'](Zb);eo(Zq,0x3*Zo,Zm,Zl),Zq['a']['applyMatrix4'](ZU),Zq['b']['applyMatrix4'](ZU),Zq['c']['applyMatrix4'](ZU),Zq['needsUpdate']=!0x0;for(let ZO=ZM,ZF=ZM+Zg;ZO<ZF;ZO++){const ZV=ZI['resolveTriangleIndex'](ZO);eo(Zd,0x3*ZV,Zh,ZG),Zd['needsUpdate']=!0x0;const Zy=Zd['distanceToTriangle'](Zq,Zj,Zw);if(Zy<ZT&&(Zu['copy'](Zj),Zk&&Zk['copy'](Zw),ZT=Zy,ZP=ZO,ZE=Zb),Zy<ZJ)return!0x0;}}}});}else{const ZX=RG(ZZ);for(let Zp=0x0,Zb=ZX;Zp<Zb;Zp++){eo(Zq,0x3*Zp,Zm,Zl),Zq['a']['applyMatrix4'](ZU),Zq['b']['applyMatrix4'](ZU),Zq['c']['applyMatrix4'](ZU),Zq['needsUpdate']=!0x0;for(let Zr=ZM,Zo=ZM+Zg;Zr<Zo;Zr++){const ZO=ZI['resolveTriangleIndex'](Zr);eo(Zd,0x3*ZO,Zh,ZG),Zd['needsUpdate']=!0x0;const ZF=Zd['distanceToTriangle'](Zq,Zj,Zw);if(ZF<ZT&&(Zu['copy'](Zj),Zk&&Zk['copy'](Zw),ZT=ZF,ZP=Zr,ZE=Zp),ZF<ZJ)return!0x0;}}}}}),eW['releasePrimitive'](Zd),eW['releasePrimitive'](Zq),ZT===0x1/0x0?null:(ZW['point']?ZW['point']['copy'](Zu):ZW['point']=Zu['clone'](),ZW['distance']=ZT,ZW['faceIndex']=ZP,Za&&(Za['point']?Za['point']['copy'](Zk):Za['point']=Zk['clone'](),Za['point']['applyMatrix4'](Iu),Zu['applyMatrix4'](Iu),Za['distance']=Zu['sub'](Za['point'])['length'](),Za['faceIndex']=ZE),ZW);}function IQ(){return typeof SharedArrayBuffer!='undefined';}const IX=new eJ['constructor'](),Ip=new eJ['constructor'](),Ib=new eZ(()=>new Y()),Io=new Y(),IO=new Y(),IF=new Y(),IV=new Y();let Iy=!0x1;function Ic(ZI,ZZ,ZU,ZW){if(Iy)throw new Error('MeshBVH:\x20Recursive\x20calls\x20to\x20bvhcast\x20not\x20supported.');Iy=!0x0;const Za=ZI['_roots'],ZJ=ZZ['_roots'];let ZS,ZD=0x0,ZG=0x0;const Zh=new z()['copy'](ZU)['invert']();for(let Zl=0x0,Zm=Za['length'];Zl<Zm;Zl++){IX['setBuffer'](Za[Zl]),ZG=0x0;const Zd=Ib['getPrimitive']();Rw(0x0,IX['float32Array'],Zd),Zd['applyMatrix4'](Zh);for(let Zq=0x0,Zj=ZJ['length'];Zq<Zj&&(Ip['setBuffer'](ZJ[Zl]),ZS=IC(0x0,0x0,ZU,Zh,ZW,ZD,ZG,0x0,0x0,Zd),Ip['clearBuffer'](),ZG+=ZJ[Zq]['length'],!ZS);Zq++);if(Ib['releasePrimitive'](Zd),IX['clearBuffer'](),ZD+=Za[Zl]['length'],ZS)break;}return Iy=!0x1,ZS;}function IC(ZI,ZZ,ZU,ZW,Za,ZJ=0x0,ZS=0x0,ZD=0x0,ZG=0x0,Zh=null,Zl=!0x1){let Zm,Zd;Zl?(Zm=Ip,Zd=IX):(Zm=IX,Zd=Ip);const Zq=Zm['float32Array'],Zj=Zm['uint32Array'],Zu=Zm['uint16Array'],Zw=Zd['float32Array'],Zk=Zd['uint32Array'],ZT=Zd['uint16Array'],ZP=ZI*0x2,ZE=ZZ*0x2,ZM=Ry(ZP,Zu),Zg=Ry(ZE,ZT);let ZQ=!0x1;if(Zg&&ZM)Zl?ZQ=Za(Rc(ZZ,Zk),RC(ZZ*0x2,ZT),Rc(ZI,Zj),RC(ZI*0x2,Zu),ZG,ZS+ZZ,ZD,ZJ+ZI):ZQ=Za(Rc(ZI,Zj),RC(ZI*0x2,Zu),Rc(ZZ,Zk),RC(ZZ*0x2,ZT),ZD,ZJ+ZI,ZG,ZS+ZZ);else{if(Zg){const ZX=Ib['getPrimitive']();Rw(ZZ,Zw,ZX),ZX['applyMatrix4'](ZU);const Zp=RK(ZI),Zb=RB(ZI,Zj);Rw(Zp,Zq,Io),Rw(Zb,Zq,IO);const Zr=ZX['intersectsBox'](Io),Zo=ZX['intersectsBox'](IO);ZQ=Zr&&IC(ZZ,Zp,ZW,ZU,Za,ZS,ZJ,ZG,ZD+0x1,ZX,!Zl)||Zo&&IC(ZZ,Zb,ZW,ZU,Za,ZS,ZJ,ZG,ZD+0x1,ZX,!Zl),Ib['releasePrimitive'](ZX);}else{const ZO=RK(ZZ),ZF=RB(ZZ,Zk);Rw(ZO,Zw,IF),Rw(ZF,Zw,IV);const ZV=Zh['intersectsBox'](IF),Zy=Zh['intersectsBox'](IV);if(ZV&&Zy)ZQ=IC(ZI,ZO,ZU,ZW,Za,ZJ,ZS,ZD,ZG+0x1,Zh,Zl)||IC(ZI,ZF,ZU,ZW,Za,ZJ,ZS,ZD,ZG+0x1,Zh,Zl);else{if(ZV){if(ZM)ZQ=IC(ZI,ZO,ZU,ZW,Za,ZJ,ZS,ZD,ZG+0x1,Zh,Zl);else{const Zc=Ib['getPrimitive']();Zc['copy'](IF)['applyMatrix4'](ZU);const ZC=RK(ZI),ZK=RB(ZI,Zj);Rw(ZC,Zq,Io),Rw(ZK,Zq,IO);const ZB=Zc['intersectsBox'](Io),Zx=Zc['intersectsBox'](IO);ZQ=ZB&&IC(ZO,ZC,ZW,ZU,Za,ZS,ZJ,ZG,ZD+0x1,Zc,!Zl)||Zx&&IC(ZO,ZK,ZW,ZU,Za,ZS,ZJ,ZG,ZD+0x1,Zc,!Zl),Ib['releasePrimitive'](Zc);}}else{if(Zy){if(ZM)ZQ=IC(ZI,ZF,ZU,ZW,Za,ZJ,ZS,ZD,ZG+0x1,Zh,Zl);else{const Zz=Ib['getPrimitive']();Zz['copy'](IV)['applyMatrix4'](ZU);const ZY=RK(ZI),Zv=RB(ZI,Zj);Rw(ZY,Zq,Io),Rw(Zv,Zq,IO);const Zf=Zz['intersectsBox'](Io),ZH=Zz['intersectsBox'](IO);ZQ=Zf&&IC(ZF,ZY,ZW,ZU,Za,ZS,ZJ,ZG,ZD+0x1,Zz,!Zl)||ZH&&IC(ZF,Zv,ZW,ZU,Za,ZS,ZJ,ZG,ZD+0x1,Zz,!Zl),Ib['releasePrimitive'](Zz);}}}}}}return ZQ;}const IK=new eI(),IB=new Y(),Ix={'strategy':R9,'maxDepth':0x28,'maxLeafTris':0xa,'useSharedArrayBuffer':!0x1,'setBoundingBox':!0x0,'onProgress':null,'indirect':!0x1,'verbose':!0x0};class Iz{static['serialize'](ZI,ZZ={}){ZZ=h({'cloneBuffers':!0x0},ZZ);const ZU=ZI['geometry'],ZW=ZI['_roots'],Za=ZI['_indirectBuffer'],ZJ=ZU['getIndex']();let ZS;return ZZ['cloneBuffers']?ZS={'roots':ZW['map'](ZD=>ZD['slice']()),'index':ZJ?ZJ['array']['slice']():null,'indirectBuffer':Za?Za['slice']():null}:ZS={'roots':ZW,'index':ZJ?ZJ['array']:null,'indirectBuffer':Za},ZS;}static['deserialize'](ZI,ZZ,ZU={}){ZU=h({'setIndex':!0x0,'indirect':!!ZI['indirectBuffer']},ZU);const {index:ZW,roots:Za,indirectBuffer:ZJ}=ZI,ZS=new Iz(ZZ,i(h({},ZU),{[RS]:!0x0}));if(ZS['_roots']=Za,ZS['_indirectBuffer']=ZJ||null,ZU['setIndex']){const ZD=ZZ['getIndex']();if(ZD===null){const ZG=new o(ZI['index'],0x1,!0x1);ZZ['setIndex'](ZG);}else ZD['array']!==ZW&&(ZD['array']['set'](ZW),ZD['needsUpdate']=!0x0);}return ZS;}get['indirect'](){return!!this['_indirectBuffer'];}constructor(ZI,ZZ={}){if(ZI['isBufferGeometry']){if(ZI['index']&&ZI['index']['isInterleavedBufferAttribute'])throw new Error('MeshBVH:\x20InterleavedBufferAttribute\x20is\x20not\x20supported\x20for\x20the\x20index\x20attribute.');}else throw new Error('MeshBVH:\x20Only\x20BufferGeometries\x20are\x20supported.');if(ZZ=Object['assign'](i(h({},Ix),{[RS]:!0x1}),ZZ),ZZ['useSharedArrayBuffer']&&!IQ())throw new Error('MeshBVH:\x20SharedArrayBuffer\x20is\x20not\x20available.');this['geometry']=ZI,this['_roots']=null,this['_indirectBuffer']=null,ZZ[RS]||(e4(this,ZZ),!ZI['boundingBox']&&ZZ['setBoundingBox']&&(ZI['boundingBox']=this['getBoundingBox'](new Y()))),this['resolveTriangleIndex']=ZZ['indirect']?ZU=>this['_indirectBuffer'][ZU]:ZU=>ZU;}['refit'](ZI=null){return(this['indirect']?IZ:ey)(this,ZI);}['traverse'](ZI,ZZ=0x0){const ZU=this['_roots'][ZZ],ZW=new Uint32Array(ZU),Za=new Uint16Array(ZU);ZJ(0x0);function ZJ(ZS,ZD=0x0){const ZG=ZS*0x2,Zh=Za[ZG+0xf]===Ra;if(Zh){const Zl=ZW[ZS+0x6],Zm=Za[ZG+0xe];ZI(ZD,Zh,new Float32Array(ZU,ZS*0x4,0x6),Zl,Zm);}else{const Zd=ZS+RW/0x4,Zq=ZW[ZS+0x6],Zj=ZW[ZS+0x7];ZI(ZD,Zh,new Float32Array(ZU,ZS*0x4,0x6),Zj)||(ZJ(Zd,ZD+0x1),ZJ(Zq,ZD+0x1));}}}['raycast'](ZI,ZZ=A0,ZU=0x0,ZW=0x1/0x0){const Za=this['_roots'],ZJ=this['geometry'],ZS=[],ZD=ZZ['isMaterial'],ZG=Array['isArray'](ZZ),Zh=ZJ['groups'],Zl=ZD?ZZ['side']:ZZ,Zm=this['indirect']?IU:ex;for(let Zd=0x0,Zq=Za['length'];Zd<Zq;Zd++){const Zj=ZG?ZZ[Zh[Zd]['materialIndex']]['side']:Zl,Zu=ZS['length'];if(Zm(this,Zd,Zj,ZI,ZS,ZU,ZW),ZG){const Zw=Zh[Zd]['materialIndex'];for(let Zk=Zu,ZT=ZS['length'];Zk<ZT;Zk++)ZS[Zk]['face']['materialIndex']=Zw;}}return ZS;}['raycastFirst'](ZI,ZZ=A0,ZU=0x0,ZW=0x1/0x0){const Za=this['_roots'],ZJ=this['geometry'],ZS=ZZ['isMaterial'],ZD=Array['isArray'](ZZ);let ZG=null;const Zh=ZJ['groups'],Zl=ZS?ZZ['side']:ZZ,Zm=this['indirect']?IJ:ev;for(let Zd=0x0,Zq=Za['length'];Zd<Zq;Zd++){const Zj=ZD?ZZ[Zh[Zd]['materialIndex']]['side']:Zl,Zu=Zm(this,Zd,Zj,ZI,ZU,ZW);Zu!=null&&(ZG==null||Zu['distance']<ZG['distance'])&&(ZG=Zu,ZD&&(Zu['face']['materialIndex']=Zh[Zd]['materialIndex']));}return ZG;}['intersectsGeometry'](ZI,ZZ){let ZU=!0x1;const ZW=this['_roots'],Za=this['indirect']?Iq:I3;for(let ZJ=0x0,ZS=ZW['length'];ZJ<ZS&&(ZU=Za(this,ZJ,ZI,ZZ),!ZU);ZJ++);return ZU;}['shapecast'](ZI){const ZZ=eW['getPrimitive'](),ZU=this['indirect']?eB:eV;let {boundsTraverseOrder:ZW,intersectsBounds:Za,intersectsRange:ZJ,intersectsTriangle:ZS}=ZI;if(ZJ&&ZS){const Zl=ZJ;ZJ=(Zm,Zd,Zq,Zj,Zu)=>Zl(Zm,Zd,Zq,Zj,Zu)?!0x0:ZU(Zm,Zd,this,ZS,Zq,Zj,ZZ);}else ZJ||(ZS?ZJ=(Zm,Zd,Zq,Zj)=>ZU(Zm,Zd,this,ZS,Zq,Zj,ZZ):ZJ=(Zm,Zd,Zq)=>Zq);let ZD=!0x1,ZG=0x0;const Zh=this['_roots'];for(let Zm=0x0,Zd=Zh['length'];Zm<Zd;Zm++){const Zq=Zh[Zm];if(ZD=el(this,Zm,Za,ZJ,ZW,ZG),ZD)break;ZG+=Zq['byteLength'];}return eW['releasePrimitive'](ZZ),ZD;}['bvhcast'](ZI,ZZ,ZU){let {intersectsRanges:ZW,intersectsTriangles:Za}=ZU;const ZJ=eW['getPrimitive'](),ZS=this['geometry']['index'],ZD=this['geometry']['attributes']['position'],ZG=this['indirect']?Zq=>{const Zj=this['resolveTriangleIndex'](Zq);eo(ZJ,Zj*0x3,ZS,ZD);}:Zq=>{eo(ZJ,Zq*0x3,ZS,ZD);},Zh=eW['getPrimitive'](),Zl=ZI['geometry']['index'],Zm=ZI['geometry']['attributes']['position'],Zd=ZI['indirect']?Zq=>{const Zj=ZI['resolveTriangleIndex'](Zq);eo(Zh,Zj*0x3,Zl,Zm);}:Zq=>{eo(Zh,Zq*0x3,Zl,Zm);};if(Za){const Zq=(Zj,Zu,Zw,Zk,ZT,ZP,ZE,ZM)=>{for(let Zg=Zw,ZQ=Zw+Zk;Zg<ZQ;Zg++){Zd(Zg),Zh['a']['applyMatrix4'](ZZ),Zh['b']['applyMatrix4'](ZZ),Zh['c']['applyMatrix4'](ZZ),Zh['needsUpdate']=!0x0;for(let ZX=Zj,Zp=Zj+Zu;ZX<Zp;ZX++)if(ZG(ZX),ZJ['needsUpdate']=!0x0,Za(ZJ,Zh,ZX,Zg,ZT,ZP,ZE,ZM))return!0x0;}return!0x1;};if(ZW){const Zj=ZW;ZW=function(Zu,Zw,Zk,ZT,ZP,ZE,ZM,Zg){return Zj(Zu,Zw,Zk,ZT,ZP,ZE,ZM,Zg)?!0x0:Zq(Zu,Zw,Zk,ZT,ZP,ZE,ZM,Zg);};}else ZW=Zq;}return Ic(this,ZI,ZZ,ZW);}['intersectsBox'](ZI,ZZ){return IK['set'](ZI['min'],ZI['max'],ZZ),IK['needsUpdate']=!0x0,this['shapecast']({'intersectsBounds':ZU=>IK['intersectsBox'](ZU),'intersectsTriangle':ZU=>IK['intersectsTriangle'](ZU)});}['intersectsSphere'](ZI){return this['shapecast']({'intersectsBounds':ZZ=>ZI['intersectsBox'](ZZ),'intersectsTriangle':ZZ=>ZZ['intersectsSphere'](ZI)});}['closestPointToGeometry'](ZI,ZZ,ZU={},ZW={},Za=0x0,ZJ=0x1/0x0){return(this['indirect']?Ig:II)(this,ZI,ZZ,ZU,ZW,Za,ZJ);}['closestPointToPoint'](ZI,ZZ={},ZU=0x0,ZW=0x1/0x0){return ej(this,ZI,ZZ,ZU,ZW);}['getBoundingBox'](ZI){return ZI['makeEmpty'](),this['_roots']['forEach'](ZZ=>{Rw(0x0,new Float32Array(ZZ),IB),ZI['union'](IB);}),ZI;}}A1['prototype']['raycast'];function IY(ZI){switch(ZI){case 0x1:return'R';case 0x2:return'RG';case 0x3:return'RGBA';case 0x4:return'RGBA';}throw new Error();}function Iv(ZI){switch(ZI){case 0x1:return AZ;case 0x2:return AI;case 0x3:return AR;case 0x4:return AR;}}function If(ZI){switch(ZI){case 0x1:return AW;case 0x2:return AU;case 0x3:return Ae;case 0x4:return Ae;}}class IH extends A4{constructor(){super(),this['minFilter']=A5,this['magFilter']=A5,this['generateMipmaps']=!0x1,this['overrideItemSize']=null,this['_forcedType']=null;}['updateFrom'](ZI){const ZZ=this['overrideItemSize'],ZU=ZI['itemSize'],ZW=ZI['count'];if(ZZ!==null){if(ZU*ZW%ZZ!==0x0)throw new Error('VertexAttributeTexture:\x20overrideItemSize\x20must\x20divide\x20evenly\x20into\x20buffer\x20length.');ZI['itemSize']=ZZ,ZI['count']=ZW*ZU/ZZ;}const Za=ZI['itemSize'],ZJ=ZI['count'],ZS=ZI['normalized'],ZD=ZI['array']['constructor'],ZG=ZD['BYTES_PER_ELEMENT'];let Zh=this['_forcedType'],Zl=Za;if(Zh===null)switch(ZD){case Float32Array:Zh=A3;break;case Uint8Array:case Uint16Array:case Uint32Array:Zh=A2;break;case Int8Array:case Int16Array:case Int32Array:Zh=A6;break;}let Zm,Zd,Zq,Zj,Zu=IY(Za);switch(Zh){case A3:Zq=0x1,Zd=Iv(Za),ZS&&ZG===0x1?(Zj=ZD,Zu+='8',ZD===Uint8Array?Zm=A7:(Zm=A9,Zu+='_SNORM')):(Zj=Float32Array,Zu+='32F',Zm=A3);break;case A6:Zu+=ZG*0x8+'I',Zq=ZS?Math['pow'](0x2,ZD['BYTES_PER_ELEMENT']*0x8-0x1):0x1,Zd=If(Za),ZG===0x1?(Zj=Int8Array,Zm=A9):ZG===0x2?(Zj=Int16Array,Zm=AA):(Zj=Int32Array,Zm=A6);break;case A2:Zu+=ZG*0x8+'UI',Zq=ZS?Math['pow'](0x2,ZD['BYTES_PER_ELEMENT']*0x8-0x1):0x1,Zd=If(Za),ZG===0x1?(Zj=Uint8Array,Zm=A7):ZG===0x2?(Zj=Uint16Array,Zm=A8):(Zj=Uint32Array,Zm=A2);break;}Zl===0x3&&(Zd===AR||Zd===Ae)&&(Zl=0x4);const Zw=Math['ceil'](Math['sqrt'](ZJ))||0x1,Zk=Zl*Zw*Zw,ZT=new Zj(Zk),ZP=ZI['normalized'];ZI['normalized']=!0x1;for(let ZE=0x0;ZE<ZJ;ZE++){const ZM=Zl*ZE;ZT[ZM]=ZI['getX'](ZE)/Zq,Za>=0x2&&(ZT[ZM+0x1]=ZI['getY'](ZE)/Zq),Za>=0x3&&(ZT[ZM+0x2]=ZI['getZ'](ZE)/Zq,Zl===0x4&&(ZT[ZM+0x3]=0x1)),Za>=0x4&&(ZT[ZM+0x3]=ZI['getW'](ZE)/Zq);}ZI['normalized']=ZP,this['internalFormat']=Zu,this['format']=Zd,this['type']=Zm,this['image']['width']=Zw,this['image']['height']=Zw,this['image']['data']=ZT,this['needsUpdate']=!0x0,this['dispose'](),ZI['itemSize']=ZU,ZI['count']=ZW;}}class IN extends IH{constructor(){super(),this['_forcedType']=A2;}}class IL extends IH{constructor(){super(),this['_forcedType']=A3;}}class Z0{constructor(){this['index']=new IN(),this['position']=new IL(),this['bvhBounds']=new A4(),this['bvhContents']=new A4(),this['_cachedIndexAttr']=null,this['index']['overrideItemSize']=0x3;}['updateFrom'](ZI){const {geometry:ZZ}=ZI;if(Z2(ZI,this['bvhBounds'],this['bvhContents']),this['position']['updateFrom'](ZZ['attributes']['position']),ZI['indirect']){const ZU=ZI['_indirectBuffer'];if(this['_cachedIndexAttr']===null||this['_cachedIndexAttr']['count']!==ZU['length']){if(ZZ['index'])this['_cachedIndexAttr']=ZZ['index']['clone']();else{const ZW=Rh(RD(ZZ));this['_cachedIndexAttr']=new o(ZW,0x1,!0x1);}}Z1(ZZ,ZU,this['_cachedIndexAttr']),this['index']['updateFrom'](this['_cachedIndexAttr']);}else this['index']['updateFrom'](ZZ['index']);}['dispose'](){const {index:ZI,position:ZZ,bvhBounds:ZU,bvhContents:ZW}=this;ZI&&ZI['dispose'](),ZZ&&ZZ['dispose'](),ZU&&ZU['dispose'](),ZW&&ZW['dispose']();}}function Z1(ZI,ZZ,ZU){const ZW=ZU['array'],Za=ZI['index']?ZI['index']['array']:null;for(let ZJ=0x0,ZS=ZZ['length'];ZJ<ZS;ZJ++){const ZD=0x3*ZJ,ZG=0x3*ZZ[ZJ];for(let Zh=0x0;Zh<0x3;Zh++)ZW[ZD+Zh]=Za?Za[ZG+Zh]:ZG+Zh;}}function Z2(ZI,ZZ,ZU){const ZW=ZI['_roots'];if(ZW['length']!==0x1)throw new Error('MeshBVHUniformStruct:\x20Multi-root\x20BVHs\x20not\x20supported.');const Za=ZW[0x0],ZJ=new Uint16Array(Za),ZS=new Uint32Array(Za),ZD=new Float32Array(Za),ZG=Za['byteLength']/RW,Zh=0x2*Math['ceil'](Math['sqrt'](ZG/0x2)),Zl=new Float32Array(0x4*Zh*Zh),Zm=Math['ceil'](Math['sqrt'](ZG)),Zd=new Uint32Array(0x2*Zm*Zm);for(let Zq=0x0;Zq<ZG;Zq++){const Zj=Zq*RW/0x4,Zu=Zj*0x2,Zw=Zj;for(let Zk=0x0;Zk<0x3;Zk++)Zl[0x8*Zq+0x0+Zk]=ZD[Zw+0x0+Zk],Zl[0x8*Zq+0x4+Zk]=ZD[Zw+0x3+Zk];if(Ry(Zu,ZJ)){const ZT=RC(Zu,ZJ),ZP=Rc(Zj,ZS),ZE=0xffff0000|ZT;Zd[Zq*0x2+0x0]=ZE,Zd[Zq*0x2+0x1]=ZP;}else{const ZM=0x4*RB(Zj,ZS)/RW,Zg=Rx(Zj,ZS);Zd[Zq*0x2+0x0]=Zg,Zd[Zq*0x2+0x1]=ZM;}}ZZ['image']['data']=Zl,ZZ['image']['width']=Zh,ZZ['image']['height']=Zh,ZZ['format']=AR,ZZ['type']=A3,ZZ['internalFormat']='RGBA32F',ZZ['minFilter']=A5,ZZ['magFilter']=A5,ZZ['generateMipmaps']=!0x1,ZZ['needsUpdate']=!0x0,ZZ['dispose'](),ZU['image']['data']=Zd,ZU['image']['width']=Zm,ZU['image']['height']=Zm,ZU['format']=AU,ZU['type']=A2,ZU['internalFormat']='RG32UI',ZU['minFilter']=A5,ZU['magFilter']=A5,ZU['generateMipmaps']=!0x1,ZU['needsUpdate']=!0x0,ZU['dispose']();}const Z3='\x0a\x0a//\x20A\x20stack\x20of\x20uint32\x20indices\x20can\x20can\x20store\x20the\x20indices\x20for\x0a//\x20a\x20perfectly\x20balanced\x20tree\x20with\x20a\x20depth\x20up\x20to\x2031.\x20Lower\x20stack\x0a//\x20depth\x20gets\x20higher\x20performance.\x0a//\x0a//\x20However\x20not\x20all\x20trees\x20are\x20balanced.\x20Best\x20value\x20to\x20set\x20this\x20to\x0a//\x20is\x20the\x20trees\x20max\x20depth.\x0a#ifndef\x20BVH_STACK_DEPTH\x0a#define\x20BVH_STACK_DEPTH\x2060\x0a#endif\x0a\x0a#ifndef\x20INFINITY\x0a#define\x20INFINITY\x201e20\x0a#endif\x0a\x0a//\x20Utilities\x0auvec4\x20uTexelFetch1D(\x20usampler2D\x20tex,\x20uint\x20index\x20)\x20{\x0a\x0a\x09uint\x20width\x20=\x20uint(\x20textureSize(\x20tex,\x200\x20).x\x20);\x0a\x09uvec2\x20uv;\x0a\x09uv.x\x20=\x20index\x20%\x20width;\x0a\x09uv.y\x20=\x20index\x20/\x20width;\x0a\x0a\x09return\x20texelFetch(\x20tex,\x20ivec2(\x20uv\x20),\x200\x20);\x0a\x0a}\x0a\x0aivec4\x20iTexelFetch1D(\x20isampler2D\x20tex,\x20uint\x20index\x20)\x20{\x0a\x0a\x09uint\x20width\x20=\x20uint(\x20textureSize(\x20tex,\x200\x20).x\x20);\x0a\x09uvec2\x20uv;\x0a\x09uv.x\x20=\x20index\x20%\x20width;\x0a\x09uv.y\x20=\x20index\x20/\x20width;\x0a\x0a\x09return\x20texelFetch(\x20tex,\x20ivec2(\x20uv\x20),\x200\x20);\x0a\x0a}\x0a\x0avec4\x20texelFetch1D(\x20sampler2D\x20tex,\x20uint\x20index\x20)\x20{\x0a\x0a\x09uint\x20width\x20=\x20uint(\x20textureSize(\x20tex,\x200\x20).x\x20);\x0a\x09uvec2\x20uv;\x0a\x09uv.x\x20=\x20index\x20%\x20width;\x0a\x09uv.y\x20=\x20index\x20/\x20width;\x0a\x0a\x09return\x20texelFetch(\x20tex,\x20ivec2(\x20uv\x20),\x200\x20);\x0a\x0a}\x0a\x0avec4\x20textureSampleBarycoord(\x20sampler2D\x20tex,\x20vec3\x20barycoord,\x20uvec3\x20faceIndices\x20)\x20{\x0a\x0a\x09return\x0a\x09\x09barycoord.x\x20*\x20texelFetch1D(\x20tex,\x20faceIndices.x\x20)\x20+\x0a\x09\x09barycoord.y\x20*\x20texelFetch1D(\x20tex,\x20faceIndices.y\x20)\x20+\x0a\x09\x09barycoord.z\x20*\x20texelFetch1D(\x20tex,\x20faceIndices.z\x20);\x0a\x0a}\x0a\x0avoid\x20ndcToCameraRay(\x0a\x09vec2\x20coord,\x20mat4\x20cameraWorld,\x20mat4\x20invProjectionMatrix,\x0a\x09out\x20vec3\x20rayOrigin,\x20out\x20vec3\x20rayDirection\x0a)\x20{\x0a\x0a\x09//\x20get\x20camera\x20look\x20direction\x20and\x20near\x20plane\x20for\x20camera\x20clipping\x0a\x09vec4\x20lookDirection\x20=\x20cameraWorld\x20*\x20vec4(\x200.0,\x200.0,\x20-\x201.0,\x200.0\x20);\x0a\x09vec4\x20nearVector\x20=\x20invProjectionMatrix\x20*\x20vec4(\x200.0,\x200.0,\x20-\x201.0,\x201.0\x20);\x0a\x09float\x20near\x20=\x20abs(\x20nearVector.z\x20/\x20nearVector.w\x20);\x0a\x0a\x09//\x20get\x20the\x20camera\x20direction\x20and\x20position\x20from\x20camera\x20matrices\x0a\x09vec4\x20origin\x20=\x20cameraWorld\x20*\x20vec4(\x200.0,\x200.0,\x200.0,\x201.0\x20);\x0a\x09vec4\x20direction\x20=\x20invProjectionMatrix\x20*\x20vec4(\x20coord,\x200.5,\x201.0\x20);\x0a\x09direction\x20/=\x20direction.w;\x0a\x09direction\x20=\x20cameraWorld\x20*\x20direction\x20-\x20origin;\x0a\x0a\x09//\x20slide\x20the\x20origin\x20along\x20the\x20ray\x20until\x20it\x20sits\x20at\x20the\x20near\x20clip\x20plane\x20position\x0a\x09origin.xyz\x20+=\x20direction.xyz\x20*\x20near\x20/\x20dot(\x20direction,\x20lookDirection\x20);\x0a\x0a\x09rayOrigin\x20=\x20origin.xyz;\x0a\x09rayDirection\x20=\x20direction.xyz;\x0a\x0a}\x0a',Z4='\x0a\x0a#ifndef\x20TRI_INTERSECT_EPSILON\x0a#define\x20TRI_INTERSECT_EPSILON\x201e-5\x0a#endif\x0a\x0a//\x20Raycasting\x0abool\x20intersectsBounds(\x20vec3\x20rayOrigin,\x20vec3\x20rayDirection,\x20vec3\x20boundsMin,\x20vec3\x20boundsMax,\x20out\x20float\x20dist\x20)\x20{\x0a\x0a\x09//\x20https://www.reddit.com/r/opengl/comments/8ntzz5/fast_glsl_ray_box_intersection/\x0a\x09//\x20https://tavianator.com/2011/ray_box.html\x0a\x09vec3\x20invDir\x20=\x201.0\x20/\x20rayDirection;\x0a\x0a\x09//\x20find\x20intersection\x20distances\x20for\x20each\x20plane\x0a\x09vec3\x20tMinPlane\x20=\x20invDir\x20*\x20(\x20boundsMin\x20-\x20rayOrigin\x20);\x0a\x09vec3\x20tMaxPlane\x20=\x20invDir\x20*\x20(\x20boundsMax\x20-\x20rayOrigin\x20);\x0a\x0a\x09//\x20get\x20the\x20min\x20and\x20max\x20distances\x20from\x20each\x20intersection\x0a\x09vec3\x20tMinHit\x20=\x20min(\x20tMaxPlane,\x20tMinPlane\x20);\x0a\x09vec3\x20tMaxHit\x20=\x20max(\x20tMaxPlane,\x20tMinPlane\x20);\x0a\x0a\x09//\x20get\x20the\x20furthest\x20hit\x20distance\x0a\x09vec2\x20t\x20=\x20max(\x20tMinHit.xx,\x20tMinHit.yz\x20);\x0a\x09float\x20t0\x20=\x20max(\x20t.x,\x20t.y\x20);\x0a\x0a\x09//\x20get\x20the\x20minimum\x20hit\x20distance\x0a\x09t\x20=\x20min(\x20tMaxHit.xx,\x20tMaxHit.yz\x20);\x0a\x09float\x20t1\x20=\x20min(\x20t.x,\x20t.y\x20);\x0a\x0a\x09//\x20set\x20distance\x20to\x200.0\x20if\x20the\x20ray\x20starts\x20inside\x20the\x20box\x0a\x09dist\x20=\x20max(\x20t0,\x200.0\x20);\x0a\x0a\x09return\x20t1\x20>=\x20dist;\x0a\x0a}\x0a\x0abool\x20intersectsTriangle(\x0a\x09vec3\x20rayOrigin,\x20vec3\x20rayDirection,\x20vec3\x20a,\x20vec3\x20b,\x20vec3\x20c,\x0a\x09out\x20vec3\x20barycoord,\x20out\x20vec3\x20norm,\x20out\x20float\x20dist,\x20out\x20float\x20side\x0a)\x20{\x0a\x0a\x09//\x20https://stackoverflow.com/questions/42740765/intersection-between-line-and-triangle-in-3d\x0a\x09vec3\x20edge1\x20=\x20b\x20-\x20a;\x0a\x09vec3\x20edge2\x20=\x20c\x20-\x20a;\x0a\x09norm\x20=\x20cross(\x20edge1,\x20edge2\x20);\x0a\x0a\x09float\x20det\x20=\x20-\x20dot(\x20rayDirection,\x20norm\x20);\x0a\x09float\x20invdet\x20=\x201.0\x20/\x20det;\x0a\x0a\x09vec3\x20AO\x20=\x20rayOrigin\x20-\x20a;\x0a\x09vec3\x20DAO\x20=\x20cross(\x20AO,\x20rayDirection\x20);\x0a\x0a\x09vec4\x20uvt;\x0a\x09uvt.x\x20=\x20dot(\x20edge2,\x20DAO\x20)\x20*\x20invdet;\x0a\x09uvt.y\x20=\x20-\x20dot(\x20edge1,\x20DAO\x20)\x20*\x20invdet;\x0a\x09uvt.z\x20=\x20dot(\x20AO,\x20norm\x20)\x20*\x20invdet;\x0a\x09uvt.w\x20=\x201.0\x20-\x20uvt.x\x20-\x20uvt.y;\x0a\x0a\x09//\x20set\x20the\x20hit\x20information\x0a\x09barycoord\x20=\x20uvt.wxy;\x20//\x20arranged\x20in\x20A,\x20B,\x20C\x20order\x0a\x09dist\x20=\x20uvt.z;\x0a\x09side\x20=\x20sign(\x20det\x20);\x0a\x09norm\x20=\x20side\x20*\x20normalize(\x20norm\x20);\x0a\x0a\x09//\x20add\x20an\x20epsilon\x20to\x20avoid\x20misses\x20between\x20triangles\x0a\x09uvt\x20+=\x20vec4(\x20TRI_INTERSECT_EPSILON\x20);\x0a\x0a\x09return\x20all(\x20greaterThanEqual(\x20uvt,\x20vec4(\x200.0\x20)\x20)\x20);\x0a\x0a}\x0a\x0abool\x20intersectTriangles(\x0a\x09//\x20geometry\x20info\x20and\x20triangle\x20range\x0a\x09sampler2D\x20positionAttr,\x20usampler2D\x20indexAttr,\x20uint\x20offset,\x20uint\x20count,\x0a\x0a\x09//\x20ray\x0a\x09vec3\x20rayOrigin,\x20vec3\x20rayDirection,\x0a\x0a\x09//\x20outputs\x0a\x09inout\x20float\x20minDistance,\x20inout\x20uvec4\x20faceIndices,\x20inout\x20vec3\x20faceNormal,\x20inout\x20vec3\x20barycoord,\x0a\x09inout\x20float\x20side,\x20inout\x20float\x20dist\x0a)\x20{\x0a\x0a\x09bool\x20found\x20=\x20false;\x0a\x09vec3\x20localBarycoord,\x20localNormal;\x0a\x09float\x20localDist,\x20localSide;\x0a\x09for\x20(\x20uint\x20i\x20=\x20offset,\x20l\x20=\x20offset\x20+\x20count;\x20i\x20<\x20l;\x20i\x20++\x20)\x20{\x0a\x0a\x09\x09uvec3\x20indices\x20=\x20uTexelFetch1D(\x20indexAttr,\x20i\x20).xyz;\x0a\x09\x09vec3\x20a\x20=\x20texelFetch1D(\x20positionAttr,\x20indices.x\x20).rgb;\x0a\x09\x09vec3\x20b\x20=\x20texelFetch1D(\x20positionAttr,\x20indices.y\x20).rgb;\x0a\x09\x09vec3\x20c\x20=\x20texelFetch1D(\x20positionAttr,\x20indices.z\x20).rgb;\x0a\x0a\x09\x09if\x20(\x0a\x09\x09\x09intersectsTriangle(\x20rayOrigin,\x20rayDirection,\x20a,\x20b,\x20c,\x20localBarycoord,\x20localNormal,\x20localDist,\x20localSide\x20)\x0a\x09\x09\x09&&\x20localDist\x20<\x20minDistance\x0a\x09\x09)\x20{\x0a\x0a\x09\x09\x09found\x20=\x20true;\x0a\x09\x09\x09minDistance\x20=\x20localDist;\x0a\x0a\x09\x09\x09faceIndices\x20=\x20uvec4(\x20indices.xyz,\x20i\x20);\x0a\x09\x09\x09faceNormal\x20=\x20localNormal;\x0a\x0a\x09\x09\x09side\x20=\x20localSide;\x0a\x09\x09\x09barycoord\x20=\x20localBarycoord;\x0a\x09\x09\x09dist\x20=\x20localDist;\x0a\x0a\x09\x09}\x0a\x0a\x09}\x0a\x0a\x09return\x20found;\x0a\x0a}\x0a\x0abool\x20intersectsBVHNodeBounds(\x20vec3\x20rayOrigin,\x20vec3\x20rayDirection,\x20sampler2D\x20bvhBounds,\x20uint\x20currNodeIndex,\x20out\x20float\x20dist\x20)\x20{\x0a\x0a\x09uint\x20cni2\x20=\x20currNodeIndex\x20*\x202u;\x0a\x09vec3\x20boundsMin\x20=\x20texelFetch1D(\x20bvhBounds,\x20cni2\x20).xyz;\x0a\x09vec3\x20boundsMax\x20=\x20texelFetch1D(\x20bvhBounds,\x20cni2\x20+\x201u\x20).xyz;\x0a\x09return\x20intersectsBounds(\x20rayOrigin,\x20rayDirection,\x20boundsMin,\x20boundsMax,\x20dist\x20);\x0a\x0a}\x0a\x0a//\x20use\x20a\x20macro\x20to\x20hide\x20the\x20fact\x20that\x20we\x20need\x20to\x20expand\x20the\x20struct\x20into\x20separate\x20fields\x0a#define\x09bvhIntersectFirstHit(\x09\x09bvh,\x09\x09rayOrigin,\x20rayDirection,\x20faceIndices,\x20faceNormal,\x20barycoord,\x20side,\x20dist\x09)\x09_bvhIntersectFirstHit(\x09\x09bvh.position,\x20bvh.index,\x20bvh.bvhBounds,\x20bvh.bvhContents,\x09\x09rayOrigin,\x20rayDirection,\x20faceIndices,\x20faceNormal,\x20barycoord,\x20side,\x20dist\x09)\x0a\x0abool\x20_bvhIntersectFirstHit(\x0a\x09//\x20bvh\x20info\x0a\x09sampler2D\x20bvh_position,\x20usampler2D\x20bvh_index,\x20sampler2D\x20bvh_bvhBounds,\x20usampler2D\x20bvh_bvhContents,\x0a\x0a\x09//\x20ray\x0a\x09vec3\x20rayOrigin,\x20vec3\x20rayDirection,\x0a\x0a\x09//\x20output\x20variables\x20split\x20into\x20separate\x20variables\x20due\x20to\x20output\x20precision\x0a\x09inout\x20uvec4\x20faceIndices,\x20inout\x20vec3\x20faceNormal,\x20inout\x20vec3\x20barycoord,\x0a\x09inout\x20float\x20side,\x20inout\x20float\x20dist\x0a)\x20{\x0a\x0a\x09//\x20stack\x20needs\x20to\x20be\x20twice\x20as\x20long\x20as\x20the\x20deepest\x20tree\x20we\x20expect\x20because\x0a\x09//\x20we\x20push\x20both\x20the\x20left\x20and\x20right\x20child\x20onto\x20the\x20stack\x20every\x20traversal\x0a\x09int\x20ptr\x20=\x200;\x0a\x09uint\x20stack[\x20BVH_STACK_DEPTH\x20];\x0a\x09stack[\x200\x20]\x20=\x200u;\x0a\x0a\x09float\x20triangleDistance\x20=\x20INFINITY;\x0a\x09bool\x20found\x20=\x20false;\x0a\x09while\x20(\x20ptr\x20>\x20-\x201\x20&&\x20ptr\x20<\x20BVH_STACK_DEPTH\x20)\x20{\x0a\x0a\x09\x09uint\x20currNodeIndex\x20=\x20stack[\x20ptr\x20];\x0a\x09\x09ptr\x20--;\x0a\x0a\x09\x09//\x20check\x20if\x20we\x20intersect\x20the\x20current\x20bounds\x0a\x09\x09float\x20boundsHitDistance;\x0a\x09\x09if\x20(\x0a\x09\x09\x09!\x20intersectsBVHNodeBounds(\x20rayOrigin,\x20rayDirection,\x20bvh_bvhBounds,\x20currNodeIndex,\x20boundsHitDistance\x20)\x0a\x09\x09\x09||\x20boundsHitDistance\x20>\x20triangleDistance\x0a\x09\x09)\x20{\x0a\x0a\x09\x09\x09continue;\x0a\x0a\x09\x09}\x0a\x0a\x09\x09uvec2\x20boundsInfo\x20=\x20uTexelFetch1D(\x20bvh_bvhContents,\x20currNodeIndex\x20).xy;\x0a\x09\x09bool\x20isLeaf\x20=\x20bool(\x20boundsInfo.x\x20&\x200xffff0000u\x20);\x0a\x0a\x09\x09if\x20(\x20isLeaf\x20)\x20{\x0a\x0a\x09\x09\x09uint\x20count\x20=\x20boundsInfo.x\x20&\x200x0000ffffu;\x0a\x09\x09\x09uint\x20offset\x20=\x20boundsInfo.y;\x0a\x0a\x09\x09\x09found\x20=\x20intersectTriangles(\x0a\x09\x09\x09\x09bvh_position,\x20bvh_index,\x20offset,\x20count,\x0a\x09\x09\x09\x09rayOrigin,\x20rayDirection,\x20triangleDistance,\x0a\x09\x09\x09\x09faceIndices,\x20faceNormal,\x20barycoord,\x20side,\x20dist\x0a\x09\x09\x09)\x20||\x20found;\x0a\x0a\x09\x09}\x20else\x20{\x0a\x0a\x09\x09\x09uint\x20leftIndex\x20=\x20currNodeIndex\x20+\x201u;\x0a\x09\x09\x09uint\x20splitAxis\x20=\x20boundsInfo.x\x20&\x200x0000ffffu;\x0a\x09\x09\x09uint\x20rightIndex\x20=\x20boundsInfo.y;\x0a\x0a\x09\x09\x09bool\x20leftToRight\x20=\x20rayDirection[\x20splitAxis\x20]\x20>=\x200.0;\x0a\x09\x09\x09uint\x20c1\x20=\x20leftToRight\x20?\x20leftIndex\x20:\x20rightIndex;\x0a\x09\x09\x09uint\x20c2\x20=\x20leftToRight\x20?\x20rightIndex\x20:\x20leftIndex;\x0a\x0a\x09\x09\x09//\x20set\x20c2\x20in\x20the\x20stack\x20so\x20we\x20traverse\x20it\x20later.\x20We\x20need\x20to\x20keep\x20track\x20of\x20a\x20pointer\x20in\x0a\x09\x09\x09//\x20the\x20stack\x20while\x20we\x20traverse.\x20The\x20second\x20pointer\x20added\x20is\x20the\x20one\x20that\x20will\x20be\x0a\x09\x09\x09//\x20traversed\x20first\x0a\x09\x09\x09ptr\x20++;\x0a\x09\x09\x09stack[\x20ptr\x20]\x20=\x20c2;\x0a\x0a\x09\x09\x09ptr\x20++;\x0a\x09\x09\x09stack[\x20ptr\x20]\x20=\x20c1;\x0a\x0a\x09\x09}\x0a\x0a\x09}\x0a\x0a\x09return\x20found;\x0a\x0a}\x0a',Z5='\x0astruct\x20BVH\x20{\x0a\x0a\x09usampler2D\x20index;\x0a\x09sampler2D\x20position;\x0a\x0a\x09sampler2D\x20bvhBounds;\x0a\x09usampler2D\x20bvhContents;\x0a\x0a};\x0a',Z6=Z5,Z7='\x0a\x09'+Z3+'\x0a\x09'+Z4+'\x0a',Z8=parseInt(b['replace'](/\D+/g,''));class Z9 extends Aj{constructor(ZI,ZZ=new Aw(0xd0d0e0),ZU=0x1,ZW=0x4,Za=2.4,ZJ=0x0,ZS=0.2,ZD=!0x0){const ZG=()=>{var Zh,Zl;const Zm={},Zd=AN(ZI),Zq=(Zl=Zd?(Zh=ZI['image'][0x0])==null?void 0x0:Zh['width']:ZI['image']['width'])!=null?Zl:0x400,Zj=Math['floor'](Math['log2'](Zq/0x4)),Zu=Math['pow'](0x2,Zj),Zw=0x3*Math['max'](Zu,0x10*0x7),Zk=0x4*Zu;return Zd&&(Zm['ENVMAP_TYPE_CUBEM']=''),Zm['CUBEUV_TEXEL_WIDTH']=''+0x1/Zw,Zm['CUBEUV_TEXEL_HEIGHT']=''+0x1/Zk,Zm['CUBEUV_MAX_MIP']=Zj+'.0',ZS>0x0&&(Zm['CHROMATIC_ABERRATIONS']=''),ZD&&(Zm['FAST_CHROMA']=''),Zm;};super({'vertexShader':ZA,'fragmentShader':ZR,'uniforms':{'envMap':{'value':ZI},'color':{'value':ZZ},'opacity':{'value':ZU},'bounces':{'value':ZW},'ior':{'value':Za},'correctMips':{'value':!0x0},'aberrationStrength':{'value':ZS},'fresnel':{'value':ZJ},'bvh':{'value':new Z0()},'resolution':{'value':new Au()},'viewMatrixInverse':{'value':new Ah()},'projectionMatrixInverse':{'value':new Ah()}},'defines':ZG()}),this['toneMapped']=!0x1,this['onBeforeRender']=(Zh,Zl,Zm,Zd)=>{this['uniforms']['viewMatrixInverse']['value']=Zm['matrixWorld'],this['uniforms']['projectionMatrixInverse']['value']=Zm['projectionMatrixInverse'],this['uniforms']['resolution']['value']=Zh['getSize'](new Au()),Zd['bvh']||(Zd['bvh']=new Iz(Zd['clone']()['toNonIndexed'](),{'strategy':RR})),this['uniforms']['bvh']['value']['updateFrom'](Zd['bvh']),this['uniformsNeedUpdate']=!0x0;};}}const ZA='\x0a\x20\x20\x20\x20uniform\x20mat4\x20viewMatrixInverse;\x0a\x0a\x20\x20\x20\x20varying\x20vec3\x20vWorldPosition;\x0a\x20\x20\x20\x20varying\x20vec3\x20vNormal;\x0a\x20\x20\x20\x20varying\x20mat4\x20vModelMatrixInverse;\x0a\x0a\x20\x20\x20\x20#include\x20<color_pars_vertex>\x0a\x0a\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_vertex>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20transformedNormal\x20=\x20vec4(normal,\x200.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20transformedPosition\x20=\x20vec4(position,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20USE_INSTANCING\x0a\x20\x20\x20\x20\x20\x20\x20\x20transformedNormal\x20=\x20instanceMatrix\x20*\x20transformedNormal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20transformedPosition\x20=\x20instanceMatrix\x20*\x20transformedPosition;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20USE_INSTANCING\x0a\x20\x20\x20\x20\x20\x20\x20\x20vModelMatrixInverse\x20=\x20inverse(modelMatrix\x20*\x20instanceMatrix);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20vModelMatrixInverse\x20=\x20inverse(modelMatrix);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20vWorldPosition\x20=\x20(modelMatrix\x20*\x20transformedPosition).xyz;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vNormal\x20=\x20normalize((viewMatrixInverse\x20*\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec4(normalMatrix\x20*\x20transformedNormal.xyz,\x200.0)).xyz);\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_Position\x20=\x20projectionMatrix\x20*\x20viewMatrix\x20*\x20modelMatrix\x20*\x20transformedPosition;\x0a\x20\x20\x20\x20}',ZR='\x0a\x20\x20\x20\x20#define\x20ENVMAP_TYPE_CUBE_UV\x0a\x20\x20\x20\x20precision\x20highp\x20isampler2D;\x0a\x20\x20\x20\x20precision\x20highp\x20usampler2D;\x0a\x20\x20\x20\x20varying\x20vec3\x20vWorldPosition;\x0a\x20\x20\x20\x20varying\x20vec3\x20vNormal;\x0a\x20\x20\x20\x20varying\x20mat4\x20vModelMatrixInverse;\x0a\x0a\x20\x20\x20\x20#include\x20<color_pars_fragment>\x0a\x0a\x20\x20\x20\x20#ifdef\x20ENVMAP_TYPE_CUBEM\x0a\x20\x20\x20\x20uniform\x20samplerCube\x20envMap;\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20uniform\x20sampler2D\x20envMap;\x0a\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20uniform\x20float\x20bounces;\x0a\x20\x20\x20\x20'+Z6+'\x0a\x20\x20\x20\x20'+Z7+'\x0a\x20\x20\x20\x20uniform\x20BVH\x20bvh;\x0a\x20\x20\x20\x20uniform\x20float\x20ior;\x0a\x20\x20\x20\x20uniform\x20bool\x20correctMips;\x0a\x20\x20\x20\x20uniform\x20vec2\x20resolution;\x0a\x20\x20\x20\x20uniform\x20float\x20fresnel;\x0a\x20\x20\x20\x20uniform\x20mat4\x20modelMatrix;\x0a\x20\x20\x20\x20uniform\x20mat4\x20projectionMatrixInverse;\x0a\x20\x20\x20\x20uniform\x20mat4\x20viewMatrixInverse;\x0a\x20\x20\x20\x20uniform\x20float\x20aberrationStrength;\x0a\x20\x20\x20\x20uniform\x20vec3\x20color;\x0a\x20\x20\x20\x20uniform\x20float\x20opacity;\x0a\x0a\x20\x20\x20\x20float\x20fresnelFunc(vec3\x20viewDirection,\x20vec3\x20worldNormal)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20pow(1.0\x20+\x20dot(viewDirection,\x20worldNormal),\x2010.0);\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20vec3\x20totalInternalReflection(vec3\x20ro,\x20vec3\x20rd,\x20vec3\x20normal,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20ior,\x20mat4\x20modelMatrixInverse)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayOrigin\x20=\x20ro;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirection\x20=\x20rd;\x0a\x20\x20\x20\x20\x20\x20\x20\x20rayDirection\x20=\x20refract(rayDirection,\x20normal,\x201.0\x20/\x20ior);\x0a\x20\x20\x20\x20\x20\x20\x20\x20rayOrigin\x20=\x20vWorldPosition\x20+\x20rayDirection\x20*\x200.0001;\x0a\x20\x20\x20\x20\x20\x20\x20\x20rayOrigin\x20=\x20(modelMatrixInverse\x20*\x20vec4(rayOrigin,\x201.0)).xyz;\x0a\x20\x20\x20\x20\x20\x20\x20\x20rayDirection\x20=\x20normalize((modelMatrixInverse\x20*\x20vec4(rayDirection,\x200.0)).xyz);\x0a\x20\x20\x20\x20\x20\x20\x20\x20for(float\x20i\x20=\x200.0;\x20i\x20<\x20bounces;\x20i++)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20uvec4\x20faceIndices\x20=\x20uvec4(0u);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20faceNormal\x20=\x20vec3(0.0,\x200.0,\x201.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20barycoord\x20=\x20vec3(0.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20side\x20=\x201.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20float\x20dist\x20=\x200.0;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20bvhIntersectFirstHit(bvh,\x20rayOrigin,\x20rayDirection,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20faceIndices,\x20faceNormal,\x20barycoord,\x20side,\x20dist);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20hitPos\x20=\x20rayOrigin\x20+\x20rayDirection\x20*\x20max(dist\x20-\x200.001,\x200.0);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20tempDir\x20=\x20refract(rayDirection,\x20faceNormal,\x20ior);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20if\x20(length(tempDir)\x20!=\x200.0)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rayDirection\x20=\x20tempDir;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20break;\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rayDirection\x20=\x20reflect(rayDirection,\x20faceNormal);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rayOrigin\x20=\x20hitPos\x20+\x20rayDirection\x20*\x200.01;\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20\x20\x20\x20\x20rayDirection\x20=\x20normalize((modelMatrix\x20*\x20vec4(rayDirection,\x200.0)).xyz);\x0a\x20\x20\x20\x20\x20\x20\x20\x20return\x20rayDirection;\x0a\x20\x20\x20\x20}\x0a\x0a\x20\x20\x20\x20#include\x20<common>\x0a\x20\x20\x20\x20#include\x20<cube_uv_reflection_fragment>\x0a\x0a\x20\x20\x20\x20#ifdef\x20ENVMAP_TYPE_CUBEM\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20textureGradient(samplerCube\x20envMap,\x20vec3\x20rayDirection,\x20vec3\x20directionCamPerfect)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20textureGrad(envMap,\x20rayDirection,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20dFdx(correctMips\x20?\x20directionCamPerfect\x20:\x20rayDirection),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20dFdy(correctMips\x20?\x20directionCamPerfect\x20:\x20rayDirection));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20textureGradient(sampler2D\x20envMap,\x20vec3\x20rayDirection,\x20vec3\x20directionCamPerfect)\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uvv\x20=\x20equirectUv(rayDirection);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20smoothUv\x20=\x20equirectUv(directionCamPerfect);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20return\x20textureGrad(envMap,\x20uvv,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20dFdx(correctMips\x20?\x20smoothUv\x20:\x20uvv),\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20dFdy(correctMips\x20?\x20smoothUv\x20:\x20uvv));\x0a\x20\x20\x20\x20\x20\x20\x20\x20}\x0a\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20void\x20main()\x20{\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec2\x20uv\x20=\x20gl_FragCoord.xy\x20/\x20resolution;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20directionCamPerfect\x20=\x20(projectionMatrixInverse\x20*\x20vec4(uv\x20*\x202.0\x20-\x201.0,\x200.0,\x201.0)).xyz;\x0a\x20\x20\x20\x20\x20\x20\x20\x20directionCamPerfect\x20=\x20(viewMatrixInverse\x20*\x20vec4(directionCamPerfect,\x200.0)).xyz;\x0a\x20\x20\x20\x20\x20\x20\x20\x20directionCamPerfect\x20=\x20normalize(directionCamPerfect);\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20normal\x20=\x20vNormal;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayOrigin\x20=\x20cameraPosition;\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirection\x20=\x20normalize(vWorldPosition\x20-\x20cameraPosition);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec4\x20diffuseColor\x20=\x20vec4(color,\x20opacity);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<color_fragment>\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20CHROMATIC_ABERRATIONS\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirectionG\x20=\x20totalInternalReflection(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rayOrigin,\x20rayDirection,\x20normal,\x20max(ior,\x201.0),\x20vModelMatrixInverse);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#ifdef\x20FAST_CHROMA\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirectionR\x20=\x20normalize(rayDirectionG\x20+\x201.0\x20*\x20vec3(aberrationStrength\x20/\x202.0));\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirectionB\x20=\x20normalize(rayDirectionG\x20-\x201.0\x20*\x20vec3(aberrationStrength\x20/\x202.0));\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirectionR\x20=\x20totalInternalReflection(rayOrigin,\x20rayDirection,\x20normal,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20max(ior\x20*\x20(1.0\x20-\x20aberrationStrength),\x201.0),\x20vModelMatrixInverse);\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20rayDirectionB\x20=\x20totalInternalReflection(rayOrigin,\x20rayDirection,\x20normal,\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20max(ior\x20*\x20(1.0\x20+\x20aberrationStrength),\x201.0),\x20vModelMatrixInverse);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20finalColorR\x20=\x20textureGradient(envMap,\x20rayDirectionR,\x20directionCamPerfect).r;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20finalColorG\x20=\x20textureGradient(envMap,\x20rayDirectionG,\x20directionCamPerfect).g;\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20finalColorB\x20=\x20textureGradient(envMap,\x20rayDirectionB,\x20directionCamPerfect).b;\x0a\x20\x20\x20\x20\x20\x20\x20\x20diffuseColor.rgb\x20*=\x20vec3(finalColorR,\x20finalColorG,\x20finalColorB);\x0a\x20\x20\x20\x20\x20\x20\x20\x20#else\x0a\x20\x20\x20\x20\x20\x20\x20\x20rayDirection\x20=\x20totalInternalReflection(\x0a\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20rayOrigin,\x20rayDirection,\x20normal,\x20max(ior,\x201.0),\x20vModelMatrixInverse);\x0a\x20\x20\x20\x20\x20\x20\x20\x20diffuseColor.rgb\x20*=\x20textureGradient(envMap,\x20rayDirection,\x20directionCamPerfect).rgb;\x0a\x20\x20\x20\x20\x20\x20\x20\x20#endif\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20vec3\x20viewDirection\x20=\x20normalize(vWorldPosition\x20-\x20cameraPosition);\x0a\x20\x20\x20\x20\x20\x20\x20\x20float\x20nFresnel\x20=\x20fresnelFunc(viewDirection,\x20normal)\x20*\x20fresnel;\x0a\x20\x20\x20\x20\x20\x20\x20\x20gl_FragColor\x20=\x20vec4(mix(diffuseColor.rgb,\x20vec3(1.0),\x20nFresnel),\x20diffuseColor.a);\x0a\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<tonemapping_fragment>\x0a\x20\x20\x20\x20\x20\x20\x20\x20#include\x20<'+(Z8>=0x9a?'colorspace_fragment':'encodings_fragment')+'>\x0a\x20\x20\x20\x20}';export{AK as BoneList,AC as FaceMaskPlugin,AO as FacePlugin,Ao as FaceRenderer,Ac as FaceTrackPlugin,R4 as HandAlignPlugin,R5 as HandFitPlugin,AV as HandPlugin,AF as HandRenderer,Ay as HeadTrackPlugin,R8 as OccluderMaterial,R7 as OccluderPlugin,AB as PoseAlignPlugin,Ax as PoseOutfitPlugin,Ab as PosePlugin,Ap as PoseRenderer,Az as PoseTwinPlugin,AY as PoseUtils,Z9 as RefractionMaterial,R6 as RingFitPlugin,AX as ThreePlugin,AQ as ThreeRenderer,AH as isBone,AN as isCubeTexture,Av as isMesh,R0 as isMeshPhysicalMaterial,AL as isMeshStandardMaterial,Af as isSkinnedMesh};
