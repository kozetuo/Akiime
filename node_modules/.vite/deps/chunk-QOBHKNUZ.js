import {
  __commonJS,
  __toESM
} from "./chunk-5WRI5ZAA.js";

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn) console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/@geenee/armature/dist/armature.js
var import_events = __toESM(require_events());
var c = class extends import_events.EventEmitter {
};
var R = Object["defineProperty"];
var h = Object["getOwnPropertySymbols"];
var p = Object["prototype"]["hasOwnProperty"];
var I = Object["prototype"]["propertyIsEnumerable"];
var f = (bx, bi, bX) => bi in bx ? R(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var a = (bx, bi) => {
  for (var bX in bi || (bi = {})) p["call"](bi, bX) && f(bx, bX, bi[bX]);
  if (h) {
    for (var bX of h(bi)) I["call"](bi, bX) && f(bx, bX, bi[bX]);
  }
  return bx;
};
var r = class {
  constructor(bx = "canvas") {
    this["size"] = { "width": 0, "height": 0 }, this["transpose"] = false, this["context"] = null, this["canvas"] = document["createElement"]("canvas"), this["canvas"]["id"] = "engeenee.capture." + bx, this["canvas"]["hidden"] = true, this["context"] = this["canvas"]["getContext"]("2d", { "alpha": false });
  }
  ["capture"](bx) {
    const { context: bi, clipPix: bX, transpose: bw } = this;
    if (!bi) return false;
    let { width: bo, height: bK } = this["size"];
    return bw && ([bo, bK] = [bK, bo]), bw && bi["setTransform"](0, 1, 1, 0, 0, 0), bX ? bi["drawImage"](bx, bX["left"], bX["top"], bX["width"], bX["height"], 0, 0, bo, bK) : bi["drawImage"](bx, 0, 0, bo, bK), bw && bi["resetTransform"](), true;
  }
  ["fill"]() {
    const { context: bx } = this;
    if (!bx) return;
    let { width: bi, height: bX } = this["size"];
    bx["fillStyle"] = "rgba(255, 255, 255, 1)", bx["fillRect"](0, 0, bi, bX);
  }
  ["data"]() {
    const { context: bx } = this;
    if (!bx) return;
    const { width: bi, height: bX } = this["size"];
    return bx["getImageData"](0, 0, bi, bX);
  }
  ["setSize"](bx) {
    let { width: bi, height: bX } = bx;
    this["transpose"] && ([bi, bX] = [bX, bi]), this["size"] = { "width": bi, "height": bX }, this["canvas"]["width"] = bi, this["canvas"]["height"] = bX, this["setClip"](this["clip"]);
  }
  ["setClip"](bx) {
    let { width: bi, height: bX } = this["size"];
    this["transpose"] && ([bi, bX] = [bX, bi]), this["clip"] = bx, this["clipPix"] = bx && { "left": bx["left"] * bi, "top": bx["top"] * bX, "width": bx["width"] * bi, "height": bx["height"] * bX };
  }
  ["setTranspose"](bx) {
    if (bx == this["transpose"]) return;
    let { width: bi, height: bX } = this["size"];
    this["transpose"] && ([bi, bX] = [bX, bi]), this["transpose"] = bx, this["setSize"]({ "width": bi, "height": bX });
  }
  ["dispose"]() {
    this["context"] = null, this["canvas"]["remove"]();
  }
};
var M = class extends c {
  constructor() {
    super(), this["buffer"] = new r("capture"), this["captureTime"] = 0;
  }
  async ["setup"](bx) {
    delete this["sizeMax"], delete this["aspectRatio"], delete this["clipRect"], delete this["transpose"];
    const bi = ((bw) => bw !== void 0 && typeof bw != "string" && "size" in bw)(bx) ? bx : void 0, bX = (bi == null ? void 0 : bi["size"]) || { "width": 1920, "height": 1080 };
    return bi && (this["aspectRatio"] = bi["ratio"], this["clipRect"] = bi["clip"], this["transpose"] = bi["transpose"]), this["updateSize"](bX), this["buffer"]["fill"](), true;
  }
  ["dispose"]() {
    this["reset"](), this["buffer"]["dispose"]();
  }
  async ["start"]() {
    this["captureTime"] = 0, this["timer"] = Date["now"]();
  }
  ["pause"]() {
  }
  ["reset"]() {
    this["pause"](), delete this["timer"];
  }
  ["capture"]() {
    return this["timer"] === void 0 ? false : (this["captureTime"] = (Date["now"]() - this["timer"]) * 1e3, true);
  }
  ["size"]() {
    return a({}, this["buffer"]["size"]);
  }
  ["ratio"]() {
    const bx = this["buffer"]["size"];
    return bx["width"] / bx["height"];
  }
  ["updateSize"](bx) {
    let { width: bi, height: bX } = bx, { sizeMax: bw, aspectRatio: bo, clipRect: bK, transpose: bY } = this;
    if (bw && (bi > bw || bX > bw)) {
      const bs = bi / bX;
      bs > 1 ? (bi = bw, bX = bw / bs) : (bX = bw, bi = bs * bw), bx = { "width": bi, "height": bX };
    }
    const bd = bi / bX;
    bo && bd > bo ? (bK = { "left": 0.5 * (bd / bo - 1), "top": 0, "width": 1, "height": 1 }, bi = bX * bo, bx = { "width": bi, "height": bX }) : bo && bd < bo && (bK = { "top": 0.5 * (bo / bd - 1), "left": 0, "width": 1, "height": 1 }, bX = bi / bo, bx = { "width": bi, "height": bX }), this["buffer"]["setSize"](bx), this["buffer"]["setClip"](bK), this["buffer"]["setTranspose"](!!bY), this["emit"]("resize", this["buffer"]["size"]);
  }
};
var n = Object["defineProperty"];
var u = Object["getOwnPropertySymbols"];
var t = Object["prototype"]["hasOwnProperty"];
var A = Object["prototype"]["propertyIsEnumerable"];
var l = (bx, bi, bX) => bi in bx ? n(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var F = (bx, bi) => {
  for (var bX in bi || (bi = {})) t["call"](bi, bX) && l(bx, bX, bi[bX]);
  if (u) {
    for (var bX of u(bi)) A["call"](bi, bX) && l(bx, bX, bi[bX]);
  }
  return bx;
};
var m = (bx, bi) => {
  var bX = {};
  for (var bw in bx) t["call"](bx, bw) && bi["indexOf"](bw) < 0 && (bX[bw] = bx[bw]);
  if (bx != null && u) {
    for (var bw of u(bx)) bi["indexOf"](bw) < 0 && A["call"](bx, bw) && (bX[bw] = bx[bw]);
  }
  return bX;
};
var x = class extends M {
  constructor() {
    super(), this["timeShift"] = 0, this["videoRef"] = document["createElement"]("video"), this["videoRef"]["id"] = "engeenee.capture.source", this["videoRef"]["muted"] = true, this["videoRef"]["loop"] = true, this["videoRef"]["playsInline"] = true;
  }
  async ["setup"](bx) {
    const bi = (bd) => typeof bd == "string" || "url" in bd && typeof bd["url"] == "string", bX = (bd) => bi(bd) || "getVideoTracks" in bd, bw = (bd) => bi(bd) && typeof bd != "string" ? (this["sizeMax"] = bd["sizeMax"], bd["url"]) : bd, bo = (bd) => {
      var bs, bQ;
      if (!bd) return { "video": true, "audio": false };
      this["aspectRatio"] = bd["ratio"], this["clipRect"] = bd["clip"], this["transpose"] = bd["transpose"];
      const bU = bd["opts"] || {}, { video: bE } = bU, bg = m(bU, ["video"]);
      return F({ "video": F({ "facingMode": bd["rear"] === void 0 ? void 0 : bd["rear"] ? "environment" : "user", "width": (bs = bd["size"]) == null ? void 0 : bs["width"], "height": (bQ = bd["size"]) == null ? void 0 : bQ["height"], "frameRate": bd["fps"] }, bE instanceof Object ? bE : {}), "audio": false }, bg);
    };
    delete this["sizeMax"], delete this["aspectRatio"], delete this["clipRect"], delete this["transpose"];
    const bK = bx !== void 0 && bX(bx) ? bw(bx) : await navigator["mediaDevices"]["getUserMedia"](bo(bx))["catch"](() => {
    });
    if (!bK) return false;
    const { videoRef: bY } = this;
    return new Promise((bd) => {
      bY["onloadedmetadata"] = () => {
        this["updateSize"]({ "width": bY["videoWidth"], "height": bY["videoHeight"] }), bY["onresize"] = () => {
          this["updateSize"]({ "width": bY["videoWidth"], "height": bY["videoHeight"] });
        }, bY["onseeked"] = () => {
          this["timeShift"] = this["captureTime"], this["captureTime"] = 0;
        }, bd(true);
      }, typeof bK == "string" ? bY["src"] = bK : bY["srcObject"] = bK;
    });
  }
  ["dispose"]() {
    super["dispose"](), this["videoRef"]["remove"]();
  }
  async ["start"]() {
    this["captureTime"] = 0, this["timeShift"] = 0, (this["videoRef"]["srcObject"] || this["videoRef"]["src"]) && await this["videoRef"]["play"]();
  }
  ["pause"]() {
    this["videoRef"]["pause"]();
  }
  ["reset"]() {
    this["pause"](), this["videoRef"]["srcObject"] && (this["videoRef"]["srcObject"]["getTracks"]()["forEach"]((bx) => bx["stop"]()), this["videoRef"]["srcObject"] = null);
  }
  ["capture"]() {
    const { videoRef: bx, buffer: bi } = this, bX = bx["currentTime"] + this["timeShift"];
    return bX <= this["captureTime"] ? false : (this["captureTime"] = bX, bi["capture"](bx));
  }
};
var i = class extends c {
  constructor(bx, bi, bX = x) {
    super(), this["engineParams"] = bi, this["renderers"] = [], this["videoRatio"] = 1920 / 1080, this["streamSize"] = { "width": 1920, "height": 1080 }, this["processSize"] = { "width": 1920, "height": 1080 }, this["resizeEnabled"] = false, this["loopState"] = false, this["init"] = async (bw) => {
      const bo = await this["setupProcessor"](bw);
      return this["emit"]("init", bo), bo;
    }, this["setup"] = async (bw) => {
      this["pause"]();
      const bo = await this["setupVideo"](bw);
      return this["emit"]("setup", bo), bo;
    }, this["start"] = async () => {
      await this["video"]["start"](), this["loopState"] = true, this["emit"]("start"), this["enqueue"]();
    }, this["pause"] = () => {
      this["loopState"] = false, this["loopId"] && (window["cancelAnimationFrame"](this["loopId"]), delete this["loopId"]), this["video"]["pause"](), this["emit"]("pause");
    }, this["reset"] = () => {
      this["pause"](), this["video"]["reset"](), delete this["streamCanvas"], delete this["processCanvas"], this["processor"]["reset"]();
    }, this["iterate"] = async () => {
      var bw;
      const { video: bo, streamCanvas: bK, processCanvas: bY } = this;
      if (!bo["capture"]() || !bK || !bY) return this["enqueue"]();
      this["resizeEnabled"] && ((bw = this["resizeBuffer"]) == null || bw["capture"](bo["buffer"]["canvas"]));
      const bd = await this["processor"]["process"](bY, bo["captureTime"]);
      bd && await Promise["all"](this["renderers"]["map"]((bs) => bs["update"](bd, bK))), this["enqueue"]();
    }, this["processor"] = typeof bx == "function" ? new bx() : bx, this["video"] = typeof bX == "function" ? new bX() : bX, this["video"]["on"]("resize", this["resizeVideo"]["bind"](this));
  }
  async ["addRenderer"](bx) {
    this["renderers"]["push"](bx), await bx["load"](), bx["setupVideo"](this["video"]["size"](), this["video"]["ratio"]()), bx["setupCamera"](this["processor"]["cameraRatio"], this["processor"]["cameraAngle"]);
  }
  ["removeRenderer"](bx) {
    const { renderers: bi } = this, bX = bi["indexOf"](bx);
    bX < 0 || (bi[bX]["dispose"](), bi["splice"](bX, 1));
  }
  ["enqueue"]() {
    this["loopId"] = this["loopState"] ? window["requestAnimationFrame"](this["iterate"]) : void 0;
  }
  async ["setupProcessor"](bx) {
    var bi;
    const bX = this["resizeEnabled"] && ((bi = this["resizeBuffer"]) == null ? void 0 : bi["size"]) || this["video"]["size"]();
    return this["processor"]["init"](bx, bX, this["video"]["ratio"]());
  }
  async ["setupVideo"](bx) {
    return this["video"]["reset"](), await this["video"]["setup"](bx) ? (this["setupSize"](this["video"]["size"]()), true) : false;
  }
  async ["setupSize"](bx) {
    var bi, bX;
    const { width: bw, height: bo } = bx;
    this["videoRatio"] = bw / bo;
    const bK = Math["max"](bw, bo), bY = ((bi = this["engineParams"]) == null ? void 0 : bi["max"]) || this["processor"]["optimalSize"];
    if (this["resizeEnabled"] = false, bY < bK) {
      this["resizeEnabled"] = true;
      const bd = bK / bY;
      this["resizeBuffer"] || (this["resizeBuffer"] = new r("resize")), this["resizeBuffer"]["setSize"]({ "width": bw / bd, "height": bo / bd });
    }
    this["resizeEnabled"] && this["resizeBuffer"] ? (this["processCanvas"] = this["resizeBuffer"]["canvas"], this["processSize"] = this["resizeBuffer"]["size"]) : (this["processCanvas"] = this["video"]["buffer"]["canvas"], this["processSize"] = this["video"]["size"]()), ((bX = this["engineParams"]) == null ? void 0 : bX["orig"]) !== false ? (this["streamCanvas"] = this["video"]["buffer"]["canvas"], this["streamSize"] = this["video"]["size"]()) : (this["streamCanvas"] = this["processCanvas"], this["streamSize"] = this["streamSize"]);
  }
  ["resizeVideo"](bx) {
    this["setupSize"](bx), this["processor"]["setupVideo"](this["processSize"], this["videoRatio"]), this["renderers"]["forEach"]((bi) => bi["setupVideo"](this["streamSize"], this["videoRatio"])), this["renderers"]["forEach"]((bi) => bi["setupCamera"](this["processor"]["cameraRatio"], this["processor"]["cameraAngle"]));
  }
};
var o = Object["defineProperty"];
var d = Object["getOwnPropertySymbols"];
var e = Object["prototype"]["hasOwnProperty"];
var s = Object["prototype"]["propertyIsEnumerable"];
var U = (bx, bi, bX) => bi in bx ? o(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var E = (bx, bi) => {
  for (var bX in bi || (bi = {})) e["call"](bi, bX) && U(bx, bX, bi[bX]);
  if (d) {
    for (var bX of d(bi)) s["call"](bi, bX) && U(bx, bX, bi[bX]);
  }
  return bx;
};
var b0 = class extends c {
  constructor() {
    super(), this["params"] = {}, this["videoSize"] = { "width": 1920, "height": 1080 }, this["videoRatio"] = this["videoSize"]["width"] / this["videoSize"]["height"], this["optimalSize"] = 1024, this["cameraRatio"] = this["videoRatio"], this["cameraAngle"] = 60 / 180 * Math["PI"];
  }
  async ["process"](bx, bi) {
    return {};
  }
  async ["init"](bx, bi, bX) {
    return this["params"] = bx, !bX && bi && (bX = bi["width"] / bi["height"]), this["setupVideo"](bi || this["videoSize"], bX || this["videoRatio"]), this["emit"]("init", true), true;
  }
  ["reset"]() {
    this["emit"]("reset");
  }
  ["dispose"]() {
  }
  ["setupVideo"](bx, bi) {
    bi = bi || bx["width"] / bx["height"], this["videoSize"] = E({}, bx), this["videoRatio"] = bi, this["cameraRatio"] = bi;
  }
};
var b1 = class extends M {
  async ["setup"](bx) {
    var bi;
    if ((bi = this["imageRef"]) == null || bi["close"](), delete this["imageRef"], typeof bx != "string") return false;
    const bX = await (await fetch(bx))["blob"]();
    return this["imageRef"] = await createImageBitmap(bX), this["updateSize"]({ "width": this["imageRef"]["width"], "height": this["imageRef"]["height"] }), true;
  }
  ["dispose"]() {
    var bx;
    super["dispose"](), (bx = this["imageRef"]) == null || bx["close"](), delete this["imageRef"];
  }
  async ["start"]() {
    this["captureTime"] = Date["now"]();
  }
  ["pause"]() {
  }
  ["reset"]() {
    var bx;
    this["pause"](), (bx = this["imageRef"]) == null || bx["close"](), delete this["imageRef"];
  }
  ["capture"]() {
    const { imageRef: bx, buffer: bi } = this;
    if (!bx) return false;
    const bX = Date["now"]();
    return bX <= this["captureTime"] ? false : (this["captureTime"] = bX, bi["capture"](bx));
  }
};
var b2 = class extends c {
  constructor(bx, bi = "crop", bX = 1, bw = false, bo = 1) {
    super(), this["container"] = bx, this["mode"] = bi, this["layerCount"] = bX, this["mirror"] = bw, this["aspectRatio"] = bo, this["layers"] = [], this["padsSize"] = [1, 1], this["setAspectRatio"] = (bK) => {
      this["aspectRatio"] = bK, this["updateSizes"](this["container"]["clientWidth"] / this["container"]["clientHeight"]);
    }, this["setMirror"] = (bK) => {
      this["mirror"] = bK, this["layers"]["forEach"]((bY) => {
        bY["style"]["transform"] = bK ? "scaleX(-1)" : "";
      });
    }, this["getMirror"] = () => this["mirror"], this["setMode"] = (bK) => {
      if (this["mode"] = bK, this["mode"] === "pad" && !this["pads"]) {
        this["pads"] = [document["createElement"]("canvas"), document["createElement"]("canvas")];
        const bY = -10 * (this["layerCount"] + 1) + "";
        for (let bd = 0; bd < 2; bd++) this["pads"][bd]["id"] = "engeenee.canvas.pad" + bd, this["pads"][bd]["style"]["position"] = "absolute", this["pads"][bd]["style"]["zIndex"] = bY, this["container"]["appendChild"](this["pads"][bd]);
      }
      this["mode"] !== "pad" && this["pads"] && (this["pads"]["forEach"]((bs) => bs["remove"]()), delete this["pads"]), this["setAspectRatio"](this["aspectRatio"]);
    }, this["getMode"] = () => this["mode"], this["dispose"] = () => {
      var bK, bY;
      (bK = this["observer"]) == null || bK["disconnect"](), delete this["observer"], (bY = this["pads"]) == null || bY["forEach"]((bd) => bd["remove"]()), delete this["pads"], this["layers"]["forEach"]((bd) => bd["remove"]()), this["layers"] = [];
    }, this["updateSizes"] = (bK) => {
      let bY = 1, bd = 1;
      bK > this["aspectRatio"] ? this["mode"] === "crop" ? bd = bK / this["aspectRatio"] : bY = this["aspectRatio"] / bK : this["mode"] === "crop" ? bY = this["aspectRatio"] / bK : bd = bK / this["aspectRatio"];
      const bs = (1 - bY) / 2, bQ = (1 - bd) / 2, bU = bY * 100 + "%", bE = bd * 100 + "%", bg = bs * 100 + "%", bW = bQ * 100 + "%";
      for (const D0 of this["layers"]) D0["style"]["width"] = bU, D0["style"]["height"] = bE, D0["style"]["left"] = bg, D0["style"]["top"] = bW;
      if (this["pads"]) {
        this["padsSize"] = bs > 0 ? [bs, 1] : [1, bQ];
        const D1 = 10, { clientWidth: D2, clientHeight: D3 } = this["container"], D4 = [2 * D1 / D2, 2 * D1 / D3], D5 = (this["padsSize"][0] + 2 * D4[0]) * 100 + "%", D6 = (this["padsSize"][1] + 2 * D4[1]) * 100 + "%";
        this["pads"][0]["style"]["width"] = D5, this["pads"][0]["style"]["height"] = D6, this["pads"][1]["style"]["width"] = D5, this["pads"][1]["style"]["height"] = D6;
        const D7 = -D4[0] * 100 + "%", D8 = -D4[1] * 100 + "%";
        this["pads"][0]["style"]["top"] = D8, this["pads"][1]["style"]["bottom"] = D8, this["pads"][0]["style"]["left"] = "unset", this["pads"][0]["style"]["right"] = "unset", this["pads"][1]["style"]["left"] = "unset", this["pads"][1]["style"]["right"] = "unset", this["pads"][this["mirror"] ? 1 : 0]["style"]["left"] = D7, this["pads"][this["mirror"] ? 0 : 1]["style"]["right"] = D7;
        const D9 = bs > 0 ? this["mirror"] ? "" : "scaleX(-1)" : "scaleY(-1) " + (this["mirror"] ? "scaleX(-1)" : "");
        this["pads"][0]["style"]["transform"] = D9, this["pads"][1]["style"]["transform"] = D9;
        const Db = "blur(" + D1 + "px)";
        this["pads"][0]["style"]["filter"] = Db, this["pads"][1]["style"]["filter"] = Db;
      }
      this["emit"]("resize");
    }, this["handleResize"] = (bK) => {
      if (bK["length"] < 1) return;
      const bY = bK[0]["contentRect"];
      this["updateSizes"](bY["width"] / bY["height"]);
    };
    for (let bK = 0; bK < bX; bK++) {
      const bY = document["createElement"]("canvas");
      bY["id"] = "engeenee.canvas.layer" + bK, bY["style"]["position"] = "absolute", bY["style"]["zIndex"] = -10 * (bX - bK) + "", this["mirror"] && (bY["style"]["transform"] = "scaleX(-1)"), this["container"]["appendChild"](bY), this["layers"]["push"](bY);
    }
    this["setMode"](bi), this["observer"] = new ResizeObserver(this["handleResize"]), this["observer"]["observe"](this["container"]), this["container"]["style"]["overflow"] = "hidden";
  }
};
var b3 = Object["defineProperty"];
var b4 = Object["getOwnPropertySymbols"];
var b5 = Object["prototype"]["hasOwnProperty"];
var b6 = Object["prototype"]["propertyIsEnumerable"];
var b7 = (bx, bi, bX) => bi in bx ? b3(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var b8 = (bx, bi) => {
  for (var bX in bi || (bi = {})) b5["call"](bi, bX) && b7(bx, bX, bi[bX]);
  if (b4) {
    for (var bX of b4(bi)) b6["call"](bi, bX) && b7(bx, bX, bi[bX]);
  }
  return bx;
};
var b9 = class extends c {
  constructor() {
    super(), this["loaded"] = false, this["videoSize"] = { "width": 1920, "height": 1080 }, this["videoRatio"] = this["videoSize"]["width"] / this["videoSize"]["height"], this["cameraRatio"] = this["videoRatio"], this["cameraAngle"] = 10 / 180 * Math["PI"];
  }
  async ["load"]() {
    this["loaded"] || (this["loaded"] = true, this["emit"]("load"));
  }
  ["unload"]() {
    this["loaded"] && (this["loaded"] = false);
  }
  async ["update"](bx, bi) {
    this["loaded"] && (this["updateVideo"](bi), this["updateScene"](), this["emit"]("render"));
  }
  ["updateVideo"](bx) {
  }
  ["updateScene"]() {
  }
  ["dispose"]() {
    this["unload"]();
  }
  ["setupVideo"](bx, bi) {
    this["videoSize"] = b8({}, bx), this["videoRatio"] = bi || bx["width"] / bx["height"], this["emit"]("resize", this["videoSize"], this["videoRatio"]);
  }
  ["setupCamera"](bx, bi) {
    this["cameraRatio"] = bx, this["cameraAngle"] = bi;
  }
};
var bb = class extends b9 {
  constructor() {
    super(...arguments), this["plugins"] = [];
  }
  async ["load"]() {
    if (!this["loaded"]) return await Promise["all"](this["plugins"]["map"]((bx) => bx["load"](this))), super["load"]();
  }
  ["unload"]() {
    this["plugins"]["forEach"]((bx) => bx["unload"]()), super["unload"]();
  }
  async ["update"](bx, bi) {
    if (this["loaded"]) return await this["updatePlugins"](bx, bi), super["update"](bx, bi);
  }
  async ["updatePlugins"](bx, bi) {
    for (let bX of this["plugins"]) bX["loaded"] && await bX["update"](bx, bi);
  }
  ["dispose"]() {
    this["plugins"]["forEach"]((bx) => bx["dispose"]()), this["plugins"] = [], super["dispose"]();
  }
  async ["addPlugin"](bx) {
    const { plugins: bi } = this;
    this["loaded"] && !bx["loaded"] && await bx["load"](this), bi["push"](bx), bi["sort"]((bX, bw) => bX["ordinal"] - bw["ordinal"]);
  }
  ["removePlugin"](bx) {
    const { plugins: bi } = this, bX = bi["indexOf"](bx);
    bX < 0 || bi["splice"](bX, 1)[0]["unload"]();
  }
  ["removeAllPlugins"]() {
    this["plugins"]["forEach"]((bx) => bx["dispose"]()), this["plugins"] = [];
  }
  ["setupVideo"](bx, bi) {
    super["setupVideo"](bx, bi), this["plugins"]["forEach"]((bX) => bX["setupVideo"](bx));
  }
  ["setupCamera"](bx, bi) {
    super["setupCamera"](bx, bi), this["plugins"]["forEach"]((bX) => bX["setupCamera"](bx, bi));
  }
};
var bD = class extends bb {
  constructor(bx) {
    super(), this["padCtx"] = [null, null], this["setupPadding"] = () => {
      if (!this["canvas"]["pads"]) return;
      const { width: bi, height: bX } = this["videoSize"], { padsSize: bw } = this["canvas"], bo = bi * bw[0] / (bw[0] < 0.5 ? 1 - 2 * bw[0] : 1), bK = bX * bw[1] / (bw[1] < 0.5 ? 1 - 2 * bw[1] : 1);
      this["canvas"]["pads"][0]["width"] = bo, this["canvas"]["pads"][0]["height"] = bK, this["canvas"]["pads"][1]["width"] = bo, this["canvas"]["pads"][1]["height"] = bK;
    }, this["canvas"] = new b2(bx["container"], bx["mode"], bx["layerCount"], bx["mirror"], bx["aspectRatio"]), this["canvas"]["pads"] && (this["padCtx"] = [this["canvas"]["pads"][0]["getContext"]("2d"), this["canvas"]["pads"][1]["getContext"]("2d")]), this["canvas"]["addListener"]("resize", this["setupPadding"]);
  }
  ["updateVideo"](bx) {
    super["updateVideo"](bx), this["updatePads"](bx);
  }
  ["dispose"]() {
    this["padCtx"] = [null, null], this["canvas"]["dispose"](), super["dispose"]();
  }
  ["setupVideo"](bx, bi) {
    super["setupVideo"](bx, bi), this["canvas"]["setAspectRatio"](this["videoRatio"]);
  }
  ["setMirror"](bx) {
    this["canvas"]["setMirror"](bx);
  }
  ["setMode"](bx) {
    this["canvas"]["setMode"](bx), this["canvas"]["pads"] ? this["padCtx"] = [this["canvas"]["pads"][0]["getContext"]("2d"), this["canvas"]["pads"][1]["getContext"]("2d")] : this["padCtx"] = [null, null];
  }
  ["updatePads"](bx) {
    if (!this["padCtx"][0] || !this["padCtx"][1] || !this["canvas"]["pads"]) return;
    const { videoSize: { width: bi, height: bX } } = this, { width: bw, height: bo } = this["canvas"]["pads"][0];
    this["padCtx"][0]["clearRect"](0, 0, bw, bo), this["padCtx"][0]["drawImage"](bx, 0, 0, bw, bo, 0, 0, bw, bo), this["padCtx"][1]["clearRect"](0, 0, bw, bo), this["padCtx"][1]["drawImage"](bx, bi - bw, bX - bo, bw, bo, 0, 0, bw, bo);
  }
};
var bH = class extends bD {
  constructor(bx) {
    super(bx), this["videoCtx"] = null;
    const bi = this["canvas"]["layers"][0];
    this["videoCtx"] = bi["getContext"]("2d");
  }
  ["updateVideo"](bx) {
    const { videoCtx: bi } = this;
    if (!bi) return;
    const { width: bX, height: bw } = this["videoSize"];
    bi["clearRect"](0, 0, bX, bw), bi["drawImage"](bx, 0, 0), super["updateVideo"](bx);
  }
  ["setupVideo"](bx, bi) {
    super["setupVideo"](bx, bi);
    const { width: bX, height: bw } = this["videoSize"];
    this["canvas"]["layers"][0]["width"] = bX, this["canvas"]["layers"][0]["height"] = bw;
  }
};
var bC = Object["defineProperty"];
var bc = Object["getOwnPropertySymbols"];
var bL = Object["prototype"]["hasOwnProperty"];
var bB = Object["prototype"]["propertyIsEnumerable"];
var bR = (bx, bi, bX) => bi in bx ? bC(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var bk = (bx, bi) => {
  for (var bX in bi || (bi = {})) bL["call"](bi, bX) && bR(bx, bX, bi[bX]);
  if (bc) {
    for (var bX of bc(bi)) bB["call"](bi, bX) && bR(bx, bX, bi[bX]);
  }
  return bx;
};
var bh = class {
  constructor(bx, bi = { "width": 1920, "height": 1080 }, bX = false, bw = false, bo = false) {
    this["gl"] = bx, this["size"] = bi, this["grayscale"] = bX, this["linear"] = bw, this["mipmap"] = bo, this["buffer"] = null, this["levels"] = 0, this["resize"](bi);
  }
  ["update"](bx) {
    const { gl: bi, size: { width: bX, height: bw } } = this, bo = bi["getParameter"](bi["TEXTURE_BINDING_2D"]), bK = bi["getParameter"](bi["UNPACK_FLIP_Y_WEBGL"]);
    return bi["bindTexture"](bi["TEXTURE_2D"], this["buffer"]), bi["pixelStorei"](bi["UNPACK_FLIP_Y_WEBGL"], false), bx instanceof Float32Array ? bi["texSubImage2D"](bi["TEXTURE_2D"], 0, 0, 0, bX, bw, this["grayscale"] ? bi["RED"] : bi["RGBA"], bi["FLOAT"], bx) : bx instanceof Uint8Array ? bi["texSubImage2D"](bi["TEXTURE_2D"], 0, 0, 0, bX, bw, this["grayscale"] ? bi["RED"] : bi["RGBA"], bi["UNSIGNED_BYTE"], bx) : bi["texSubImage2D"](bi["TEXTURE_2D"], 0, 0, 0, bX, bw, this["grayscale"] ? bi["RED"] : bi["RGBA"], bi["UNSIGNED_BYTE"], bx), this["genLevels"](), bi["bindTexture"](bi["TEXTURE_2D"], bo), bi["pixelStorei"](bi["UNPACK_FLIP_Y_WEBGL"], bK), this["buffer"];
  }
  ["resize"](bx) {
    const { width: bi, height: bX } = bx;
    if (bi === this["size"]["width"] && bX === this["size"]["height"] && this["buffer"]) return true;
    const { gl: bw } = this;
    if (bw["deleteTexture"](this["buffer"]), this["buffer"] = null, (bi > 0 || bX > 0) && (this["buffer"] = bw["createTexture"]()), !this["buffer"]) return false;
    const bo = this["linear"] ? bw["LINEAR"] : bw["NEAREST"], bK = this["mipmap"] ? this["linear"] ? bw["LINEAR_MIPMAP_LINEAR"] : bw["NEAREST_MIPMAP_NEAREST"] : bo, bY = bw["getParameter"](bw["TEXTURE_BINDING_2D"]), bd = bw["getParameter"](bw["UNPACK_FLIP_Y_WEBGL"]);
    return bw["bindTexture"](bw["TEXTURE_2D"], this["buffer"]), bw["pixelStorei"](bw["UNPACK_FLIP_Y_WEBGL"], false), bw["texParameteri"](bw["TEXTURE_2D"], bw["TEXTURE_WRAP_R"], bw["CLAMP_TO_EDGE"]), bw["texParameteri"](bw["TEXTURE_2D"], bw["TEXTURE_WRAP_S"], bw["CLAMP_TO_EDGE"]), bw["texParameteri"](bw["TEXTURE_2D"], bw["TEXTURE_WRAP_T"], bw["CLAMP_TO_EDGE"]), bw["texParameteri"](bw["TEXTURE_2D"], bw["TEXTURE_MIN_FILTER"], bK), bw["texParameteri"](bw["TEXTURE_2D"], bw["TEXTURE_MAG_FILTER"], bo), this["size"] = { "width": bi, "height": bX }, this["levels"] = 1 + (this["mipmap"] ? Math["floor"](Math["log2"](Math["max"](bi, bX))) : 0), bw["texStorage2D"](bw["TEXTURE_2D"], this["levels"], this["grayscale"] ? bw["R8"] : bw["RGBA8"], bi, bX), bw["bindTexture"](bw["TEXTURE_2D"], bY), bw["pixelStorei"](bw["UNPACK_FLIP_Y_WEBGL"], bd), true;
  }
  ["dispose"]() {
    this["gl"]["deleteTexture"](this["buffer"]), this["buffer"] = null;
  }
  ["texture"]() {
    return this["buffer"];
  }
  ["textureSize"]() {
    return this["size"];
  }
  ["valid"]() {
    return !!this["buffer"];
  }
  ["isGrayscale"]() {
    return this["grayscale"];
  }
  ["genLevels"]() {
    if (!this["buffer"] || !this["mipmap"]) return false;
    const { gl: bx } = this, bi = bx["getParameter"](bx["TEXTURE_BINDING_2D"]);
    return bx["bindTexture"](bx["TEXTURE_2D"], this["buffer"]), bx["generateMipmap"](bx["TEXTURE_2D"]), bx["bindTexture"](bx["TEXTURE_2D"], bi), true;
  }
  ["levelCount"]() {
    return this["levels"];
  }
  ["levelSize"](bx) {
    const bi = bk({}, this["size"]);
    for (let bX = 0; bX < bx && bX < this["levels"]; bX++) bi["width"] = Math["max"](Math["floor"](bi["width"] / 2), 1), bi["height"] = Math["max"](Math["floor"](bi["height"] / 2), 1);
    return bi;
  }
};
var bN = Object["defineProperty"];
var bp = Object["getOwnPropertySymbols"];
var bJ = Object["prototype"]["hasOwnProperty"];
var bI = Object["prototype"]["propertyIsEnumerable"];
var by = (bx, bi, bX) => bi in bx ? bN(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var bf = (bx, bi) => {
  for (var bX in bi || (bi = {})) bJ["call"](bi, bX) && by(bx, bX, bi[bX]);
  if (bp) {
    for (var bX of bp(bi)) bI["call"](bi, bX) && by(bx, bX, bi[bX]);
  }
  return bx;
};
var bG = class {
  constructor(bx, bi = { "width": 1920, "height": 1080 }, bX = ["image"], bw = {}, bo = br, bK = ba, bY = false, bd = false, bs = false) {
    this["gl"] = bx, this["size"] = bi, this["inputs"] = bX, this["uniforms"] = bw, this["vertShader"] = null, this["fragShader"] = null, this["shaderProgram"] = null, this["vertBuffer"] = null, this["vertAttrs"] = null, this["uniformsLoc"] = {}, this["frameBuffer"] = null, bo["includes"]("uniform vec2 wh;") && !bw["wh"] && (bw["wh"] = "2f"), bK["includes"]("uniform float flip;") && !bw["flip"] && (bw["flip"] = "1f"), this["outputTexture"] = new bh(bx, bi, bY, bd, bs), this["compile"](bo, bK), this["resize"](bi);
  }
  ["process"](bx, bi = {}) {
    const { gl: bX, outputTexture: bw } = this;
    if (!bX || !bw || bx["length"] !== this["inputs"]["length"]) return null;
    const bo = bw["texture"]();
    if (!bo) return null;
    const bK = this["save"](bX);
    return bX["bindFramebuffer"](bX["FRAMEBUFFER"], this["frameBuffer"]), bX["framebufferTexture2D"](bX["FRAMEBUFFER"], bX["COLOR_ATTACHMENT0"], bX["TEXTURE_2D"], bo, 0), bi = bf({ "flip": [-1] }, bi), this["prepare"](bX, bx, bi), bX["drawArrays"](bX["TRIANGLES"], 0, 6), bw["genLevels"](), this["restore"](bX, bK), bo;
  }
  ["render"](bx, bi = {}) {
    const { gl: bX, outputTexture: bw } = this;
    if (!bX || !bw || bx["length"] !== this["inputs"]["length"]) return;
    const bo = this["save"](bX);
    bX["bindFramebuffer"](bX["FRAMEBUFFER"], null), bi = bf({ "flip": [1] }, bi), this["prepare"](bX, bx, bi), bX["drawArrays"](bX["TRIANGLES"], 0, 6), this["restore"](bX, bo);
  }
  ["output"]() {
    var bx;
    return ((bx = this["outputTexture"]) == null ? void 0 : bx["texture"]()) || null;
  }
  ["read"]() {
    const { gl: bx, outputTexture: bi, frameBuffer: bX } = this;
    if (!bx || !bi || !bX) return null;
    const bw = bi["texture"]();
    if (!bw) return null;
    const bo = bx["getParameter"](bx["TEXTURE_BINDING_2D"]), bK = bx["getParameter"](bx["FRAMEBUFFER_BINDING"]);
    bx["bindFramebuffer"](bx["FRAMEBUFFER"], this["frameBuffer"]), bx["framebufferTexture2D"](bx["FRAMEBUFFER"], bx["COLOR_ATTACHMENT0"], bx["TEXTURE_2D"], bw, 0);
    const { width: bY, height: bd } = bi["textureSize"](), bs = bi["isGrayscale"](), bQ = new Uint8Array(bY * bd * (bs ? 1 : 4)), bU = bs ? bx["RED"] : bx["RGBA"];
    return bx["readPixels"](0, 0, bY, bd, bU, bx["UNSIGNED_BYTE"], bQ), bx["bindTexture"](bx["TEXTURE_2D"], bo), bx["bindFramebuffer"](bx["FRAMEBUFFER"], bK), bQ;
  }
  ["program"]() {
    return this["shaderProgram"];
  }
  ["resize"](bx) {
    var bi;
    const { gl: bX } = this;
    this["size"] = bf({}, bx), (bi = this["outputTexture"]) == null || bi["resize"](bx);
    const bw = bX["getParameter"](bX["CURRENT_PROGRAM"]);
    bX["useProgram"](this["shaderProgram"]), this["uniformsLoc"]["wh"] && bX["uniform2f"](this["uniformsLoc"]["wh"], bx["width"], bx["height"]), bX["useProgram"](bw);
  }
  ["setUniform"](bx, bi) {
    const { gl: bX } = this, bw = bX["getParameter"](bX["CURRENT_PROGRAM"]);
    bX["useProgram"](this["shaderProgram"]), this["setUniformUnsafe"](bx, bi), bX["useProgram"](bw);
  }
  ["dispose"]() {
    var bx;
    const { gl: bi } = this;
    bi["deleteBuffer"](this["vertBuffer"]), this["vertBuffer"] = null, bi["deleteFramebuffer"](this["frameBuffer"]), this["frameBuffer"] = null, bi["deleteShader"](this["vertShader"]), this["vertShader"] = null, bi["deleteShader"](this["fragShader"]), this["fragShader"] = null, bi["deleteProgram"](this["shaderProgram"]), this["shaderProgram"] = null, (bx = this["outputTexture"]) == null || bx["dispose"](), delete this["outputTexture"];
  }
  ["compile"](bx, bi) {
    const { gl: bX } = this, bw = this["save"](bX);
    if (this["vertBuffer"] = bX["createBuffer"](), this["vertAttrs"] = bX["createVertexArray"](), this["frameBuffer"] = bX["createFramebuffer"](), !this["vertBuffer"] || !this["frameBuffer"] || !this["vertAttrs"]) {
      bX["deleteBuffer"](this["vertBuffer"]), this["vertBuffer"] = null, bX["deleteFramebuffer"](this["frameBuffer"]), this["frameBuffer"] = null, bX["deleteVertexArray"](this["vertAttrs"]), this["vertAttrs"] = null;
      return;
    }
    if (this["vertShader"] = bX["createShader"](bX["VERTEX_SHADER"]), this["fragShader"] = bX["createShader"](bX["FRAGMENT_SHADER"]), this["shaderProgram"] = bX["createProgram"](), !this["vertShader"] || !this["fragShader"] || !this["shaderProgram"]) {
      bX["deleteBuffer"](this["vertBuffer"]), this["vertBuffer"] = null, bX["deleteFramebuffer"](this["frameBuffer"]), this["frameBuffer"] = null, bX["deleteShader"](this["vertShader"]), this["vertShader"] = null, bX["deleteShader"](this["fragShader"]), this["fragShader"] = null, bX["deleteProgram"](this["shaderProgram"]), this["shaderProgram"] = null;
      return;
    }
    bX["shaderSource"](this["vertShader"], bi), bX["shaderSource"](this["fragShader"], bx), bX["compileShader"](this["vertShader"]), bX["compileShader"](this["fragShader"]), bX["attachShader"](this["shaderProgram"], this["vertShader"]), bX["attachShader"](this["shaderProgram"], this["fragShader"]), bX["linkProgram"](this["shaderProgram"]), bX["useProgram"](this["shaderProgram"]), bX["bindBuffer"](bX["ARRAY_BUFFER"], this["vertBuffer"]), bX["bufferData"](bX["ARRAY_BUFFER"], new Float32Array([-1, -1, 1, 1, -1, 1, -1, -1, 1, -1, 1, 1]), bX["STATIC_DRAW"]), bX["bindVertexArray"](this["vertAttrs"]);
    const bo = bX["getAttribLocation"](this["shaderProgram"], "pos");
    bX["vertexAttribPointer"](bo, 2, bX["FLOAT"], false, 0, 0), bX["enableVertexAttribArray"](bo), this["uniformsLoc"] = {};
    for (let bK in this["uniforms"]) this["uniformsLoc"][bK] = bX["getUniformLocation"](this["shaderProgram"], bK);
    for (let bY = 0; bY < this["inputs"]["length"]; bY++) bX["uniform1i"](bX["getUniformLocation"](this["shaderProgram"], this["inputs"][bY]), bY);
    this["restore"](bX, bw);
  }
  ["prepare"](bx, bi, bX = {}) {
    const { size: { width: bw, height: bo } } = this;
    for (let bK = 0; bK < bi["length"]; bK++) bx["activeTexture"](bx["TEXTURE0"] + bK), bx["bindTexture"](bx["TEXTURE_2D"], bi[bK]);
    bx["useProgram"](this["shaderProgram"]), bx["bindVertexArray"](this["vertAttrs"]);
    for (let bY in bX) this["setUniformUnsafe"](bY, bX[bY]);
    bx["disable"](bx["CULL_FACE"]), bx["disable"](bx["BLEND"]), bx["colorMask"](true, true, true, true), bx["viewport"](0, 0, bw, bo), bx["scissor"](0, 0, bw, bo), bx["clear"](bx["COLOR_BUFFER_BIT"]);
  }
  ["save"](bx) {
    return { "program": bx["getParameter"](bx["CURRENT_PROGRAM"]), "arrayBuffer": bx["getParameter"](bx["ARRAY_BUFFER_BINDING"]), "framebuffer": bx["getParameter"](bx["FRAMEBUFFER_BINDING"]), "vertexArray": bx["getParameter"](bx["VERTEX_ARRAY_BINDING"]), "viewport": bx["getParameter"](bx["VIEWPORT"]), "scissor": bx["getParameter"](bx["SCISSOR_BOX"]), "colorMask": bx["getParameter"](bx["COLOR_WRITEMASK"]), "cullFace": bx["getParameter"](bx["CULL_FACE"]), "blend": bx["getParameter"](bx["BLEND"]), "activeTexture": bx["getParameter"](bx["ACTIVE_TEXTURE"]), "textures": this["inputs"]["map"]((bi, bX) => (bx["activeTexture"](bx["TEXTURE0"] + bX), bx["getParameter"](bx["TEXTURE_BINDING_2D"]))) };
  }
  ["restore"](bx, bi) {
    bx["useProgram"](bi["program"]), bx["bindBuffer"](bx["ARRAY_BUFFER"], bi["arrayBuffer"]), bx["bindFramebuffer"](bx["FRAMEBUFFER"], bi["framebuffer"]), bx["bindVertexArray"](bi["vertexArray"]), bx["viewport"](bi["viewport"][0], bi["viewport"][1], bi["viewport"][2], bi["viewport"][3]), bx["scissor"](bi["scissor"][0], bi["scissor"][1], bi["scissor"][2], bi["scissor"][3]), bx["colorMask"](bi["colorMask"][0], bi["colorMask"][1], bi["colorMask"][2], bi["colorMask"][3]);
    for (let bX = 0; bX < bi["textures"]["length"]; bX++) bx["activeTexture"](bx["TEXTURE0"] + bX), bx["bindTexture"](bx["TEXTURE_2D"], bi["textures"][bX]);
    bx["activeTexture"](bi["activeTexture"]), bi["cullFace"] ? bx["enable"](bx["CULL_FACE"]) : bx["disable"](bx["CULL_FACE"]), bi["blend"] ? bx["enable"](bx["BLEND"]) : bx["disable"](bx["BLEND"]);
  }
  ["setUniformUnsafe"](bx, bi) {
    const bX = this["uniformsLoc"][bx];
    if (!bX) return;
    const { gl: bw } = this;
    switch (this["uniforms"][bx]) {
      case "1f":
        bi["length"] === 1 && bw["uniform1f"](bX, bi[0]);
        break;
      case "2f":
        bi["length"] === 2 && bw["uniform2f"](bX, bi[0], bi[1]);
        break;
      case "3f":
        bi["length"] === 3 && bw["uniform3f"](bX, bi[0], bi[1], bi[2]);
        break;
      case "4f":
        bi["length"] === 4 && bw["uniform4f"](bX, bi[0], bi[1], bi[2], bi[3]);
        break;
      case "1fv":
        bw["uniform1fv"](bX, bi);
        break;
      case "2fv":
        bw["uniform2fv"](bX, bi);
        break;
      case "3fv":
        bw["uniform3fv"](bX, bi);
        break;
      case "4fv":
        bw["uniform4fv"](bX, bi);
        break;
      case "1i":
        bi["length"] === 1 && bw["uniform1i"](bX, bi[0]);
        break;
      case "2i":
        bi["length"] === 2 && bw["uniform2i"](bX, bi[0], bi[1]);
        break;
      case "3i":
        bi["length"] === 3 && bw["uniform3i"](bX, bi[0], bi[1], bi[2]);
        break;
      case "4i":
        bi["length"] === 4 && bw["uniform4i"](bX, bi[0], bi[1], bi[2], bi[3]);
        break;
      case "1iv":
        bw["uniform1iv"](bX, bi);
        break;
      case "2iv":
        bw["uniform2iv"](bX, bi);
        break;
      case "3iv":
        bw["uniform3iv"](bX, bi);
        break;
      case "4iv":
        bw["uniform4iv"](bX, bi);
        break;
    }
  }
};
var ba = "\nattribute vec2 pos;\nuniform float flip;\nvarying vec2 xy;\nvoid main() {\n    xy = (vec2(pos.x, -pos.y) + 1.0) * 0.5;\n    gl_Position = vec4(pos.x, pos.y * flip, 0, 1.0);\n}";
var br = "\nprecision mediump float;\nvarying vec2 xy;\nuniform vec2 wh;\nuniform sampler2D image;\nvoid main() {\n    gl_FragColor = texture2D(image, xy);\n}";
var bM = class extends bD {
  constructor(bx) {
    super(bx), this["shaderCtx"] = null, this["current"] = null;
    const bi = this["canvas"]["layers"][0];
    this["shaderCtx"] = bi["getContext"]("webgl2", { "alpha": true, "preserveDrawingBuffer": true });
  }
  async ["load"]() {
    if (this["loaded"]) return;
    const { shaderCtx: bx, videoSize: bi } = this;
    if (bx) return this["shader"] = new bG(bx, bi), this["input"] = new bh(bx, bi), super["load"]();
  }
  ["unload"]() {
    var bx, bi;
    (bx = this["input"]) == null || bx["dispose"](), delete this["input"], (bi = this["shader"]) == null || bi["dispose"](), delete this["shader"], super["unload"]();
  }
  async ["update"](bx, bi) {
    if (!this["loaded"]) return;
    const { input: bX } = this, bw = bX == null ? void 0 : bX["texture"]();
    if (!(!bX || !bw)) return bX["update"](bi), this["current"] = bw, super["update"](bx, bi);
  }
  ["updateVideo"](bx) {
    this["shader"] && (this["shader"]["render"]([this["current"]]), super["updateVideo"](bx));
  }
  ["setupVideo"](bx, bi) {
    var bX, bw;
    super["setupVideo"](bx, bi);
    const { width: bo, height: bK } = this["videoSize"];
    this["canvas"]["layers"][0]["width"] = bo, this["canvas"]["layers"][0]["height"] = bK, (bX = this["input"]) == null || bX["resize"]({ "width": bo, "height": bK }), (bw = this["shader"]) == null || bw["resize"]({ "width": bo, "height": bK });
  }
};
var bn = class extends bM {
  ["dispose"]() {
    delete this["scene"], super["dispose"]();
  }
};
var bT = class {
  constructor() {
    this["loaded"] = false, this["ordinal"] = 800;
  }
  async ["load"](bx) {
    this["loaded"] || (this["renderer"] = bx, this["loaded"] = true);
  }
  ["unload"]() {
    this["loaded"] && (this["loaded"] = false);
  }
  async ["update"](bx, bi) {
    this["loaded"];
  }
  ["dispose"]() {
    this["unload"]();
  }
  ["setupVideo"](bx) {
  }
  ["setupCamera"](bx, bi) {
  }
};
var bu = ((bx) => (bx[bx["PreProcess"] = 100] = "PreProcess", bx[bx["Process"] = 200] = "Process", bx[bx["PostProcess"] = 300] = "PostProcess", bx[bx["PreRender"] = 700] = "PreRender", bx[bx["Render"] = 800] = "Render", bx[bx["PostRender"] = 900] = "PostRender", bx))(bu || {});
var bt = class extends bT {
  constructor() {
    super(), this["ordinal"] = bu["PreRender"];
  }
  async ["load"](bx) {
    if (!(this["loaded"] || !(bx instanceof bH) || !bx["videoCtx"])) return this["videoCtx"] = bx["videoCtx"], super["load"](bx);
  }
  ["unload"]() {
    this["loaded"] && (delete this["videoCtx"], super["unload"]());
  }
};
var bV = Object["defineProperty"];
var bv = Object["getOwnPropertySymbols"];
var bO = Object["prototype"]["hasOwnProperty"];
var bS = Object["prototype"]["propertyIsEnumerable"];
var bj = (bx, bi, bX) => bi in bx ? bV(bx, bi, { "enumerable": true, "configurable": true, "writable": true, "value": bX }) : bx[bi] = bX;
var bA = (bx, bi) => {
  for (var bX in bi || (bi = {})) bO["call"](bi, bX) && bj(bx, bX, bi[bX]);
  if (bv) {
    for (var bX of bv(bi)) bS["call"](bi, bX) && bj(bx, bX, bi[bX]);
  }
  return bx;
};
var bl = class extends bT {
  constructor(bx, bi, bX, bw) {
    super(), this["inputs"] = bx, this["uniforms"] = bi, this["fragSrc"] = bX, this["vertSrc"] = bw, this["size"] = { "width": 0, "height": 0 }, this["ordinal"] = bu["PreRender"];
  }
  async ["load"](bx) {
    if (!(this["loaded"] || !(bx instanceof bM) || !bx["shaderCtx"])) return this["shaderCtx"] = bx["shaderCtx"], this["shader"] = new bG(this["shaderCtx"], this["size"], this["inputs"], this["uniforms"], this["fragSrc"], this["vertSrc"]), super["load"](bx);
  }
  ["unload"]() {
    var bx;
    this["loaded"] && ((bx = this["shader"]) == null || bx["dispose"](), delete this["shader"], delete this["shaderCtx"], super["unload"]());
  }
  async ["update"](bx, bi) {
    var bX;
    const { renderer: bw } = this;
    if (!this["loaded"] || !(bw instanceof bM) || !bw["current"]) return;
    const bo = await this["process"](bx, bw["current"]) && ((bX = this["shader"]) == null ? void 0 : bX["output"]());
    bo && (bw["current"] = bo);
  }
  async ["process"](bx, bi) {
    var bX;
    return (bX = this["shader"]) == null || bX["process"]([bi]), true;
  }
  ["setupVideo"](bx) {
    var bi;
    this["size"] = bA({}, bx), (bi = this["shader"]) == null || bi["resize"](bx);
  }
};
var bF = class extends bT {
  constructor() {
    super(), this["ordinal"] = bu["Render"];
  }
  async ["load"](bx) {
    if (!(this["loaded"] || !(bx instanceof bn) || !bx["scene"])) return this["scene"] = bx["scene"], super["load"](bx);
  }
  ["unload"]() {
    this["loaded"] && (delete this["scene"], super["unload"]());
  }
};
var bq = class {
  constructor(bx) {
    this["gl"] = bx, this["frameBuffer"] = null, this["pixelBuffer"] = null, this["frameBuffer"] = bx["createFramebuffer"](), this["pixelBuffer"] = bx["createBuffer"]();
  }
  ["read"](bx, bi = 0) {
    const { gl: bX } = this, bw = bx["texture"]();
    if (!bX || !bw) return null;
    const { width: bo, height: bK } = bx["levelSize"](bi), bY = bx["isGrayscale"](), bd = new Uint8Array(bo * bK * (bY ? 1 : 4)), bs = bY ? bX["RED"] : bX["RGBA"], bQ = bX["getParameter"](bX["TEXTURE_BINDING_2D"]), bU = bX["getParameter"](bX["FRAMEBUFFER_BINDING"]);
    return bX["bindFramebuffer"](bX["FRAMEBUFFER"], this["frameBuffer"]), bX["framebufferTexture2D"](bX["FRAMEBUFFER"], bX["COLOR_ATTACHMENT0"], bX["TEXTURE_2D"], bw, bi), bX["readPixels"](0, 0, bo, bK, bs, bX["UNSIGNED_BYTE"], bd), bX["bindTexture"](bX["TEXTURE_2D"], bQ), bX["bindFramebuffer"](bX["FRAMEBUFFER"], bU), bd;
  }
  async ["readAsync"](bx, bi = 0) {
    const { gl: bX } = this, bw = bx["texture"]();
    if (!bX || !bw) return null;
    const { width: bo, height: bK } = bx["levelSize"](bi), bY = bx["isGrayscale"](), bd = new Uint8Array(bo * bK * (bY ? 1 : 4)), bs = bY ? bX["RED"] : bX["RGBA"], bQ = bX["getParameter"](bX["TEXTURE_BINDING_2D"]), bU = bX["getParameter"](bX["FRAMEBUFFER_BINDING"]), bE = bX["getParameter"](bX["PIXEL_PACK_BUFFER_BINDING"]);
    bX["bindFramebuffer"](bX["FRAMEBUFFER"], this["frameBuffer"]), bX["framebufferTexture2D"](bX["FRAMEBUFFER"], bX["COLOR_ATTACHMENT0"], bX["TEXTURE_2D"], bw, bi), bX["bindBuffer"](bX["PIXEL_PACK_BUFFER"], this["pixelBuffer"]), bX["bufferData"](bX["PIXEL_PACK_BUFFER"], bd["length"], bX["STREAM_READ"]), bX["readPixels"](0, 0, bo, bK, bs, bX["UNSIGNED_BYTE"], 0);
    const bg = bX["fenceSync"](bX["SYNC_GPU_COMMANDS_COMPLETE"], 0);
    if (bX["flush"](), bX["bindTexture"](bX["TEXTURE_2D"], bQ), bX["bindFramebuffer"](bX["FRAMEBUFFER"], bU), bX["bindBuffer"](bX["PIXEL_PACK_BUFFER"], bE), !bg) return null;
    const bW = await new Promise((D1) => {
      const D2 = () => {
        const D3 = bX["clientWaitSync"](bg, 0, 0);
        if (D3 === bX["TIMEOUT_EXPIRED"]) return setTimeout(D2, 0.1);
        if (D3 === bX["WAIT_FAILED"]) return D1(false);
        D1(true);
      };
      D2();
    });
    if (bX["deleteSync"](bg), !bW) return null;
    const D0 = bX["getParameter"](bX["PIXEL_PACK_BUFFER_BINDING"]);
    return bX["bindBuffer"](bX["PIXEL_PACK_BUFFER"], this["pixelBuffer"]), bX["getBufferSubData"](bX["PIXEL_PACK_BUFFER"], 0, bd), bX["bindBuffer"](bX["PIXEL_PACK_BUFFER"], D0), bd;
  }
  ["dispose"]() {
    const { gl: bx } = this;
    bx["deleteFramebuffer"](this["frameBuffer"]), this["frameBuffer"] = null, bx["deleteBuffer"](this["pixelBuffer"]), this["pixelBuffer"] = null;
  }
};
var bm = class {
  constructor(bx, bi = false, bX = "video", bw) {
    this["renderer"] = bx, this["mirror"] = bi, this["sizeMode"] = bX, this["sizeMax"] = bw;
  }
  async ["snapshot"]() {
    return new Promise((bx) => {
      this["renderer"]["once"]("render", () => {
        const { renderer: bi } = this, { layers: bX } = bi["canvas"];
        let { width: bw, height: bo } = bi["canvas"]["layers"][0];
        this["sizeMode"] === "max" ? (bw = Math["max"](...bX["map"]((bs) => bs["width"])), bo = Math["max"](...bX["map"]((bs) => bs["height"]))) : this["sizeMode"] === "min" && (bw = Math["min"](...bX["map"]((bs) => bs["width"])), bo = Math["min"](...bX["map"]((bs) => bs["height"])));
        const bK = document["createElement"]("canvas");
        bK["id"] = "engeenee.snapshot", bK["hidden"] = true, bK["width"] = bw, bK["height"] = bo;
        const bY = bK["getContext"]("2d", { "alpha": true });
        if (!bY) return;
        this["mirror"] && (bY["translate"](bw, 0), bY["scale"](-1, 1)), bX["forEach"]((bs) => bY["drawImage"](bs, 0, 0, bw, bo));
        const bd = bY["getImageData"](0, 0, bw, bo);
        bK["remove"](), bx(bd);
      });
    });
  }
  async ["snapshotLayers"]() {
    return new Promise((bx) => {
      this["renderer"]["once"]("render", () => {
        const bi = document["createElement"]("canvas");
        bi["id"] = "engeenee.snapshot", bi["hidden"] = true;
        const bX = bi["getContext"]("2d", { "alpha": true });
        if (!bX) return;
        const bw = this["renderer"]["canvas"]["layers"]["map"]((bo) => {
          const { width: bK, height: bY } = bo;
          return bi["width"] = bK, bi["height"] = bY, bX["resetTransform"](), this["mirror"] && (bX["translate"](bK, 0), bX["scale"](-1, 1)), bX["drawImage"](bo, 0, 0), bX["getImageData"](0, 0, bK, bY);
        });
        bi["remove"](), bx(bw);
      });
    });
  }
};
var bZ = class {
  constructor(bx, bi = "video/webm", bX = false, bw = "video", bo, bK) {
    this["renderer"] = bx, this["type"] = bi, this["mirror"] = bX, this["sizeMode"] = bw, this["sizeMax"] = bo, this["bitRate"] = bK, this["context"] = null, this["records"] = [], this["frame"] = () => {
      var bY;
      const { renderer: bd, context: bs, stream: bQ } = this, { width: bU, height: bE } = this["canvas"];
      !bQ || !bs || (bd["canvas"]["layers"]["map"]((bg) => bs["drawImage"](bg, 0, 0, bU, bE)), (bY = bQ["getVideoTracks"]()[0]) == null || bY["requestFrame"]());
    }, this["canvas"] = document["createElement"]("canvas"), this["canvas"]["id"] = "engeenee.record", this["canvas"]["hidden"] = true, this["context"] = this["canvas"]["getContext"]("2d", { "alpha": false });
  }
  ["start"]() {
    const { canvas: bx, context: bi, renderer: bX } = this;
    if (!bx || !bi) return false;
    const { layers: bw } = bX["canvas"];
    let { width: bo, height: bK } = bw[0];
    this["sizeMode"] === "max" ? (bo = Math["max"](...bw["map"]((bd) => bd["width"])), bK = Math["max"](...bw["map"]((bd) => bd["height"]))) : this["sizeMode"] === "min" && (bo = Math["min"](...bw["map"]((bd) => bd["width"])), bK = Math["min"](...bw["map"]((bd) => bd["height"])));
    const bY = Math["max"](bo, bK);
    if (this["sizeMax"] && bY > this["sizeMax"]) {
      const bd = this["sizeMax"] / bY;
      bo *= bd, bK *= bd;
    }
    return bx["width"] = bo, bx["height"] = bK, bi["resetTransform"](), this["mirror"] && (bi["translate"](bo, 0), bi["scale"](-1, 1)), bX["on"]("render", this["frame"]), this["records"] = [], this["stream"] = bx["captureStream"](0), this["recorder"] = new MediaRecorder(this["stream"], { "mimeType": this["type"], "videoBitsPerSecond": this["bitRate"] }), this["recorder"]["ondataavailable"] = (bs) => this["records"]["push"](bs["data"]), this["recorder"]["start"](), true;
  }
  async ["stop"]() {
    const { recorder: bx } = this;
    if (!(!bx || bx["state"] != "recording")) return new Promise((bi) => {
      bx["onstop"] = () => {
        var bX;
        bi(new Blob(this["records"], { "type": this["type"] })), this["records"] = [], (bX = this["stream"]) == null || bX["getVideoTracks"]()["forEach"]((bw) => bw["stop"]()), this["renderer"]["removeListener"]("render", this["frame"]), delete this["stream"], delete this["recorder"];
      }, bx["stop"]();
    });
  }
  ["dispose"]() {
    this["canvas"]["remove"]();
  }
};
var bP = class {
  constructor(bx, bi = 0, bX = "video/webm", bw) {
    this["renderer"] = bx, this["layer"] = bi, this["type"] = bX, this["bitRate"] = bw, this["records"] = [];
  }
  ["start"]() {
    const { renderer: bx } = this, bi = bx["canvas"]["layers"][this["layer"]];
    return this["records"] = [], this["stream"] = bi["captureStream"](), this["recorder"] = new MediaRecorder(this["stream"], { "mimeType": this["type"], "videoBitsPerSecond": this["bitRate"] }), this["recorder"]["ondataavailable"] = (bX) => this["records"]["push"](bX["data"]), this["recorder"]["start"](), true;
  }
  async ["stop"]() {
    const { recorder: bx } = this;
    if (!(!bx || bx["state"] != "recording")) return new Promise((bi) => {
      bx["onstop"] = () => {
        var bX;
        bi(new Blob(this["records"], { "type": this["type"] })), this["records"] = [], (bX = this["stream"]) == null || bX["getVideoTracks"]()["forEach"]((bw) => bw["stop"]()), delete this["stream"], delete this["recorder"];
      }, bx["stop"]();
    });
  }
};
var bz = class {
  constructor(bx, bi = false, bX = "video", bw) {
    this["renderer"] = bx, this["mirror"] = bi, this["sizeMode"] = bX, this["sizeMax"] = bw, this["context"] = null, this["render"] = () => {
      const { canvas: bo, context: bK } = this;
      !bo || !bK || this["renderer"]["canvas"]["layers"]["map"]((bY) => bK["drawImage"](bY, 0, 0, bo["width"], bo["height"]));
    }, this["canvas"] = document["createElement"]("canvas"), this["canvas"]["id"] = "engeenee.record", this["canvas"]["hidden"] = true, this["mirror"] && (this["canvas"]["style"]["transform"] = "scaleX(-1)"), this["context"] = this["canvas"]["getContext"]("2d", { "alpha": false });
  }
  ["start"]() {
    const { canvas: bx, context: bi, renderer: bX } = this;
    if (!bx || !bi) return false;
    const { layers: bw } = bX["canvas"];
    let { width: bo, height: bK } = bw[0];
    this["sizeMode"] === "max" ? (bo = Math["max"](...bw["map"]((bd) => bd["width"])), bK = Math["max"](...bw["map"]((bd) => bd["height"]))) : this["sizeMode"] === "min" && (bo = Math["min"](...bw["map"]((bd) => bd["width"])), bK = Math["min"](...bw["map"]((bd) => bd["height"])));
    const bY = Math["max"](bo, bK);
    if (this["sizeMax"] && bY > this["sizeMax"]) {
      const bd = this["sizeMax"] / bY;
      bo *= bd, bK *= bd;
    }
    return bx["width"] = bo, bx["height"] = bK, bi["resetTransform"](), this["mirror"] && (bi["translate"](bo, 0), bi["scale"](-1, 1)), this["renderer"]["on"]("render", this["render"]), this["stream"] = bx["captureStream"](), true;
  }
  ["pause"]() {
    this["renderer"]["removeListener"]("render", this["render"]);
  }
  ["mediaStream"]() {
    return this["stream"];
  }
};

export {
  c,
  r,
  M,
  x,
  i,
  b0,
  b1,
  b2,
  b9,
  bb,
  bD,
  bH,
  bh,
  bG,
  bM,
  bn,
  bT,
  bu,
  bt,
  bl,
  bF,
  bq,
  bm,
  bZ,
  bP,
  bz
};
//# sourceMappingURL=chunk-QOBHKNUZ.js.map
